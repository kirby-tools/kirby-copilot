var dh = Object.defineProperty;
var xI = (t) => {
  throw TypeError(t);
};
var fh = (t, A, e) => A in t ? dh(t, A, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[A] = e;
var Ft = (t, A, e) => fh(t, typeof A != "symbol" ? A + "" : A, e), gg = (t, A, e) => A.has(t) || xI("Cannot " + e);
var NA = (t, A, e) => (gg(t, A, "read from private field"), e ? e.call(t) : A.get(t)), MA = (t, A, e) => A.has(t) ? xI("Cannot add the same private member more than once") : A instanceof WeakSet ? A.add(t) : A.set(t, e), Vt = (t, A, e, i) => (gg(t, A, "write to private field"), i ? i.call(t, e) : A.set(t, e), e), CA = (t, A, e) => (gg(t, A, "access private method"), e);
var Kg = { d: (t, A) => {
  for (var e in A) Kg.o(A, e) && !Kg.o(t, e) && Object.defineProperty(t, e, { enumerable: !0, get: A[e] });
}, o: (t, A) => Object.prototype.hasOwnProperty.call(t, A) }, Y0 = globalThis.pdfjsWorker = {};
Kg.d(Y0, { WorkerMessageHandler: () => Po });
const ph = !(typeof process != "object" || process + "" != "[object process]" || process.versions.nw || process.versions.electron && process.type && process.type !== "browser"), Be = [1, 0, 0, 1, 0, 0], Ji = [1e-3, 0, 0, 1e-3, 0, 0], Hi = 1.35, UI = 0.35, MI = 0.25925925925925924, LI = 1, tr = 2, JI = 4, HI = 8, v0 = 16, mh = 64, yh = 128, wh = 256, K0 = "pdfjs_internal_editor_", YI = 3, vI = 9, KI = 13, qI = 15, TI = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }, Dh = 0, bh = 4, er = 1, os = 2, Ue = 3, kh = 1, Fh = 2, Sh = 3, Rh = 4, Gh = 5, Nh = 6, xh = 7, Uh = 8, Mh = 9, Lh = 10, Jh = 11, Hh = 12, Yh = 13, vh = 14, Kh = 15, qh = 16, Th = 17, Ph = 20, q0 = "Group", Wh = "R", Cn = 1, $e = 2, Vi = 4, Zh = 16, Ia = 32, Oh = 128, Xh = 512, Vh = 1, jh = 2, PI = 4096, qg = 8192, WI = 32768, og = 65536, zh = 131072, _h = 1048576, $h = 2097152, AB = 8388608, tB = 16777216, ZI = 1, eB = 2, iB = 3, aB = 4, sB = 5, T0 = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" }, nB = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" }, rB = { O: "PageOpen", C: "PageClose" }, fs = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }, gB = 1, oB = 2, IB = 3, cB = 4, CB = 5, hB = 6, P0 = 7, BB = 8, ca = 9, Se = 10, Wt = 11, Qi = 12, Is = 13, Un = 14, W0 = 15, Z0 = 16, O0 = 17, X0 = 18, Mn = 19, lB = 20, QB = 21, OI = 22, EB = 23, uB = 24, dB = 25, fB = 26, pB = 27, XI = 28, mB = 29, yB = 30, ps = 31, ms = 32, Tg = 33, Pg = 34, V0 = 35, j0 = 36, li = 37, z0 = 38, _0 = 39, $0 = 40, A1 = 41, ys = 42, Ln = 43, Je = 44, ir = 45, ar = 46, sr = 47, wB = 48, Wg = 49, Wo = 50, qr = 51, Zo = 52, nr = 53, Tr = 54, rr = 55, Oo = 56, tn = 57, Ai = 58, me = 59, Xo = 60, en = 61, gr = 62, DB = 63, bB = 64, t1 = 65, Zg = 66, e1 = 67, i1 = 68, a1 = 69, ye = 70, Ra = 71, s1 = 72, n1 = 73, kB = 74, FB = 75, SB = 76, RB = 77, r1 = 80, g1 = 81, oi = 83, GB = 84, Ri = 85, or = 86, o1 = 87, NB = 88, xB = 89, VI = 90, jI = 91, UB = 92, MB = 93, LB = 1, JB = 2;
let Pr = fs.WARNINGS;
function HB() {
  return Pr;
}
function RA(t) {
  Pr >= fs.INFOS && console.log(`Info: ${t}`);
}
function G(t) {
  Pr >= fs.WARNINGS && console.log(`Warning: ${t}`);
}
function xA(t) {
  throw new Error(t);
}
function Rt(t, A) {
  t || xA(A);
}
function Ir(t, A = null, e = null) {
  if (!t) return null;
  try {
    if (e && typeof t == "string") {
      if (e.addDefaultProtocol && t.startsWith("www.")) {
        const a = t.match(/\./g);
        (a == null ? void 0 : a.length) >= 2 && (t = `http://${t}`);
      }
      if (e.tryConvertEncoding) try {
        t = ws(t);
      } catch {
      }
    }
    const i = A ? new URL(t, A) : new URL(t);
    if (function(s) {
      switch (s == null ? void 0 : s.protocol) {
        case "http:":
        case "https:":
        case "ftp:":
        case "mailto:":
        case "tel:":
          return !0;
        default:
          return !1;
      }
    }(i)) return i;
  } catch {
  }
  return null;
}
function sA(t, A, e, i = !1) {
  return Object.defineProperty(t, A, { value: e, enumerable: !i, configurable: !0, writable: !1 }), e;
}
const bt = function() {
  function A(e, i) {
    this.message = e, this.name = i;
  }
  return A.prototype = new Error(), A.constructor = A, A;
}();
class cr extends bt {
  constructor(A, e) {
    super(A, "PasswordException"), this.code = e;
  }
}
class Cr extends bt {
  constructor(A, e) {
    super(A, "UnknownErrorException"), this.details = e;
  }
}
class hr extends bt {
  constructor(A) {
    super(A, "InvalidPDFException");
  }
}
class I1 extends bt {
  constructor(A) {
    super(A, "MissingPDFException");
  }
}
class c1 extends bt {
  constructor(A, e) {
    super(A, "UnexpectedResponseException"), this.status = e;
  }
}
class X extends bt {
  constructor(A) {
    super(A, "FormatError");
  }
}
class pt extends bt {
  constructor(A) {
    super(A, "AbortException");
  }
}
function Mt(t) {
  typeof t == "object" && (t == null ? void 0 : t.length) !== void 0 || xA("Invalid argument for bytesToString");
  const A = t.length, e = 8192;
  if (A < e) return String.fromCharCode.apply(null, t);
  const i = [];
  for (let a = 0; a < A; a += e) {
    const s = Math.min(a + e, A), r = t.subarray(a, s);
    i.push(String.fromCharCode.apply(null, r));
  }
  return i.join("");
}
function ut(t) {
  typeof t != "string" && xA("Invalid argument for stringToBytes");
  const A = t.length, e = new Uint8Array(A);
  for (let i = 0; i < A; ++i) e[i] = 255 & t.charCodeAt(i);
  return e;
}
function Et(t) {
  return String.fromCharCode(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t);
}
function C1(t) {
  return Object.keys(t).length;
}
class Jt {
  static get isLittleEndian() {
    return sA(this, "isLittleEndian", function() {
      const e = new Uint8Array(4);
      return e[0] = 1, new Uint32Array(e.buffer, 0, 1)[0] === 1;
    }());
  }
  static get isEvalSupported() {
    return sA(this, "isEvalSupported", function() {
      try {
        return new Function(""), !0;
      } catch {
        return !1;
      }
    }());
  }
  static get isOffscreenCanvasSupported() {
    return sA(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get isImageDecoderSupported() {
    return sA(this, "isImageDecoderSupported", typeof ImageDecoder < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? sA(this, "platform", { isMac: navigator.platform.includes("Mac"), isWindows: navigator.platform.includes("Win"), isFirefox: typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && navigator.userAgent.includes("Firefox") }) : sA(this, "platform", { isMac: !1, isWindows: !1, isFirefox: !1 });
  }
  static get isCSSRoundSupported() {
    var A, e;
    return sA(this, "isCSSRoundSupported", (e = (A = globalThis.CSS) == null ? void 0 : A.supports) == null ? void 0 : e.call(A, "width: round(1.5px, 1px)"));
  }
}
const da = Array.from(Array(256).keys(), (t) => t.toString(16).padStart(2, "0"));
var Pe, Jn, Og;
class nt {
  static makeHexColor(A, e, i) {
    return `#${da[A]}${da[e]}${da[i]}`;
  }
  static scaleMinMax(A, e) {
    let i;
    A[0] ? (A[0] < 0 && (i = e[0], e[0] = e[2], e[2] = i), e[0] *= A[0], e[2] *= A[0], A[3] < 0 && (i = e[1], e[1] = e[3], e[3] = i), e[1] *= A[3], e[3] *= A[3]) : (i = e[0], e[0] = e[1], e[1] = i, i = e[2], e[2] = e[3], e[3] = i, A[1] < 0 && (i = e[1], e[1] = e[3], e[3] = i), e[1] *= A[1], e[3] *= A[1], A[2] < 0 && (i = e[0], e[0] = e[2], e[2] = i), e[0] *= A[2], e[2] *= A[2]), e[0] += A[4], e[1] += A[5], e[2] += A[4], e[3] += A[5];
  }
  static transform(A, e) {
    return [A[0] * e[0] + A[2] * e[1], A[1] * e[0] + A[3] * e[1], A[0] * e[2] + A[2] * e[3], A[1] * e[2] + A[3] * e[3], A[0] * e[4] + A[2] * e[5] + A[4], A[1] * e[4] + A[3] * e[5] + A[5]];
  }
  static applyTransform(A, e) {
    return [A[0] * e[0] + A[1] * e[2] + e[4], A[0] * e[1] + A[1] * e[3] + e[5]];
  }
  static applyInverseTransform(A, e) {
    const i = e[0] * e[3] - e[1] * e[2];
    return [(A[0] * e[3] - A[1] * e[2] + e[2] * e[5] - e[4] * e[3]) / i, (-A[0] * e[1] + A[1] * e[0] + e[4] * e[1] - e[5] * e[0]) / i];
  }
  static getAxialAlignedBoundingBox(A, e) {
    const i = this.applyTransform(A, e), a = this.applyTransform(A.slice(2, 4), e), s = this.applyTransform([A[0], A[3]], e), r = this.applyTransform([A[2], A[1]], e);
    return [Math.min(i[0], a[0], s[0], r[0]), Math.min(i[1], a[1], s[1], r[1]), Math.max(i[0], a[0], s[0], r[0]), Math.max(i[1], a[1], s[1], r[1])];
  }
  static inverseTransform(A) {
    const e = A[0] * A[3] - A[1] * A[2];
    return [A[3] / e, -A[1] / e, -A[2] / e, A[0] / e, (A[2] * A[5] - A[4] * A[3]) / e, (A[4] * A[1] - A[5] * A[0]) / e];
  }
  static singularValueDecompose2dScale(A) {
    const e = [A[0], A[2], A[1], A[3]], i = A[0] * e[0] + A[1] * e[2], a = A[0] * e[1] + A[1] * e[3], s = A[2] * e[0] + A[3] * e[2], r = A[2] * e[1] + A[3] * e[3], n = (i + r) / 2, g = Math.sqrt((i + r) ** 2 - 4 * (i * r - s * a)) / 2, o = n + g || 1, I = n - g || 1;
    return [Math.sqrt(o), Math.sqrt(I)];
  }
  static normalizeRect(A) {
    const e = A.slice(0);
    return A[0] > A[2] && (e[0] = A[2], e[2] = A[0]), A[1] > A[3] && (e[1] = A[3], e[3] = A[1]), e;
  }
  static intersect(A, e) {
    const i = Math.max(Math.min(A[0], A[2]), Math.min(e[0], e[2])), a = Math.min(Math.max(A[0], A[2]), Math.max(e[0], e[2]));
    if (i > a) return null;
    const s = Math.max(Math.min(A[1], A[3]), Math.min(e[1], e[3])), r = Math.min(Math.max(A[1], A[3]), Math.max(e[1], e[3]));
    return s > r ? null : [i, s, a, r];
  }
  static bezierBoundingBox(A, e, i, a, s, r, n, g, o) {
    return o ? (o[0] = Math.min(o[0], A, n), o[1] = Math.min(o[1], e, g), o[2] = Math.max(o[2], A, n), o[3] = Math.max(o[3], e, g)) : o = [Math.min(A, n), Math.min(e, g), Math.max(A, n), Math.max(e, g)], CA(this, Pe, Og).call(this, A, i, s, n, e, a, r, g, 3 * (3 * (i - s) - A + n), 6 * (A - 2 * i + s), 3 * (i - A), o), CA(this, Pe, Og).call(this, A, i, s, n, e, a, r, g, 3 * (3 * (a - r) - e + g), 6 * (e - 2 * a + r), 3 * (a - e), o), o;
  }
}
Pe = new WeakSet(), Jn = function(A, e, i, a, s, r, n, g, o, I) {
  if (o <= 0 || o >= 1) return;
  const C = 1 - o, h = o * o, c = h * o, B = C * (C * (C * A + 3 * o * e) + 3 * h * i) + c * a, l = C * (C * (C * s + 3 * o * r) + 3 * h * n) + c * g;
  I[0] = Math.min(I[0], B), I[1] = Math.min(I[1], l), I[2] = Math.max(I[2], B), I[3] = Math.max(I[3], l);
}, Og = function(A, e, i, a, s, r, n, g, o, I, C, h) {
  if (Math.abs(o) < 1e-12) {
    Math.abs(I) >= 1e-12 && CA(this, Pe, Jn).call(this, A, e, i, a, s, r, n, g, -C / I, h);
    return;
  }
  const c = I ** 2 - 4 * C * o;
  if (c < 0) return;
  const B = Math.sqrt(c), l = 2 * o;
  CA(this, Pe, Jn).call(this, A, e, i, a, s, r, n, g, (-I + B) / l, h), CA(this, Pe, Jn).call(this, A, e, i, a, s, r, n, g, (-I - B) / l, h);
}, MA(nt, Pe);
const YB = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function LA(t) {
  if (t[0] >= "ï") {
    let e;
    if (t[0] === "þ" && t[1] === "ÿ" ? (e = "utf-16be", t.length % 2 == 1 && (t = t.slice(0, -1))) : t[0] === "ÿ" && t[1] === "þ" ? (e = "utf-16le", t.length % 2 == 1 && (t = t.slice(0, -1))) : t[0] === "ï" && t[1] === "»" && t[2] === "¿" && (e = "utf-8"), e) try {
      const i = new TextDecoder(e, { fatal: !0 }), a = ut(t), s = i.decode(a);
      return s.includes("\x1B") ? s.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : s;
    } catch (i) {
      G(`stringToPDFString: "${i}".`);
    }
  }
  const A = [];
  for (let e = 0, i = t.length; e < i; e++) {
    const a = t.charCodeAt(e);
    if (a === 27) {
      for (; ++e < i && t.charCodeAt(e) !== 27; ) ;
      continue;
    }
    const s = YB[a];
    A.push(s ? String.fromCharCode(s) : t.charAt(e));
  }
  return A.join("");
}
function ws(t) {
  return decodeURIComponent(escape(t));
}
function Xg(t) {
  return unescape(encodeURIComponent(t));
}
function Pi(t, A) {
  if (t.length !== A.length) return !1;
  for (let e = 0, i = t.length; e < i; e++) if (t[e] !== A[e]) return !1;
  return !0;
}
function We(t = /* @__PURE__ */ new Date()) {
  return [t.getUTCFullYear().toString(), (t.getUTCMonth() + 1).toString().padStart(2, "0"), t.getUTCDate().toString().padStart(2, "0"), t.getUTCHours().toString().padStart(2, "0"), t.getUTCMinutes().toString().padStart(2, "0"), t.getUTCSeconds().toString().padStart(2, "0")].join("");
}
let Ig = null, zI = null;
const vB = 0, h1 = 1, B1 = 2, KB = 3, Vo = 4, jo = 5, qB = 6, l1 = 7, TB = 8;
function _I(t) {
  return Uint8Array.prototype.toHex ? t.toHex() : Array.from(t, (A) => da[A]).join("");
}
typeof Promise.try != "function" && (Promise.try = function(t, ...A) {
  return new Promise((e) => {
    e(t(...A));
  });
});
const PB = Symbol("CIRCULAR_REF"), lt = Symbol("EOF");
let Hn = /* @__PURE__ */ Object.create(null), Yn = /* @__PURE__ */ Object.create(null), ea = /* @__PURE__ */ Object.create(null);
class T {
  constructor(A) {
    this.name = A;
  }
  static get(A) {
    return Yn[A] || (Yn[A] = new T(A));
  }
}
class ot {
  constructor(A) {
    this.cmd = A;
  }
  static get(A) {
    return Hn[A] || (Hn[A] = new ot(A));
  }
}
const Q1 = function() {
  return Q1;
};
class U {
  constructor(A = null) {
    this._map = /* @__PURE__ */ new Map(), this.xref = A, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = Q1;
  }
  assignXref(A) {
    this.xref = A;
  }
  get size() {
    return this._map.size;
  }
  get(A, e, i) {
    let a = this._map.get(A);
    return a === void 0 && e !== void 0 && (a = this._map.get(e), a === void 0 && i !== void 0 && (a = this._map.get(i))), a instanceof rA && this.xref ? this.xref.fetch(a, this.suppressEncryption) : a;
  }
  async getAsync(A, e, i) {
    let a = this._map.get(A);
    return a === void 0 && e !== void 0 && (a = this._map.get(e), a === void 0 && i !== void 0 && (a = this._map.get(i))), a instanceof rA && this.xref ? this.xref.fetchAsync(a, this.suppressEncryption) : a;
  }
  getArray(A, e, i) {
    let a = this._map.get(A);
    if (a === void 0 && e !== void 0 && (a = this._map.get(e), a === void 0 && i !== void 0 && (a = this._map.get(i))), a instanceof rA && this.xref && (a = this.xref.fetch(a, this.suppressEncryption)), Array.isArray(a)) {
      a = a.slice();
      for (let s = 0, r = a.length; s < r; s++) a[s] instanceof rA && this.xref && (a[s] = this.xref.fetch(a[s], this.suppressEncryption));
    }
    return a;
  }
  getRaw(A) {
    return this._map.get(A);
  }
  getKeys() {
    return [...this._map.keys()];
  }
  getRawValues() {
    return [...this._map.values()];
  }
  set(A, e) {
    this._map.set(A, e);
  }
  has(A) {
    return this._map.has(A);
  }
  *[Symbol.iterator]() {
    for (const [A, e] of this._map) yield [A, e instanceof rA && this.xref ? this.xref.fetch(e, this.suppressEncryption) : e];
  }
  static get empty() {
    const A = new U(null);
    return A.set = (e, i) => {
      xA("Should not call `set` on the empty dictionary.");
    }, sA(this, "empty", A);
  }
  static merge({ xref: A, dictArray: e, mergeSubDicts: i = !1 }) {
    const a = new U(A), s = /* @__PURE__ */ new Map();
    for (const r of e) if (r instanceof U) for (const [n, g] of r._map) {
      let o = s.get(n);
      if (o === void 0)
        o = [], s.set(n, o);
      else if (!(i && g instanceof U)) continue;
      o.push(g);
    }
    for (const [r, n] of s) {
      if (n.length === 1 || !(n[0] instanceof U)) {
        a._map.set(r, n[0]);
        continue;
      }
      const g = new U(A);
      for (const o of n) for (const [I, C] of o._map) g._map.has(I) || g._map.set(I, C);
      g.size > 0 && a._map.set(r, g);
    }
    return s.clear(), a.size > 0 ? a : U.empty;
  }
  clone() {
    const A = new U(this.xref);
    for (const e of this.getKeys()) A.set(e, this.getRaw(e));
    return A;
  }
  delete(A) {
    delete this._map[A];
  }
}
class rA {
  constructor(A, e) {
    this.num = A, this.gen = e;
  }
  toString() {
    return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(A) {
    const e = ea[A];
    if (e) return e;
    const i = /^(\d+)R(\d*)$/.exec(A);
    return i && i[1] !== "0" ? ea[A] = new rA(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0) : null;
  }
  static get(A, e) {
    const i = e === 0 ? `${A}R` : `${A}R${e}`;
    return ea[i] || (ea[i] = new rA(A, e));
  }
}
class Bt {
  constructor(A = null) {
    this._set = new Set(A == null ? void 0 : A._set);
  }
  has(A) {
    return this._set.has(A.toString());
  }
  put(A) {
    this._set.add(A.toString());
  }
  remove(A) {
    this._set.delete(A.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
class xt {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(A) {
    return this._map.get(A.toString());
  }
  has(A) {
    return this._map.has(A.toString());
  }
  put(A, e) {
    this._map.set(A.toString(), e);
  }
  putAlias(A, e) {
    this._map.set(A.toString(), this.get(e));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *values() {
    yield* this._map.values();
  }
  *items() {
    for (const [A, e] of this._map) yield [rA.fromString(A), e];
  }
}
function it(t, A) {
  return t instanceof T && (A === void 0 || t.name === A);
}
function ht(t, A) {
  return t instanceof ot && (A === void 0 || t.cmd === A);
}
function E1(t, A) {
  return t instanceof U && (A === void 0 || it(t.get("Type"), A));
}
function Br(t, A) {
  return t.num === A.num && t.gen === A.gen;
}
class FA {
  get length() {
    xA("Abstract getter `length` accessed");
  }
  get isEmpty() {
    xA("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return sA(this, "isDataLoaded", !0);
  }
  getByte() {
    xA("Abstract method `getByte` called");
  }
  getBytes(A) {
    xA("Abstract method `getBytes` called");
  }
  async getImageData(A, e) {
    return this.getBytes(A, e);
  }
  async asyncGetBytes() {
    xA("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return !1;
  }
  get canAsyncDecodeImageFromBuffer() {
    return !1;
  }
  async getTransferableImage() {
    return null;
  }
  peekByte() {
    const A = this.getByte();
    return A !== -1 && this.pos--, A;
  }
  peekBytes(A) {
    const e = this.getBytes(A);
    return this.pos -= e.length, e;
  }
  getUint16() {
    const A = this.getByte(), e = this.getByte();
    return A === -1 || e === -1 ? -1 : (A << 8) + e;
  }
  getInt32() {
    return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
  }
  getByteRange(A, e) {
    xA("Abstract method `getByteRange` called");
  }
  getString(A) {
    return Mt(this.getBytes(A));
  }
  skip(A) {
    this.pos += A || 1;
  }
  reset() {
    xA("Abstract method `reset` called");
  }
  moveStart() {
    xA("Abstract method `moveStart` called");
  }
  makeSubStream(A, e, i = null) {
    xA("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
const u1 = /^[1-9]\.\d$/, Vg = 2 ** 31 - 1, WB = -(2 ** 31);
function jA(t) {
  let A;
  return function() {
    return t && (A = /* @__PURE__ */ Object.create(null), t(A), t = null), A;
  };
}
class OA extends bt {
  constructor(A, e) {
    super(`Missing data [${A}, ${e})`, "MissingDataException"), this.begin = A, this.end = e;
  }
}
class jg extends bt {
  constructor(A) {
    super(A, "ParserEOFException");
  }
}
class Ii extends bt {
  constructor(A) {
    super(A, "XRefEntryException");
  }
}
class fa extends bt {
  constructor(A) {
    super(A, "XRefParseException");
  }
}
function d1(t) {
  const A = t.length;
  if (A === 0) return new Uint8Array(0);
  if (A === 1) return new Uint8Array(t[0]);
  let e = 0;
  for (let s = 0; s < A; s++) e += t[s].byteLength;
  const i = new Uint8Array(e);
  let a = 0;
  for (let s = 0; s < A; s++) {
    const r = new Uint8Array(t[s]);
    i.set(r, a), a += r.byteLength;
  }
  return i;
}
function ee({ dict: t, key: A, getArray: e = !1, stopWhenFound: i = !0 }) {
  let a;
  const s = new Bt();
  for (; t instanceof U && (!t.objId || !s.has(t.objId)); ) {
    t.objId && s.put(t.objId);
    const r = e ? t.getArray(A) : t.get(A);
    if (r !== void 0) {
      if (i) return r;
      (a || (a = [])).push(r);
    }
    t = t.get("Parent");
  }
  return a;
}
const cg = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function ZB(t, A = !1) {
  Rt(Number.isInteger(t) && t > 0, "The number should be a positive integer.");
  const e = "M".repeat(t / 1e3 | 0) + cg[t % 1e3 / 100 | 0] + cg[10 + (t % 100 / 10 | 0)] + cg[20 + t % 10];
  return A ? e.toLowerCase() : e;
}
function Cg(t) {
  return t > 0 ? Math.ceil(Math.log2(t)) : 0;
}
function Oe(t, A) {
  return t[A] << 24 >> 24;
}
function XA(t, A) {
  return t[A] << 8 | t[A + 1];
}
function VA(t, A) {
  return (t[A] << 24 | t[A + 1] << 16 | t[A + 2] << 8 | t[A + 3]) >>> 0;
}
function Zt(t) {
  return t === 32 || t === 9 || t === 13 || t === 10;
}
function Gt(t, A) {
  return Array.isArray(t) ? (A === null || t.length === A) && t.every((e) => typeof e == "number") : ArrayBuffer.isView(t) && (t.length === 0 || typeof t[0] == "number") && (A === null || t.length === A);
}
function ci(t, A) {
  return Gt(t, 6) ? t : A;
}
function zg(t, A) {
  return Gt(t, 4) ? t : A;
}
function be(t, A) {
  return Gt(t, 4) ? nt.normalizeRect(t) : A;
}
function f1(t) {
  const A = /(.+)\[(\d+)\]$/;
  return t.split(".").map((e) => {
    const i = e.match(A);
    return i ? { name: i[1], pos: parseInt(i[2], 10) } : { name: e, pos: 0 };
  });
}
function zo(t) {
  const A = [];
  let e = 0;
  for (let i = 0, a = t.length; i < a; i++) {
    const s = t.charCodeAt(i);
    (s < 33 || s > 126 || s === 35 || s === 40 || s === 41 || s === 60 || s === 62 || s === 91 || s === 93 || s === 123 || s === 125 || s === 47 || s === 37) && (e < i && A.push(t.substring(e, i)), A.push(`#${s.toString(16)}`), e = i + 1);
  }
  return A.length === 0 ? t : (e < t.length && A.push(t.substring(e, t.length)), A.join(""));
}
function Ga(t) {
  return t.replaceAll(/([()\\\n\r])/g, (A) => A === `
` ? "\\n" : A === "\r" ? "\\r" : `\\${A}`);
}
function lr(t, A, e, i) {
  if (!t) return;
  let a = null;
  if (t instanceof rA) {
    if (i.has(t)) return;
    a = t, i.put(a), t = A.fetch(t);
  }
  if (Array.isArray(t)) for (const s of t) lr(s, A, e, i);
  else if (t instanceof U) {
    if (it(t.get("S"), "JavaScript")) {
      const s = t.get("JS");
      let r;
      s instanceof FA ? r = s.getString() : typeof s == "string" && (r = s), r && (r = LA(r).replaceAll("\0", "")), r && e.push(r);
    }
    lr(t.getRaw("Next"), A, e, i);
  }
  a && i.remove(a);
}
function Wr(t, A, e) {
  const i = /* @__PURE__ */ Object.create(null), a = ee({ dict: A, key: "AA", stopWhenFound: !1 });
  if (a) for (let s = a.length - 1; s >= 0; s--) {
    const r = a[s];
    if (r instanceof U) for (const n of r.getKeys()) {
      const g = e[n];
      if (!g) continue;
      const o = [];
      lr(r.getRaw(n), t, o, new Bt()), o.length > 0 && (i[g] = o);
    }
  }
  if (A.has("A")) {
    const s = [];
    lr(A.get("A"), t, s, new Bt()), s.length > 0 && (i.Action = s);
  }
  return C1(i) > 0 ? i : null;
}
const OB = { 60: "&lt;", 62: "&gt;", 38: "&amp;", 34: "&quot;", 39: "&apos;" };
function* XB(t) {
  for (let A = 0, e = t.length; A < e; A++) {
    const i = t.codePointAt(A);
    i > 55295 && (i < 57344 || i > 65533) && A++, yield i;
  }
}
function pa(t) {
  const A = [];
  let e = 0;
  for (let i = 0, a = t.length; i < a; i++) {
    const s = t.codePointAt(i);
    if (32 <= s && s <= 126) {
      const r = OB[s];
      r && (e < i && A.push(t.substring(e, i)), A.push(r), e = i + 1);
    } else
      e < i && A.push(t.substring(e, i)), A.push(`&#x${s.toString(16).toUpperCase()};`), s > 55295 && (s < 57344 || s > 65533) && i++, e = i + 1;
  }
  return A.length === 0 ? t : (e < t.length && A.push(t.substring(e, t.length)), A.join(""));
}
function _g(t, A = !1) {
  const e = /^("|').*("|')$/.exec(t);
  if (e && e[1] === e[2]) {
    if (new RegExp(`[^\\\\]${e[1]}`).test(t.slice(1, -1)))
      return A && G(`FontFamily contains unescaped ${e[1]}: ${t}.`), !1;
  } else for (const i of t.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(i) || !/^[\w-\\]+$/.test(i))
    return A && G(`FontFamily contains invalid <custom-ident>: ${t}.`), !1;
  return !0;
}
function VB(t) {
  const A = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), { fontFamily: e, fontWeight: i, italicAngle: a } = t;
  if (!_g(e, !0)) return !1;
  const s = i ? i.toString() : "";
  t.fontWeight = A.has(s) ? s : "400";
  const r = parseFloat(a);
  return t.italicAngle = isNaN(r) || r < -90 || r > 90 ? "14" : a.toString(), !0;
}
function p1(t) {
  const A = new RegExp("^\\s*(" + ["app.launchURL", "window.open", "xfa.host.gotoURL"].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(t);
  return A != null && A[2] ? { url: A[2], newWindow: A[1] === "app.launchURL" && A[3] === "true" } : null;
}
function vA(t) {
  if (Number.isInteger(t)) return t.toString();
  const A = Math.round(100 * t);
  return A % 100 == 0 ? (A / 100).toString() : A % 10 == 0 ? t.toFixed(1) : t.toFixed(2);
}
function m1(t) {
  if (!t) return null;
  const A = /* @__PURE__ */ new Map();
  for (const [e, i] of t) {
    if (!e.startsWith(K0)) continue;
    let a = A.get(i.pageIndex);
    a || (a = [], A.set(i.pageIndex, a)), a.push(i);
  }
  return A.size > 0 ? A : null;
}
function ie(t) {
  return function(e) {
    return /^[\x00-\x7F]*$/.test(e);
  }(t) ? t : y1(t, !0);
}
function jB(t) {
  const A = [];
  for (let e = 0, i = t.length; e < i; e++) {
    const a = t.charCodeAt(e);
    A.push(da[a >> 8 & 255], da[255 & a]);
  }
  return A.join("");
}
function y1(t, A = !1) {
  const e = [];
  A && e.push("þÿ");
  for (let i = 0, a = t.length; i < a; i++) {
    const s = t.charCodeAt(i);
    e.push(String.fromCharCode(s >> 8 & 255), String.fromCharCode(255 & s));
  }
  return e.join("");
}
function Qr(t, A, e) {
  switch (t) {
    case 90:
      return [0, 1, -1, 0, A, 0];
    case 180:
      return [-1, 0, 0, -1, A, e];
    case 270:
      return [0, -1, 1, 0, 0, e];
    default:
      throw new Error("Invalid rotation");
  }
}
function $I(t) {
  return Math.ceil(Math.ceil(Math.log2(1 + t)) / 8);
}
class At extends FA {
  constructor(A, e, i, a) {
    super(), this.bytes = A instanceof Uint8Array ? A : new Uint8Array(A), this.start = e || 0, this.pos = this.start, this.end = e + i || this.bytes.length, this.dict = a;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(A) {
    const e = this.bytes, i = this.pos, a = this.end;
    if (!A) return e.subarray(i, a);
    let s = i + A;
    return s > a && (s = a), this.pos = s, e.subarray(i, s);
  }
  getByteRange(A, e) {
    return A < 0 && (A = 0), e > this.end && (e = this.end), this.bytes.subarray(A, e);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(A, e, i = null) {
    return new At(this.bytes.buffer, A, e, i);
  }
}
class Ht extends At {
  constructor(A) {
    super(ut(A));
  }
}
class $g extends At {
  constructor() {
    super(new Uint8Array(0));
  }
}
class zB extends At {
  constructor(A, e, i) {
    super(new Uint8Array(A), 0, A, null), this.chunkSize = e, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(A / e), this.manager = i, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const A = [];
    for (let e = 0, i = this.numChunks; e < i; ++e) this._loadedChunks.has(e) || A.push(e);
    return A;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(A, e) {
    const i = this.chunkSize;
    if (A % i != 0) throw new Error(`Bad begin offset: ${A}`);
    const a = A + e.byteLength;
    if (a % i != 0 && a !== this.bytes.length) throw new Error(`Bad end offset: ${a}`);
    this.bytes.set(new Uint8Array(e), A);
    const s = Math.floor(A / i), r = Math.floor((a - 1) / i) + 1;
    for (let n = s; n < r; ++n) this._loadedChunks.add(n);
  }
  onReceiveProgressiveData(A) {
    let e = this.progressiveDataLength;
    const i = Math.floor(e / this.chunkSize);
    this.bytes.set(new Uint8Array(A), e), e += A.byteLength, this.progressiveDataLength = e;
    const a = e >= this.end ? this.numChunks : Math.floor(e / this.chunkSize);
    for (let s = i; s < a; ++s) this._loadedChunks.add(s);
  }
  ensureByte(A) {
    if (A < this.progressiveDataLength) return;
    const e = Math.floor(A / this.chunkSize);
    if (!(e > this.numChunks) && e !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(e)) throw new OA(A, A + 1);
      this.lastSuccessfulEnsureByteChunk = e;
    }
  }
  ensureRange(A, e) {
    if (A >= e || e <= this.progressiveDataLength) return;
    const i = Math.floor(A / this.chunkSize);
    if (i > this.numChunks) return;
    const a = Math.min(Math.floor((e - 1) / this.chunkSize) + 1, this.numChunks);
    for (let s = i; s < a; ++s) if (!this._loadedChunks.has(s)) throw new OA(A, e);
  }
  nextEmptyChunk(A) {
    const e = this.numChunks;
    for (let i = 0; i < e; ++i) {
      const a = (A + i) % e;
      if (!this._loadedChunks.has(a)) return a;
    }
    return null;
  }
  hasChunk(A) {
    return this._loadedChunks.has(A);
  }
  getByte() {
    const A = this.pos;
    return A >= this.end ? -1 : (A >= this.progressiveDataLength && this.ensureByte(A), this.bytes[this.pos++]);
  }
  getBytes(A) {
    const e = this.bytes, i = this.pos, a = this.end;
    if (!A)
      return a > this.progressiveDataLength && this.ensureRange(i, a), e.subarray(i, a);
    let s = i + A;
    return s > a && (s = a), s > this.progressiveDataLength && this.ensureRange(i, s), this.pos = s, e.subarray(i, s);
  }
  getByteRange(A, e) {
    return A < 0 && (A = 0), e > this.end && (e = this.end), e > this.progressiveDataLength && this.ensureRange(A, e), this.bytes.subarray(A, e);
  }
  makeSubStream(A, e, i = null) {
    e ? A + e > this.progressiveDataLength && this.ensureRange(A, A + e) : A >= this.progressiveDataLength && this.ensureByte(A);
    function a() {
    }
    a.prototype = Object.create(this), a.prototype.getMissingChunks = function() {
      const r = this.chunkSize, n = Math.floor(this.start / r), g = Math.floor((this.end - 1) / r) + 1, o = [];
      for (let I = n; I < g; ++I) this._loadedChunks.has(I) || o.push(I);
      return o;
    }, Object.defineProperty(a.prototype, "isDataLoaded", { get() {
      return this.numChunksLoaded === this.numChunks || this.getMissingChunks().length === 0;
    }, configurable: !0 });
    const s = new a();
    return s.pos = s.start = A, s.end = A + e || this.end, s.dict = i, s;
  }
  getBaseStreams() {
    return [this];
  }
}
class _B {
  constructor(A, e) {
    this.length = e.length, this.chunkSize = e.rangeChunkSize, this.stream = new zB(this.length, this.chunkSize, this), this.pdfNetworkStream = A, this.disableAutoFetch = e.disableAutoFetch, this.msgHandler = e.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(A, e) {
    const i = this.pdfNetworkStream.getRangeReader(A, e);
    i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));
    let a = [], s = 0;
    return new Promise((r, n) => {
      const g = ({ value: o, done: I }) => {
        try {
          if (I) {
            const C = d1(a);
            a = null, r(C);
            return;
          }
          s += o.byteLength, i.isStreamingSupported && this.onProgress({ loaded: s }), a.push(o), i.read().then(g, n);
        } catch (C) {
          n(C);
        }
      };
      i.read().then(g, n);
    }).then((r) => {
      this.aborted || this.onReceiveData({ chunk: r, begin: A });
    });
  }
  requestAllChunks(A = !1) {
    if (!A) {
      const e = this.stream.getMissingChunks();
      this._requestChunks(e);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(A) {
    const e = this.currRequestId++, i = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(e, i);
    for (const r of A) this.stream.hasChunk(r) || i.add(r);
    if (i.size === 0) return Promise.resolve();
    const a = Promise.withResolvers();
    this._promisesByRequest.set(e, a);
    const s = [];
    for (const r of i) {
      let n = this._requestsByChunk.get(r);
      n || (n = [], this._requestsByChunk.set(r, n), s.push(r)), n.push(e);
    }
    if (s.length > 0) {
      const r = this.groupChunks(s);
      for (const n of r) {
        const g = n.beginChunk * this.chunkSize, o = Math.min(n.endChunk * this.chunkSize, this.length);
        this.sendRequest(g, o).catch(a.reject);
      }
    }
    return a.promise.catch((r) => {
      if (!this.aborted) throw r;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(A, e) {
    e = Math.min(e, this.length);
    const i = this.getBeginChunk(A), a = this.getEndChunk(e), s = [];
    for (let r = i; r < a; ++r) s.push(r);
    return this._requestChunks(s);
  }
  requestRanges(A = []) {
    const e = [];
    for (const i of A) {
      const a = this.getBeginChunk(i.begin), s = this.getEndChunk(i.end);
      for (let r = a; r < s; ++r) e.includes(r) || e.push(r);
    }
    return e.sort(function(i, a) {
      return i - a;
    }), this._requestChunks(e);
  }
  groupChunks(A) {
    const e = [];
    let i = -1, a = -1;
    for (let s = 0, r = A.length; s < r; ++s) {
      const n = A[s];
      i < 0 && (i = n), a >= 0 && a + 1 !== n && (e.push({ beginChunk: i, endChunk: a + 1 }), i = n), s + 1 === A.length && e.push({ beginChunk: i, endChunk: n + 1 }), a = n;
    }
    return e;
  }
  onProgress(A) {
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize + A.loaded, total: this.length });
  }
  onReceiveData(A) {
    const e = A.chunk, i = A.begin === void 0, a = i ? this.progressiveDataLength : A.begin, s = a + e.byteLength, r = Math.floor(a / this.chunkSize), n = s < this.length ? Math.floor(s / this.chunkSize) : Math.ceil(s / this.chunkSize);
    i ? (this.stream.onReceiveProgressiveData(e), this.progressiveDataLength = s) : this.stream.onReceiveData(a, e), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const g = [];
    for (let o = r; o < n; ++o) {
      const I = this._requestsByChunk.get(o);
      if (I) {
        this._requestsByChunk.delete(o);
        for (const C of I) {
          const h = this._chunksNeededByRequest.get(C);
          h.has(o) && h.delete(o), h.size > 0 || g.push(C);
        }
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let o;
      if (this.stream.numChunksLoaded === 1) {
        const I = this.stream.numChunks - 1;
        this.stream.hasChunk(I) || (o = I);
      } else o = this.stream.nextEmptyChunk(n);
      Number.isInteger(o) && this._requestChunks([o]);
    }
    for (const o of g) {
      const I = this._promisesByRequest.get(o);
      this._promisesByRequest.delete(o), I.resolve();
    }
    this.msgHandler.send("DocProgress", { loaded: this.stream.numChunksLoaded * this.chunkSize, total: this.length });
  }
  onError(A) {
    this._loadedStreamCapability.reject(A);
  }
  getBeginChunk(A) {
    return Math.floor(A / this.chunkSize);
  }
  getEndChunk(A) {
    return Math.floor((A - 1) / this.chunkSize) + 1;
  }
  abort(A) {
    var e;
    this.aborted = !0, (e = this.pdfNetworkStream) == null || e.cancelAllRequests(A);
    for (const i of this._promisesByRequest.values()) i.reject(A);
  }
}
class kA {
  constructor(A, e) {
    this.name = A, this.numComps = e;
  }
  getRgb(A, e) {
    const i = new Uint8ClampedArray(3);
    return this.getRgbItem(A, e, i, 0), i;
  }
  getRgbItem(A, e, i, a) {
    xA("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(A, e, i, a, s, r, n) {
    xA("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(A, e) {
    xA("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(A) {
    return !1;
  }
  isDefaultDecode(A, e) {
    return kA.isDefaultDecode(A, this.numComps);
  }
  fillRgb(A, e, i, a, s, r, n, g, o) {
    const I = e * i;
    let C = null;
    const h = 1 << n, c = i !== s || e !== a;
    if (this.isPassthrough(n)) C = g;
    else if (this.numComps === 1 && I > h && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const B = n <= 8 ? new Uint8Array(h) : new Uint16Array(h);
      for (let Q = 0; Q < h; Q++) B[Q] = Q;
      const l = new Uint8ClampedArray(3 * h);
      if (this.getRgbBuffer(B, 0, h, l, 0, n, 0), c) {
        C = new Uint8Array(3 * I);
        let Q = 0;
        for (let E = 0; E < I; ++E) {
          const u = 3 * g[E];
          C[Q++] = l[u], C[Q++] = l[u + 1], C[Q++] = l[u + 2];
        }
      } else {
        let Q = 0;
        for (let E = 0; E < I; ++E) {
          const u = 3 * g[E];
          A[Q++] = l[u], A[Q++] = l[u + 1], A[Q++] = l[u + 2], Q += o;
        }
      }
    } else c ? (C = new Uint8ClampedArray(3 * I), this.getRgbBuffer(g, 0, I, C, 0, n, 0)) : this.getRgbBuffer(g, 0, a * r, A, 0, n, o);
    if (C) if (c) (function(l, Q, E, u, f, d, p) {
      p = p !== 1 ? 0 : p;
      const m = E / f, y = u / d;
      let b, D = 0;
      const R = new Uint16Array(f), k = 3 * E;
      for (let Y = 0; Y < f; Y++) R[Y] = 3 * Math.floor(Y * m);
      for (let Y = 0; Y < d; Y++) {
        const V = Math.floor(Y * y) * k;
        for (let eA = 0; eA < f; eA++)
          b = V + R[eA], Q[D++] = l[b++], Q[D++] = l[b++], Q[D++] = l[b++], D += p;
      }
    })(C, A, e, i, a, s, o);
    else {
      let B = 0, l = 0;
      for (let Q = 0, E = a * r; Q < E; Q++)
        A[B++] = C[l++], A[B++] = C[l++], A[B++] = C[l++], B += o;
    }
  }
  get usesZeroToOneRange() {
    return sA(this, "usesZeroToOneRange", !0);
  }
  static _cache(A, e, i, a) {
    if (!i) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    if (!a) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    let s, r;
    A instanceof rA && (r = A, A = e.fetch(A)), A instanceof T && (s = A.name), (s || r) && i.set(s, r, a);
  }
  static getCached(A, e, i) {
    if (!i) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    if (A instanceof rA) {
      const a = i.getByRef(A);
      if (a) return a;
      try {
        A = e.fetch(A);
      } catch (s) {
        if (s instanceof OA) throw s;
      }
    }
    if (A instanceof T) {
      const a = i.getByName(A.name);
      if (a) return a;
    }
    return null;
  }
  static async parseAsync({ cs: A, xref: e, resources: i = null, pdfFunctionFactory: a, localColorSpaceCache: s }) {
    const r = this._parse(A, e, i, a);
    return this._cache(A, e, s, r), r;
  }
  static parse({ cs: A, xref: e, resources: i = null, pdfFunctionFactory: a, localColorSpaceCache: s }) {
    const r = this.getCached(A, e, s);
    if (r) return r;
    const n = this._parse(A, e, i, a);
    return this._cache(A, e, s, n), n;
  }
  static _parse(A, e, i = null, a) {
    if ((A = e.fetchIfRef(A)) instanceof T) switch (A.name) {
      case "G":
      case "DeviceGray":
        return this.singletons.gray;
      case "RGB":
      case "DeviceRGB":
        return this.singletons.rgb;
      case "DeviceRGBA":
        return this.singletons.rgba;
      case "CMYK":
      case "DeviceCMYK":
        return this.singletons.cmyk;
      case "Pattern":
        return new Ac(null);
      default:
        if (i instanceof U) {
          const s = i.get("ColorSpace");
          if (s instanceof U) {
            const r = s.get(A.name);
            if (r) {
              if (r instanceof T) return this._parse(r, e, i, a);
              A = r;
              break;
            }
          }
        }
        return G(`Unrecognized ColorSpace: ${A.name}`), this.singletons.gray;
    }
    if (Array.isArray(A)) {
      const s = e.fetchIfRef(A[0]).name;
      let r, n, g, o, I, C;
      switch (s) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "CalGray":
          return r = e.fetchIfRef(A[1]), o = r.getArray("WhitePoint"), I = r.getArray("BlackPoint"), C = r.get("Gamma"), new sl(o, I, C);
        case "CalRGB":
          r = e.fetchIfRef(A[1]), o = r.getArray("WhitePoint"), I = r.getArray("BlackPoint"), C = r.getArray("Gamma");
          const h = r.getArray("Matrix");
          return new eo(o, I, C, h);
        case "ICCBased":
          const c = e.fetchIfRef(A[1]).dict;
          n = c.get("N");
          const B = c.get("Alternate");
          if (B) {
            const d = this._parse(B, e, i, a);
            if (d.numComps === n) return d;
            G("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (n === 1) return this.singletons.gray;
          if (n === 3) return this.singletons.rgb;
          if (n === 4) return this.singletons.cmyk;
          break;
        case "Pattern":
          return g = A[1] || null, g && (g = this._parse(g, e, i, a)), new Ac(g);
        case "I":
        case "Indexed":
          g = this._parse(A[1], e, i, a);
          const l = Math.max(0, Math.min(e.fetchIfRef(A[2]), 255)), Q = e.fetchIfRef(A[3]);
          return new Al(g, l, Q);
        case "Separation":
        case "DeviceN":
          const E = e.fetchIfRef(A[1]);
          n = Array.isArray(E) ? E.length : 1, g = this._parse(A[2], e, i, a);
          const u = a.create(A[3]);
          return new $B(n, g, u);
        case "Lab":
          r = e.fetchIfRef(A[1]), o = r.getArray("WhitePoint"), I = r.getArray("BlackPoint");
          const f = r.getArray("Range");
          return new nl(o, I, f);
        default:
          return G(`Unimplemented ColorSpace object: ${s}`), this.singletons.gray;
      }
    }
    return G(`Unrecognized ColorSpace object: ${A}`), this.singletons.gray;
  }
  static isDefaultDecode(A, e) {
    if (!Array.isArray(A)) return !0;
    if (2 * e !== A.length)
      return G("The decode map is not the correct length"), !0;
    for (let i = 0, a = A.length; i < a; i += 2) if (A[i] !== 0 || A[i + 1] !== 1) return !1;
    return !0;
  }
  static get singletons() {
    return sA(this, "singletons", { get gray() {
      return sA(this, "gray", new tl());
    }, get rgb() {
      return sA(this, "rgb", new el());
    }, get rgba() {
      return sA(this, "rgba", new il());
    }, get cmyk() {
      return sA(this, "cmyk", new al());
    } });
  }
}
class $B extends kA {
  constructor(A, e, i) {
    super("Alternate", A), this.base = e, this.tintFn = i, this.tmpBuf = new Float32Array(e.numComps);
  }
  getRgbItem(A, e, i, a) {
    const s = this.tmpBuf;
    this.tintFn(A, e, s, 0), this.base.getRgbItem(s, 0, i, a);
  }
  getRgbBuffer(A, e, i, a, s, r, n) {
    const g = this.tintFn, o = this.base, I = 1 / ((1 << r) - 1), C = o.numComps, h = o.usesZeroToOneRange, c = (o.isPassthrough(8) || !h) && n === 0;
    let B = c ? s : 0;
    const l = c ? a : new Uint8ClampedArray(C * i), Q = this.numComps, E = new Float32Array(Q), u = new Float32Array(C);
    let f, d;
    for (f = 0; f < i; f++) {
      for (d = 0; d < Q; d++) E[d] = A[e++] * I;
      if (g(E, 0, u, 0), h) for (d = 0; d < C; d++) l[B++] = 255 * u[d];
      else
        o.getRgbItem(u, 0, l, B), B += C;
    }
    c || o.getRgbBuffer(l, 0, i, a, s, 8, n);
  }
  getOutputLength(A, e) {
    return this.base.getOutputLength(A * this.base.numComps / this.numComps, e);
  }
}
class Ac extends kA {
  constructor(A) {
    super("Pattern", null), this.base = A;
  }
  isDefaultDecode(A, e) {
    xA("Should not call PatternCS.isDefaultDecode");
  }
}
class Al extends kA {
  constructor(A, e, i) {
    super("Indexed", 1), this.base = A;
    const a = A.numComps * (e + 1);
    if (this.lookup = new Uint8Array(a), i instanceof FA) {
      const s = i.getBytes(a);
      this.lookup.set(s);
    } else {
      if (typeof i != "string") throw new X(`IndexedCS - unrecognized lookup table: ${i}`);
      for (let s = 0; s < a; ++s) this.lookup[s] = 255 & i.charCodeAt(s);
    }
  }
  getRgbItem(A, e, i, a) {
    const s = this.base.numComps, r = A[e] * s;
    this.base.getRgbBuffer(this.lookup, r, 1, i, a, 8, 0);
  }
  getRgbBuffer(A, e, i, a, s, r, n) {
    const g = this.base, o = g.numComps, I = g.getOutputLength(o, n), C = this.lookup;
    for (let h = 0; h < i; ++h) {
      const c = A[e++] * o;
      g.getRgbBuffer(C, c, 1, a, s, 8, n), s += I;
    }
  }
  getOutputLength(A, e) {
    return this.base.getOutputLength(A * this.base.numComps, e);
  }
  isDefaultDecode(A, e) {
    return Array.isArray(A) ? A.length !== 2 ? (G("Decode map length is not correct"), !0) : !Number.isInteger(e) || e < 1 ? (G("Bits per component is not correct"), !0) : A[0] === 0 && A[1] === (1 << e) - 1 : !0;
  }
}
class tl extends kA {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(A, e, i, a) {
    const s = 255 * A[e];
    i[a] = i[a + 1] = i[a + 2] = s;
  }
  getRgbBuffer(A, e, i, a, s, r, n) {
    const g = 255 / ((1 << r) - 1);
    let o = e, I = s;
    for (let C = 0; C < i; ++C) {
      const h = g * A[o++];
      a[I++] = h, a[I++] = h, a[I++] = h, I += n;
    }
  }
  getOutputLength(A, e) {
    return A * (3 + e);
  }
}
class el extends kA {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(A, e, i, a) {
    i[a] = 255 * A[e], i[a + 1] = 255 * A[e + 1], i[a + 2] = 255 * A[e + 2];
  }
  getRgbBuffer(A, e, i, a, s, r, n) {
    if (r === 8 && n === 0) {
      a.set(A.subarray(e, e + 3 * i), s);
      return;
    }
    const g = 255 / ((1 << r) - 1);
    let o = e, I = s;
    for (let C = 0; C < i; ++C)
      a[I++] = g * A[o++], a[I++] = g * A[o++], a[I++] = g * A[o++], I += n;
  }
  getOutputLength(A, e) {
    return A * (3 + e) / 3 | 0;
  }
  isPassthrough(A) {
    return A === 8;
  }
}
class il extends kA {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(A, e) {
    return 4 * A;
  }
  isPassthrough(A) {
    return A === 8;
  }
  fillRgb(A, e, i, a, s, r, n, g, o) {
    i !== s || e !== a ? function(C, h, c, B, l, Q, E) {
      const u = c / l, f = B / Q;
      let d = 0;
      const p = new Uint16Array(l);
      if (E === 1) {
        for (let D = 0; D < l; D++) p[D] = Math.floor(D * u);
        const m = new Uint32Array(C.buffer), y = new Uint32Array(h.buffer), b = Jt.isLittleEndian ? 16777215 : 4294967040;
        for (let D = 0; D < Q; D++) {
          const R = m.subarray(Math.floor(D * f) * c);
          for (let k = 0; k < l; k++) y[d++] |= R[p[k]] & b;
        }
      } else {
        const y = c * 4;
        for (let b = 0; b < l; b++) p[b] = Math.floor(b * u) * 4;
        for (let b = 0; b < Q; b++) {
          const D = C.subarray(Math.floor(b * f) * y);
          for (let R = 0; R < l; R++) {
            const k = p[R];
            h[d++] = D[k], h[d++] = D[k + 1], h[d++] = D[k + 2];
          }
        }
      }
    }(g, A, e, i, a, s, o) : function(C, h, c) {
      if (c === 1) {
        const B = new Uint32Array(C.buffer), l = new Uint32Array(h.buffer), Q = Jt.isLittleEndian ? 16777215 : 4294967040;
        for (let E = 0, u = B.length; E < u; E++) l[E] |= B[E] & Q;
      } else {
        let B = 0;
        for (let l = 0, Q = C.length; l < Q; l += 4)
          h[B++] = C[l], h[B++] = C[l + 1], h[B++] = C[l + 2];
      }
    }(g, A, o);
  }
}
var vs, Ao;
class al extends kA {
  constructor() {
    super("DeviceCMYK", 4);
    MA(this, vs);
  }
  getRgbItem(e, i, a, s) {
    CA(this, vs, Ao).call(this, e, i, 1, a, s);
  }
  getRgbBuffer(e, i, a, s, r, n, g) {
    const o = 1 / ((1 << n) - 1);
    for (let I = 0; I < a; I++)
      CA(this, vs, Ao).call(this, e, i, o, s, r), i += 4, r += 3 + g;
  }
  getOutputLength(e, i) {
    return e / 4 * (3 + i) | 0;
  }
}
vs = new WeakSet(), Ao = function(e, i, a, s, r) {
  const n = e[i] * a, g = e[i + 1] * a, o = e[i + 2] * a, I = e[i + 3] * a;
  s[r] = 255 + n * (-4.387332384609988 * n + 54.48615194189176 * g + 18.82290502165302 * o + 212.25662451639585 * I - 285.2331026137004) + g * (1.7149763477362134 * g - 5.6096736904047315 * o + -17.873870861415444 * I - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * I + 17.5119270841813) + I * (-21.86122147463605 * I - 189.48180835922747), s[r + 1] = 255 + n * (8.841041422036149 * n + 60.118027045597366 * g + 6.871425592049007 * o + 31.159100130055922 * I - 79.2970844816548) + g * (-15.310361306967817 * g + 17.575251261109482 * o + 131.35250912493976 * I - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * I - 24.86741582555878) + I * (-20.737325471181034 * I - 187.80453709719578), s[r + 2] = 255 + n * (0.8842522430003296 * n + 8.078677503112928 * g + 30.89978309703729 * o - 0.23883238689178934 * I - 14.183576799673286) + g * (10.49593273432072 * g + 63.02378494754052 * o + 50.606957656360734 * I - 112.23884253719248) + o * (0.03296041114873217 * o + 115.60384449646641 * I - 193.58209356861505) + I * (-22.33816807309886 * I - 180.12613974708367);
};
var Ks, to;
class sl extends kA {
  constructor(e, i, a) {
    super("CalGray", 1);
    MA(this, Ks);
    if (!e) throw new X("WhitePoint missing - required for color space CalGray");
    if ([this.XW, this.YW, this.ZW] = e, [this.XB, this.YB, this.ZB] = i || [0, 0, 0], this.G = a || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1) throw new X(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (RA(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), this.XB === 0 && this.YB === 0 && this.ZB === 0 || G(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (RA(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
  }
  getRgbItem(e, i, a, s) {
    CA(this, Ks, to).call(this, e, i, a, s, 1);
  }
  getRgbBuffer(e, i, a, s, r, n, g) {
    const o = 1 / ((1 << n) - 1);
    for (let I = 0; I < a; ++I)
      CA(this, Ks, to).call(this, e, i, s, r, o), i += 1, r += 3 + g;
  }
  getOutputLength(e, i) {
    return e * (3 + i);
  }
}
Ks = new WeakSet(), to = function(e, i, a, s, r) {
  const n = (e[i] * r) ** this.G, g = this.YW * n, o = Math.max(295.8 * g ** 0.3333333333333333 - 40.8, 0);
  a[s] = o, a[s + 1] = o, a[s + 2] = o;
};
var qs, Ts, xr, Ur, Ps, Da, Ws, Mr, YA, ia, w1, D1, vn, aa, sa, b1, k1, F1, io;
const zA = class zA extends kA {
  constructor(e, i, a, s) {
    super("CalRGB", 3);
    MA(this, YA);
    if (!e) throw new X("WhitePoint missing - required for color space CalRGB");
    const [r, n, g] = this.whitePoint = e, [o, I, C] = this.blackPoint = i || new Float32Array(3);
    if ([this.GR, this.GG, this.GB] = a || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = s || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), r < 0 || g < 0 || n !== 1) throw new X(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (o < 0 || I < 0 || C < 0) && (RA(`Invalid BlackPoint for ${this.name} [${o}, ${I}, ${C}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (RA(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
  }
  getRgbItem(e, i, a, s) {
    CA(this, YA, io).call(this, e, i, a, s, 1);
  }
  getRgbBuffer(e, i, a, s, r, n, g) {
    const o = 1 / ((1 << n) - 1);
    for (let I = 0; I < a; ++I)
      CA(this, YA, io).call(this, e, i, s, r, o), i += 3, r += 3 + g;
  }
  getOutputLength(e, i) {
    return e * (3 + i) / 3 | 0;
  }
};
qs = new WeakMap(), Ts = new WeakMap(), xr = new WeakMap(), Ur = new WeakMap(), Ps = new WeakMap(), Da = new WeakMap(), Ws = new WeakMap(), Mr = new WeakMap(), YA = new WeakSet(), ia = function(e, i, a) {
  a[0] = e[0] * i[0] + e[1] * i[1] + e[2] * i[2], a[1] = e[3] * i[0] + e[4] * i[1] + e[5] * i[2], a[2] = e[6] * i[0] + e[7] * i[1] + e[8] * i[2];
}, w1 = function(e, i, a) {
  a[0] = 1 * i[0] / e[0], a[1] = 1 * i[1] / e[1], a[2] = 1 * i[2] / e[2];
}, D1 = function(e, i, a) {
  a[0] = 0.95047 * i[0] / e[0], a[1] = 1 * i[1] / e[1], a[2] = 1.08883 * i[2] / e[2];
}, vn = function(e) {
  return e <= 31308e-7 ? CA(this, YA, aa).call(this, 0, 1, 12.92 * e) : e >= 0.99554525 ? 1 : CA(this, YA, aa).call(this, 0, 1, 1.055 * e ** (1 / 2.4) - 0.055);
}, aa = function(e, i, a) {
  return Math.max(e, Math.min(i, a));
}, sa = function(e) {
  return e < 0 ? -CA(this, YA, sa).call(this, -e) : e > 8 ? ((e + 16) / 116) ** 3 : e * NA(zA, Mr);
}, b1 = function(e, i, a) {
  if (e[0] === 0 && e[1] === 0 && e[2] === 0) {
    a[0] = i[0], a[1] = i[1], a[2] = i[2];
    return;
  }
  const s = CA(this, YA, sa).call(this, 0), r = (1 - s) / (1 - CA(this, YA, sa).call(this, e[0])), n = 1 - r, g = (1 - s) / (1 - CA(this, YA, sa).call(this, e[1])), o = 1 - g, I = (1 - s) / (1 - CA(this, YA, sa).call(this, e[2])), C = 1 - I;
  a[0] = i[0] * r + n, a[1] = i[1] * g + o, a[2] = i[2] * I + C;
}, k1 = function(e, i, a) {
  if (e[0] === 1 && e[2] === 1) {
    a[0] = i[0], a[1] = i[1], a[2] = i[2];
    return;
  }
  const s = a;
  CA(this, YA, ia).call(this, NA(zA, qs), i, s);
  const r = NA(zA, Ps);
  CA(this, YA, w1).call(this, e, s, r), CA(this, YA, ia).call(this, NA(zA, Ts), r, a);
}, F1 = function(e, i, a) {
  const s = a;
  CA(this, YA, ia).call(this, NA(zA, qs), i, s);
  const r = NA(zA, Ps);
  CA(this, YA, D1).call(this, e, s, r), CA(this, YA, ia).call(this, NA(zA, Ts), r, a);
}, io = function(e, i, a, s, r) {
  const n = CA(this, YA, aa).call(this, 0, 1, e[i] * r), g = CA(this, YA, aa).call(this, 0, 1, e[i + 1] * r), o = CA(this, YA, aa).call(this, 0, 1, e[i + 2] * r), I = n === 1 ? 1 : n ** this.GR, C = g === 1 ? 1 : g ** this.GG, h = o === 1 ? 1 : o ** this.GB, c = this.MXA * I + this.MXB * C + this.MXC * h, B = this.MYA * I + this.MYB * C + this.MYC * h, l = this.MZA * I + this.MZB * C + this.MZC * h, Q = NA(zA, Da);
  Q[0] = c, Q[1] = B, Q[2] = l;
  const E = NA(zA, Ws);
  CA(this, YA, k1).call(this, this.whitePoint, Q, E);
  const u = NA(zA, Da);
  CA(this, YA, b1).call(this, this.blackPoint, E, u);
  const f = NA(zA, Ws);
  CA(this, YA, F1).call(this, NA(zA, Ur), u, f);
  const d = NA(zA, Da);
  CA(this, YA, ia).call(this, NA(zA, xr), f, d), a[s] = 255 * CA(this, YA, vn).call(this, d[0]), a[s + 1] = 255 * CA(this, YA, vn).call(this, d[1]), a[s + 2] = 255 * CA(this, YA, vn).call(this, d[2]);
}, MA(zA, qs, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296])), MA(zA, Ts, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867])), MA(zA, xr, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252])), MA(zA, Ur, new Float32Array([1, 1, 1])), MA(zA, Ps, new Float32Array(3)), MA(zA, Da, new Float32Array(3)), MA(zA, Ws, new Float32Array(3)), MA(zA, Mr, (24 / 116) ** 3 / 8);
let eo = zA;
var Ot, Kn, qn, ao;
class nl extends kA {
  constructor(e, i, a) {
    super("Lab", 3);
    MA(this, Ot);
    if (!e) throw new X("WhitePoint missing - required for color space Lab");
    if ([this.XW, this.YW, this.ZW] = e, [this.amin, this.amax, this.bmin, this.bmax] = a || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = i || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1) throw new X("Invalid WhitePoint components, no fallback available");
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (RA("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (RA("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
  }
  getRgbItem(e, i, a, s) {
    CA(this, Ot, ao).call(this, e, i, !1, a, s);
  }
  getRgbBuffer(e, i, a, s, r, n, g) {
    const o = (1 << n) - 1;
    for (let I = 0; I < a; I++)
      CA(this, Ot, ao).call(this, e, i, o, s, r), i += 3, r += 3 + g;
  }
  getOutputLength(e, i) {
    return e * (3 + i) / 3 | 0;
  }
  isDefaultDecode(e, i) {
    return !0;
  }
  get usesZeroToOneRange() {
    return sA(this, "usesZeroToOneRange", !1);
  }
}
Ot = new WeakSet(), Kn = function(e) {
  return e >= 6 / 29 ? e ** 3 : 108 / 841 * (e - 4 / 29);
}, qn = function(e, i, a, s) {
  return a + e * (s - a) / i;
}, ao = function(e, i, a, s, r) {
  let n = e[i], g = e[i + 1], o = e[i + 2];
  a !== !1 && (n = CA(this, Ot, qn).call(this, n, a, 0, 100), g = CA(this, Ot, qn).call(this, g, a, this.amin, this.amax), o = CA(this, Ot, qn).call(this, o, a, this.bmin, this.bmax)), g > this.amax ? g = this.amax : g < this.amin && (g = this.amin), o > this.bmax ? o = this.bmax : o < this.bmin && (o = this.bmin);
  const I = (n + 16) / 116, C = I + g / 500, h = I - o / 200, c = this.XW * CA(this, Ot, Kn).call(this, C), B = this.YW * CA(this, Ot, Kn).call(this, I), l = this.ZW * CA(this, Ot, Kn).call(this, h);
  let Q, E, u;
  this.ZW < 1 ? (Q = 3.1339 * c + -1.617 * B + -0.4906 * l, E = -0.9785 * c + 1.916 * B + 0.0333 * l, u = 0.072 * c + -0.229 * B + 1.4057 * l) : (Q = 3.2406 * c + -1.5372 * B + -0.4986 * l, E = -0.9689 * c + 1.8758 * B + 0.0415 * l, u = 0.0557 * c + -0.204 * B + 1.057 * l), s[r] = 255 * Math.sqrt(Q), s[r + 1] = 255 * Math.sqrt(E), s[r + 2] = 255 * Math.sqrt(u);
};
function ft(t, A) {
  let e = 0;
  for (let i = 0; i <= A; i++) e = e << 8 | t[i];
  return e >>> 0;
}
function hn(t, A) {
  return A === 1 ? String.fromCharCode(t[0], t[1]) : A === 3 ? String.fromCharCode(t[0], t[1], t[2], t[3]) : String.fromCharCode(...t.subarray(0, A + 1));
}
function St(t, A, e) {
  let i = 0;
  for (let a = e; a >= 0; a--)
    i += t[a] + A[a], t[a] = 255 & i, i >>= 8;
}
function fi(t, A) {
  let e = 1;
  for (let i = A; i >= 0 && e > 0; i--)
    e += t[i], t[i] = 255 & e, e >>= 8;
}
const ji = 16;
class rl {
  constructor(A) {
    this.buffer = A, this.pos = 0, this.end = A.length, this.tmpBuf = new Uint8Array(19);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let A, e = 0;
    do {
      const i = this.readByte();
      if (i < 0) throw new X("unexpected EOF in bcmap");
      A = !(128 & i), e = e << 7 | 127 & i;
    } while (!A);
    return e;
  }
  readSigned() {
    const A = this.readNumber();
    return 1 & A ? ~(A >>> 1) : A >>> 1;
  }
  readHex(A, e) {
    A.set(this.buffer.subarray(this.pos, this.pos + e + 1)), this.pos += e + 1;
  }
  readHexNumber(A, e) {
    let i;
    const a = this.tmpBuf;
    let s = 0;
    do {
      const o = this.readByte();
      if (o < 0) throw new X("unexpected EOF in bcmap");
      i = !(128 & o), a[s++] = 127 & o;
    } while (!i);
    let r = e, n = 0, g = 0;
    for (; r >= 0; ) {
      for (; g < 8 && a.length > 0; )
        n |= a[--s] << g, g += 7;
      A[r] = 255 & n, r--, n >>= 8, g -= 8;
    }
  }
  readHexSigned(A, e) {
    this.readHexNumber(A, e);
    const i = 1 & A[e] ? 255 : 0;
    let a = 0;
    for (let s = 0; s <= e; s++)
      a = (1 & a) << 8 | A[s], A[s] = a >> 1 ^ i;
  }
  readString() {
    const A = this.readNumber(), e = new Array(A);
    for (let i = 0; i < A; i++) e[i] = this.readNumber();
    return String.fromCharCode(...e);
  }
}
class gl {
  async process(A, e, i) {
    const a = new rl(A), s = a.readByte();
    e.vertical = !!(1 & s);
    let r = null;
    const n = new Uint8Array(ji), g = new Uint8Array(ji), o = new Uint8Array(ji), I = new Uint8Array(ji), C = new Uint8Array(ji);
    let h, c;
    for (; (c = a.readByte()) >= 0; ) {
      const B = c >> 5;
      if (B === 7) {
        switch (31 & c) {
          case 0:
            a.readString();
            break;
          case 1:
            r = a.readString();
        }
        continue;
      }
      const l = !!(16 & c), Q = 15 & c;
      if (Q + 1 > ji) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const E = 1, u = a.readNumber();
      switch (B) {
        case 0:
          a.readHex(n, Q), a.readHexNumber(g, Q), St(g, n, Q), e.addCodespaceRange(Q + 1, ft(n, Q), ft(g, Q));
          for (let f = 1; f < u; f++)
            fi(g, Q), a.readHexNumber(n, Q), St(n, g, Q), a.readHexNumber(g, Q), St(g, n, Q), e.addCodespaceRange(Q + 1, ft(n, Q), ft(g, Q));
          break;
        case 1:
          a.readHex(n, Q), a.readHexNumber(g, Q), St(g, n, Q), a.readNumber();
          for (let f = 1; f < u; f++)
            fi(g, Q), a.readHexNumber(n, Q), St(n, g, Q), a.readHexNumber(g, Q), St(g, n, Q), a.readNumber();
          break;
        case 2:
          a.readHex(o, Q), h = a.readNumber(), e.mapOne(ft(o, Q), h);
          for (let f = 1; f < u; f++)
            fi(o, Q), l || (a.readHexNumber(C, Q), St(o, C, Q)), h = a.readSigned() + (h + 1), e.mapOne(ft(o, Q), h);
          break;
        case 3:
          a.readHex(n, Q), a.readHexNumber(g, Q), St(g, n, Q), h = a.readNumber(), e.mapCidRange(ft(n, Q), ft(g, Q), h);
          for (let f = 1; f < u; f++)
            fi(g, Q), l ? n.set(g) : (a.readHexNumber(n, Q), St(n, g, Q)), a.readHexNumber(g, Q), St(g, n, Q), h = a.readNumber(), e.mapCidRange(ft(n, Q), ft(g, Q), h);
          break;
        case 4:
          a.readHex(o, E), a.readHex(I, Q), e.mapOne(ft(o, E), hn(I, Q));
          for (let f = 1; f < u; f++)
            fi(o, E), l || (a.readHexNumber(C, E), St(o, C, E)), fi(I, Q), a.readHexSigned(C, Q), St(I, C, Q), e.mapOne(ft(o, E), hn(I, Q));
          break;
        case 5:
          a.readHex(n, E), a.readHexNumber(g, E), St(g, n, E), a.readHex(I, Q), e.mapBfRange(ft(n, E), ft(g, E), hn(I, Q));
          for (let f = 1; f < u; f++)
            fi(g, E), l ? n.set(g) : (a.readHexNumber(n, E), St(n, g, E)), a.readHexNumber(g, E), St(g, n, E), a.readHex(I, Q), e.mapBfRange(ft(n, E), ft(g, E), hn(I, Q));
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${B}`);
      }
    }
    return r ? i(r) : e;
  }
}
const ol = new Uint8Array(0);
class Dt extends FA {
  constructor(A) {
    if (super(), this._rawMinBufferLength = A || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = ol, this.minBufferLength = 512, A) for (; this.minBufferLength < A; ) this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && this.bufferLength === 0; ) this.readBlock();
    return this.bufferLength === 0;
  }
  ensureBuffer(A) {
    const e = this.buffer;
    if (A <= e.byteLength) return e;
    let i = this.minBufferLength;
    for (; i < A; ) i *= 2;
    const a = new Uint8Array(i);
    return a.set(e), this.buffer = a;
  }
  getByte() {
    const A = this.pos;
    for (; this.bufferLength <= A; ) {
      if (this.eof) return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(A, e = null) {
    const i = this.pos;
    let a;
    if (A) {
      for (this.ensureBuffer(i + A), a = i + A; !this.eof && this.bufferLength < a; ) this.readBlock(e);
      const s = this.bufferLength;
      a > s && (a = s);
    } else {
      for (; !this.eof; ) this.readBlock(e);
      a = this.bufferLength;
    }
    return this.pos = a, this.buffer.subarray(i, a);
  }
  async getImageData(A, e = null) {
    if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(A, e);
    const i = await this.stream.asyncGetBytes();
    return this.decodeImage(i, e);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(A, e, i = null) {
    if (e === void 0) for (; !this.eof; ) this.readBlock();
    else {
      const a = A + e;
      for (; this.bufferLength <= a && !this.eof; ) this.readBlock();
    }
    return new At(this.buffer, A, e, i);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
class Il extends Dt {
  constructor(A, e = null) {
    A = A.filter((a) => a instanceof FA);
    let i = 0;
    for (const a of A) i += a instanceof Dt ? a._rawMinBufferLength : a.length;
    super(i), this.streams = A, this._onError = e;
  }
  readBlock() {
    var r;
    const A = this.streams;
    if (A.length === 0) {
      this.eof = !0;
      return;
    }
    const e = A.shift();
    let i;
    try {
      i = e.getBytes();
    } catch (n) {
      if (this._onError) {
        this._onError(n, (r = e.dict) == null ? void 0 : r.objId);
        return;
      }
      throw n;
    }
    const a = this.bufferLength, s = a + i.length;
    this.ensureBuffer(s).set(i, a), this.bufferLength = s;
  }
  getBaseStreams() {
    const A = [];
    for (const e of this.streams) {
      const i = e.getBaseStreams();
      i && A.push(...i);
    }
    return A.length > 0 ? A : null;
  }
}
class cl extends Dt {
  constructor(A, e) {
    e && (e *= 0.8), super(e), this.str = A, this.dict = A.dict, this.input = new Uint8Array(5);
  }
  readBlock() {
    const A = this.str;
    let e = A.getByte();
    for (; Zt(e); ) e = A.getByte();
    if (e === -1 || e === 126) {
      this.eof = !0;
      return;
    }
    const i = this.bufferLength;
    let a, s;
    if (e === 122) {
      for (a = this.ensureBuffer(i + 4), s = 0; s < 4; ++s) a[i + s] = 0;
      this.bufferLength += 4;
    } else {
      const r = this.input;
      for (r[0] = e, s = 1; s < 5; ++s) {
        for (e = A.getByte(); Zt(e); ) e = A.getByte();
        if (r[s] = e, e === -1 || e === 126) break;
      }
      if (a = this.ensureBuffer(i + s - 1), this.bufferLength += s - 1, s < 5) {
        for (; s < 5; ++s) r[s] = 117;
        this.eof = !0;
      }
      let n = 0;
      for (s = 0; s < 5; ++s) n = 85 * n + (r[s] - 33);
      for (s = 3; s >= 0; --s)
        a[i + s] = 255 & n, n >>= 8;
    }
  }
}
class Cl extends Dt {
  constructor(A, e) {
    e && (e *= 0.5), super(e), this.str = A, this.dict = A.dict, this.firstDigit = -1;
  }
  readBlock() {
    const A = this.str.getBytes(8e3);
    if (!A.length) {
      this.eof = !0;
      return;
    }
    const e = A.length + 1 >> 1, i = this.ensureBuffer(this.bufferLength + e);
    let a = this.bufferLength, s = this.firstDigit;
    for (const r of A) {
      let n;
      if (r >= 48 && r <= 57) n = 15 & r;
      else {
        if (!(r >= 65 && r <= 70 || r >= 97 && r <= 102)) {
          if (r === 62) {
            this.eof = !0;
            break;
          }
          continue;
        }
        n = 9 + (15 & r);
      }
      s < 0 ? s = n : (i[a++] = s << 4 | n, s = -1);
    }
    s >= 0 && this.eof && (i[a++] = s << 4, s = -1), this.firstDigit = s, this.bufferLength = a;
  }
}
const Ge = -1, tc = [[-1, -1], [-1, -1], [7, 8], [7, 7], [6, 6], [6, 6], [6, 5], [6, 5], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [4, 0], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]], ec = [[-1, -1], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], ic = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], ac = [[-1, -1], [-1, -1], [12, -2], [12, -2], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], sc = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], nc = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class S1 {
  constructor(A, e = {}) {
    if (!A || typeof A.next != "function") throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    this.source = A, this.eof = !1, this.encoding = e.K || 0, this.eoline = e.EndOfLine || !1, this.byteAlign = e.EncodedByteAlign || !1, this.columns = e.Columns || 1728, this.rows = e.Rows || 0, this.eoblock = e.EndOfBlock ?? !0, this.black = e.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
    let i;
    for (; (i = this._lookBits(12)) === 0; ) this._eatBits(1);
    i === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
  }
  readNextChar() {
    if (this.eof) return -1;
    const A = this.refLine, e = this.codingLine, i = this.columns;
    let a, s, r, n, g;
    if (this.outputBits === 0) {
      if (this.rowsDone && (this.eof = !0), this.eof) return -1;
      this.err = !1;
      let o, I, C;
      if (this.nextLine2D) {
        for (n = 0; e[n] < i; ++n) A[n] = e[n];
        for (A[n++] = i, A[n] = i, e[0] = 0, this.codingPos = 0, a = 0, s = 0; e[this.codingPos] < i; )
          switch (o = this._getTwoDimCode(), o) {
            case 0:
              this._addPixels(A[a + 1], s), A[a + 1] < i && (a += 2);
              break;
            case 1:
              if (o = I = 0, s) {
                do
                  o += C = this._getBlackCode();
                while (C >= 64);
                do
                  I += C = this._getWhiteCode();
                while (C >= 64);
              } else {
                do
                  o += C = this._getWhiteCode();
                while (C >= 64);
                do
                  I += C = this._getBlackCode();
                while (C >= 64);
              }
              for (this._addPixels(e[this.codingPos] + o, s), e[this.codingPos] < i && this._addPixels(e[this.codingPos] + I, 1 ^ s); A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 7:
              if (this._addPixels(A[a] + 3, s), s ^= 1, e[this.codingPos] < i)
                for (++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 5:
              if (this._addPixels(A[a] + 2, s), s ^= 1, e[this.codingPos] < i)
                for (++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 3:
              if (this._addPixels(A[a] + 1, s), s ^= 1, e[this.codingPos] < i)
                for (++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 2:
              if (this._addPixels(A[a], s), s ^= 1, e[this.codingPos] < i)
                for (++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 8:
              if (this._addPixelsNeg(A[a] - 3, s), s ^= 1, e[this.codingPos] < i)
                for (a > 0 ? --a : ++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 6:
              if (this._addPixelsNeg(A[a] - 2, s), s ^= 1, e[this.codingPos] < i)
                for (a > 0 ? --a : ++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case 4:
              if (this._addPixelsNeg(A[a] - 1, s), s ^= 1, e[this.codingPos] < i)
                for (a > 0 ? --a : ++a; A[a] <= e[this.codingPos] && A[a] < i; ) a += 2;
              break;
            case Ge:
              this._addPixels(i, 0), this.eof = !0;
              break;
            default:
              RA("bad 2d code"), this._addPixels(i, 0), this.err = !0;
          }
      } else
        for (e[0] = 0, this.codingPos = 0, s = 0; e[this.codingPos] < i; ) {
          if (o = 0, s) do
            o += C = this._getBlackCode();
          while (C >= 64);
          else do
            o += C = this._getWhiteCode();
          while (C >= 64);
          this._addPixels(e[this.codingPos] + o, s), s ^= 1;
        }
      let h = !1;
      if (this.byteAlign && (this.inputBits &= -8), this.eoblock || this.row !== this.rows - 1) {
        if (o = this._lookBits(12), this.eoline) for (; o !== Ge && o !== 1; )
          this._eatBits(1), o = this._lookBits(12);
        else for (; o === 0; )
          this._eatBits(1), o = this._lookBits(12);
        o === 1 ? (this._eatBits(12), h = !0) : o === Ge && (this.eof = !0);
      } else this.rowsDone = !0;
      if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && h && this.byteAlign) {
        if (o = this._lookBits(12), o === 1) {
          if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0) for (n = 0; n < 4; ++n)
            o = this._lookBits(12), o !== 1 && RA("bad rtc code: " + o), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
          this.eof = !0;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          if (o = this._lookBits(13), o === Ge)
            return this.eof = !0, -1;
          if (o >> 1 == 1) break;
          this._eatBits(1);
        }
        this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(1 & o));
      }
      this.outputBits = e[0] > 0 ? e[this.codingPos = 0] : e[this.codingPos = 1], this.row++;
    }
    if (this.outputBits >= 8)
      g = 1 & this.codingPos ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && e[this.codingPos] < i && (this.codingPos++, this.outputBits = e[this.codingPos] - e[this.codingPos - 1]);
    else {
      r = 8, g = 0;
      do {
        if (typeof this.outputBits != "number") throw new X('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        this.outputBits > r ? (g <<= r, 1 & this.codingPos || (g |= 255 >> 8 - r), this.outputBits -= r, r = 0) : (g <<= this.outputBits, 1 & this.codingPos || (g |= 255 >> 8 - this.outputBits), r -= this.outputBits, this.outputBits = 0, e[this.codingPos] < i ? (this.codingPos++, this.outputBits = e[this.codingPos] - e[this.codingPos - 1]) : r > 0 && (g <<= r, r = 0));
      } while (r);
    }
    return this.black && (g ^= 255), g;
  }
  _addPixels(A, e) {
    const i = this.codingLine;
    let a = this.codingPos;
    A > i[a] && (A > this.columns && (RA("row is wrong length"), this.err = !0, A = this.columns), 1 & a ^ e && ++a, i[a] = A), this.codingPos = a;
  }
  _addPixelsNeg(A, e) {
    const i = this.codingLine;
    let a = this.codingPos;
    if (A > i[a])
      A > this.columns && (RA("row is wrong length"), this.err = !0, A = this.columns), 1 & a ^ e && ++a, i[a] = A;
    else if (A < i[a]) {
      for (A < 0 && (RA("invalid code"), this.err = !0, A = 0); a > 0 && A < i[a - 1]; ) --a;
      i[a] = A;
    }
    this.codingPos = a;
  }
  _findTableCode(A, e, i, a) {
    const s = a || 0;
    for (let r = A; r <= e; ++r) {
      let n = this._lookBits(r);
      if (n === Ge) return [!0, 1, !1];
      if (r < e && (n <<= e - r), !s || n >= s) {
        const g = i[n - s];
        if (g[0] === r)
          return this._eatBits(r), [!0, g[1], !0];
      }
    }
    return [!1, 0, !1];
  }
  _getTwoDimCode() {
    let A, e = 0;
    if (this.eoblock) {
      if (e = this._lookBits(7), A = tc[e], (A == null ? void 0 : A[0]) > 0)
        return this._eatBits(A[0]), A[1];
    } else {
      const i = this._findTableCode(1, 7, tc);
      if (i[0] && i[2]) return i[1];
    }
    return RA("Bad two dim code"), Ge;
  }
  _getWhiteCode() {
    let A, e = 0;
    if (this.eoblock) {
      if (e = this._lookBits(12), e === Ge) return 1;
      if (A = e >> 5 ? ic[e >> 3] : ec[e], A[0] > 0)
        return this._eatBits(A[0]), A[1];
    } else {
      let i = this._findTableCode(1, 9, ic);
      if (i[0] || (i = this._findTableCode(11, 12, ec), i[0])) return i[1];
    }
    return RA("bad white code"), this._eatBits(1), 1;
  }
  _getBlackCode() {
    let A, e;
    if (this.eoblock) {
      if (A = this._lookBits(13), A === Ge) return 1;
      if (e = A >> 7 ? !(A >> 9) && A >> 7 ? sc[(A >> 1) - 64] : nc[A >> 7] : ac[A], e[0] > 0)
        return this._eatBits(e[0]), e[1];
    } else {
      let i = this._findTableCode(2, 6, nc);
      if (i[0] || (i = this._findTableCode(7, 12, sc, 64), i[0]) || (i = this._findTableCode(10, 13, ac), i[0])) return i[1];
    }
    return RA("bad black code"), this._eatBits(1), 1;
  }
  _lookBits(A) {
    let e;
    for (; this.inputBits < A; ) {
      if ((e = this.source.next()) === -1) return this.inputBits === 0 ? Ge : this.inputBuf << A - this.inputBits & 65535 >> 16 - A;
      this.inputBuf = this.inputBuf << 8 | e, this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - A & 65535 >> 16 - A;
  }
  _eatBits(A) {
    (this.inputBits -= A) < 0 && (this.inputBits = 0);
  }
}
class hl extends Dt {
  constructor(A, e, i) {
    super(e), this.str = A, this.dict = A.dict, i instanceof U || (i = U.empty);
    const a = { next: () => A.getByte() };
    this.ccittFaxDecoder = new S1(a, { K: i.get("K"), EndOfLine: i.get("EndOfLine"), EncodedByteAlign: i.get("EncodedByteAlign"), Columns: i.get("Columns"), Rows: i.get("Rows"), EndOfBlock: i.get("EndOfBlock"), BlackIs1: i.get("BlackIs1") });
  }
  readBlock() {
    for (; !this.eof; ) {
      const A = this.ccittFaxDecoder.readNextChar();
      if (A === -1) {
        this.eof = !0;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = A;
    }
  }
}
const rc = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Bl = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), ll = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), Ql = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], El = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
var gi, na;
class gc extends Dt {
  constructor(e, i) {
    super(i);
    MA(this, gi);
    this.str = e, this.dict = e.dict;
    const a = e.getByte(), s = e.getByte();
    if (a === -1 || s === -1) throw new X(`Invalid header in flate stream: ${a}, ${s}`);
    if ((15 & a) != 8) throw new X(`Unknown compression method in flate stream: ${a}, ${s}`);
    if (((a << 8) + s) % 31 != 0) throw new X(`Bad FCHECK in flate stream: ${a}, ${s}`);
    if (32 & s) throw new X(`FDICT bit set in flate stream: ${a}, ${s}`);
    this.codeSize = 0, this.codeBuf = 0;
  }
  async getImageData(e, i) {
    const a = await this.asyncGetBytes();
    return (a == null ? void 0 : a.subarray(0, e)) || this.getBytes(e);
  }
  async asyncGetBytes() {
    this.str.reset();
    const e = this.str.getBytes();
    try {
      const { readable: i, writable: a } = new DecompressionStream("deflate"), s = a.getWriter();
      await s.ready, s.write(e).then(async () => {
        await s.ready, await s.close();
      }).catch(() => {
      });
      const r = [];
      let n = 0;
      for await (const I of i)
        r.push(I), n += I.byteLength;
      const g = new Uint8Array(n);
      let o = 0;
      for (const I of r)
        g.set(I, o), o += I.byteLength;
      return g;
    } catch {
      return this.str = new At(e, 2, e.length, this.str.dict), this.reset(), null;
    }
  }
  get isAsync() {
    return !0;
  }
  getBits(e) {
    const i = this.str;
    let a, s = this.codeSize, r = this.codeBuf;
    for (; s < e; ) {
      if ((a = i.getByte()) === -1) throw new X("Bad encoding in flate stream");
      r |= a << s, s += 8;
    }
    return a = r & (1 << e) - 1, this.codeBuf = r >> e, this.codeSize = s -= e, a;
  }
  getCode(e) {
    const i = this.str, a = e[0], s = e[1];
    let r, n = this.codeSize, g = this.codeBuf;
    for (; n < s && (r = i.getByte()) !== -1; )
      g |= r << n, n += 8;
    const o = a[g & (1 << s) - 1], I = o >> 16, C = 65535 & o;
    if (I < 1 || n < I) throw new X("Bad encoding in flate stream");
    return this.codeBuf = g >> I, this.codeSize = n - I, C;
  }
  generateHuffmanTable(e) {
    const i = e.length;
    let a, s = 0;
    for (a = 0; a < i; ++a) e[a] > s && (s = e[a]);
    const r = 1 << s, n = new Int32Array(r);
    for (let g = 1, o = 0, I = 2; g <= s; ++g, o <<= 1, I <<= 1) for (let C = 0; C < i; ++C) if (e[C] === g) {
      let h = 0, c = o;
      for (a = 0; a < g; ++a)
        h = h << 1 | 1 & c, c >>= 1;
      for (a = h; a < r; a += I) n[a] = g << 16 | C;
      ++o;
    }
    return [n, s];
  }
  readBlock() {
    let e, i, a;
    const s = this.str;
    try {
      i = this.getBits(3);
    } catch (I) {
      CA(this, gi, na).call(this, I.message);
      return;
    }
    if (1 & i && (this.eof = !0), i >>= 1, i === 0) {
      let I;
      if ((I = s.getByte()) === -1) {
        CA(this, gi, na).call(this, "Bad block header in flate stream");
        return;
      }
      let C = I;
      if ((I = s.getByte()) === -1) {
        CA(this, gi, na).call(this, "Bad block header in flate stream");
        return;
      }
      if (C |= I << 8, (I = s.getByte()) === -1) {
        CA(this, gi, na).call(this, "Bad block header in flate stream");
        return;
      }
      let h = I;
      if ((I = s.getByte()) === -1) {
        CA(this, gi, na).call(this, "Bad block header in flate stream");
        return;
      }
      if (h |= I << 8, h !== (65535 & ~C) && (C !== 0 || h !== 0)) throw new X("Bad uncompressed block length in flate stream");
      this.codeBuf = 0, this.codeSize = 0;
      const c = this.bufferLength, B = c + C;
      if (e = this.ensureBuffer(B), this.bufferLength = B, C === 0) s.peekByte() === -1 && (this.eof = !0);
      else {
        const l = s.getBytes(C);
        e.set(l, c), l.length < C && (this.eof = !0);
      }
      return;
    }
    let r, n;
    if (i === 1)
      r = Ql, n = El;
    else {
      if (i !== 2) throw new X("Unknown block type in flate stream");
      {
        const I = this.getBits(5) + 257, C = this.getBits(5) + 1, h = this.getBits(4) + 4, c = new Uint8Array(rc.length);
        let B;
        for (B = 0; B < h; ++B) c[rc[B]] = this.getBits(3);
        const l = this.generateHuffmanTable(c);
        a = 0, B = 0;
        const Q = I + C, E = new Uint8Array(Q);
        let u, f, d;
        for (; B < Q; ) {
          const p = this.getCode(l);
          if (p === 16)
            u = 2, f = 3, d = a;
          else if (p === 17)
            u = 3, f = 3, d = a = 0;
          else {
            if (p !== 18) {
              E[B++] = a = p;
              continue;
            }
            u = 7, f = 11, d = a = 0;
          }
          let m = this.getBits(u) + f;
          for (; m-- > 0; ) E[B++] = d;
        }
        r = this.generateHuffmanTable(E.subarray(0, I)), n = this.generateHuffmanTable(E.subarray(I, Q));
      }
    }
    e = this.buffer;
    let g = e ? e.length : 0, o = this.bufferLength;
    for (; ; ) {
      let I = this.getCode(r);
      if (I < 256) {
        o + 1 >= g && (e = this.ensureBuffer(o + 1), g = e.length), e[o++] = I;
        continue;
      }
      if (I === 256) {
        this.bufferLength = o;
        return;
      }
      I -= 257, I = Bl[I];
      let C = I >> 16;
      C > 0 && (C = this.getBits(C)), a = (65535 & I) + C, I = this.getCode(n), I = ll[I], C = I >> 16, C > 0 && (C = this.getBits(C));
      const h = (65535 & I) + C;
      o + a >= g && (e = this.ensureBuffer(o + a), g = e.length);
      for (let c = 0; c < a; ++c, ++o) e[o] = e[o - h];
    }
  }
}
gi = new WeakSet(), na = function(e) {
  RA(e), this.eof = !0;
};
const ul = [{ qe: 22017, nmps: 1, nlps: 1, switchFlag: 1 }, { qe: 13313, nmps: 2, nlps: 6, switchFlag: 0 }, { qe: 6145, nmps: 3, nlps: 9, switchFlag: 0 }, { qe: 2753, nmps: 4, nlps: 12, switchFlag: 0 }, { qe: 1313, nmps: 5, nlps: 29, switchFlag: 0 }, { qe: 545, nmps: 38, nlps: 33, switchFlag: 0 }, { qe: 22017, nmps: 7, nlps: 6, switchFlag: 1 }, { qe: 21505, nmps: 8, nlps: 14, switchFlag: 0 }, { qe: 18433, nmps: 9, nlps: 14, switchFlag: 0 }, { qe: 14337, nmps: 10, nlps: 14, switchFlag: 0 }, { qe: 12289, nmps: 11, nlps: 17, switchFlag: 0 }, { qe: 9217, nmps: 12, nlps: 18, switchFlag: 0 }, { qe: 7169, nmps: 13, nlps: 20, switchFlag: 0 }, { qe: 5633, nmps: 29, nlps: 21, switchFlag: 0 }, { qe: 22017, nmps: 15, nlps: 14, switchFlag: 1 }, { qe: 21505, nmps: 16, nlps: 14, switchFlag: 0 }, { qe: 20737, nmps: 17, nlps: 15, switchFlag: 0 }, { qe: 18433, nmps: 18, nlps: 16, switchFlag: 0 }, { qe: 14337, nmps: 19, nlps: 17, switchFlag: 0 }, { qe: 13313, nmps: 20, nlps: 18, switchFlag: 0 }, { qe: 12289, nmps: 21, nlps: 19, switchFlag: 0 }, { qe: 10241, nmps: 22, nlps: 19, switchFlag: 0 }, { qe: 9217, nmps: 23, nlps: 20, switchFlag: 0 }, { qe: 8705, nmps: 24, nlps: 21, switchFlag: 0 }, { qe: 7169, nmps: 25, nlps: 22, switchFlag: 0 }, { qe: 6145, nmps: 26, nlps: 23, switchFlag: 0 }, { qe: 5633, nmps: 27, nlps: 24, switchFlag: 0 }, { qe: 5121, nmps: 28, nlps: 25, switchFlag: 0 }, { qe: 4609, nmps: 29, nlps: 26, switchFlag: 0 }, { qe: 4353, nmps: 30, nlps: 27, switchFlag: 0 }, { qe: 2753, nmps: 31, nlps: 28, switchFlag: 0 }, { qe: 2497, nmps: 32, nlps: 29, switchFlag: 0 }, { qe: 2209, nmps: 33, nlps: 30, switchFlag: 0 }, { qe: 1313, nmps: 34, nlps: 31, switchFlag: 0 }, { qe: 1089, nmps: 35, nlps: 32, switchFlag: 0 }, { qe: 673, nmps: 36, nlps: 33, switchFlag: 0 }, { qe: 545, nmps: 37, nlps: 34, switchFlag: 0 }, { qe: 321, nmps: 38, nlps: 35, switchFlag: 0 }, { qe: 273, nmps: 39, nlps: 36, switchFlag: 0 }, { qe: 133, nmps: 40, nlps: 37, switchFlag: 0 }, { qe: 73, nmps: 41, nlps: 38, switchFlag: 0 }, { qe: 37, nmps: 42, nlps: 39, switchFlag: 0 }, { qe: 21, nmps: 43, nlps: 40, switchFlag: 0 }, { qe: 9, nmps: 44, nlps: 41, switchFlag: 0 }, { qe: 5, nmps: 45, nlps: 42, switchFlag: 0 }, { qe: 1, nmps: 45, nlps: 43, switchFlag: 0 }, { qe: 22017, nmps: 46, nlps: 46, switchFlag: 0 }];
class dl {
  constructor(A, e, i) {
    this.data = A, this.bp = e, this.dataEnd = i, this.chigh = A[e], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
  }
  byteIn() {
    const A = this.data;
    let e = this.bp;
    A[e] === 255 ? A[e + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (e++, this.clow += A[e] << 9, this.ct = 7, this.bp = e) : (e++, this.clow += e < this.dataEnd ? A[e] << 8 : 65280, this.ct = 8, this.bp = e), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
  }
  readBit(A, e) {
    let i = A[e] >> 1, a = 1 & A[e];
    const s = ul[i], r = s.qe;
    let n, g = this.a - r;
    if (this.chigh < r) g < r ? (g = r, n = a, i = s.nmps) : (g = r, n = 1 ^ a, s.switchFlag === 1 && (a = n), i = s.nlps);
    else {
      if (this.chigh -= r, 32768 & g)
        return this.a = g, a;
      g < r ? (n = 1 ^ a, s.switchFlag === 1 && (a = n), i = s.nlps) : (n = a, i = s.nmps);
    }
    do
      this.ct === 0 && this.byteIn(), g <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
    while (!(32768 & g));
    return this.a = g, A[e] = i << 1 | a, n;
  }
}
class _A extends bt {
  constructor(A) {
    super(A, "Jbig2Error");
  }
}
class fl {
  getContexts(A) {
    return A in this ? this[A] : this[A] = new Int8Array(65536);
  }
}
class Wa {
  constructor(A, e, i) {
    this.data = A, this.start = e, this.end = i;
  }
  get decoder() {
    return sA(this, "decoder", new dl(this.data, this.start, this.end));
  }
  get contextCache() {
    return sA(this, "contextCache", new fl());
  }
}
function mt(t, A, e) {
  const i = t.getContexts(A);
  let a = 1;
  function s(o) {
    let I = 0;
    for (let C = 0; C < o; C++) {
      const h = e.readBit(i, a);
      a = a < 256 ? a << 1 | h : 511 & (a << 1 | h) | 256, I = I << 1 | h;
    }
    return I >>> 0;
  }
  const r = s(1), n = s(1) ? s(1) ? s(1) ? s(1) ? s(1) ? s(32) + 4436 : s(12) + 340 : s(8) + 84 : s(6) + 20 : s(4) + 4 : s(2);
  let g;
  return r === 0 ? g = n : n > 0 && (g = -n), g >= WB && g <= Vg ? g : null;
}
function R1(t, A, e) {
  const i = t.getContexts("IAID");
  let a = 1;
  for (let s = 0; s < e; s++)
    a = a << 1 | A.readBit(i, a);
  return e < 31 ? a & (1 << e) - 1 : 2147483647 & a;
}
const oc = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], pl = [[{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: 2, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -1, y: -2 }, { x: 0, y: -2 }, { x: 1, y: -2 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -2, y: 0 }, { x: -1, y: 0 }], [{ x: -3, y: -1 }, { x: -2, y: -1 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -4, y: 0 }, { x: -3, y: 0 }, { x: -2, y: 0 }, { x: -1, y: 0 }]], Ic = [{ coding: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }, { coding: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 0 }], reference: [{ x: 0, y: -1 }, { x: -1, y: 0 }, { x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] }], ml = [39717, 1941, 229, 405], yl = [32, 8];
function Bn(t, A, e, i, a, s, r, n) {
  if (t)
    return so(new as(n.data, n.start, n.end), A, e, !1);
  if (i === 0 && !s && !a && r.length === 4 && r[0].x === 3 && r[0].y === -1 && r[1].x === -3 && r[1].y === -1 && r[2].x === 2 && r[2].y === -2 && r[3].x === -2 && r[3].y === -2) return function(F, w, x) {
    const J = x.decoder, M = x.contextCache.getContexts("GB"), H = [];
    let z, aA, tA, hA, BA, gA, wA;
    for (aA = 0; aA < w; aA++)
      for (BA = H[aA] = new Uint8Array(F), gA = aA < 1 ? BA : H[aA - 1], wA = aA < 2 ? BA : H[aA - 2], z = wA[0] << 13 | wA[1] << 12 | wA[2] << 11 | gA[0] << 7 | gA[1] << 6 | gA[2] << 5 | gA[3] << 4, tA = 0; tA < F; tA++)
        BA[tA] = hA = J.readBit(M, z), z = (31735 & z) << 1 | (tA + 3 < F ? wA[tA + 3] << 11 : 0) | (tA + 4 < F ? gA[tA + 4] << 4 : 0) | hA;
    return H;
  }(A, e, n);
  const g = pl[i].concat(r);
  g.sort(function(N, F) {
    return N.y - F.y || N.x - F.x;
  });
  const o = g.length, I = new Int8Array(o), C = new Int8Array(o), h = [];
  let c, B, l = 0, Q = 0, E = 0, u = 0;
  for (B = 0; B < o; B++)
    I[B] = g[B].x, C[B] = g[B].y, Q = Math.min(Q, g[B].x), E = Math.max(E, g[B].x), u = Math.min(u, g[B].y), B < o - 1 && g[B].y === g[B + 1].y && g[B].x === g[B + 1].x - 1 ? l |= 1 << o - 1 - B : h.push(B);
  const f = h.length, d = new Int8Array(f), p = new Int8Array(f), m = new Uint16Array(f);
  for (c = 0; c < f; c++)
    B = h[c], d[c] = g[B].x, p[c] = g[B].y, m[c] = 1 << o - 1 - B;
  const y = -Q, b = -u, D = A - E, R = ml[i];
  let k = new Uint8Array(A);
  const Y = [], V = n.decoder, eA = n.contextCache.getContexts("GB");
  let AA, O, L, v, W, K = 0, q = 0;
  for (let N = 0; N < e; N++) {
    if (a && (K ^= V.readBit(eA, R), K)) {
      Y.push(k);
      continue;
    }
    for (k = new Uint8Array(k), Y.push(k), AA = 0; AA < A; AA++) {
      if (AA >= y && AA < D && N >= b)
        for (q = q << 1 & l, B = 0; B < f; B++)
          O = N + p[B], L = AA + d[B], v = Y[O][L], v && (v = m[B], q |= v);
      else
        for (q = 0, W = o - 1, B = 0; B < o; B++, W--)
          L = AA + I[B], L >= 0 && L < A && (O = N + C[B], O >= 0 && (v = Y[O][L], v && (q |= v << W)));
      const F = V.readBit(eA, q);
      k[AA] = F;
    }
  }
  return Y;
}
function G1(t, A, e, i, a, s, r, n, g) {
  let o = Ic[e].coding;
  e === 0 && (o = o.concat([n[0]]));
  const I = o.length, C = new Int32Array(I), h = new Int32Array(I);
  let c;
  for (c = 0; c < I; c++)
    C[c] = o[c].x, h[c] = o[c].y;
  let B = Ic[e].reference;
  e === 0 && (B = B.concat([n[1]]));
  const l = B.length, Q = new Int32Array(l), E = new Int32Array(l);
  for (c = 0; c < l; c++)
    Q[c] = B[c].x, E[c] = B[c].y;
  const u = i[0].length, f = i.length;
  yl[e];
  const d = [], p = g.decoder, m = g.contextCache.getContexts("GR");
  for (let y = 0; y < A; y++) {
    const b = new Uint8Array(t);
    d.push(b);
    for (let D = 0; D < t; D++) {
      let R, k, Y = 0;
      for (c = 0; c < I; c++)
        R = y + h[c], k = D + C[c], R < 0 || k < 0 || k >= t ? Y <<= 1 : Y = Y << 1 | d[R][k];
      for (c = 0; c < l; c++)
        R = y + E[c] - s, k = D + Q[c] - a, R < 0 || R >= f || k < 0 || k >= u ? Y <<= 1 : Y = Y << 1 | i[R][k];
      const V = p.readBit(m, Y);
      b[D] = V;
    }
  }
  return d;
}
function cc(t, A, e, i, a, s, r, n, g, o, I, C, h, c, B, l, Q, E, u) {
  if (t && A) throw new _A("refinement with Huffman is not supported");
  const f = [];
  let d, p;
  for (d = 0; d < i; d++) {
    if (p = new Uint8Array(e), a) for (let R = 0; R < e; R++) p[R] = a;
    f.push(p);
  }
  const m = Q.decoder, y = Q.contextCache;
  let b = t ? -c.tableDeltaT.decode(u) : -mt(y, "IADT", m), D = 0;
  for (d = 0; d < s; ) {
    b += t ? c.tableDeltaT.decode(u) : mt(y, "IADT", m), D += t ? c.tableFirstS.decode(u) : mt(y, "IAFS", m);
    let R = D;
    for (; ; ) {
      let k = 0;
      r > 1 && (k = t ? u.readBits(E) : mt(y, "IAIT", m));
      const Y = r * b + k, V = t ? c.symbolIDTable.decode(u) : R1(y, m, g), eA = A && (t ? u.readBit() : mt(y, "IARI", m));
      let AA = n[V], O = AA[0].length, L = AA.length;
      if (eA) {
        const x = mt(y, "IARDW", m), J = mt(y, "IARDH", m);
        O += x, L += J, AA = G1(O, L, B, AA, (x >> 1) + mt(y, "IARDX", m), (J >> 1) + mt(y, "IARDY", m), !1, l, Q);
      }
      let v = 0;
      o ? 1 & C ? v = L - 1 : R += L - 1 : C > 1 ? R += O - 1 : v = O - 1;
      const W = Y - (1 & C ? 0 : L - 1), K = R - (2 & C ? O - 1 : 0);
      let q, N, F;
      if (o) for (q = 0; q < L; q++) {
        if (p = f[K + q], !p) continue;
        F = AA[q];
        const x = Math.min(e - W, O);
        switch (h) {
          case 0:
            for (N = 0; N < x; N++) p[W + N] |= F[N];
            break;
          case 2:
            for (N = 0; N < x; N++) p[W + N] ^= F[N];
            break;
          default:
            throw new _A(`operator ${h} is not supported`);
        }
      }
      else for (N = 0; N < L; N++)
        if (p = f[W + N], p)
          switch (F = AA[N], h) {
            case 0:
              for (q = 0; q < O; q++) p[K + q] |= F[q];
              break;
            case 2:
              for (q = 0; q < O; q++) p[K + q] ^= F[q];
              break;
            default:
              throw new _A(`operator ${h} is not supported`);
          }
      d++;
      const w = t ? c.tableDeltaS.decode(u) : mt(y, "IADS", m);
      if (w === null) break;
      R += v + w + I;
    }
  }
  return f;
}
function wl(t, A) {
  const e = {};
  e.number = VA(t, A);
  const i = t[A + 4], a = 63 & i;
  if (!oc[a]) throw new _A("invalid segment type: " + a);
  e.type = a, e.typeName = oc[a], e.deferredNonRetain = !!(128 & i);
  const s = !!(64 & i), r = t[A + 5];
  let n = r >> 5 & 7;
  const g = [31 & r];
  let o = A + 6;
  if (r === 7) {
    n = 536870911 & VA(t, o - 1), o += 3;
    let B = n + 7 >> 3;
    for (g[0] = t[o++]; --B > 0; ) g.push(t[o++]);
  } else if (r === 5 || r === 6) throw new _A("invalid referred-to flags");
  e.retainBits = g;
  let I = 4;
  e.number <= 256 ? I = 1 : e.number <= 65536 && (I = 2);
  const C = [];
  let h, c;
  for (h = 0; h < n; h++) {
    let B;
    B = I === 1 ? t[o] : I === 2 ? XA(t, o) : VA(t, o), C.push(B), o += I;
  }
  if (e.referredTo = C, s ? (e.pageAssociation = VA(t, o), o += 4) : e.pageAssociation = t[o++], e.length = VA(t, o), o += 4, e.length === 4294967295) {
    if (a !== 38) throw new _A("invalid unknown segment length");
    {
      const B = Tn(t, o), l = !!(1 & t[o + Pn]), Q = 6, E = new Uint8Array(Q);
      for (l || (E[0] = 255, E[1] = 172), E[2] = B.height >>> 24 & 255, E[3] = B.height >> 16 & 255, E[4] = B.height >> 8 & 255, E[5] = 255 & B.height, h = o, c = t.length; h < c; h++) {
        let u = 0;
        for (; u < Q && E[u] === t[h + u]; ) u++;
        if (u === Q) {
          e.length = h + Q;
          break;
        }
      }
      if (e.length === 4294967295) throw new _A("segment end was not found");
    }
  }
  return e.headerEnd = o, e;
}
function Dl(t, A, e, i) {
  const a = [];
  let s = e;
  for (; s < i; ) {
    const r = wl(A, s);
    s = r.headerEnd;
    const n = { header: r, data: A };
    if (t.randomAccess || (n.start = s, s += r.length, n.end = s), a.push(n), r.type === 51) break;
  }
  if (t.randomAccess) for (let r = 0, n = a.length; r < n; r++)
    a[r].start = s, s += a[r].header.length, a[r].end = s;
  return a;
}
function Tn(t, A) {
  return { width: VA(t, A), height: VA(t, A + 4), x: VA(t, A + 8), y: VA(t, A + 12), combinationOperator: 7 & t[A + 16] };
}
const Pn = 17;
function bl(t, A) {
  const e = t.header, i = t.data, a = t.end;
  let s, r, n, g, o = t.start;
  switch (e.type) {
    case 0:
      const C = {}, h = XA(i, o);
      if (C.huffman = !!(1 & h), C.refinement = !!(2 & h), C.huffmanDHSelector = h >> 2 & 3, C.huffmanDWSelector = h >> 4 & 3, C.bitmapSizeSelector = h >> 6 & 1, C.aggregationInstancesSelector = h >> 7 & 1, C.bitmapCodingContextUsed = !!(256 & h), C.bitmapCodingContextRetained = !!(512 & h), C.template = h >> 10 & 3, C.refinementTemplate = h >> 12 & 1, o += 2, !C.huffman) {
        for (g = C.template === 0 ? 4 : 1, r = [], n = 0; n < g; n++)
          r.push({ x: Oe(i, o), y: Oe(i, o + 1) }), o += 2;
        C.at = r;
      }
      if (C.refinement && !C.refinementTemplate) {
        for (r = [], n = 0; n < 2; n++)
          r.push({ x: Oe(i, o), y: Oe(i, o + 1) }), o += 2;
        C.refinementAt = r;
      }
      C.numberOfExportedSymbols = VA(i, o), o += 4, C.numberOfNewSymbols = VA(i, o), o += 4, s = [C, e.number, e.referredTo, i, o, a];
      break;
    case 6:
    case 7:
      const c = {};
      c.info = Tn(i, o), o += Pn;
      const B = XA(i, o);
      if (o += 2, c.huffman = !!(1 & B), c.refinement = !!(2 & B), c.logStripSize = B >> 2 & 3, c.stripSize = 1 << c.logStripSize, c.referenceCorner = B >> 4 & 3, c.transposed = !!(64 & B), c.combinationOperator = B >> 7 & 3, c.defaultPixelValue = B >> 9 & 1, c.dsOffset = B << 17 >> 27, c.refinementTemplate = B >> 15 & 1, c.huffman) {
        const y = XA(i, o);
        o += 2, c.huffmanFS = 3 & y, c.huffmanDS = y >> 2 & 3, c.huffmanDT = y >> 4 & 3, c.huffmanRefinementDW = y >> 6 & 3, c.huffmanRefinementDH = y >> 8 & 3, c.huffmanRefinementDX = y >> 10 & 3, c.huffmanRefinementDY = y >> 12 & 3, c.huffmanRefinementSizeSelector = !!(16384 & y);
      }
      if (c.refinement && !c.refinementTemplate) {
        for (r = [], n = 0; n < 2; n++)
          r.push({ x: Oe(i, o), y: Oe(i, o + 1) }), o += 2;
        c.refinementAt = r;
      }
      c.numberOfSymbolInstances = VA(i, o), o += 4, s = [c, e.referredTo, i, o, a];
      break;
    case 16:
      const l = {}, Q = i[o++];
      l.mmr = !!(1 & Q), l.template = Q >> 1 & 3, l.patternWidth = i[o++], l.patternHeight = i[o++], l.maxPatternIndex = VA(i, o), o += 4, s = [l, e.number, i, o, a];
      break;
    case 22:
    case 23:
      const E = {};
      E.info = Tn(i, o), o += Pn;
      const u = i[o++];
      E.mmr = !!(1 & u), E.template = u >> 1 & 3, E.enableSkip = !!(8 & u), E.combinationOperator = u >> 4 & 7, E.defaultPixelValue = u >> 7 & 1, E.gridWidth = VA(i, o), o += 4, E.gridHeight = VA(i, o), o += 4, E.gridOffsetX = 4294967295 & VA(i, o), o += 4, E.gridOffsetY = 4294967295 & VA(i, o), o += 4, E.gridVectorX = XA(i, o), o += 2, E.gridVectorY = XA(i, o), o += 2, s = [E, e.referredTo, i, o, a];
      break;
    case 38:
    case 39:
      const f = {};
      f.info = Tn(i, o), o += Pn;
      const d = i[o++];
      if (f.mmr = !!(1 & d), f.template = d >> 1 & 3, f.prediction = !!(8 & d), !f.mmr) {
        for (g = f.template === 0 ? 4 : 1, r = [], n = 0; n < g; n++)
          r.push({ x: Oe(i, o), y: Oe(i, o + 1) }), o += 2;
        f.at = r;
      }
      s = [f, i, o, a];
      break;
    case 48:
      const p = { width: VA(i, o), height: VA(i, o + 4), resolutionX: VA(i, o + 8), resolutionY: VA(i, o + 12) };
      p.height === 4294967295 && delete p.height;
      const m = i[o + 16];
      XA(i, o + 17), p.lossless = !!(1 & m), p.refinement = !!(2 & m), p.defaultPixelValue = m >> 2 & 1, p.combinationOperator = m >> 3 & 3, p.requiresBuffer = !!(32 & m), p.combinationOperatorOverride = !!(64 & m), s = [p];
      break;
    case 49:
    case 50:
    case 51:
    case 62:
      break;
    case 53:
      s = [e.number, i, o, a];
      break;
    default:
      throw new _A(`segment type ${e.typeName}(${e.type}) is not implemented`);
  }
  const I = "on" + e.typeName;
  I in A && A[I].apply(A, s);
}
function kl(t, A) {
  for (let e = 0, i = t.length; e < i; e++) bl(t[e], A);
}
class Fl {
  onPageInformation(A) {
    this.currentPageInfo = A;
    const e = A.width + 7 >> 3, i = new Uint8ClampedArray(e * A.height);
    A.defaultPixelValue && i.fill(255), this.buffer = i;
  }
  drawBitmap(A, e) {
    const i = this.currentPageInfo, a = A.width, s = A.height, r = i.width + 7 >> 3, n = i.combinationOperatorOverride ? A.combinationOperator : i.combinationOperator, g = this.buffer, o = 128 >> (7 & A.x);
    let I, C, h, c, B = A.y * r + (A.x >> 3);
    switch (n) {
      case 0:
        for (I = 0; I < s; I++) {
          for (h = o, c = B, C = 0; C < a; C++)
            e[I][C] && (g[c] |= h), h >>= 1, h || (h = 128, c++);
          B += r;
        }
        break;
      case 2:
        for (I = 0; I < s; I++) {
          for (h = o, c = B, C = 0; C < a; C++)
            e[I][C] && (g[c] ^= h), h >>= 1, h || (h = 128, c++);
          B += r;
        }
        break;
      default:
        throw new _A(`operator ${n} is not supported`);
    }
  }
  onImmediateGenericRegion(A, e, i, a) {
    const s = A.info, r = new Wa(e, i, a), n = Bn(A.mmr, s.width, s.height, A.template, A.prediction, null, A.at, r);
    this.drawBitmap(s, n);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(A, e, i, a, s, r) {
    let n, g;
    A.huffman && (n = function(c, B, l) {
      let Q, E, u, f, d = 0;
      switch (c.huffmanDHSelector) {
        case 0:
        case 1:
          Q = Xe(c.huffmanDHSelector + 4);
          break;
        case 3:
          Q = pi(d, B, l), d++;
          break;
        default:
          throw new _A("invalid Huffman DH selector");
      }
      switch (c.huffmanDWSelector) {
        case 0:
        case 1:
          E = Xe(c.huffmanDWSelector + 2);
          break;
        case 3:
          E = pi(d, B, l), d++;
          break;
        default:
          throw new _A("invalid Huffman DW selector");
      }
      return c.bitmapSizeSelector ? (u = pi(d, B, l), d++) : u = Xe(1), f = c.aggregationInstancesSelector ? pi(d, B, l) : Xe(1), { tableDeltaHeight: Q, tableDeltaWidth: E, tableBitmapSize: u, tableAggregateInstances: f };
    }(A, i, this.customTables), g = new as(a, s, r));
    let o = this.symbols;
    o || (this.symbols = o = {});
    const I = [];
    for (const h of i) {
      const c = o[h];
      c && I.push(...c);
    }
    const C = new Wa(a, s, r);
    o[e] = function(c, B, l, Q, E, u, f, d, p, m, y, b) {
      if (c && B) throw new _A("symbol refinement with Huffman is not supported");
      const D = [];
      let R = 0, k = Cg(l.length + Q);
      const Y = y.decoder, V = y.contextCache;
      let eA, AA;
      for (c && (eA = Xe(1), AA = [], k = Math.max(k, 1)); D.length < Q; ) {
        R += c ? u.tableDeltaHeight.decode(b) : mt(V, "IADH", Y);
        let N = 0, F = 0;
        const w = c ? AA.length : 0;
        for (; ; ) {
          const x = c ? u.tableDeltaWidth.decode(b) : mt(V, "IADW", Y);
          if (x === null) break;
          N += x, F += N;
          let J;
          if (B) {
            const M = mt(V, "IAAI", Y);
            if (M > 1) J = cc(c, B, N, R, 0, M, 1, l.concat(D), k, 0, 0, 1, 0, u, p, m, y, 0, b);
            else {
              const H = R1(V, Y, k), z = mt(V, "IARDX", Y), aA = mt(V, "IARDY", Y);
              J = G1(N, R, p, H < l.length ? l[H] : D[H - l.length], z, aA, !1, m, y);
            }
            D.push(J);
          } else c ? AA.push(N) : (J = Bn(!1, N, R, f, !1, null, d, y), D.push(J));
        }
        if (c && !B) {
          const x = u.tableBitmapSize.decode(b);
          b.byteAlign();
          let J;
          if (x === 0) J = Sl(b, F, R);
          else {
            const H = b.end, z = b.position + x;
            b.end = z, J = so(b, F, R, !1), b.end = H, b.position = z;
          }
          const M = AA.length;
          if (w === M - 1) D.push(J);
          else {
            let H, z, aA, tA, hA, BA = 0;
            for (H = w; H < M; H++) {
              for (tA = AA[H], aA = BA + tA, hA = [], z = 0; z < R; z++) hA.push(J[z].subarray(BA, aA));
              D.push(hA), BA = aA;
            }
          }
        }
      }
      const O = [], L = [];
      let v, W, K = !1;
      const q = l.length + Q;
      for (; L.length < q; ) {
        let N = c ? eA.decode(b) : mt(V, "IAEX", Y);
        for (; N--; ) L.push(K);
        K = !K;
      }
      for (v = 0, W = l.length; v < W; v++) L[v] && O.push(l[v]);
      for (let N = 0; N < Q; v++, N++) L[v] && O.push(D[N]);
      return O;
    }(A.huffman, A.refinement, I, A.numberOfNewSymbols, A.numberOfExportedSymbols, n, A.template, A.at, A.refinementTemplate, A.refinementAt, C, g);
  }
  onImmediateTextRegion(A, e, i, a, s) {
    const r = A.info;
    let n, g;
    const o = this.symbols, I = [];
    for (const B of e) {
      const l = o[B];
      l && I.push(...l);
    }
    const C = Cg(I.length);
    A.huffman && (g = new as(i, a, s), n = function(l, Q, E, u, f) {
      const d = [];
      for (let k = 0; k <= 34; k++) {
        const Y = f.readBits(4);
        d.push(new _e([k, Y, 0, 0]));
      }
      const p = new Wn(d, !1);
      d.length = 0;
      for (let k = 0; k < u; ) {
        const Y = p.decode(f);
        if (Y >= 32) {
          let V, eA, AA;
          switch (Y) {
            case 32:
              if (k === 0) throw new _A("no previous value in symbol ID table");
              eA = f.readBits(2) + 3, V = d[k - 1].prefixLength;
              break;
            case 33:
              eA = f.readBits(3) + 3, V = 0;
              break;
            case 34:
              eA = f.readBits(7) + 11, V = 0;
              break;
            default:
              throw new _A("invalid code length in symbol ID table");
          }
          for (AA = 0; AA < eA; AA++)
            d.push(new _e([k, V, 0, 0])), k++;
        } else
          d.push(new _e([k, Y, 0, 0])), k++;
      }
      f.byteAlign();
      const m = new Wn(d, !1);
      let y, b, D, R = 0;
      switch (l.huffmanFS) {
        case 0:
        case 1:
          y = Xe(l.huffmanFS + 6);
          break;
        case 3:
          y = pi(R, Q, E), R++;
          break;
        default:
          throw new _A("invalid Huffman FS selector");
      }
      switch (l.huffmanDS) {
        case 0:
        case 1:
        case 2:
          b = Xe(l.huffmanDS + 8);
          break;
        case 3:
          b = pi(R, Q, E), R++;
          break;
        default:
          throw new _A("invalid Huffman DS selector");
      }
      switch (l.huffmanDT) {
        case 0:
        case 1:
        case 2:
          D = Xe(l.huffmanDT + 11);
          break;
        case 3:
          D = pi(R, Q, E), R++;
          break;
        default:
          throw new _A("invalid Huffman DT selector");
      }
      if (l.refinement) throw new _A("refinement with Huffman is not supported");
      return { symbolIDTable: m, tableFirstS: y, tableDeltaS: b, tableDeltaT: D };
    }(A, e, this.customTables, I.length, g));
    const h = new Wa(i, a, s), c = cc(A.huffman, A.refinement, r.width, r.height, A.defaultPixelValue, A.numberOfSymbolInstances, A.stripSize, I, C, A.transposed, A.dsOffset, A.referenceCorner, A.combinationOperator, n, A.refinementTemplate, A.refinementAt, h, A.logStripSize, g);
    this.drawBitmap(r, c);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(A, e, i, a, s) {
    let r = this.patterns;
    r || (this.patterns = r = {});
    const n = new Wa(i, a, s);
    r[e] = function(o, I, C, h, c, B) {
      const l = [];
      o || (l.push({ x: -I, y: 0 }), c === 0 && l.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const Q = Bn(o, (h + 1) * I, C, c, !1, null, l, B), E = [];
      for (let u = 0; u <= h; u++) {
        const f = [], d = I * u, p = d + I;
        for (let m = 0; m < C; m++) f.push(Q[m].subarray(d, p));
        E.push(f);
      }
      return E;
    }(A.mmr, A.patternWidth, A.patternHeight, A.maxPatternIndex, A.template, n);
  }
  onImmediateHalftoneRegion(A, e, i, a, s) {
    const r = this.patterns[e[0]], n = A.info, g = new Wa(i, a, s), o = function(C, h, c, B, l, Q, E, u, f, d, p, m, y, b, D) {
      if (E) throw new _A("skip is not supported");
      if (u !== 0) throw new _A(`operator "${u}" is not supported in halftone region`);
      const R = [];
      let k, Y, V;
      for (k = 0; k < l; k++) {
        if (V = new Uint8Array(B), Q) for (Y = 0; Y < B; Y++) V[Y] = Q;
        R.push(V);
      }
      const eA = h.length, AA = h[0], O = AA[0].length, L = AA.length, v = Cg(eA), W = [];
      C || (W.push({ x: c <= 1 ? 3 : 2, y: -1 }), c === 0 && W.push({ x: -3, y: -1 }, { x: 2, y: -2 }, { x: -2, y: -2 }));
      const K = [];
      let q, N, F, w, x, J, M, H, z, aA, tA;
      for (C && (q = new as(D.data, D.start, D.end)), k = v - 1; k >= 0; k--)
        N = C ? so(q, f, d, !0) : Bn(!1, f, d, c, !1, null, W, D), K[k] = N;
      for (F = 0; F < d; F++) for (w = 0; w < f; w++) {
        for (x = 0, J = 0, Y = v - 1; Y >= 0; Y--)
          x ^= K[Y][F][w], J |= x << Y;
        if (M = h[J], H = p + F * b + w * y >> 8, z = m + F * y - w * b >> 8, H >= 0 && H + O <= B && z >= 0 && z + L <= l) for (k = 0; k < L; k++)
          for (tA = R[z + k], aA = M[k], Y = 0; Y < O; Y++) tA[H + Y] |= aA[Y];
        else {
          let hA, BA;
          for (k = 0; k < L; k++)
            if (BA = z + k, !(BA < 0 || BA >= l))
              for (tA = R[BA], aA = M[k], Y = 0; Y < O; Y++)
                hA = H + Y, hA >= 0 && hA < B && (tA[hA] |= aA[Y]);
        }
      }
      return R;
    }(A.mmr, r, A.template, n.width, n.height, A.defaultPixelValue, A.enableSkip, A.combinationOperator, A.gridWidth, A.gridHeight, A.gridOffsetX, A.gridOffsetY, A.gridVectorX, A.gridVectorY, g);
    this.drawBitmap(n, o);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(A, e, i, a) {
    let s = this.customTables;
    s || (this.customTables = s = {}), s[A] = function(n, g, o) {
      const I = n[g], C = 4294967295 & VA(n, g + 1), h = 4294967295 & VA(n, g + 5), c = new as(n, g + 9, o), B = 1 + (I >> 1 & 7), l = 1 + (I >> 4 & 7), Q = [];
      let E, u, f = C;
      do
        E = c.readBits(B), u = c.readBits(l), Q.push(new _e([f, E, u, 0])), f += 1 << u;
      while (f < h);
      return E = c.readBits(B), Q.push(new _e([C - 1, E, 32, 0, "lower"])), E = c.readBits(B), Q.push(new _e([h, E, 32, 0])), 1 & I && (E = c.readBits(B), Q.push(new _e([E, 0]))), new Wn(Q, !1);
    }(e, i, a);
  }
}
class _e {
  constructor(A) {
    A.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = A[0], this.rangeLength = 0, this.prefixCode = A[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = A[0], this.prefixLength = A[1], this.rangeLength = A[2], this.prefixCode = A[3], this.isLowerRange = A[4] === "lower");
  }
}
class Er {
  constructor(A) {
    this.children = [], A ? (this.isLeaf = !0, this.rangeLength = A.rangeLength, this.rangeLow = A.rangeLow, this.isLowerRange = A.isLowerRange, this.isOOB = A.isOOB) : this.isLeaf = !1;
  }
  buildTree(A, e) {
    const i = A.prefixCode >> e & 1;
    if (e <= 0) this.children[i] = new Er(A);
    else {
      let a = this.children[i];
      a || (this.children[i] = a = new Er(null)), a.buildTree(A, e - 1);
    }
  }
  decodeNode(A) {
    if (this.isLeaf) {
      if (this.isOOB) return null;
      const i = A.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -i : i);
    }
    const e = this.children[A.readBit()];
    if (!e) throw new _A("invalid Huffman data");
    return e.decodeNode(A);
  }
}
class Wn {
  constructor(A, e) {
    e || this.assignPrefixCodes(A), this.rootNode = new Er(null);
    for (let i = 0, a = A.length; i < a; i++) {
      const s = A[i];
      s.prefixLength > 0 && this.rootNode.buildTree(s, s.prefixLength - 1);
    }
  }
  decode(A) {
    return this.rootNode.decodeNode(A);
  }
  assignPrefixCodes(A) {
    const e = A.length;
    let i = 0;
    for (let I = 0; I < e; I++) i = Math.max(i, A[I].prefixLength);
    const a = new Uint32Array(i + 1);
    for (let I = 0; I < e; I++) a[A[I].prefixLength]++;
    let s, r, n, g = 1, o = 0;
    for (a[0] = 0; g <= i; ) {
      for (o = o + a[g - 1] << 1, s = o, r = 0; r < e; )
        n = A[r], n.prefixLength === g && (n.prefixCode = s, s++), r++;
      g++;
    }
  }
}
const Cc = {};
function Xe(t) {
  let A, e = Cc[t];
  if (e) return e;
  switch (t) {
    case 1:
      A = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      A = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      A = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      A = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      A = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      A = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      A = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      A = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      A = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      A = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      A = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      A = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      A = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      A = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      A = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new _A(`standard table B.${t} does not exist`);
  }
  for (let i = 0, a = A.length; i < a; i++) A[i] = new _e(A[i]);
  return e = new Wn(A, !0), Cc[t] = e, e;
}
class as {
  constructor(A, e, i) {
    this.data = A, this.start = e, this.end = i, this.position = e, this.shift = -1, this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end) throw new _A("end of data while reading bit");
      this.currentByte = this.data[this.position++], this.shift = 7;
    }
    const A = this.currentByte >> this.shift & 1;
    return this.shift--, A;
  }
  readBits(A) {
    let e, i = 0;
    for (e = A - 1; e >= 0; e--) i |= this.readBit() << e;
    return i;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
}
function pi(t, A, e) {
  let i = 0;
  for (let a = 0, s = A.length; a < s; a++) {
    const r = e[A[a]];
    if (r) {
      if (t === i) return r;
      i++;
    }
  }
  throw new _A("can't find custom Huffman table");
}
function Sl(t, A, e) {
  const i = [];
  for (let a = 0; a < e; a++) {
    const s = new Uint8Array(A);
    i.push(s);
    for (let r = 0; r < A; r++) s[r] = t.readBit();
    t.byteAlign();
  }
  return i;
}
function so(t, A, e, i) {
  const a = new S1(t, { K: -1, Columns: A, Rows: e, BlackIs1: !0, EndOfBlock: i }), s = [];
  let r, n = !1;
  for (let g = 0; g < e; g++) {
    const o = new Uint8Array(A);
    s.push(o);
    let I = -1;
    for (let C = 0; C < A; C++)
      I < 0 && (r = a.readNextChar(), r === -1 && (r = 0, n = !0), I = 7), o[C] = r >> I & 1, I--;
  }
  if (i && !n)
    for (let o = 0; o < 5 && a.readNextChar() !== -1; o++) ;
  return s;
}
class Rl {
  parseChunks(A) {
    return function(i) {
      const a = new Fl();
      for (let s = 0, r = i.length; s < r; s++) {
        const n = i[s];
        kl(Dl({}, n.data, n.start, n.end), a);
      }
      return a.buffer;
    }(A);
  }
  parse(A) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
class Gl extends Dt {
  constructor(A, e, i) {
    super(e), this.stream = A, this.dict = A.dict, this.maybeLength = e, this.params = i;
  }
  get bytes() {
    return sA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(A) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(A) {
    if (this.eof) return this.buffer;
    A || (A = this.bytes);
    const e = new Rl(), i = [];
    if (this.params instanceof U) {
      const r = this.params.get("JBIG2Globals");
      if (r instanceof FA) {
        const n = r.getBytes();
        i.push({ data: n, start: 0, end: n.length });
      }
    }
    i.push({ data: A, start: 0, end: A.length });
    const a = e.parseChunks(i), s = a.length;
    for (let r = 0; r < s; r++) a[r] ^= 255;
    return this.buffer = a, this.bufferLength = s, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
function N1(t) {
  switch (t.kind) {
    case er:
      return no(t);
    case os:
      return function({ src: e, srcPos: i = 0, dest: a, destPos: s = 0, width: r, height: n }) {
        let g = 0;
        const o = r * n * 3, I = o >> 2, C = new Uint32Array(e.buffer, i, I);
        if (Jt.isLittleEndian) {
          for (; g < I - 2; g += 3, s += 4) {
            const h = C[g], c = C[g + 1], B = C[g + 2];
            a[s] = 4278190080 | h, a[s + 1] = h >>> 24 | c << 8 | 4278190080, a[s + 2] = c >>> 16 | B << 16 | 4278190080, a[s + 3] = B >>> 8 | 4278190080;
          }
          for (let h = 4 * g, c = i + o; h < c; h += 3) a[s++] = e[h] | e[h + 1] << 8 | e[h + 2] << 16 | 4278190080;
        } else {
          for (; g < I - 2; g += 3, s += 4) {
            const h = C[g], c = C[g + 1], B = C[g + 2];
            a[s] = 255 | h, a[s + 1] = h << 24 | c >>> 8 | 255, a[s + 2] = c << 16 | B >>> 16 | 255, a[s + 3] = B << 8 | 255;
          }
          for (let h = 4 * g, c = i + o; h < c; h += 3) a[s++] = e[h] << 24 | e[h + 1] << 16 | e[h + 2] << 8 | 255;
        }
        return { srcPos: i + o, destPos: s };
      }(t);
  }
  return null;
}
function no({ src: t, srcPos: A = 0, dest: e, width: i, height: a, nonBlackColor: s = 4294967295, inverseDecode: r = !1 }) {
  const n = Jt.isLittleEndian ? 4278190080 : 255, [g, o] = r ? [s, n] : [n, s], I = i >> 3, C = 7 & i, h = t.length;
  e = new Uint32Array(e.buffer);
  let c = 0;
  for (let B = 0; B < a; B++) {
    for (const Q = A + I; A < Q; A++) {
      const E = A < h ? t[A] : 255;
      e[c++] = 128 & E ? o : g, e[c++] = 64 & E ? o : g, e[c++] = 32 & E ? o : g, e[c++] = 16 & E ? o : g, e[c++] = 8 & E ? o : g, e[c++] = 4 & E ? o : g, e[c++] = 2 & E ? o : g, e[c++] = 1 & E ? o : g;
    }
    if (C === 0) continue;
    const l = A < h ? t[A++] : 255;
    for (let Q = 0; Q < C; Q++) e[c++] = l & 1 << 7 - Q ? o : g;
  }
  return { srcPos: A, destPos: c };
}
class Ie extends bt {
  constructor(A) {
    super(A, "JpegError");
  }
}
class ro extends bt {
  constructor(A, e) {
    super(A, "DNLMarkerError"), this.scanLines = e;
  }
}
class x1 extends bt {
  constructor(A) {
    super(A, "EOIMarkerError");
  }
}
const cs = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), ln = 4017, Qn = 799, En = 3406, un = 2276, dn = 1567, fn = 3784, zi = 5793, pn = 2896;
function Nl(t, A) {
  let e, i, a = 0, s = 16;
  for (; s > 0 && !t[s - 1]; ) s--;
  const r = [{ children: [], index: 0 }];
  let n, g = r[0];
  for (e = 0; e < s; e++) {
    for (i = 0; i < t[e]; i++) {
      for (g = r.pop(), g.children[g.index] = A[a]; g.index > 0; ) g = r.pop();
      for (g.index++, r.push(g); r.length <= e; )
        r.push(n = { children: [], index: 0 }), g.children[g.index] = n.children, g = n;
      a++;
    }
    e + 1 < s && (r.push(n = { children: [], index: 0 }), g.children[g.index] = n.children, g = n);
  }
  return r[0].children;
}
function go(t, A, e) {
  return 64 * ((t.blocksPerLine + 1) * A + e);
}
function xl(t, A, e, i, a, s, r, n, g, o = !1) {
  const I = e.mcusPerLine, C = e.progressive, h = A;
  let c = 0, B = 0;
  function l() {
    if (B > 0)
      return B--, c >> B & 1;
    if (c = t[A++], c === 255) {
      const q = t[A++];
      if (q) {
        if (q === 220 && o) {
          const N = XA(t, A += 2);
          if (A += 2, N > 0 && N !== e.scanLines) throw new ro("Found DNL marker (0xFFDC) while parsing scan data", N);
        } else if (q === 217) {
          if (o) {
            const N = m * (e.precision === 8 ? 8 : 0);
            if (N > 0 && Math.round(e.scanLines / N) >= 5) throw new ro("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", N);
          }
          throw new x1("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new Ie(`unexpected marker ${(c << 8 | q).toString(16)}`);
      }
    }
    return B = 7, c >>> 7;
  }
  function Q(q) {
    let N = q;
    for (; ; ) {
      switch (N = N[l()], typeof N) {
        case "number":
          return N;
        case "object":
          continue;
      }
      throw new Ie("invalid huffman sequence");
    }
  }
  function E(q) {
    let N = 0;
    for (; q > 0; )
      N = N << 1 | l(), q--;
    return N;
  }
  function u(q) {
    if (q === 1) return l() === 1 ? 1 : -1;
    const N = E(q);
    return N >= 1 << q - 1 ? N : N + (-1 << q) + 1;
  }
  let f = 0, d, p = 0, m = 0;
  function y(q, N, F, w, x) {
    const J = F % I;
    m = (F / I | 0) * q.v + w;
    const M = J * q.h + x;
    N(q, go(q, m, M));
  }
  function b(q, N, F) {
    m = F / q.blocksPerLine | 0;
    const w = F % q.blocksPerLine;
    N(q, go(q, m, w));
  }
  const D = i.length;
  let R, k, Y, V, eA, AA;
  AA = C ? s === 0 ? n === 0 ? function(N, F) {
    const w = Q(N.huffmanTableDC), x = w === 0 ? 0 : u(w) << g;
    N.blockData[F] = N.pred += x;
  } : function(N, F) {
    N.blockData[F] |= l() << g;
  } : n === 0 ? function(N, F) {
    if (f > 0) {
      f--;
      return;
    }
    let w = s;
    const x = r;
    for (; w <= x; ) {
      const J = Q(N.huffmanTableAC), M = 15 & J, H = J >> 4;
      if (M === 0) {
        if (H < 15) {
          f = E(H) + (1 << H) - 1;
          break;
        }
        w += 16;
        continue;
      }
      w += H;
      const z = cs[w];
      N.blockData[F + z] = u(M) * (1 << g), w++;
    }
  } : function(N, F) {
    let w = s;
    const x = r;
    let J, M, H = 0;
    for (; w <= x; ) {
      const z = F + cs[w], aA = N.blockData[z] < 0 ? -1 : 1;
      switch (p) {
        case 0:
          if (M = Q(N.huffmanTableAC), J = 15 & M, H = M >> 4, J === 0) H < 15 ? (f = E(H) + (1 << H), p = 4) : (H = 16, p = 1);
          else {
            if (J !== 1) throw new Ie("invalid ACn encoding");
            d = u(J), p = H ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          N.blockData[z] ? N.blockData[z] += aA * (l() << g) : (H--, H === 0 && (p = p === 2 ? 3 : 0));
          break;
        case 3:
          N.blockData[z] ? N.blockData[z] += aA * (l() << g) : (N.blockData[z] = d << g, p = 0);
          break;
        case 4:
          N.blockData[z] && (N.blockData[z] += aA * (l() << g));
      }
      w++;
    }
    p === 4 && (f--, f === 0 && (p = 0));
  } : function(N, F) {
    const w = Q(N.huffmanTableDC), x = w === 0 ? 0 : u(w);
    N.blockData[F] = N.pred += x;
    let J = 1;
    for (; J < 64; ) {
      const M = Q(N.huffmanTableAC), H = 15 & M, z = M >> 4;
      if (H === 0) {
        if (z < 15) break;
        J += 16;
        continue;
      }
      J += z;
      const aA = cs[J];
      N.blockData[F + aA] = u(H), J++;
    }
  };
  let O, L = 0;
  const v = D === 1 ? i[0].blocksPerLine * i[0].blocksPerColumn : I * e.mcusPerColumn;
  let W, K;
  for (; L <= v; ) {
    const q = a ? Math.min(v - L, a) : v;
    if (q > 0) {
      for (k = 0; k < D; k++) i[k].pred = 0;
      if (f = 0, D === 1)
        for (R = i[0], eA = 0; eA < q; eA++)
          b(R, AA, L), L++;
      else for (eA = 0; eA < q; eA++) {
        for (k = 0; k < D; k++)
          for (R = i[k], W = R.h, K = R.v, Y = 0; Y < K; Y++) for (V = 0; V < W; V++) y(R, AA, L, Y, V);
        L++;
      }
    }
    if (B = 0, O = Zr(t, A), !O || (O.invalid && (G(`decodeScan - ${q > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${O.invalid}`), A = O.offset), !(O.marker >= 65488 && O.marker <= 65495))) break;
    A += 2;
  }
  return A - h;
}
function Ul(t, A, e) {
  const i = t.quantizationTable, a = t.blockData;
  let s, r, n, g, o, I, C, h, c, B, l, Q, E, u, f, d, p;
  if (!i) throw new Ie("missing required Quantization Table.");
  for (let m = 0; m < 64; m += 8)
    c = a[A + m], B = a[A + m + 1], l = a[A + m + 2], Q = a[A + m + 3], E = a[A + m + 4], u = a[A + m + 5], f = a[A + m + 6], d = a[A + m + 7], c *= i[m], B | l | Q | E | u | f | d ? (B *= i[m + 1], l *= i[m + 2], Q *= i[m + 3], E *= i[m + 4], u *= i[m + 5], f *= i[m + 6], d *= i[m + 7], s = zi * c + 128 >> 8, r = zi * E + 128 >> 8, n = l, g = f, o = pn * (B - d) + 128 >> 8, h = pn * (B + d) + 128 >> 8, I = Q << 4, C = u << 4, s = s + r + 1 >> 1, r = s - r, p = n * fn + g * dn + 128 >> 8, n = n * dn - g * fn + 128 >> 8, g = p, o = o + C + 1 >> 1, C = o - C, h = h + I + 1 >> 1, I = h - I, s = s + g + 1 >> 1, g = s - g, r = r + n + 1 >> 1, n = r - n, p = o * un + h * En + 2048 >> 12, o = o * En - h * un + 2048 >> 12, h = p, p = I * Qn + C * ln + 2048 >> 12, I = I * ln - C * Qn + 2048 >> 12, C = p, e[m] = s + h, e[m + 7] = s - h, e[m + 1] = r + C, e[m + 6] = r - C, e[m + 2] = n + I, e[m + 5] = n - I, e[m + 3] = g + o, e[m + 4] = g - o) : (p = zi * c + 512 >> 10, e[m] = p, e[m + 1] = p, e[m + 2] = p, e[m + 3] = p, e[m + 4] = p, e[m + 5] = p, e[m + 6] = p, e[m + 7] = p);
  for (let m = 0; m < 8; ++m)
    c = e[m], B = e[m + 8], l = e[m + 16], Q = e[m + 24], E = e[m + 32], u = e[m + 40], f = e[m + 48], d = e[m + 56], B | l | Q | E | u | f | d ? (s = zi * c + 2048 >> 12, r = zi * E + 2048 >> 12, n = l, g = f, o = pn * (B - d) + 2048 >> 12, h = pn * (B + d) + 2048 >> 12, I = Q, C = u, s = 4112 + (s + r + 1 >> 1), r = s - r, p = n * fn + g * dn + 2048 >> 12, n = n * dn - g * fn + 2048 >> 12, g = p, o = o + C + 1 >> 1, C = o - C, h = h + I + 1 >> 1, I = h - I, s = s + g + 1 >> 1, g = s - g, r = r + n + 1 >> 1, n = r - n, p = o * un + h * En + 2048 >> 12, o = o * En - h * un + 2048 >> 12, h = p, p = I * Qn + C * ln + 2048 >> 12, I = I * ln - C * Qn + 2048 >> 12, C = p, c = s + h, d = s - h, B = r + C, f = r - C, l = n + I, u = n - I, Q = g + o, E = g - o, c < 16 ? c = 0 : c >= 4080 ? c = 255 : c >>= 4, B < 16 ? B = 0 : B >= 4080 ? B = 255 : B >>= 4, l < 16 ? l = 0 : l >= 4080 ? l = 255 : l >>= 4, Q < 16 ? Q = 0 : Q >= 4080 ? Q = 255 : Q >>= 4, E < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4, u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4, f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4, d < 16 ? d = 0 : d >= 4080 ? d = 255 : d >>= 4, a[A + m] = c, a[A + m + 8] = B, a[A + m + 16] = l, a[A + m + 24] = Q, a[A + m + 32] = E, a[A + m + 40] = u, a[A + m + 48] = f, a[A + m + 56] = d) : (p = zi * c + 8192 >> 14, p = p < -2040 ? 0 : p >= 2024 ? 255 : p + 2056 >> 4, a[A + m] = p, a[A + m + 8] = p, a[A + m + 16] = p, a[A + m + 24] = p, a[A + m + 32] = p, a[A + m + 40] = p, a[A + m + 48] = p, a[A + m + 56] = p);
}
function Ml(t, A) {
  const e = A.blocksPerLine, i = A.blocksPerColumn, a = new Int16Array(64);
  for (let s = 0; s < i; s++) for (let r = 0; r < e; r++)
    Ul(A, go(A, s, r), a);
  return A.blockData;
}
function Zr(t, A, e = A) {
  const i = t.length - 1;
  let a = e < A ? e : A;
  if (A >= i) return null;
  const s = XA(t, A);
  if (s >= 65472 && s <= 65534) return { invalid: null, marker: s, offset: A };
  let r = XA(t, a);
  for (; !(r >= 65472 && r <= 65534); ) {
    if (++a >= i) return null;
    r = XA(t, a);
  }
  return { invalid: s.toString(16), marker: r, offset: a };
}
function Ll(t) {
  const A = Math.ceil(t.samplesPerLine / 8 / t.maxH), e = Math.ceil(t.scanLines / 8 / t.maxV);
  for (const i of t.components) {
    const a = Math.ceil(Math.ceil(t.samplesPerLine / 8) * i.h / t.maxH), s = Math.ceil(Math.ceil(t.scanLines / 8) * i.v / t.maxV), r = A * i.h, n = 64 * (e * i.v) * (r + 1);
    i.blockData = new Int16Array(n), i.blocksPerLine = a, i.blocksPerColumn = s;
  }
  t.mcusPerLine = A, t.mcusPerColumn = e;
}
function Jl(t, A) {
  const e = XA(t, A);
  let i = (A += 2) + e - 2;
  const a = Zr(t, i, A);
  a != null && a.invalid && (G("readDataBlock - incorrect length, current marker is: " + a.invalid), i = a.offset);
  const s = t.subarray(A, i);
  return { appData: s, newOffset: A += s.length };
}
function Hl(t, A) {
  const e = XA(t, A), i = (A += 2) + e - 2, a = Zr(t, i, A);
  return a != null && a.invalid ? a.offset : i;
}
class hc {
  constructor({ decodeTransform: A = null, colorTransform: e = -1 } = {}) {
    this._decodeTransform = A, this._colorTransform = e;
  }
  static canUseImageDecoder(A, e = -1) {
    let i = 0, a = null, s = XA(A, i);
    if (i += 2, s !== 65496) throw new Ie("SOI not found");
    s = XA(A, i), i += 2;
    A: for (; s !== 65497; ) {
      switch (s) {
        case 65472:
        case 65473:
        case 65474:
          a = A[i + 7];
          break A;
        case 65535:
          A[i] !== 255 && i--;
      }
      i = Hl(A, i), s = XA(A, i), i += 2;
    }
    return a !== 4 && (a !== 3 || e !== 0);
  }
  parse(A, { dnlScanLines: e = null } = {}) {
    let i, a, s = 0, r = null, n = null, g = 0;
    const o = [], I = [], C = [];
    let h = XA(A, s);
    if (s += 2, h !== 65496) throw new Ie("SOI not found");
    h = XA(A, s), s += 2;
    A: for (; h !== 65497; ) {
      let c, B, l;
      switch (h) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const { appData: Q, newOffset: E } = Jl(A, s);
          s = E, h === 65504 && Q[0] === 74 && Q[1] === 70 && Q[2] === 73 && Q[3] === 70 && Q[4] === 0 && (r = { version: { major: Q[5], minor: Q[6] }, densityUnits: Q[7], xDensity: Q[8] << 8 | Q[9], yDensity: Q[10] << 8 | Q[11], thumbWidth: Q[12], thumbHeight: Q[13], thumbData: Q.subarray(14, 14 + 3 * Q[12] * Q[13]) }), h === 65518 && Q[0] === 65 && Q[1] === 100 && Q[2] === 111 && Q[3] === 98 && Q[4] === 101 && (n = { version: Q[5] << 8 | Q[6], flags0: Q[7] << 8 | Q[8], flags1: Q[9] << 8 | Q[10], transformCode: Q[11] });
          break;
        case 65499:
          const u = XA(A, s);
          s += 2;
          const f = u + s - 2;
          let d;
          for (; s < f; ) {
            const L = A[s++], v = new Uint16Array(64);
            if (L >> 4) {
              if (L >> 4 != 1) throw new Ie("DQT - invalid table spec");
              for (B = 0; B < 64; B++)
                d = cs[B], v[d] = XA(A, s), s += 2;
            } else
              for (B = 0; B < 64; B++)
                d = cs[B], v[d] = A[s++];
            o[15 & L] = v;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (i) throw new Ie("Only single frame JPEGs supported");
          s += 2, i = {}, i.extended = h === 65473, i.progressive = h === 65474, i.precision = A[s++];
          const p = XA(A, s);
          s += 2, i.scanLines = e || p, i.samplesPerLine = XA(A, s), s += 2, i.components = [], i.componentIds = {};
          const m = A[s++];
          let y = 0, b = 0;
          for (c = 0; c < m; c++) {
            const L = A[s], v = A[s + 1] >> 4, W = 15 & A[s + 1];
            y < v && (y = v), b < W && (b = W);
            const K = A[s + 2];
            l = i.components.push({ h: v, v: W, quantizationId: K, quantizationTable: null }), i.componentIds[L] = l - 1, s += 3;
          }
          i.maxH = y, i.maxV = b, Ll(i);
          break;
        case 65476:
          const D = XA(A, s);
          for (s += 2, c = 2; c < D; ) {
            const L = A[s++], v = new Uint8Array(16);
            let W = 0;
            for (B = 0; B < 16; B++, s++) W += v[B] = A[s];
            const K = new Uint8Array(W);
            for (B = 0; B < W; B++, s++) K[B] = A[s];
            c += 17 + W, (L >> 4 ? I : C)[15 & L] = Nl(v, K);
          }
          break;
        case 65501:
          s += 2, a = XA(A, s), s += 2;
          break;
        case 65498:
          const R = ++g == 1 && !e;
          s += 2;
          const k = A[s++], Y = [];
          for (c = 0; c < k; c++) {
            const L = A[s++], v = i.componentIds[L], W = i.components[v];
            W.index = L;
            const K = A[s++];
            W.huffmanTableDC = C[K >> 4], W.huffmanTableAC = I[15 & K], Y.push(W);
          }
          const V = A[s++], eA = A[s++], AA = A[s++];
          try {
            s += xl(A, s, i, Y, a, V, eA, AA >> 4, 15 & AA, R);
          } catch (L) {
            if (L instanceof ro)
              return G(`${L.message} -- attempting to re-parse the JPEG image.`), this.parse(A, { dnlScanLines: L.scanLines });
            if (L instanceof x1) {
              G(`${L.message} -- ignoring the rest of the image data.`);
              break A;
            }
            throw L;
          }
          break;
        case 65500:
          s += 4;
          break;
        case 65535:
          A[s] !== 255 && s--;
          break;
        default:
          const O = Zr(A, s - 2, s - 3);
          if (O != null && O.invalid) {
            G("JpegImage.parse - unexpected data, current marker is: " + O.invalid), s = O.offset;
            break;
          }
          if (!O || s >= A.length - 1) {
            G("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break A;
          }
          throw new Ie("JpegImage.parse - unknown marker: " + h.toString(16));
      }
      h = XA(A, s), s += 2;
    }
    if (!i) throw new Ie("JpegImage.parse - no frame data found.");
    this.width = i.samplesPerLine, this.height = i.scanLines, this.jfif = r, this.adobe = n, this.components = [];
    for (const c of i.components) {
      const B = o[c.quantizationId];
      B && (c.quantizationTable = B), this.components.push({ index: c.index, output: Ml(0, c), scaleX: c.h / i.maxH, scaleY: c.v / i.maxV, blocksPerLine: c.blocksPerLine, blocksPerColumn: c.blocksPerColumn });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(A, e, i = !1) {
    const a = this.width / A, s = this.height / e;
    let r, n, g, o, I, C, h, c, B, l, Q, E = 0;
    const u = this.components.length, f = A * e * u, d = new Uint8ClampedArray(f), p = new Uint32Array(A), m = 4294967288;
    let y;
    for (h = 0; h < u; h++) {
      if (r = this.components[h], n = r.scaleX * a, g = r.scaleY * s, E = h, Q = r.output, o = r.blocksPerLine + 1 << 3, n !== y) {
        for (I = 0; I < A; I++)
          c = 0 | I * n, p[I] = (c & m) << 3 | 7 & c;
        y = n;
      }
      for (C = 0; C < e; C++)
        for (c = 0 | C * g, l = o * (c & m) | (7 & c) << 3, I = 0; I < A; I++)
          d[E] = Q[l + p[I]], E += u;
    }
    let b = this._decodeTransform;
    if (i || u !== 4 || b || (b = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), b) for (h = 0; h < f; ) for (c = 0, B = 0; c < u; c++, h++, B += 2) d[h] = (d[h] * b[B] >> 8) + b[B + 1];
    return d;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform !== 0 && (this.components[0].index !== 82 || this.components[1].index !== 71 || this.components[2].index !== 66) : this._colorTransform === 1;
  }
  _convertYccToRgb(A) {
    let e, i, a;
    for (let s = 0, r = A.length; s < r; s += 3)
      e = A[s], i = A[s + 1], a = A[s + 2], A[s] = e - 179.456 + 1.402 * a, A[s + 1] = e + 135.459 - 0.344 * i - 0.714 * a, A[s + 2] = e - 226.816 + 1.772 * i;
    return A;
  }
  _convertYccToRgba(A, e) {
    for (let i = 0, a = 0, s = A.length; i < s; i += 3, a += 4) {
      const r = A[i], n = A[i + 1], g = A[i + 2];
      e[a] = r - 179.456 + 1.402 * g, e[a + 1] = r + 135.459 - 0.344 * n - 0.714 * g, e[a + 2] = r - 226.816 + 1.772 * n, e[a + 3] = 255;
    }
    return e;
  }
  _convertYcckToRgb(A) {
    let e, i, a, s, r = 0;
    for (let n = 0, g = A.length; n < g; n += 4)
      e = A[n], i = A[n + 1], a = A[n + 2], s = A[n + 3], A[r++] = i * (-660635669420364e-19 * i + 437130475926232e-18 * a - 54080610064599e-18 * e + 48449797120281e-17 * s - 0.154362151871126) - 122.67195406894 + a * (-957964378445773e-18 * a + 817076911346625e-18 * e - 0.00477271405408747 * s + 1.53380253221734) + e * (961250184130688e-18 * e - 0.00266257332283933 * s + 0.48357088451265) + s * (-336197177618394e-18 * s + 0.484791561490776), A[r++] = 107.268039397724 + i * (219927104525741e-19 * i - 640992018297945e-18 * a + 659397001245577e-18 * e + 426105652938837e-18 * s - 0.176491792462875) + a * (-778269941513683e-18 * a + 0.00130872261408275 * e + 770482631801132e-18 * s - 0.151051492775562) + e * (0.00126935368114843 * e - 0.00265090189010898 * s + 0.25802910206845) + s * (-318913117588328e-18 * s - 0.213742400323665), A[r++] = i * (-570115196973677e-18 * i - 263409051004589e-19 * a + 0.0020741088115012 * e - 0.00288260236853442 * s + 0.814272968359295) - 20.810012546947 + a * (-153496057440975e-19 * a - 132689043961446e-18 * e + 560833691242812e-18 * s - 0.195152027534049) + e * (0.00174418132927582 * e - 0.00255243321439347 * s + 0.116935020465145) + s * (-343531996510555e-18 * s + 0.24165260232407);
    return A.subarray(0, r);
  }
  _convertYcckToRgba(A) {
    for (let e = 0, i = A.length; e < i; e += 4) {
      const a = A[e], s = A[e + 1], r = A[e + 2], n = A[e + 3];
      A[e] = s * (-660635669420364e-19 * s + 437130475926232e-18 * r - 54080610064599e-18 * a + 48449797120281e-17 * n - 0.154362151871126) - 122.67195406894 + r * (-957964378445773e-18 * r + 817076911346625e-18 * a - 0.00477271405408747 * n + 1.53380253221734) + a * (961250184130688e-18 * a - 0.00266257332283933 * n + 0.48357088451265) + n * (-336197177618394e-18 * n + 0.484791561490776), A[e + 1] = 107.268039397724 + s * (219927104525741e-19 * s - 640992018297945e-18 * r + 659397001245577e-18 * a + 426105652938837e-18 * n - 0.176491792462875) + r * (-778269941513683e-18 * r + 0.00130872261408275 * a + 770482631801132e-18 * n - 0.151051492775562) + a * (0.00126935368114843 * a - 0.00265090189010898 * n + 0.25802910206845) + n * (-318913117588328e-18 * n - 0.213742400323665), A[e + 2] = s * (-570115196973677e-18 * s - 263409051004589e-19 * r + 0.0020741088115012 * a - 0.00288260236853442 * n + 0.814272968359295) - 20.810012546947 + r * (-153496057440975e-19 * r - 132689043961446e-18 * a + 560833691242812e-18 * n - 0.195152027534049) + a * (0.00174418132927582 * a - 0.00255243321439347 * n + 0.116935020465145) + n * (-343531996510555e-18 * n + 0.24165260232407), A[e + 3] = 255;
    }
    return A;
  }
  _convertYcckToCmyk(A) {
    let e, i, a;
    for (let s = 0, r = A.length; s < r; s += 4)
      e = A[s], i = A[s + 1], a = A[s + 2], A[s] = 434.456 - e - 1.402 * a, A[s + 1] = 119.541 - e + 0.344 * i + 0.714 * a, A[s + 2] = 481.816 - e - 1.772 * i;
    return A;
  }
  _convertCmykToRgb(A) {
    let e, i, a, s, r = 0;
    for (let n = 0, g = A.length; n < g; n += 4)
      e = A[n], i = A[n + 1], a = A[n + 2], s = A[n + 3], A[r++] = 255 + e * (-6747147073602441e-20 * e + 8379262121013727e-19 * i + 2894718188643294e-19 * a + 0.003264231057537806 * s - 1.1185611867203937) + i * (26374107616089405e-21 * i - 8626949158638572e-20 * a - 2748769067499491e-19 * s - 0.02155688794978967) + a * (-3878099212869363e-20 * a - 3267808279485286e-19 * s + 0.0686742238595345) - s * (3361971776183937e-19 * s + 0.7430659151342254), A[r++] = 255 + e * (13596372813588848e-20 * e + 924537132573585e-18 * i + 10567359618683593e-20 * a + 4791864687436512e-19 * s - 0.3109689587515875) + i * (-23545346108370344e-20 * i + 2702845253534714e-19 * a + 0.0020200308977307156 * s - 0.7488052167015494) + a * (6834815998235662e-20 * a + 15168452363460973e-20 * s - 0.09751927774728933) - s * (3189131175883281e-19 * s + 0.7364883807733168), A[r++] = 255 + e * (13598650411385307e-21 * e + 12423956175490851e-20 * i + 4751985097583589e-19 * a - 36729317476630422e-22 * s - 0.05562186980264034) + i * (16141380598724676e-20 * i + 9692239130725186e-19 * a + 7782692450036253e-19 * s - 0.44015232367526463) + a * (5068882914068769e-22 * a + 0.0017778369011375071 * s - 0.7591454649749609) - s * (3435319965105553e-19 * s + 0.7063770186160144);
    return A.subarray(0, r);
  }
  _convertCmykToRgba(A) {
    for (let e = 0, i = A.length; e < i; e += 4) {
      const a = A[e], s = A[e + 1], r = A[e + 2], n = A[e + 3];
      A[e] = 255 + a * (-6747147073602441e-20 * a + 8379262121013727e-19 * s + 2894718188643294e-19 * r + 0.003264231057537806 * n - 1.1185611867203937) + s * (26374107616089405e-21 * s - 8626949158638572e-20 * r - 2748769067499491e-19 * n - 0.02155688794978967) + r * (-3878099212869363e-20 * r - 3267808279485286e-19 * n + 0.0686742238595345) - n * (3361971776183937e-19 * n + 0.7430659151342254), A[e + 1] = 255 + a * (13596372813588848e-20 * a + 924537132573585e-18 * s + 10567359618683593e-20 * r + 4791864687436512e-19 * n - 0.3109689587515875) + s * (-23545346108370344e-20 * s + 2702845253534714e-19 * r + 0.0020200308977307156 * n - 0.7488052167015494) + r * (6834815998235662e-20 * r + 15168452363460973e-20 * n - 0.09751927774728933) - n * (3189131175883281e-19 * n + 0.7364883807733168), A[e + 2] = 255 + a * (13598650411385307e-21 * a + 12423956175490851e-20 * s + 4751985097583589e-19 * r - 36729317476630422e-22 * n - 0.05562186980264034) + s * (16141380598724676e-20 * s + 9692239130725186e-19 * r + 7782692450036253e-19 * n - 0.44015232367526463) + r * (5068882914068769e-22 * r + 0.0017778369011375071 * n - 0.7591454649749609) - n * (3435319965105553e-19 * n + 0.7063770186160144), A[e + 3] = 255;
    }
    return A;
  }
  getData({ width: A, height: e, forceRGBA: i = !1, forceRGB: a = !1, isSourcePDF: s = !1 }) {
    if (this.numComponents > 4) throw new Ie("Unsupported color mode");
    const r = this._getLinearizedBlockData(A, e, s);
    if (this.numComponents === 1 && (i || a)) {
      const n = r.length * (i ? 4 : 3), g = new Uint8ClampedArray(n);
      let o = 0;
      if (i) (function(C, h) {
        if (Jt.isLittleEndian) for (let c = 0, B = C.length; c < B; c++) h[c] = 65793 * C[c] | 4278190080;
        else for (let c = 0, B = C.length; c < B; c++) h[c] = 16843008 * C[c] | 255;
      })(r, new Uint32Array(g.buffer));
      else for (const I of r)
        g[o++] = I, g[o++] = I, g[o++] = I;
      return g;
    }
    if (this.numComponents === 3 && this._isColorConversionNeeded) {
      if (i) {
        const n = new Uint8ClampedArray(r.length / 3 * 4);
        return this._convertYccToRgba(r, n);
      }
      return this._convertYccToRgb(r);
    }
    if (this.numComponents === 4) {
      if (this._isColorConversionNeeded) return i ? this._convertYcckToRgba(r) : a ? this._convertYcckToRgb(r) : this._convertYcckToCmyk(r);
      if (i) return this._convertCmykToRgba(r);
      if (a) return this._convertCmykToRgb(r);
    }
    return r;
  }
}
var Zs, Os, oo;
const Lr = class Lr extends Dt {
  constructor(e, i, a) {
    super(i);
    MA(this, Os);
    this.stream = e, this.dict = e.dict, this.maybeLength = i, this.params = a;
  }
  static get canUseImageDecoder() {
    return sA(this, "canUseImageDecoder", NA(this, Zs) ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
  }
  static setOptions({ isImageDecoderSupported: e = !1 }) {
    Vt(this, Zs, e);
  }
  get bytes() {
    return sA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(e) {
  }
  readBlock() {
    this.decodeImage();
  }
  get jpegOptions() {
    const e = { decodeTransform: void 0, colorTransform: void 0 }, i = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(i)) {
      const a = this.dict.get("BPC", "BitsPerComponent") || 8, s = i.length, r = new Int32Array(s);
      let n = !1;
      const g = (1 << a) - 1;
      for (let o = 0; o < s; o += 2)
        r[o] = 256 * (i[o + 1] - i[o]) | 0, r[o + 1] = i[o] * g | 0, r[o] === 256 && r[o + 1] === 0 || (n = !0);
      n && (e.decodeTransform = r);
    }
    if (this.params instanceof U) {
      const a = this.params.get("ColorTransform");
      Number.isInteger(a) && (e.colorTransform = a);
    }
    return sA(this, "jpegOptions", e);
  }
  decodeImage(e) {
    if (this.eof) return this.buffer;
    e = CA(this, Os, oo).call(this, e || this.bytes);
    const i = new hc(this.jpegOptions);
    i.parse(e);
    const a = i.getData({ width: this.drawWidth, height: this.drawHeight, forceRGBA: this.forceRGBA, forceRGB: this.forceRGB, isSourcePDF: !0 });
    return this.buffer = a, this.bufferLength = a.length, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
  async getTransferableImage() {
    if (!await Lr.canUseImageDecoder) return null;
    const e = this.jpegOptions;
    if (e.decodeTransform) return null;
    let i;
    try {
      const a = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
      if (!a) return null;
      const s = CA(this, Os, oo).call(this, a);
      return hc.canUseImageDecoder(s, e.colorTransform) ? (i = new ImageDecoder({ data: s, type: "image/jpeg", preferAnimation: !1 }), (await i.decode()).image) : null;
    } catch (a) {
      return G(`getTransferableImage - failed: "${a}".`), null;
    } finally {
      i == null || i.close();
    }
  }
};
Zs = new WeakMap(), Os = new WeakSet(), oo = function(e) {
  for (let i = 0, a = e.length - 1; i < a; i++) if (e[i] === 255 && e[i + 1] === 216) {
    i > 0 && (e = e.subarray(i));
    break;
  }
  return e;
}, MA(Lr, Zs, Jt.isImageDecoderSupported);
let Na = Lr;
var hg, H0, Yl = (hg = typeof document < "u" ? (H0 = document.currentScript) == null ? void 0 : H0.src : void 0, function(t = {}) {
  var A, e, i = t;
  new Promise((N, F) => {
    A = N, e = F;
  }), i.decode = function(N, { numComponents: F = 4, isIndexedColormap: w = !1, smaskInData: x = !1 }) {
    const J = N.length, M = i._malloc(J);
    i.HEAPU8.set(N, M);
    const H = i._jp2_decode(M, J, F > 0 ? F : 0, !!w, !!x);
    if (i._free(M), H) {
      const { errorMessages: aA } = i;
      return aA ? (delete i.errorMessages, aA) : "Unknown error";
    }
    const { imageData: z } = i;
    return i.imageData = null, z;
  };
  var a = Object.assign({}, i), s = "./this.program", r = "";
  typeof document < "u" && document.currentScript && (r = document.currentScript.src), hg && (r = hg), r = r.startsWith("blob:") ? "" : r.substr(0, r.replace(/[?#].*/, "").lastIndexOf("/") + 1);
  var n, g, o, I, C, h = i.print || console.log.bind(console), c = i.printErr || console.error.bind(console);
  Object.assign(i, a), a = null, i.arguments && i.arguments, i.thisProgram && (s = i.thisProgram), i.quit && i.quit, i.wasmBinary && (n = i.wasmBinary);
  function B(N) {
    if (y(N)) return function(w) {
      for (var x = atob(w), J = new Uint8Array(x.length), M = 0; M < x.length; ++M) J[M] = x.charCodeAt(M);
      return J;
    }(N.slice(m.length));
  }
  function l() {
    var N = g.buffer;
    i.HEAP8 = o = new Int8Array(N), i.HEAP16 = new Int16Array(N), i.HEAPU8 = I = new Uint8Array(N), i.HEAPU16 = new Uint16Array(N), i.HEAP32 = new Int32Array(N), i.HEAPU32 = C = new Uint32Array(N), i.HEAPF32 = new Float32Array(N), i.HEAPF64 = new Float64Array(N);
  }
  var Q, E = [], u = [], f = [], d = 0, p = null, m = "data:application/octet-stream;base64,", y = (N) => N.startsWith(m);
  function b(N, F) {
    var w, x = function(M) {
      if (M == Q && n) return new Uint8Array(n);
      var H = B(M);
      if (H) return H;
      throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
    }(N);
    return w = new WebAssembly.Module(x), [new WebAssembly.Instance(w, F), w];
  }
  var D = (N) => {
    for (; N.length > 0; ) N.shift()(i);
  };
  i.noExitRuntime;
  var R, k = (N) => {
    var F = (N - g.buffer.byteLength + 65535) / 65536;
    try {
      return g.grow(F), l(), 1;
    } catch {
    }
  }, Y = {}, V = () => {
    if (!V.strings) {
      var N = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: s || "./this.program" };
      for (var F in Y) Y[F] === void 0 ? delete N[F] : N[F] = Y[F];
      var w = [];
      for (var F in N) w.push(`${F}=${N[F]}`);
      V.strings = w;
    }
    return V.strings;
  }, eA = [null, [], []], AA = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, O = (N, F, w) => {
    for (var x = F + w, J = F; N[J] && !(J >= x); ) ++J;
    if (J - F > 16 && N.buffer && AA) return AA.decode(N.subarray(F, J));
    for (var M = ""; F < J; ) {
      var H = N[F++];
      if (128 & H) {
        var z = 63 & N[F++];
        if ((224 & H) != 192) {
          var aA = 63 & N[F++];
          if ((H = (240 & H) == 224 ? (15 & H) << 12 | z << 6 | aA : (7 & H) << 18 | z << 12 | aA << 6 | 63 & N[F++]) < 65536) M += String.fromCharCode(H);
          else {
            var tA = H - 65536;
            M += String.fromCharCode(55296 | tA >> 10, 56320 | 1023 & tA);
          }
        } else M += String.fromCharCode((31 & H) << 6 | z);
      } else M += String.fromCharCode(H);
    }
    return M;
  }, L = (N, F) => {
    var w = eA[N];
    F === 0 || F === 10 ? ((N === 1 ? h : c)(O(w, 0)), w.length = 0) : w.push(F);
  }, v = (N, F) => N ? O(I, N, F) : "", W = { c: (N, F, w) => I.copyWithin(N, F, F + w), g: function(F, w) {
    F >>= 2;
    const x = i.imageData = new Uint8ClampedArray(w), J = i.HEAP32.subarray(F, F + w);
    x.set(J);
  }, f: function(F, w, x, J) {
    F >>= 2, w >>= 2, x >>= 2;
    const M = i.imageData = new Uint8ClampedArray(3 * J), H = i.HEAP32.subarray(F, F + J), z = i.HEAP32.subarray(w, w + J), aA = i.HEAP32.subarray(x, x + J);
    for (let tA = 0; tA < J; tA++)
      M[3 * tA] = H[tA], M[3 * tA + 1] = z[tA], M[3 * tA + 2] = aA[tA];
  }, e: function(F, w, x, J, M) {
    F >>= 2, w >>= 2, x >>= 2, J >>= 2;
    const H = i.imageData = new Uint8ClampedArray(4 * M), z = i.HEAP32.subarray(F, F + M), aA = i.HEAP32.subarray(w, w + M), tA = i.HEAP32.subarray(x, x + M), hA = i.HEAP32.subarray(J, J + M);
    for (let BA = 0; BA < M; BA++)
      H[4 * BA] = z[BA], H[4 * BA + 1] = aA[BA], H[4 * BA + 2] = tA[BA], H[4 * BA + 3] = hA[BA];
  }, k: (N) => {
    var F = I.length, w = 2147483648;
    if ((N >>>= 0) > w) return !1;
    for (var x, J, M = 1; M <= 4; M *= 2) {
      var H = F * (1 + 0.2 / M);
      H = Math.min(H, N + 100663296);
      var z = Math.min(w, (x = Math.max(N, H)) + ((J = 65536) - x % J) % J);
      if (k(z)) return !0;
    }
    return !1;
  }, l: (N, F) => {
    var w = 0;
    return V().forEach((x, J) => {
      var M = F + w;
      C[N + 4 * J >> 2] = M, ((H, z) => {
        for (var aA = 0; aA < H.length; ++aA) o[z++] = H.charCodeAt(aA);
        o[z] = 0;
      })(x, M), w += x.length + 1;
    }), 0;
  }, m: (N, F) => {
    var w = V();
    C[N >> 2] = w.length;
    var x = 0;
    return w.forEach((J) => x += J.length + 1), C[F >> 2] = x, 0;
  }, n: (N) => 52, j: function(F, w, x, J, M) {
    return 70;
  }, b: (N, F, w, x) => {
    for (var J = 0, M = 0; M < w; M++) {
      var H = C[F >> 2], z = C[F + 4 >> 2];
      F += 8;
      for (var aA = 0; aA < z; aA++) L(N, I[H + aA]);
      J += z;
    }
    return C[x >> 2] = J, 0;
  }, o: function(F, w) {
    F >>= 2;
    const x = i.imageData = new Uint8ClampedArray(4 * w), J = i.HEAP32.subarray(F, F + w);
    for (let M = 0; M < w; M++)
      x[4 * M] = x[4 * M + 1] = x[4 * M + 2] = J[M], x[4 * M + 3] = 255;
  }, i: function(F, w, x) {
    F >>= 2, w >>= 2;
    const J = i.imageData = new Uint8ClampedArray(4 * x), M = i.HEAP32.subarray(F, F + x), H = i.HEAP32.subarray(w, w + x);
    for (let z = 0; z < x; z++)
      J[4 * z] = J[4 * z + 1] = J[4 * z + 2] = M[z], J[4 * z + 3] = H[z];
  }, d: function(F) {
    const w = v(F);
    (i.warn || console.warn)(`OpenJPEG: ${w}`);
  }, h: function(F, w, x, J) {
    F >>= 2, w >>= 2, x >>= 2;
    const M = i.imageData = new Uint8ClampedArray(4 * J), H = i.HEAP32.subarray(F, F + J), z = i.HEAP32.subarray(w, w + J), aA = i.HEAP32.subarray(x, x + J);
    for (let tA = 0; tA < J; tA++)
      M[4 * tA] = H[tA], M[4 * tA + 1] = z[tA], M[4 * tA + 2] = aA[tA], M[4 * tA + 3] = 255;
  }, a: function(F) {
    const w = v(F);
    i.errorMessages ? i.errorMessages += `
` + w : i.errorMessages = w;
  } }, K = function() {
    var F = /* @__PURE__ */ function() {
      return { a: W };
    }();
    function w(x, J) {
      return K = x.exports, g = K.p, l(), function(H) {
        u.unshift(H);
      }(K.q), function(H) {
        var aA;
        if (d--, (aA = i.monitorRunDependencies) == null || aA.call(i, d), d == 0 && p) {
          var z = p;
          p = null, z();
        }
      }(), K;
    }
    if (function(J) {
      var M;
      d++, (M = i.monitorRunDependencies) == null || M.call(i, d);
    }(), i.instantiateWasm) try {
      return i.instantiateWasm(F, w);
    } catch (x) {
      c(`Module.instantiateWasm callback failed with error: ${x}`), e(x);
    }
    return Q || (Q = "data:application/octet-stream;base64,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A0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCAD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IABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsE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AyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxF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KT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQg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AAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo="), w(b(Q, F)[0]);
  }();
  K.q, i._malloc = K.r, i._free = K.s, i._jp2_decode = K.u, p = function N() {
    R || q(), R || (p = N);
  };
  function q() {
    d > 0 || (function() {
      if (i.preRun)
        for (typeof i.preRun == "function" && (i.preRun = [i.preRun]); i.preRun.length; ) w = i.preRun.shift(), E.unshift(w);
      var w;
      D(E);
    }(), d > 0 || (i.setStatus ? (i.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        i.setStatus("");
      }, 1), N();
    }, 1)) : N()));
    function N() {
      R || (R = !0, i.calledRun = !0, function() {
        D(u);
      }(), A(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), function() {
        if (i.postRun)
          for (typeof i.postRun == "function" && (i.postRun = [i.postRun]); i.postRun.length; ) w = i.postRun.shift(), f.unshift(w);
        var w;
        D(f);
      }());
    }
  }
  if (i.preInit)
    for (typeof i.preInit == "function" && (i.preInit = [i.preInit]); i.preInit.length > 0; ) i.preInit.pop()();
  return q(), i;
});
const vl = Yl;
class Bc extends bt {
  constructor(A) {
    super(A, "JpxError");
  }
}
var ba;
class Or {
  static decode(A, e) {
    e || (e = {}), NA(this, ba) || Vt(this, ba, vl({ warn: G }));
    const i = NA(this, ba).decode(A, e);
    if (typeof i == "string") throw new Bc(i);
    return i;
  }
  static cleanup() {
    Vt(this, ba, null);
  }
  static parseImageProperties(A) {
    let e = A.getByte();
    for (; e >= 0; ) {
      const i = e;
      if (e = A.getByte(), (i << 8 | e) === 65361) {
        A.skip(4);
        const a = A.getInt32() >>> 0, s = A.getInt32() >>> 0, r = A.getInt32() >>> 0, n = A.getInt32() >>> 0;
        return A.skip(16), { width: a - r, height: s - n, bitsPerComponent: 8, componentsCount: A.getUint16() };
      }
    }
    throw new Bc("No size marker found in JPX stream");
  }
}
ba = new WeakMap(), MA(Or, ba, null);
class Kl extends Dt {
  constructor(A, e, i) {
    super(e), this.stream = A, this.dict = A.dict, this.maybeLength = e, this.params = i;
  }
  get bytes() {
    return sA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(A) {
  }
  readBlock(A) {
    this.decodeImage(null, A);
  }
  decodeImage(A, e) {
    return this.eof ? this.buffer : (A || (A = this.bytes), this.buffer = Or.decode(A, e), this.bufferLength = this.buffer.length, this.eof = !0, this.buffer);
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class lc extends Dt {
  constructor(A, e, i) {
    super(e), this.str = A, this.dict = A.dict, this.cachedData = 0, this.bitsCached = 0;
    const a = 4096, s = { earlyChange: i, codeLength: 9, nextCode: 258, dictionaryValues: new Uint8Array(a), dictionaryLengths: new Uint16Array(a), dictionaryPrevCodes: new Uint16Array(a), currentSequence: new Uint8Array(a), currentSequenceLength: 0 };
    for (let r = 0; r < 256; ++r)
      s.dictionaryValues[r] = r, s.dictionaryLengths[r] = 1;
    this.lzwState = s;
  }
  readBits(A) {
    let e = this.bitsCached, i = this.cachedData;
    for (; e < A; ) {
      const a = this.str.getByte();
      if (a === -1)
        return this.eof = !0, null;
      i = i << 8 | a, e += 8;
    }
    return this.bitsCached = e -= A, this.cachedData = i, this.lastCode = null, i >>> e & (1 << A) - 1;
  }
  readBlock() {
    let A, e, i, a = 1024;
    const s = this.lzwState;
    if (!s) return;
    const r = s.earlyChange;
    let n = s.nextCode;
    const g = s.dictionaryValues, o = s.dictionaryLengths, I = s.dictionaryPrevCodes;
    let C = s.codeLength, h = s.prevCode;
    const c = s.currentSequence;
    let B = s.currentSequenceLength, l = 0, Q = this.bufferLength, E = this.ensureBuffer(this.bufferLength + a);
    for (A = 0; A < 512; A++) {
      const u = this.readBits(C), f = B > 0;
      if (u < 256)
        c[0] = u, B = 1;
      else {
        if (!(u >= 258)) {
          if (u === 256) {
            C = 9, n = 258, B = 0;
            continue;
          }
          this.eof = !0, delete this.lzwState;
          break;
        }
        if (u < n)
          for (B = o[u], e = B - 1, i = u; e >= 0; e--)
            c[e] = g[i], i = I[i];
        else c[B++] = c[0];
      }
      if (f && (I[n] = h, o[n] = o[h] + 1, g[n] = c[0], n++, C = n + r & n + r - 1 ? C : 0 | Math.min(Math.log(n + r) / 0.6931471805599453 + 1, 12)), h = u, l += B, a < l) {
        do
          a += 512;
        while (a < l);
        E = this.ensureBuffer(this.bufferLength + a);
      }
      for (e = 0; e < B; e++) E[Q++] = c[e];
    }
    s.nextCode = n, s.codeLength = C, s.prevCode = h, s.currentSequenceLength = B, this.bufferLength = Q;
  }
}
class Qc extends Dt {
  constructor(A, e, i) {
    if (super(e), !(i instanceof U)) return A;
    const a = this.predictor = i.get("Predictor") || 1;
    if (a <= 1) return A;
    if (a !== 2 && (a < 10 || a > 15)) throw new X(`Unsupported predictor: ${a}`);
    this.readBlock = a === 2 ? this.readBlockTiff : this.readBlockPng, this.str = A, this.dict = A.dict;
    const s = this.colors = i.get("Colors") || 1, r = this.bits = i.get("BPC", "BitsPerComponent") || 8, n = this.columns = i.get("Columns") || 1;
    return this.pixBytes = s * r + 7 >> 3, this.rowBytes = n * s * r + 7 >> 3, this;
  }
  readBlockTiff() {
    const A = this.rowBytes, e = this.bufferLength, i = this.ensureBuffer(e + A), a = this.bits, s = this.colors, r = this.str.getBytes(A);
    if (this.eof = !r.length, this.eof) return;
    let n, g = 0, o = 0, I = 0, C = 0, h = e;
    if (a === 1 && s === 1) for (n = 0; n < A; ++n) {
      let c = r[n] ^ g;
      c ^= c >> 1, c ^= c >> 2, c ^= c >> 4, g = (1 & c) << 7, i[h++] = c;
    }
    else if (a === 8) {
      for (n = 0; n < s; ++n) i[h++] = r[n];
      for (; n < A; ++n)
        i[h] = i[h - s] + r[n], h++;
    } else if (a === 16) {
      const c = 2 * s;
      for (n = 0; n < c; ++n) i[h++] = r[n];
      for (; n < A; n += 2) {
        const B = ((255 & r[n]) << 8) + (255 & r[n + 1]) + ((255 & i[h - c]) << 8) + (255 & i[h - c + 1]);
        i[h++] = B >> 8 & 255, i[h++] = 255 & B;
      }
    } else {
      const c = new Uint8Array(s + 1), B = (1 << a) - 1;
      let l = 0, Q = e;
      const E = this.columns;
      for (n = 0; n < E; ++n) for (let u = 0; u < s; ++u)
        I < a && (g = g << 8 | 255 & r[l++], I += 8), c[u] = c[u] + (g >> I - a) & B, I -= a, o = o << a | c[u], C += a, C >= 8 && (i[Q++] = o >> C - 8 & 255, C -= 8);
      C > 0 && (i[Q++] = (o << 8 - C) + (g & (1 << 8 - C) - 1));
    }
    this.bufferLength += A;
  }
  readBlockPng() {
    const A = this.rowBytes, e = this.pixBytes, i = this.str.getByte(), a = this.str.getBytes(A);
    if (this.eof = !a.length, this.eof) return;
    const s = this.bufferLength, r = this.ensureBuffer(s + A);
    let n = r.subarray(s - A, s);
    n.length === 0 && (n = new Uint8Array(A));
    let g, o, I, C = s;
    switch (i) {
      case 0:
        for (g = 0; g < A; ++g) r[C++] = a[g];
        break;
      case 1:
        for (g = 0; g < e; ++g) r[C++] = a[g];
        for (; g < A; ++g)
          r[C] = r[C - e] + a[g] & 255, C++;
        break;
      case 2:
        for (g = 0; g < A; ++g) r[C++] = n[g] + a[g] & 255;
        break;
      case 3:
        for (g = 0; g < e; ++g) r[C++] = (n[g] >> 1) + a[g];
        for (; g < A; ++g)
          r[C] = (n[g] + r[C - e] >> 1) + a[g] & 255, C++;
        break;
      case 4:
        for (g = 0; g < e; ++g)
          o = n[g], I = a[g], r[C++] = o + I;
        for (; g < A; ++g) {
          o = n[g];
          const h = n[g - e], c = r[C - e], B = c + o - h;
          let l = B - c;
          l < 0 && (l = -l);
          let Q = B - o;
          Q < 0 && (Q = -Q);
          let E = B - h;
          E < 0 && (E = -E), I = a[g], r[C++] = l <= Q && l <= E ? c + I : Q <= E ? o + I : h + I;
        }
        break;
      default:
        throw new X(`Unsupported predictor: ${i}`);
    }
    this.bufferLength += A;
  }
}
class ql extends Dt {
  constructor(A, e) {
    super(e), this.str = A, this.dict = A.dict;
  }
  readBlock() {
    const A = this.str.getBytes(2);
    if (!A || A.length < 2 || A[0] === 128) {
      this.eof = !0;
      return;
    }
    let e, i = this.bufferLength, a = A[0];
    if (a < 128) {
      if (e = this.ensureBuffer(i + a + 1), e[i++] = A[1], a > 0) {
        const s = this.str.getBytes(a);
        e.set(s, i), i += a;
      }
    } else {
      a = 257 - a;
      const s = A[1];
      e = this.ensureBuffer(i + a + 1);
      for (let r = 0; r < a; r++) e[i++] = s;
    }
    this.bufferLength = i;
  }
}
var Jr, U1;
class ti {
  constructor({ lexer: A, xref: e, allowStreams: i = !1, recoveryMode: a = !1 }) {
    MA(this, Jr);
    this.lexer = A, this.xref = e, this.allowStreams = i, this.recoveryMode = a, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
  }
  shift() {
    this.buf2 instanceof ot && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
  }
  tryShift() {
    try {
      return this.shift(), !0;
    } catch (A) {
      if (A instanceof OA) throw A;
      return !1;
    }
  }
  getObj(A = null) {
    const e = this.buf1;
    if (this.shift(), e instanceof ot) switch (e.cmd) {
      case "BI":
        return this.makeInlineImage(A);
      case "[":
        const i = [];
        for (; !ht(this.buf1, "]") && this.buf1 !== lt; ) i.push(this.getObj(A));
        if (this.buf1 === lt) {
          if (this.recoveryMode) return i;
          throw new jg("End of file inside array.");
        }
        return this.shift(), i;
      case "<<":
        const a = new U(this.xref);
        for (; !ht(this.buf1, ">>") && this.buf1 !== lt; ) {
          if (!(this.buf1 instanceof T)) {
            RA("Malformed dictionary: key must be a name object"), this.shift();
            continue;
          }
          const s = this.buf1.name;
          if (this.shift(), this.buf1 === lt) break;
          a.set(s, this.getObj(A));
        }
        if (this.buf1 === lt) {
          if (this.recoveryMode) return a;
          throw new jg("End of file inside dictionary.");
        }
        return ht(this.buf2, "stream") ? this.allowStreams ? this.makeStream(a, A) : a : (this.shift(), a);
      default:
        return e;
    }
    if (Number.isInteger(e)) {
      if (Number.isInteger(this.buf1) && ht(this.buf2, "R")) {
        const i = rA.get(e, this.buf1);
        return this.shift(), this.shift(), i;
      }
      return e;
    }
    return typeof e == "string" && A ? A.decryptString(e) : e;
  }
  findDefaultInlineStreamEnd(A) {
    const { knownCommands: e } = this.lexer, i = A.pos;
    let a, s, r = 0;
    for (; (a = A.getByte()) !== -1; ) if (r === 0) r = a === 69 ? 1 : 0;
    else if (r === 1) r = a === 73 ? 2 : 0;
    else if (a === 32 || a === 10 || a === 13) {
      s = A.pos;
      const g = A.peekBytes(15), o = g.length;
      if (o === 0) break;
      for (let h = 0; h < o; h++)
        if (a = g[h], (a !== 0 || g[h + 1] === 0) && a !== 10 && a !== 13 && (a < 32 || a > 127)) {
          r = 0;
          break;
        }
      if (r !== 2) continue;
      if (!e) {
        G("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
        continue;
      }
      const I = new Ce(new At(g.slice()), e);
      I._hexStringWarn = () => {
      };
      let C = 0;
      for (; ; ) {
        const h = I.getObj();
        if (h === lt) {
          r = 0;
          break;
        }
        if (h instanceof ot) {
          const c = e[h.cmd];
          if (!c) {
            r = 0;
            break;
          }
          if (c.variableArgs ? C <= c.numArgs : C === c.numArgs) break;
          C = 0;
        } else C++;
      }
      if (r === 2) break;
    } else r = 0;
    a === -1 && (G("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), s && (G('... trying to recover by using the last "EI" occurrence.'), A.skip(-(A.pos - s))));
    let n = 4;
    return A.skip(-n), a = A.peekByte(), A.skip(n), Zt(a) || n--, A.pos - n - i;
  }
  findDCTDecodeInlineStreamEnd(A) {
    const e = A.pos;
    let i, a, s = !1;
    for (; (i = A.getByte()) !== -1; ) if (i === 255) {
      switch (A.getByte()) {
        case 0:
          break;
        case 255:
          A.skip(-1);
          break;
        case 217:
          s = !0;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 197:
        case 198:
        case 199:
        case 201:
        case 202:
        case 203:
        case 205:
        case 206:
        case 207:
        case 196:
        case 204:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
        case 254:
          a = A.getUint16(), a > 2 ? A.skip(a - 2) : A.skip(-2);
      }
      if (s) break;
    }
    const r = A.pos - e;
    return i === -1 ? (G("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), A.skip(-r), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), r);
  }
  findASCII85DecodeInlineStreamEnd(A) {
    const e = A.pos;
    let i;
    for (; (i = A.getByte()) !== -1; ) if (i === 126) {
      const s = A.pos;
      for (i = A.peekByte(); Zt(i); )
        A.skip(), i = A.peekByte();
      if (i === 62) {
        A.skip();
        break;
      }
      if (A.pos > s) {
        const r = A.peekBytes(2);
        if (r[0] === 69 && r[1] === 73) break;
      }
    }
    const a = A.pos - e;
    return i === -1 ? (G("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), A.skip(-a), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), a);
  }
  findASCIIHexDecodeInlineStreamEnd(A) {
    const e = A.pos;
    let i;
    for (; (i = A.getByte()) !== -1 && i !== 62; ) ;
    const a = A.pos - e;
    return i === -1 ? (G("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), A.skip(-a), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), a);
  }
  inlineStreamSkipEI(A) {
    let e, i = 0;
    for (; (e = A.getByte()) !== -1; ) if (i === 0) i = e === 69 ? 1 : 0;
    else if (i === 1) i = e === 73 ? 2 : 0;
    else if (i === 2) break;
  }
  makeInlineImage(A) {
    const e = this.lexer, i = e.stream, a = /* @__PURE__ */ Object.create(null);
    let s;
    for (; !ht(this.buf1, "ID") && this.buf1 !== lt; ) {
      if (!(this.buf1 instanceof T)) throw new X("Dictionary key must be a name object");
      const c = this.buf1.name;
      if (this.shift(), this.buf1 === lt) break;
      a[c] = this.getObj(A);
    }
    e.beginInlineImagePos !== -1 && (s = i.pos - e.beginInlineImagePos);
    const r = this.xref.fetchIfRef(a.F || a.Filter);
    let n;
    if (r instanceof T) n = r.name;
    else if (Array.isArray(r)) {
      const c = this.xref.fetchIfRef(r[0]);
      c instanceof T && (n = c.name);
    }
    const g = i.pos;
    let o, I;
    switch (n) {
      case "DCT":
      case "DCTDecode":
        o = this.findDCTDecodeInlineStreamEnd(i);
        break;
      case "A85":
      case "ASCII85Decode":
        o = this.findASCII85DecodeInlineStreamEnd(i);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        o = this.findASCIIHexDecodeInlineStreamEnd(i);
        break;
      default:
        o = this.findDefaultInlineStreamEnd(i);
    }
    if (o < 1e3 && s > 0) {
      const c = i.pos;
      i.pos = e.beginInlineImagePos, I = function(Q) {
        const E = [], u = Q.length;
        let f = 0;
        for (; f < u - 1; ) E.push(Q[f++] << 8 | Q[f++]);
        return f < u && E.push(Q[f]), u + "_" + String.fromCharCode.apply(null, E);
      }(i.getBytes(s + o)), i.pos = c;
      const B = this.imageCache[I];
      if (B !== void 0)
        return this.buf2 = ot.get("EI"), this.shift(), B.reset(), B;
    }
    const C = new U(this.xref);
    for (const c in a) C.set(c, a[c]);
    let h = i.makeSubStream(g, o, C);
    return A && (h = A.createStream(h, o)), h = this.filter(h, C, o), h.dict = C, I !== void 0 && (h.cacheKey = "inline_img_" + ++this._imageId, this.imageCache[I] = h), this.buf2 = ot.get("EI"), this.shift(), h;
  }
  makeStream(A, e) {
    const i = this.lexer;
    let a = i.stream;
    i.skipToNextLine();
    const s = a.pos - 1;
    let r = A.get("Length");
    if (Number.isInteger(r) || (RA(`Bad length "${r && r.toString()}" in stream.`), r = 0), a.pos = s + r, i.nextChar(), this.tryShift() && ht(this.buf2, "endstream")) this.shift();
    else {
      if (r = CA(this, Jr, U1).call(this, s), r < 0) throw new X("Missing endstream command.");
      i.nextChar(), this.shift(), this.shift();
    }
    return this.shift(), a = a.makeSubStream(s, r, A), e && (a = e.createStream(a, r)), a = this.filter(a, A, r), a.dict = A, a;
  }
  filter(A, e, i) {
    let a = e.get("F", "Filter"), s = e.get("DP", "DecodeParms");
    if (a instanceof T)
      return Array.isArray(s) && G("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(A, a.name, i, s);
    let r = i;
    if (Array.isArray(a)) {
      const n = a, g = s;
      for (let o = 0, I = n.length; o < I; ++o) {
        if (a = this.xref.fetchIfRef(n[o]), !(a instanceof T)) throw new X(`Bad filter name "${a}"`);
        s = null, Array.isArray(g) && o in g && (s = this.xref.fetchIfRef(g[o])), A = this.makeFilter(A, a.name, r, s), r = null;
      }
    }
    return A;
  }
  makeFilter(A, e, i, a) {
    if (i === 0)
      return G(`Empty "${e}" stream.`), new $g();
    try {
      switch (e) {
        case "Fl":
        case "FlateDecode":
          return a ? new Qc(new gc(A, i), i, a) : new gc(A, i);
        case "LZW":
        case "LZWDecode":
          let s = 1;
          return a ? (a.has("EarlyChange") && (s = a.get("EarlyChange")), new Qc(new lc(A, i, s), i, a)) : new lc(A, i, s);
        case "DCT":
        case "DCTDecode":
          return new Na(A, i, a);
        case "JPX":
        case "JPXDecode":
          return new Kl(A, i, a);
        case "A85":
        case "ASCII85Decode":
          return new cl(A, i);
        case "AHx":
        case "ASCIIHexDecode":
          return new Cl(A, i);
        case "CCF":
        case "CCITTFaxDecode":
          return new hl(A, i, a);
        case "RL":
        case "RunLengthDecode":
          return new ql(A, i);
        case "JBIG2Decode":
          return new Gl(A, i, a);
      }
      return G(`Filter "${e}" is not supported.`), A;
    } catch (s) {
      if (s instanceof OA) throw s;
      return G(`Invalid stream: "${s}"`), new $g();
    }
  }
}
Jr = new WeakSet(), U1 = function(A) {
  const { stream: e } = this.lexer;
  e.pos = A;
  const i = new Uint8Array([101, 110, 100]), a = i.length, s = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], r = 9 - a;
  for (; e.pos < e.end; ) {
    const n = e.peekBytes(2048), g = n.length - 9;
    if (g <= 0) break;
    let o = 0;
    for (; o < g; ) {
      let I = 0;
      for (; I < a && n[o + I] === i[I]; ) I++;
      if (I >= a) {
        let C = !1;
        for (const h of s) {
          const c = h.length;
          let B = 0;
          for (; B < c && n[o + I + B] === h[B]; ) B++;
          if (B >= r) {
            C = !0;
            break;
          }
          if (B >= c) {
            Zt(n[o + I + B]) && (RA(`Found "${Mt([...i, ...h])}" when searching for endstream command.`), C = !0);
            break;
          }
        }
        if (C)
          return e.pos += o, e.pos - A;
      }
      o++;
    }
    e.pos += g;
  }
  return -1;
};
const _i = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function Bg(t) {
  return t >= 48 && t <= 57 ? 15 & t : t >= 65 && t <= 70 || t >= 97 && t <= 102 ? 9 + (15 & t) : -1;
}
class Ce {
  constructor(A, e = null) {
    this.stream = A, this.nextChar(), this.strBuf = [], this.knownCommands = e, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let A = this.currentChar, e = !1, i = 0, a = 1;
    if (A === 45 ? (a = -1, A = this.nextChar(), A === 45 && (A = this.nextChar())) : A === 43 && (A = this.nextChar()), A === 10 || A === 13) do
      A = this.nextChar();
    while (A === 10 || A === 13);
    if (A === 46 && (i = 10, A = this.nextChar()), A < 48 || A > 57) {
      const g = `Invalid number: ${String.fromCharCode(A)} (charCode ${A})`;
      if (Zt(A) || A === -1)
        return RA(`Lexer.getNumber - "${g}".`), 0;
      throw new X(g);
    }
    let s = A - 48, r = 0, n = 1;
    for (; (A = this.nextChar()) >= 0; ) if (A >= 48 && A <= 57) {
      const g = A - 48;
      e ? r = 10 * r + g : (i !== 0 && (i *= 10), s = 10 * s + g);
    } else if (A === 46) {
      if (i !== 0) break;
      i = 1;
    } else if (A === 45) G("Badly formatted number: minus sign in the middle");
    else {
      if (A !== 69 && A !== 101) break;
      if (A = this.peekChar(), A === 43 || A === 45)
        n = A === 45 ? -1 : 1, this.nextChar();
      else if (A < 48 || A > 57) break;
      e = !0;
    }
    return i !== 0 && (s /= i), e && (s *= 10 ** (n * r)), a * s;
  }
  getString() {
    let A = 1, e = !1;
    const i = this.strBuf;
    i.length = 0;
    let a = this.nextChar();
    for (; ; ) {
      let s = !1;
      switch (0 | a) {
        case -1:
          G("Unterminated string"), e = !0;
          break;
        case 40:
          ++A, i.push("(");
          break;
        case 41:
          --A == 0 ? (this.nextChar(), e = !0) : i.push(")");
          break;
        case 92:
          switch (a = this.nextChar(), a) {
            case -1:
              G("Unterminated string"), e = !0;
              break;
            case 110:
              i.push(`
`);
              break;
            case 114:
              i.push("\r");
              break;
            case 116:
              i.push("	");
              break;
            case 98:
              i.push("\b");
              break;
            case 102:
              i.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              i.push(String.fromCharCode(a));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let r = 15 & a;
              a = this.nextChar(), s = !0, a >= 48 && a <= 55 && (r = (r << 3) + (15 & a), a = this.nextChar(), a >= 48 && a <= 55 && (s = !1, r = (r << 3) + (15 & a))), i.push(String.fromCharCode(r));
              break;
            case 13:
              this.peekChar() === 10 && this.nextChar();
              break;
            case 10:
              break;
            default:
              i.push(String.fromCharCode(a));
          }
          break;
        default:
          i.push(String.fromCharCode(a));
      }
      if (e) break;
      s || (a = this.nextChar());
    }
    return i.join("");
  }
  getName() {
    let A, e;
    const i = this.strBuf;
    for (i.length = 0; (A = this.nextChar()) >= 0 && !_i[A]; ) if (A === 35) {
      if (A = this.nextChar(), _i[A]) {
        G("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i.push("#");
        break;
      }
      const a = Bg(A);
      if (a !== -1) {
        e = A, A = this.nextChar();
        const s = Bg(A);
        if (s === -1) {
          if (G(`Lexer_getName: Illegal digit (${String.fromCharCode(A)}) in hexadecimal number.`), i.push("#", String.fromCharCode(e)), _i[A]) break;
          i.push(String.fromCharCode(A));
          continue;
        }
        i.push(String.fromCharCode(a << 4 | s));
      } else i.push("#", String.fromCharCode(A));
    } else i.push(String.fromCharCode(A));
    return i.length > 127 && G(`Name token is longer than allowed by the spec: ${i.length}`), T.get(i.join(""));
  }
  _hexStringWarn(A) {
    this._hexStringNumWarn++ != 5 ? this._hexStringNumWarn > 5 || G(`getHexString - ignoring invalid character: ${A}`) : G("getHexString - ignoring additional invalid characters.");
  }
  getHexString() {
    const A = this.strBuf;
    A.length = 0;
    let e = this.currentChar, i = -1, a = -1;
    for (this._hexStringNumWarn = 0; ; ) {
      if (e < 0) {
        G("Unterminated hex string");
        break;
      }
      if (e === 62) {
        this.nextChar();
        break;
      }
      _i[e] !== 1 ? (a = Bg(e), a === -1 ? this._hexStringWarn(e) : i === -1 ? i = a : (A.push(String.fromCharCode(i << 4 | a)), i = -1), e = this.nextChar()) : e = this.nextChar();
    }
    return i !== -1 && A.push(String.fromCharCode(i << 4)), A.join("");
  }
  getObj() {
    let A = !1, e = this.currentChar;
    for (; ; ) {
      if (e < 0) return lt;
      if (A) e !== 10 && e !== 13 || (A = !1);
      else if (e === 37) A = !0;
      else if (_i[e] !== 1) break;
      e = this.nextChar();
    }
    switch (0 | e) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        return this.nextChar(), ot.get("[");
      case 93:
        return this.nextChar(), ot.get("]");
      case 60:
        return e = this.nextChar(), e === 60 ? (this.nextChar(), ot.get("<<")) : this.getHexString();
      case 62:
        return e = this.nextChar(), e === 62 ? (this.nextChar(), ot.get(">>")) : ot.get(">");
      case 123:
        return this.nextChar(), ot.get("{");
      case 125:
        return this.nextChar(), ot.get("}");
      case 41:
        throw this.nextChar(), new X(`Illegal character: ${e}`);
    }
    let i = String.fromCharCode(e);
    if (e < 32 || e > 127) {
      const r = this.peekChar();
      if (r >= 32 && r <= 127)
        return this.nextChar(), ot.get(i);
    }
    const a = this.knownCommands;
    let s = (a == null ? void 0 : a[i]) !== void 0;
    for (; (e = this.nextChar()) >= 0 && !_i[e]; ) {
      const r = i + String.fromCharCode(e);
      if (s && a[r] === void 0) break;
      if (i.length === 128) throw new X(`Command token too long: ${i.length}`);
      i = r, s = (a == null ? void 0 : a[i]) !== void 0;
    }
    return i === "true" ? !0 : i === "false" ? !1 : i === "null" ? null : (i === "BI" && (this.beginInlineImagePos = this.stream.pos), ot.get(i));
  }
  skipToNextLine() {
    let A = this.currentChar;
    for (; A >= 0; ) {
      if (A === 13) {
        A = this.nextChar(), A === 10 && this.nextChar();
        break;
      }
      if (A === 10) {
        this.nextChar();
        break;
      }
      A = this.nextChar();
    }
  }
}
class Tl {
  static create(A) {
    function e(I, C, h = !1) {
      const c = I.get(C);
      if (Number.isInteger(c) && (h ? c >= 0 : c > 0)) return c;
      throw new Error(`The "${C}" parameter in the linearization dictionary is invalid.`);
    }
    const i = new ti({ lexer: new Ce(A), xref: null }), a = i.getObj(), s = i.getObj(), r = i.getObj(), n = i.getObj();
    let g, o;
    if (!(Number.isInteger(a) && Number.isInteger(s) && ht(r, "obj") && n instanceof U && typeof (g = n.get("Linearized")) == "number" && g > 0)) return null;
    if ((o = e(n, "L")) !== A.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    return { length: o, hints: function(C) {
      const h = C.get("H");
      let c;
      if (Array.isArray(h) && ((c = h.length) === 2 || c === 4)) {
        for (let B = 0; B < c; B++) {
          const l = h[B];
          if (!(Number.isInteger(l) && l > 0)) throw new Error(`Hint (${B}) in the linearization dictionary is invalid.`);
        }
        return h;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }(n), objectNumberFirst: e(n, "O"), endFirst: e(n, "E"), numPages: e(n, "N"), mainXRefEntriesOffset: e(n, "T"), pageFirst: n.has("P") ? e(n, "P", !0) : 0 };
  }
}
const Pl = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], lg = 2 ** 24 - 1;
class _o {
  constructor(A = !1) {
    this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = A;
  }
  addCodespaceRange(A, e, i) {
    this.codespaceRanges[A - 1].push(e, i), this.numCodespaceRanges++;
  }
  mapCidRange(A, e, i) {
    if (e - A > lg) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; A <= e; ) this._map[A++] = i++;
  }
  mapBfRange(A, e, i) {
    if (e - A > lg) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const a = i.length - 1;
    for (; A <= e; ) {
      this._map[A++] = i;
      const s = i.charCodeAt(a) + 1;
      s > 255 ? i = i.substring(0, a - 1) + String.fromCharCode(i.charCodeAt(a - 1) + 1) + "\0" : i = i.substring(0, a) + String.fromCharCode(s);
    }
  }
  mapBfRangeToArray(A, e, i) {
    if (e - A > lg) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const a = i.length;
    let s = 0;
    for (; A <= e && s < a; )
      this._map[A] = i[s++], ++A;
  }
  mapOne(A, e) {
    this._map[A] = e;
  }
  lookup(A) {
    return this._map[A];
  }
  contains(A) {
    return this._map[A] !== void 0;
  }
  forEach(A) {
    const e = this._map, i = e.length;
    if (i <= 65536) for (let a = 0; a < i; a++) e[a] !== void 0 && A(a, e[a]);
    else for (const a in e) A(a, e[a]);
  }
  charCodeOf(A) {
    const e = this._map;
    if (e.length <= 65536) return e.indexOf(A);
    for (const i in e) if (e[i] === A) return 0 | i;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(A, e, i) {
    let a = 0;
    const s = this.codespaceRanges;
    for (let r = 0, n = s.length; r < n; r++) {
      a = (a << 8 | A.charCodeAt(e + r)) >>> 0;
      const g = s[r];
      for (let o = 0, I = g.length; o < I; ) {
        const C = g[o++], h = g[o++];
        if (a >= C && a <= h) {
          i.charcode = a, i.length = r + 1;
          return;
        }
      }
    }
    i.charcode = 0, i.length = 1;
  }
  getCharCodeLength(A) {
    const e = this.codespaceRanges;
    for (let i = 0, a = e.length; i < a; i++) {
      const s = e[i];
      for (let r = 0, n = s.length; r < n; ) {
        const g = s[r++], o = s[r++];
        if (A >= g && A <= o) return i + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (this.name !== "Identity-H" && this.name !== "Identity-V" || this._map.length !== 65536) return !1;
    for (let A = 0; A < 65536; A++) if (this._map[A] !== A) return !1;
    return !0;
  }
}
class ma extends _o {
  constructor(A, e) {
    super(), this.vertical = A, this.addCodespaceRange(e, 0, 65535);
  }
  mapCidRange(A, e, i) {
    xA("should not call mapCidRange");
  }
  mapBfRange(A, e, i) {
    xA("should not call mapBfRange");
  }
  mapBfRangeToArray(A, e, i) {
    xA("should not call mapBfRangeToArray");
  }
  mapOne(A, e) {
    xA("should not call mapCidOne");
  }
  lookup(A) {
    return Number.isInteger(A) && A <= 65535 ? A : void 0;
  }
  contains(A) {
    return Number.isInteger(A) && A <= 65535;
  }
  forEach(A) {
    for (let e = 0; e <= 65535; e++) A(e, e);
  }
  charCodeOf(A) {
    return Number.isInteger(A) && A <= 65535 ? A : -1;
  }
  getMap() {
    const A = new Array(65536);
    for (let e = 0; e <= 65535; e++) A[e] = e;
    return A;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    xA("should not access .isIdentityCMap");
  }
}
function Ei(t) {
  let A = 0;
  for (let e = 0; e < t.length; e++) A = A << 8 | t.charCodeAt(e);
  return A >>> 0;
}
function Wi(t) {
  if (typeof t != "string") throw new X("Malformed CMap: expected string.");
}
function M1(t) {
  if (!Number.isInteger(t)) throw new X("Malformed CMap: expected int.");
}
function Wl(t, A) {
  for (; ; ) {
    let e = A.getObj();
    if (e === lt) break;
    if (ht(e, "endbfchar")) return;
    Wi(e);
    const i = Ei(e);
    e = A.getObj(), Wi(e);
    const a = e;
    t.mapOne(i, a);
  }
}
function Zl(t, A) {
  for (; ; ) {
    let e = A.getObj();
    if (e === lt) break;
    if (ht(e, "endbfrange")) return;
    Wi(e);
    const i = Ei(e);
    e = A.getObj(), Wi(e);
    const a = Ei(e);
    if (e = A.getObj(), Number.isInteger(e) || typeof e == "string") {
      const s = Number.isInteger(e) ? String.fromCharCode(e) : e;
      t.mapBfRange(i, a, s);
    } else {
      if (!ht(e, "[")) break;
      {
        e = A.getObj();
        const s = [];
        for (; !ht(e, "]") && e !== lt; )
          s.push(e), e = A.getObj();
        t.mapBfRangeToArray(i, a, s);
      }
    }
  }
  throw new X("Invalid bf range.");
}
function Ol(t, A) {
  for (; ; ) {
    let e = A.getObj();
    if (e === lt) break;
    if (ht(e, "endcidchar")) return;
    Wi(e);
    const i = Ei(e);
    e = A.getObj(), M1(e);
    const a = e;
    t.mapOne(i, a);
  }
}
function Xl(t, A) {
  for (; ; ) {
    let e = A.getObj();
    if (e === lt) break;
    if (ht(e, "endcidrange")) return;
    Wi(e);
    const i = Ei(e);
    e = A.getObj(), Wi(e);
    const a = Ei(e);
    e = A.getObj(), M1(e);
    const s = e;
    t.mapCidRange(i, a, s);
  }
}
function Vl(t, A) {
  for (; ; ) {
    let e = A.getObj();
    if (e === lt) break;
    if (ht(e, "endcodespacerange")) return;
    if (typeof e != "string") break;
    const i = Ei(e);
    if (e = A.getObj(), typeof e != "string") break;
    const a = Ei(e);
    t.addCodespaceRange(e.length, i, a);
  }
  throw new X("Invalid codespace range.");
}
function jl(t, A) {
  const e = A.getObj();
  Number.isInteger(e) && (t.vertical = !!e);
}
function zl(t, A) {
  const e = A.getObj();
  e instanceof T && (t.name = e.name);
}
async function L1(t, A, e, i) {
  let a, s;
  A: for (; ; ) try {
    const r = A.getObj();
    if (r === lt) break;
    if (r instanceof T)
      r.name === "WMode" ? jl(t, A) : r.name === "CMapName" && zl(t, A), a = r;
    else if (r instanceof ot) switch (r.cmd) {
      case "endcmap":
        break A;
      case "usecmap":
        a instanceof T && (s = a.name);
        break;
      case "begincodespacerange":
        Vl(t, A);
        break;
      case "beginbfchar":
        Wl(t, A);
        break;
      case "begincidchar":
        Ol(t, A);
        break;
      case "beginbfrange":
        Zl(t, A);
        break;
      case "begincidrange":
        Xl(t, A);
    }
  } catch (r) {
    if (r instanceof OA) throw r;
    G("Invalid cMap data: " + r);
    continue;
  }
  return !i && s && (i = s), i ? J1(t, e, i) : t;
}
async function J1(t, A, e) {
  if (t.useCMap = await Io(e, A), t.numCodespaceRanges === 0) {
    const i = t.useCMap.codespaceRanges;
    for (let a = 0; a < i.length; a++) t.codespaceRanges[a] = i[a].slice();
    t.numCodespaceRanges = t.useCMap.numCodespaceRanges;
  }
  return t.useCMap.forEach(function(i, a) {
    t.contains(i) || t.mapOne(i, a);
  }), t;
}
async function Io(t, A) {
  if (t === "Identity-H") return new ma(!1, 2);
  if (t === "Identity-V") return new ma(!0, 2);
  if (!Pl.includes(t)) throw new Error("Unknown CMap name: " + t);
  if (!A) throw new Error("Built-in CMap parameters are not provided.");
  const { cMapData: e, isCompressed: i } = await A(t), a = new _o(!0);
  if (i) return new gl().process(e, a, (r) => J1(a, A, r));
  const s = new Ce(new At(e));
  return L1(a, s, A, null);
}
class mn {
  static async create({ encoding: A, fetchBuiltInCMap: e, useCMap: i }) {
    if (A instanceof T) return Io(A.name, e);
    if (A instanceof FA) {
      const a = await L1(new _o(), new Ce(A), e, i);
      return a.isIdentityCMap ? Io(a.name, e) : a;
    }
    throw new Error("Encoding required.");
  }
}
const _l = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], $l = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], AQ = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"], H1 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], tQ = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], $o = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"], ve = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""], Ds = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"], AI = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""], tI = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function bs(t) {
  switch (t) {
    case "WinAnsiEncoding":
      return Ds;
    case "StandardEncoding":
      return ve;
    case "MacRomanEncoding":
      return $o;
    case "SymbolSetEncoding":
      return AI;
    case "ZapfDingbatsEncoding":
      return tI;
    case "ExpertEncoding":
      return H1;
    case "MacExpertEncoding":
      return tQ;
    default:
      return null;
  }
}
const Zn = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], Qg = 391, $i = [null, { id: "hstem", min: 2, stackClearing: !0, stem: !0 }, null, { id: "vstem", min: 2, stackClearing: !0, stem: !0 }, { id: "vmoveto", min: 1, stackClearing: !0 }, { id: "rlineto", min: 2, resetStack: !0 }, { id: "hlineto", min: 1, resetStack: !0 }, { id: "vlineto", min: 1, resetStack: !0 }, { id: "rrcurveto", min: 6, resetStack: !0 }, null, { id: "callsubr", min: 1, undefStack: !0 }, { id: "return", min: 0, undefStack: !0 }, null, null, { id: "endchar", min: 0, stackClearing: !0 }, null, null, null, { id: "hstemhm", min: 2, stackClearing: !0, stem: !0 }, { id: "hintmask", min: 0, stackClearing: !0 }, { id: "cntrmask", min: 0, stackClearing: !0 }, { id: "rmoveto", min: 2, stackClearing: !0 }, { id: "hmoveto", min: 1, stackClearing: !0 }, { id: "vstemhm", min: 2, stackClearing: !0, stem: !0 }, { id: "rcurveline", min: 8, resetStack: !0 }, { id: "rlinecurve", min: 8, resetStack: !0 }, { id: "vvcurveto", min: 4, resetStack: !0 }, { id: "hhcurveto", min: 4, resetStack: !0 }, null, { id: "callgsubr", min: 1, undefStack: !0 }, { id: "vhcurveto", min: 4, resetStack: !0 }, { id: "hvcurveto", min: 4, resetStack: !0 }], eQ = [null, null, null, { id: "and", min: 2, stackDelta: -1 }, { id: "or", min: 2, stackDelta: -1 }, { id: "not", min: 1, stackDelta: 0 }, null, null, null, { id: "abs", min: 1, stackDelta: 0 }, { id: "add", min: 2, stackDelta: -1, stackFn(t, A) {
  t[A - 2] = t[A - 2] + t[A - 1];
} }, { id: "sub", min: 2, stackDelta: -1, stackFn(t, A) {
  t[A - 2] = t[A - 2] - t[A - 1];
} }, { id: "div", min: 2, stackDelta: -1, stackFn(t, A) {
  t[A - 2] = t[A - 2] / t[A - 1];
} }, null, { id: "neg", min: 1, stackDelta: 0, stackFn(t, A) {
  t[A - 1] = -t[A - 1];
} }, { id: "eq", min: 2, stackDelta: -1 }, null, null, { id: "drop", min: 1, stackDelta: -1 }, null, { id: "put", min: 2, stackDelta: -2 }, { id: "get", min: 1, stackDelta: 0 }, { id: "ifelse", min: 4, stackDelta: -3 }, { id: "random", min: 0, stackDelta: 1 }, { id: "mul", min: 2, stackDelta: -1, stackFn(t, A) {
  t[A - 2] = t[A - 2] * t[A - 1];
} }, null, { id: "sqrt", min: 1, stackDelta: 0 }, { id: "dup", min: 1, stackDelta: 1 }, { id: "exch", min: 2, stackDelta: 0 }, { id: "index", min: 2, stackDelta: 0 }, { id: "roll", min: 3, stackDelta: -2 }, null, null, null, { id: "hflex", min: 7, resetStack: !0 }, { id: "flex", min: 13, resetStack: !0 }, { id: "hflex1", min: 9, resetStack: !0 }, { id: "flex1", min: 11, resetStack: !0 }];
class eI {
  constructor(A, e, i) {
    this.bytes = A.getBytes(), this.properties = e, this.seacAnalysisEnabled = !!i;
  }
  parse() {
    const A = this.properties, e = new Y1();
    this.cff = e;
    const i = this.parseHeader(), a = this.parseIndex(i.endPos), s = this.parseIndex(a.endPos), r = this.parseIndex(s.endPos), n = this.parseIndex(r.endPos), g = this.parseDict(s.obj.get(0)), o = this.createDict(ks, g, e.strings);
    e.header = i.obj, e.names = this.parseNameIndex(a.obj), e.strings = this.parseStringIndex(r.obj), e.topDict = o, e.globalSubrIndex = n.obj, this.parsePrivateDict(e.topDict), e.isCIDFont = o.hasName("ROS");
    const I = o.getByName("CharStrings"), C = this.parseIndex(I).obj, h = o.getByName("FontMatrix");
    h && (A.fontMatrix = h);
    const c = o.getByName("FontBBox");
    c && (A.ascent = Math.max(c[3], c[1]), A.descent = Math.min(c[1], c[3]), A.ascentScaled = !0);
    let B, l;
    if (e.isCIDFont) {
      const E = this.parseIndex(o.getByName("FDArray")).obj;
      for (let u = 0, f = E.count; u < f; ++u) {
        const d = E.get(u), p = this.createDict(ks, this.parseDict(d), e.strings);
        this.parsePrivateDict(p), e.fdArray.push(p);
      }
      l = null, B = this.parseCharsets(o.getByName("charset"), C.count, e.strings, !0), e.fdSelect = this.parseFDSelect(o.getByName("FDSelect"), C.count);
    } else
      B = this.parseCharsets(o.getByName("charset"), C.count, e.strings, !1), l = this.parseEncoding(o.getByName("Encoding"), A, e.strings, B.charset);
    e.charset = B, e.encoding = l;
    const Q = this.parseCharStrings({ charStrings: C, localSubrIndex: o.privateDict.subrsIndex, globalSubrIndex: n.obj, fdSelect: e.fdSelect, fdArray: e.fdArray, privateDict: o.privateDict });
    return e.charStrings = Q.charStrings, e.seacs = Q.seacs, e.widths = Q.widths, e;
  }
  parseHeader() {
    let A = this.bytes;
    const e = A.length;
    let i = 0;
    for (; i < e && A[i] !== 1; ) ++i;
    if (i >= e) throw new X("Invalid CFF header");
    i !== 0 && (RA("cff data is shifted"), A = A.subarray(i), this.bytes = A);
    const a = A[0], s = A[1], r = A[2], n = A[3];
    return { obj: new v1(a, s, r, n), endPos: r };
  }
  parseDict(A) {
    let e = 0;
    function i() {
      let n = A[e++];
      return n === 30 ? function() {
        let o = "";
        const C = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], h = A.length;
        for (; e < h; ) {
          const c = A[e++], B = c >> 4, l = 15 & c;
          if (B === 15 || (o += C[B], l === 15)) break;
          o += C[l];
        }
        return parseFloat(o);
      }() : n === 28 ? (n = A[e++], n = (n << 24 | A[e++] << 16) >> 16, n) : n === 29 ? (n = A[e++], n = n << 8 | A[e++], n = n << 8 | A[e++], n = n << 8 | A[e++], n) : n >= 32 && n <= 246 ? n - 139 : n >= 247 && n <= 250 ? 256 * (n - 247) + A[e++] + 108 : n >= 251 && n <= 254 ? -256 * (n - 251) - A[e++] - 108 : (G('CFFParser_parseDict: "' + n + '" is a reserved command.'), NaN);
    }
    let a = [];
    const s = [];
    e = 0;
    const r = A.length;
    for (; e < r; ) {
      let n = A[e];
      n <= 21 ? (n === 12 && (n = n << 8 | A[++e]), s.push([n, a]), a = [], ++e) : a.push(i());
    }
    return s;
  }
  parseIndex(A) {
    const e = new Ci(), i = this.bytes, a = i[A++] << 8 | i[A++], s = [];
    let r, n, g = A;
    if (a !== 0) {
      const o = i[A++], I = A + (a + 1) * o - 1;
      for (r = 0, n = a + 1; r < n; ++r) {
        let C = 0;
        for (let h = 0; h < o; ++h)
          C <<= 8, C += i[A++];
        s.push(I + C);
      }
      g = s[a];
    }
    for (r = 0, n = s.length - 1; r < n; ++r) {
      const o = s[r], I = s[r + 1];
      e.add(i.subarray(o, I));
    }
    return { obj: e, endPos: g };
  }
  parseNameIndex(A) {
    const e = [];
    for (let i = 0, a = A.count; i < a; ++i) {
      const s = A.get(i);
      e.push(Mt(s));
    }
    return e;
  }
  parseStringIndex(A) {
    const e = new iI();
    for (let i = 0, a = A.count; i < a; ++i) {
      const s = A.get(i);
      e.add(Mt(s));
    }
    return e;
  }
  createDict(A, e, i) {
    const a = new A(i);
    for (const [s, r] of e) a.setByKey(s, r);
    return a;
  }
  parseCharString(A, e, i, a) {
    if (!e || A.callDepth > 10) return !1;
    let s = A.stackSize;
    const r = A.stack;
    let n = e.length;
    for (let g = 0; g < n; ) {
      const o = e[g++];
      let I = null;
      if (o === 12) {
        const C = e[g++];
        C === 0 ? (e[g - 2] = 139, e[g - 1] = 22, s = 0) : I = eQ[C];
      } else if (o === 28)
        r[s] = (e[g] << 24 | e[g + 1] << 16) >> 16, g += 2, s++;
      else if (o === 14) {
        if (s >= 4 && (s -= 4, this.seacAnalysisEnabled))
          return A.seac = r.slice(s, s + 4), !1;
        I = $i[o];
      } else if (o >= 32 && o <= 246)
        r[s] = o - 139, s++;
      else if (o >= 247 && o <= 254)
        r[s] = o < 251 ? (o - 247 << 8) + e[g] + 108 : -(o - 251 << 8) - e[g] - 108, g++, s++;
      else if (o === 255)
        r[s] = (e[g] << 24 | e[g + 1] << 16 | e[g + 2] << 8 | e[g + 3]) / 65536, g += 4, s++;
      else if (o === 19 || o === 20) {
        if (A.hints += s >> 1, A.hints === 0) {
          e.copyWithin(g - 1, g, -1), g -= 1, n -= 1;
          continue;
        }
        g += A.hints + 7 >> 3, s %= 2, I = $i[o];
      } else {
        if (o === 10 || o === 29) {
          const C = o === 10 ? i : a;
          if (!C)
            return I = $i[o], G("Missing subrsIndex for " + I.id), !1;
          let h = 32768;
          C.count < 1240 ? h = 107 : C.count < 33900 && (h = 1131);
          const c = r[--s] + h;
          if (c < 0 || c >= C.count || isNaN(c))
            return I = $i[o], G("Out of bounds subrIndex for " + I.id), !1;
          if (A.stackSize = s, A.callDepth++, !this.parseCharString(A, C.get(c), i, a)) return !1;
          A.callDepth--, s = A.stackSize;
          continue;
        }
        if (o === 11)
          return A.stackSize = s, !0;
        if (o === 0 && g === e.length)
          e[g - 1] = 14, I = $i[14];
        else {
          if (o === 9) {
            e.copyWithin(g - 1, g, -1), g -= 1, n -= 1;
            continue;
          }
          I = $i[o];
        }
      }
      if (I) {
        if (I.stem && (A.hints += s >> 1, o === 3 || o === 23 ? A.hasVStems = !0 : A.hasVStems && (o === 1 || o === 18) && (G("CFF stem hints are in wrong order"), e[g - 1] = o === 1 ? 3 : 23)), "min" in I && !A.undefStack && s < I.min)
          return G("Not enough parameters for " + I.id + "; actual: " + s + ", expected: " + I.min), s === 0 ? (e[g - 1] = 14, !0) : !1;
        A.firstStackClearing && I.stackClearing && (A.firstStackClearing = !1, s -= I.min, s >= 2 && I.stem ? s %= 2 : s > 1 && G("Found too many parameters for stack-clearing command"), s > 0 && (A.width = r[s - 1])), "stackDelta" in I ? ("stackFn" in I && I.stackFn(r, s), s += I.stackDelta) : I.stackClearing ? s = 0 : I.resetStack ? (s = 0, A.undefStack = !1) : I.undefStack && (s = 0, A.undefStack = !0, A.firstStackClearing = !1);
      }
    }
    return n < e.length && e.fill(14, n), A.stackSize = s, !0;
  }
  parseCharStrings({ charStrings: A, localSubrIndex: e, globalSubrIndex: i, fdSelect: a, fdArray: s, privateDict: r }) {
    const n = [], g = [], o = A.count;
    for (let I = 0; I < o; I++) {
      const C = A.get(I), h = { callDepth: 0, stackSize: 0, stack: [], undefStack: !0, hints: 0, firstStackClearing: !0, seac: null, width: null, hasVStems: !1 };
      let c = !0, B = null, l = r;
      if (a && s.length) {
        const Q = a.getFDIndex(I);
        Q === -1 && (G("Glyph index is not in fd select."), c = !1), Q >= s.length && (G("Invalid fd index for glyph index."), c = !1), c && (l = s[Q].privateDict, B = l.subrsIndex);
      } else e && (B = e);
      if (c && (c = this.parseCharString(h, C, B, i)), h.width !== null) {
        const Q = l.getByName("nominalWidthX");
        g[I] = Q + h.width;
      } else {
        const Q = l.getByName("defaultWidthX");
        g[I] = Q;
      }
      h.seac !== null && (n[I] = h.seac), c || A.set(I, new Uint8Array([14]));
    }
    return { charStrings: A, seacs: n, widths: g };
  }
  emptyPrivateDictionary(A) {
    const e = this.createDict(Fs, [], A.strings);
    A.setByKey(18, [0, 0]), A.privateDict = e;
  }
  parsePrivateDict(A) {
    if (!A.hasName("Private")) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const e = A.getByName("Private");
    if (!Array.isArray(e) || e.length !== 2) {
      A.removeByName("Private");
      return;
    }
    const i = e[0], a = e[1];
    if (i === 0 || a >= this.bytes.length) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const s = a + i, r = this.bytes.subarray(a, s), n = this.parseDict(r), g = this.createDict(Fs, n, A.strings);
    if (A.privateDict = g, g.getByName("ExpansionFactor") === 0 && g.setByName("ExpansionFactor", 0.06), !g.getByName("Subrs")) return;
    const o = g.getByName("Subrs"), I = a + o;
    if (o === 0 || I >= this.bytes.length) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const C = this.parseIndex(I);
    g.subrsIndex = C.obj;
  }
  parseCharsets(A, e, i, a) {
    if (A === 0) return new ss(!0, Eg.ISO_ADOBE, _l);
    if (A === 1) return new ss(!0, Eg.EXPERT, $l);
    if (A === 2) return new ss(!0, Eg.EXPERT_SUBSET, AQ);
    const s = this.bytes, r = A, n = s[A++], g = [a ? 0 : ".notdef"];
    let o, I, C;
    switch (e -= 1, n) {
      case 0:
        for (C = 0; C < e; C++)
          o = s[A++] << 8 | s[A++], g.push(a ? o : i.get(o));
        break;
      case 1:
        for (; g.length <= e; )
          for (o = s[A++] << 8 | s[A++], I = s[A++], C = 0; C <= I; C++) g.push(a ? o++ : i.get(o++));
        break;
      case 2:
        for (; g.length <= e; )
          for (o = s[A++] << 8 | s[A++], I = s[A++] << 8 | s[A++], C = 0; C <= I; C++) g.push(a ? o++ : i.get(o++));
        break;
      default:
        throw new X("Unknown charset format");
    }
    const h = A, c = s.subarray(r, h);
    return new ss(!1, n, g, c);
  }
  parseEncoding(A, e, i, a) {
    const s = /* @__PURE__ */ Object.create(null), r = this.bytes;
    let n, g, o, I = !1, C = null;
    if (A === 0 || A === 1) {
      I = !0, n = A;
      const h = A ? H1 : ve;
      for (g = 0, o = a.length; g < o; g++) {
        const c = h.indexOf(a[g]);
        c !== -1 && (s[c] = g);
      }
    } else {
      const h = A;
      switch (n = r[A++], 127 & n) {
        case 0:
          const B = r[A++];
          for (g = 1; g <= B; g++) s[r[A++]] = g;
          break;
        case 1:
          const l = r[A++];
          let Q = 1;
          for (g = 0; g < l; g++) {
            const E = r[A++], u = r[A++];
            for (let f = E; f <= E + u; f++) s[f] = Q++;
          }
          break;
        default:
          throw new X(`Unknown encoding format: ${n} in CFF`);
      }
      const c = A;
      128 & n && (r[h] &= 127, function() {
        const l = r[A++];
        for (g = 0; g < l; g++) {
          const Q = r[A++], E = (r[A++] << 8) + (255 & r[A++]);
          s[Q] = a.indexOf(i.get(E));
        }
      }()), C = r.subarray(h, c);
    }
    return n &= 127, new sQ(I, n, s, C);
  }
  parseFDSelect(A, e) {
    const i = this.bytes, a = i[A++], s = [];
    let r;
    switch (a) {
      case 0:
        for (r = 0; r < e; ++r) {
          const g = i[A++];
          s.push(g);
        }
        break;
      case 3:
        const n = i[A++] << 8 | i[A++];
        for (r = 0; r < n; ++r) {
          let g = i[A++] << 8 | i[A++];
          r === 0 && g !== 0 && (G("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), g = 0);
          const o = i[A++], I = i[A] << 8 | i[A + 1];
          for (let C = g; C < I; ++C) s.push(o);
        }
        A += 2;
        break;
      default:
        throw new X(`parseFDSelect: Unknown format "${a}".`);
    }
    if (s.length !== e) throw new X("parseFDSelect: Invalid font data.");
    return new nQ(a, s);
  }
}
class Y1 {
  constructor() {
    this.header = null, this.names = [], this.topDict = null, this.strings = new iI(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      G("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const A = this.charStrings.get(0);
    this.charStrings.add(A), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(A) {
    return A < 0 || A >= this.charStrings.count ? !1 : this.charStrings.get(A).length > 0;
  }
}
class v1 {
  constructor(A, e, i, a) {
    this.major = A, this.minor = e, this.hdrSize = i, this.offSize = a;
  }
}
class iI {
  constructor() {
    this.strings = [];
  }
  get(A) {
    return A >= 0 && A <= 390 ? Zn[A] : A - Qg <= this.strings.length ? this.strings[A - Qg] : Zn[0];
  }
  getSID(A) {
    let e = Zn.indexOf(A);
    return e !== -1 ? e : (e = this.strings.indexOf(A), e !== -1 ? e + Qg : -1);
  }
  add(A) {
    this.strings.push(A);
  }
  get count() {
    return this.strings.length;
  }
}
class Ci {
  constructor() {
    this.objects = [], this.length = 0;
  }
  add(A) {
    this.length += A.length, this.objects.push(A);
  }
  set(A, e) {
    this.length += e.length - this.objects[A].length, this.objects[A] = e;
  }
  get(A) {
    return this.objects[A];
  }
  get count() {
    return this.objects.length;
  }
}
class K1 {
  constructor(A, e) {
    this.keyToNameMap = A.keyToNameMap, this.nameToKeyMap = A.nameToKeyMap, this.defaults = A.defaults, this.types = A.types, this.opcodes = A.opcodes, this.order = A.order, this.strings = e, this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(A, e) {
    if (!(A in this.keyToNameMap)) return !1;
    if (e.length === 0) return !0;
    for (const a of e) if (isNaN(a))
      return G(`Invalid CFFDict value: "${e}" for key "${A}".`), !0;
    const i = this.types[A];
    return i !== "num" && i !== "sid" && i !== "offset" || (e = e[0]), this.values[A] = e, !0;
  }
  setByName(A, e) {
    if (!(A in this.nameToKeyMap)) throw new X(`Invalid dictionary name "${A}"`);
    this.values[this.nameToKeyMap[A]] = e;
  }
  hasName(A) {
    return this.nameToKeyMap[A] in this.values;
  }
  getByName(A) {
    if (!(A in this.nameToKeyMap)) throw new X(`Invalid dictionary name ${A}"`);
    const e = this.nameToKeyMap[A];
    return e in this.values ? this.values[e] : this.defaults[e];
  }
  removeByName(A) {
    delete this.values[this.nameToKeyMap[A]];
  }
  static createTables(A) {
    const e = { keyToNameMap: {}, nameToKeyMap: {}, defaults: {}, types: {}, opcodes: {}, order: [] };
    for (const i of A) {
      const a = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];
      e.keyToNameMap[a] = i[1], e.nameToKeyMap[i[1]] = a, e.types[a] = i[2], e.defaults[a] = i[3], e.opcodes[a] = Array.isArray(i[0]) ? i[0] : [i[0]], e.order.push(a);
    }
    return e;
  }
}
const iQ = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class ks extends K1 {
  static get tables() {
    return sA(this, "tables", this.createTables(iQ));
  }
  constructor(A) {
    super(ks.tables, A), this.privateDict = null;
  }
}
const aQ = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class Fs extends K1 {
  static get tables() {
    return sA(this, "tables", this.createTables(aQ));
  }
  constructor(A) {
    super(Fs.tables, A), this.subrsIndex = null;
  }
}
const Eg = { ISO_ADOBE: 0, EXPERT: 1, EXPERT_SUBSET: 2 };
class ss {
  constructor(A, e, i, a) {
    this.predefined = A, this.format = e, this.charset = i, this.raw = a;
  }
}
class sQ {
  constructor(A, e, i, a) {
    this.predefined = A, this.format = e, this.encoding = i, this.raw = a;
  }
}
class nQ {
  constructor(A, e) {
    this.format = A, this.fdSelect = e;
  }
  getFDIndex(A) {
    return A < 0 || A >= this.fdSelect.length ? -1 : this.fdSelect[A];
  }
}
class Ec {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(A) {
    return A in this.offsets;
  }
  track(A, e) {
    if (A in this.offsets) throw new X(`Already tracking location of ${A}`);
    this.offsets[A] = e;
  }
  offset(A) {
    for (const e in this.offsets) this.offsets[e] += A;
  }
  setEntryLocation(A, e, i) {
    if (!(A in this.offsets)) throw new X(`Not tracking location of ${A}`);
    const a = i.data, s = this.offsets[A];
    for (let r = 0, n = e.length; r < n; ++r) {
      const g = 5 * r + s, o = g + 1, I = g + 2, C = g + 3, h = g + 4;
      if (a[g] !== 29 || a[o] !== 0 || a[I] !== 0 || a[C] !== 0 || a[h] !== 0) throw new X("writing to an offset that is not empty");
      const c = e[r];
      a[g] = 29, a[o] = c >> 24 & 255, a[I] = c >> 16 & 255, a[C] = c >> 8 & 255, a[h] = 255 & c;
    }
  }
}
class an {
  constructor(A) {
    this.cff = A;
  }
  compile() {
    const A = this.cff, e = { data: [], length: 0, add(h) {
      try {
        this.data.push(...h);
      } catch {
        this.data = this.data.concat(h);
      }
      this.length = this.data.length;
    } }, i = this.compileHeader(A.header);
    e.add(i);
    const a = this.compileNameIndex(A.names);
    if (e.add(a), A.isCIDFont && A.topDict.hasName("FontMatrix")) {
      const h = A.topDict.getByName("FontMatrix");
      A.topDict.removeByName("FontMatrix");
      for (const c of A.fdArray) {
        let B = h.slice(0);
        c.hasName("FontMatrix") && (B = nt.transform(B, c.getByName("FontMatrix"))), c.setByName("FontMatrix", B);
      }
    }
    const s = A.topDict.getByName("XUID");
    (s == null ? void 0 : s.length) > 16 && A.topDict.removeByName("XUID"), A.topDict.setByName("charset", 0);
    let r = this.compileTopDicts([A.topDict], e.length, A.isCIDFont);
    e.add(r.output);
    const n = r.trackers[0], g = this.compileStringIndex(A.strings.strings);
    e.add(g);
    const o = this.compileIndex(A.globalSubrIndex);
    if (e.add(o), A.encoding && A.topDict.hasName("Encoding")) if (A.encoding.predefined) n.setEntryLocation("Encoding", [A.encoding.format], e);
    else {
      const h = this.compileEncoding(A.encoding);
      n.setEntryLocation("Encoding", [e.length], e), e.add(h);
    }
    const I = this.compileCharset(A.charset, A.charStrings.count, A.strings, A.isCIDFont);
    n.setEntryLocation("charset", [e.length], e), e.add(I);
    const C = this.compileCharStrings(A.charStrings);
    if (n.setEntryLocation("CharStrings", [e.length], e), e.add(C), A.isCIDFont) {
      n.setEntryLocation("FDSelect", [e.length], e);
      const h = this.compileFDSelect(A.fdSelect);
      e.add(h), r = this.compileTopDicts(A.fdArray, e.length, !0), n.setEntryLocation("FDArray", [e.length], e), e.add(r.output);
      const c = r.trackers;
      this.compilePrivateDicts(A.fdArray, c, e);
    }
    return this.compilePrivateDicts([A.topDict], [n], e), e.add([0]), e.data;
  }
  encodeNumber(A) {
    return Number.isInteger(A) ? this.encodeInteger(A) : this.encodeFloat(A);
  }
  static get EncodeFloatRegExp() {
    return sA(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(A) {
    let e = A.toString();
    const i = an.EncodeFloatRegExp.exec(e);
    if (i) {
      const g = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
      e = (Math.round(A * g) / g).toString();
    }
    let a, s, r = "";
    for (a = 0, s = e.length; a < s; ++a) {
      const g = e[a];
      r += g === "e" ? e[++a] === "-" ? "c" : "b" : g === "." ? "a" : g === "-" ? "e" : g;
    }
    r += 1 & r.length ? "f" : "ff";
    const n = [30];
    for (a = 0, s = r.length; a < s; a += 2) n.push(parseInt(r.substring(a, a + 2), 16));
    return n;
  }
  encodeInteger(A) {
    let e;
    return e = A >= -107 && A <= 107 ? [A + 139] : A >= 108 && A <= 1131 ? [247 + ((A -= 108) >> 8), 255 & A] : A >= -1131 && A <= -108 ? [251 + ((A = -A - 108) >> 8), 255 & A] : A >= -32768 && A <= 32767 ? [28, A >> 8 & 255, 255 & A] : [29, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, 255 & A], e;
  }
  compileHeader(A) {
    return [A.major, A.minor, 4, A.offSize];
  }
  compileNameIndex(A) {
    const e = new Ci();
    for (const i of A) {
      const a = Math.min(i.length, 127);
      let s = new Array(a);
      for (let r = 0; r < a; r++) {
        let n = i[r];
        (n < "!" || n > "~" || n === "[" || n === "]" || n === "(" || n === ")" || n === "{" || n === "}" || n === "<" || n === ">" || n === "/" || n === "%") && (n = "_"), s[r] = n;
      }
      s = s.join(""), s === "" && (s = "Bad_Font_Name"), e.add(ut(s));
    }
    return this.compileIndex(e);
  }
  compileTopDicts(A, e, i) {
    const a = [];
    let s = new Ci();
    for (const r of A) {
      i && (r.removeByName("CIDFontVersion"), r.removeByName("CIDFontRevision"), r.removeByName("CIDFontType"), r.removeByName("CIDCount"), r.removeByName("UIDBase"));
      const n = new Ec(), g = this.compileDict(r, n);
      a.push(n), s.add(g), n.offset(e);
    }
    return s = this.compileIndex(s, a), { trackers: a, output: s };
  }
  compilePrivateDicts(A, e, i) {
    for (let a = 0, s = A.length; a < s; ++a) {
      const r = A[a], n = r.privateDict;
      if (!n || !r.hasName("Private")) throw new X("There must be a private dictionary.");
      const g = new Ec(), o = this.compileDict(n, g);
      let I = i.length;
      if (g.offset(I), o.length || (I = 0), e[a].setEntryLocation("Private", [o.length, I], i), i.add(o), n.subrsIndex && n.hasName("Subrs")) {
        const C = this.compileIndex(n.subrsIndex);
        g.setEntryLocation("Subrs", [o.length], i), i.add(C);
      }
    }
  }
  compileDict(A, e) {
    const i = [];
    for (const a of A.order) {
      if (!(a in A.values)) continue;
      let s = A.values[a], r = A.types[a];
      if (Array.isArray(r) || (r = [r]), Array.isArray(s) || (s = [s]), s.length !== 0) {
        for (let n = 0, g = r.length; n < g; ++n) {
          const o = r[n], I = s[n];
          switch (o) {
            case "num":
            case "sid":
              i.push(...this.encodeNumber(I));
              break;
            case "offset":
              const C = A.keyToNameMap[a];
              e.isTracking(C) || e.track(C, i.length), i.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              i.push(...this.encodeNumber(I));
              for (let h = 1, c = s.length; h < c; ++h) i.push(...this.encodeNumber(s[h]));
              break;
            default:
              throw new X(`Unknown data type of ${o}`);
          }
        }
        i.push(...A.opcodes[a]);
      }
    }
    return i;
  }
  compileStringIndex(A) {
    const e = new Ci();
    for (const i of A) e.add(ut(i));
    return this.compileIndex(e);
  }
  compileCharStrings(A) {
    const e = new Ci();
    for (let i = 0; i < A.count; i++) {
      const a = A.get(i);
      a.length !== 0 ? e.add(a) : e.add(new Uint8Array([139, 14]));
    }
    return this.compileIndex(e);
  }
  compileCharset(A, e, i, a) {
    let s;
    const r = e - 1;
    if (a) s = new Uint8Array([2, 0, 0, r >> 8 & 255, 255 & r]);
    else {
      s = new Uint8Array(1 + 2 * r), s[0] = 0;
      let n = 0;
      const g = A.charset.length;
      let o = !1;
      for (let I = 1; I < s.length; I += 2) {
        let C = 0;
        if (n < g) {
          const h = A.charset[n++];
          C = i.getSID(h), C === -1 && (C = 0, o || (o = !0, G(`Couldn't find ${h} in CFF strings`)));
        }
        s[I] = C >> 8 & 255, s[I + 1] = 255 & C;
      }
    }
    return this.compileTypedArray(s);
  }
  compileEncoding(A) {
    return this.compileTypedArray(A.raw);
  }
  compileFDSelect(A) {
    const e = A.format;
    let i, a;
    switch (e) {
      case 0:
        for (i = new Uint8Array(1 + A.fdSelect.length), i[0] = e, a = 0; a < A.fdSelect.length; a++) i[a + 1] = A.fdSelect[a];
        break;
      case 3:
        const s = 0;
        let r = A.fdSelect[0];
        const n = [e, 0, 0, s >> 8 & 255, 255 & s, r];
        for (a = 1; a < A.fdSelect.length; a++) {
          const o = A.fdSelect[a];
          o !== r && (n.push(a >> 8 & 255, 255 & a, o), r = o);
        }
        const g = (n.length - 3) / 3;
        n[1] = g >> 8 & 255, n[2] = 255 & g, n.push(a >> 8 & 255, 255 & a), i = new Uint8Array(n);
    }
    return this.compileTypedArray(i);
  }
  compileTypedArray(A) {
    return Array.from(A);
  }
  compileIndex(A, e = []) {
    const i = A.objects, a = i.length;
    if (a === 0) return [0, 0];
    const s = [a >> 8 & 255, 255 & a];
    let r, n, g = 1;
    for (r = 0; r < a; ++r) g += i[r].length;
    n = g < 256 ? 1 : g < 65536 ? 2 : g < 16777216 ? 3 : 4, s.push(n);
    let o = 1;
    for (r = 0; r < a + 1; r++)
      n === 1 ? s.push(255 & o) : n === 2 ? s.push(o >> 8 & 255, 255 & o) : n === 3 ? s.push(o >> 16 & 255, o >> 8 & 255, 255 & o) : s.push(o >>> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o), i[r] && (o += i[r].length);
    for (r = 0; r < a; r++)
      e[r] && e[r].offset(s.length), s.push(...i[r]);
    return s;
  }
}
const fe = jA(function(t) {
  t.A = 65, t.AE = 198, t.AEacute = 508, t.AEmacron = 482, t.AEsmall = 63462, t.Aacute = 193, t.Aacutesmall = 63457, t.Abreve = 258, t.Abreveacute = 7854, t.Abrevecyrillic = 1232, t.Abrevedotbelow = 7862, t.Abrevegrave = 7856, t.Abrevehookabove = 7858, t.Abrevetilde = 7860, t.Acaron = 461, t.Acircle = 9398, t.Acircumflex = 194, t.Acircumflexacute = 7844, t.Acircumflexdotbelow = 7852, t.Acircumflexgrave = 7846, t.Acircumflexhookabove = 7848, t.Acircumflexsmall = 63458, t.Acircumflextilde = 7850, t.Acute = 63177, t.Acutesmall = 63412, t.Acyrillic = 1040, t.Adblgrave = 512, t.Adieresis = 196, t.Adieresiscyrillic = 1234, t.Adieresismacron = 478, t.Adieresissmall = 63460, t.Adotbelow = 7840, t.Adotmacron = 480, t.Agrave = 192, t.Agravesmall = 63456, t.Ahookabove = 7842, t.Aiecyrillic = 1236, t.Ainvertedbreve = 514, t.Alpha = 913, t.Alphatonos = 902, t.Amacron = 256, t.Amonospace = 65313, t.Aogonek = 260, t.Aring = 197, t.Aringacute = 506, t.Aringbelow = 7680, t.Aringsmall = 63461, t.Asmall = 63329, t.Atilde = 195, t.Atildesmall = 63459, t.Aybarmenian = 1329, t.B = 66, t.Bcircle = 9399, t.Bdotaccent = 7682, t.Bdotbelow = 7684, t.Becyrillic = 1041, t.Benarmenian = 1330, t.Beta = 914, t.Bhook = 385, t.Blinebelow = 7686, t.Bmonospace = 65314, t.Brevesmall = 63220, t.Bsmall = 63330, t.Btopbar = 386, t.C = 67, t.Caarmenian = 1342, t.Cacute = 262, t.Caron = 63178, t.Caronsmall = 63221, t.Ccaron = 268, t.Ccedilla = 199, t.Ccedillaacute = 7688, t.Ccedillasmall = 63463, t.Ccircle = 9400, t.Ccircumflex = 264, t.Cdot = 266, t.Cdotaccent = 266, t.Cedillasmall = 63416, t.Chaarmenian = 1353, t.Cheabkhasiancyrillic = 1212, t.Checyrillic = 1063, t.Chedescenderabkhasiancyrillic = 1214, t.Chedescendercyrillic = 1206, t.Chedieresiscyrillic = 1268, t.Cheharmenian = 1347, t.Chekhakassiancyrillic = 1227, t.Cheverticalstrokecyrillic = 1208, t.Chi = 935, t.Chook = 391, t.Circumflexsmall = 63222, t.Cmonospace = 65315, t.Coarmenian = 1361, t.Csmall = 63331, t.D = 68, t.DZ = 497, t.DZcaron = 452, t.Daarmenian = 1332, t.Dafrican = 393, t.Dcaron = 270, t.Dcedilla = 7696, t.Dcircle = 9401, t.Dcircumflexbelow = 7698, t.Dcroat = 272, t.Ddotaccent = 7690, t.Ddotbelow = 7692, t.Decyrillic = 1044, t.Deicoptic = 1006, t.Delta = 8710, t.Deltagreek = 916, t.Dhook = 394, t.Dieresis = 63179, t.DieresisAcute = 63180, t.DieresisGrave = 63181, t.Dieresissmall = 63400, t.Digammagreek = 988, t.Djecyrillic = 1026, t.Dlinebelow = 7694, t.Dmonospace = 65316, t.Dotaccentsmall = 63223, t.Dslash = 272, t.Dsmall = 63332, t.Dtopbar = 395, t.Dz = 498, t.Dzcaron = 453, t.Dzeabkhasiancyrillic = 1248, t.Dzecyrillic = 1029, t.Dzhecyrillic = 1039, t.E = 69, t.Eacute = 201, t.Eacutesmall = 63465, t.Ebreve = 276, t.Ecaron = 282, t.Ecedillabreve = 7708, t.Echarmenian = 1333, t.Ecircle = 9402, t.Ecircumflex = 202, t.Ecircumflexacute = 7870, t.Ecircumflexbelow = 7704, t.Ecircumflexdotbelow = 7878, t.Ecircumflexgrave = 7872, t.Ecircumflexhookabove = 7874, t.Ecircumflexsmall = 63466, t.Ecircumflextilde = 7876, t.Ecyrillic = 1028, t.Edblgrave = 516, t.Edieresis = 203, t.Edieresissmall = 63467, t.Edot = 278, t.Edotaccent = 278, t.Edotbelow = 7864, t.Efcyrillic = 1060, t.Egrave = 200, t.Egravesmall = 63464, t.Eharmenian = 1335, t.Ehookabove = 7866, t.Eightroman = 8551, t.Einvertedbreve = 518, t.Eiotifiedcyrillic = 1124, t.Elcyrillic = 1051, t.Elevenroman = 8554, t.Emacron = 274, t.Emacronacute = 7702, t.Emacrongrave = 7700, t.Emcyrillic = 1052, t.Emonospace = 65317, t.Encyrillic = 1053, t.Endescendercyrillic = 1186, t.Eng = 330, t.Enghecyrillic = 1188, t.Enhookcyrillic = 1223, t.Eogonek = 280, t.Eopen = 400, t.Epsilon = 917, t.Epsilontonos = 904, t.Ercyrillic = 1056, t.Ereversed = 398, t.Ereversedcyrillic = 1069, t.Escyrillic = 1057, t.Esdescendercyrillic = 1194, t.Esh = 425, t.Esmall = 63333, t.Eta = 919, t.Etarmenian = 1336, t.Etatonos = 905, t.Eth = 208, t.Ethsmall = 63472, t.Etilde = 7868, t.Etildebelow = 7706, t.Euro = 8364, t.Ezh = 439, t.Ezhcaron = 494, t.Ezhreversed = 440, t.F = 70, t.Fcircle = 9403, t.Fdotaccent = 7710, t.Feharmenian = 1366, t.Feicoptic = 996, t.Fhook = 401, t.Fitacyrillic = 1138, t.Fiveroman = 8548, t.Fmonospace = 65318, t.Fourroman = 8547, t.Fsmall = 63334, t.G = 71, t.GBsquare = 13191, t.Gacute = 500, t.Gamma = 915, t.Gammaafrican = 404, t.Gangiacoptic = 1002, t.Gbreve = 286, t.Gcaron = 486, t.Gcedilla = 290, t.Gcircle = 9404, t.Gcircumflex = 284, t.Gcommaaccent = 290, t.Gdot = 288, t.Gdotaccent = 288, t.Gecyrillic = 1043, t.Ghadarmenian = 1346, t.Ghemiddlehookcyrillic = 1172, t.Ghestrokecyrillic = 1170, t.Gheupturncyrillic = 1168, t.Ghook = 403, t.Gimarmenian = 1331, t.Gjecyrillic = 1027, t.Gmacron = 7712, t.Gmonospace = 65319, t.Grave = 63182, t.Gravesmall = 63328, t.Gsmall = 63335, t.Gsmallhook = 667, t.Gstroke = 484, t.H = 72, t.H18533 = 9679, t.H18543 = 9642, t.H18551 = 9643, t.H22073 = 9633, t.HPsquare = 13259, t.Haabkhasiancyrillic = 1192, t.Hadescendercyrillic = 1202, t.Hardsigncyrillic = 1066, t.Hbar = 294, t.Hbrevebelow = 7722, t.Hcedilla = 7720, t.Hcircle = 9405, t.Hcircumflex = 292, t.Hdieresis = 7718, t.Hdotaccent = 7714, t.Hdotbelow = 7716, t.Hmonospace = 65320, t.Hoarmenian = 1344, t.Horicoptic = 1e3, t.Hsmall = 63336, t.Hungarumlaut = 63183, t.Hungarumlautsmall = 63224, t.Hzsquare = 13200, t.I = 73, t.IAcyrillic = 1071, t.IJ = 306, t.IUcyrillic = 1070, t.Iacute = 205, t.Iacutesmall = 63469, t.Ibreve = 300, t.Icaron = 463, t.Icircle = 9406, t.Icircumflex = 206, t.Icircumflexsmall = 63470, t.Icyrillic = 1030, t.Idblgrave = 520, t.Idieresis = 207, t.Idieresisacute = 7726, t.Idieresiscyrillic = 1252, t.Idieresissmall = 63471, t.Idot = 304, t.Idotaccent = 304, t.Idotbelow = 7882, t.Iebrevecyrillic = 1238, t.Iecyrillic = 1045, t.Ifraktur = 8465, t.Igrave = 204, t.Igravesmall = 63468, t.Ihookabove = 7880, t.Iicyrillic = 1048, t.Iinvertedbreve = 522, t.Iishortcyrillic = 1049, t.Imacron = 298, t.Imacroncyrillic = 1250, t.Imonospace = 65321, t.Iniarmenian = 1339, t.Iocyrillic = 1025, t.Iogonek = 302, t.Iota = 921, t.Iotaafrican = 406, t.Iotadieresis = 938, t.Iotatonos = 906, t.Ismall = 63337, t.Istroke = 407, t.Itilde = 296, t.Itildebelow = 7724, t.Izhitsacyrillic = 1140, t.Izhitsadblgravecyrillic = 1142, t.J = 74, t.Jaarmenian = 1345, t.Jcircle = 9407, t.Jcircumflex = 308, t.Jecyrillic = 1032, t.Jheharmenian = 1355, t.Jmonospace = 65322, t.Jsmall = 63338, t.K = 75, t.KBsquare = 13189, t.KKsquare = 13261, t.Kabashkircyrillic = 1184, t.Kacute = 7728, t.Kacyrillic = 1050, t.Kadescendercyrillic = 1178, t.Kahookcyrillic = 1219, t.Kappa = 922, t.Kastrokecyrillic = 1182, t.Kaverticalstrokecyrillic = 1180, t.Kcaron = 488, t.Kcedilla = 310, t.Kcircle = 9408, t.Kcommaaccent = 310, t.Kdotbelow = 7730, t.Keharmenian = 1364, t.Kenarmenian = 1343, t.Khacyrillic = 1061, t.Kheicoptic = 998, t.Khook = 408, t.Kjecyrillic = 1036, t.Klinebelow = 7732, t.Kmonospace = 65323, t.Koppacyrillic = 1152, t.Koppagreek = 990, t.Ksicyrillic = 1134, t.Ksmall = 63339, t.L = 76, t.LJ = 455, t.LL = 63167, t.Lacute = 313, t.Lambda = 923, t.Lcaron = 317, t.Lcedilla = 315, t.Lcircle = 9409, t.Lcircumflexbelow = 7740, t.Lcommaaccent = 315, t.Ldot = 319, t.Ldotaccent = 319, t.Ldotbelow = 7734, t.Ldotbelowmacron = 7736, t.Liwnarmenian = 1340, t.Lj = 456, t.Ljecyrillic = 1033, t.Llinebelow = 7738, t.Lmonospace = 65324, t.Lslash = 321, t.Lslashsmall = 63225, t.Lsmall = 63340, t.M = 77, t.MBsquare = 13190, t.Macron = 63184, t.Macronsmall = 63407, t.Macute = 7742, t.Mcircle = 9410, t.Mdotaccent = 7744, t.Mdotbelow = 7746, t.Menarmenian = 1348, t.Mmonospace = 65325, t.Msmall = 63341, t.Mturned = 412, t.Mu = 924, t.N = 78, t.NJ = 458, t.Nacute = 323, t.Ncaron = 327, t.Ncedilla = 325, t.Ncircle = 9411, t.Ncircumflexbelow = 7754, t.Ncommaaccent = 325, t.Ndotaccent = 7748, t.Ndotbelow = 7750, t.Nhookleft = 413, t.Nineroman = 8552, t.Nj = 459, t.Njecyrillic = 1034, t.Nlinebelow = 7752, t.Nmonospace = 65326, t.Nowarmenian = 1350, t.Nsmall = 63342, t.Ntilde = 209, t.Ntildesmall = 63473, t.Nu = 925, t.O = 79, t.OE = 338, t.OEsmall = 63226, t.Oacute = 211, t.Oacutesmall = 63475, t.Obarredcyrillic = 1256, t.Obarreddieresiscyrillic = 1258, t.Obreve = 334, t.Ocaron = 465, t.Ocenteredtilde = 415, t.Ocircle = 9412, t.Ocircumflex = 212, t.Ocircumflexacute = 7888, t.Ocircumflexdotbelow = 7896, t.Ocircumflexgrave = 7890, t.Ocircumflexhookabove = 7892, t.Ocircumflexsmall = 63476, t.Ocircumflextilde = 7894, t.Ocyrillic = 1054, t.Odblacute = 336, t.Odblgrave = 524, t.Odieresis = 214, t.Odieresiscyrillic = 1254, t.Odieresissmall = 63478, t.Odotbelow = 7884, t.Ogoneksmall = 63227, t.Ograve = 210, t.Ogravesmall = 63474, t.Oharmenian = 1365, t.Ohm = 8486, t.Ohookabove = 7886, t.Ohorn = 416, t.Ohornacute = 7898, t.Ohorndotbelow = 7906, t.Ohorngrave = 7900, t.Ohornhookabove = 7902, t.Ohorntilde = 7904, t.Ohungarumlaut = 336, t.Oi = 418, t.Oinvertedbreve = 526, t.Omacron = 332, t.Omacronacute = 7762, t.Omacrongrave = 7760, t.Omega = 8486, t.Omegacyrillic = 1120, t.Omegagreek = 937, t.Omegaroundcyrillic = 1146, t.Omegatitlocyrillic = 1148, t.Omegatonos = 911, t.Omicron = 927, t.Omicrontonos = 908, t.Omonospace = 65327, t.Oneroman = 8544, t.Oogonek = 490, t.Oogonekmacron = 492, t.Oopen = 390, t.Oslash = 216, t.Oslashacute = 510, t.Oslashsmall = 63480, t.Osmall = 63343, t.Ostrokeacute = 510, t.Otcyrillic = 1150, t.Otilde = 213, t.Otildeacute = 7756, t.Otildedieresis = 7758, t.Otildesmall = 63477, t.P = 80, t.Pacute = 7764, t.Pcircle = 9413, t.Pdotaccent = 7766, t.Pecyrillic = 1055, t.Peharmenian = 1354, t.Pemiddlehookcyrillic = 1190, t.Phi = 934, t.Phook = 420, t.Pi = 928, t.Piwrarmenian = 1363, t.Pmonospace = 65328, t.Psi = 936, t.Psicyrillic = 1136, t.Psmall = 63344, t.Q = 81, t.Qcircle = 9414, t.Qmonospace = 65329, t.Qsmall = 63345, t.R = 82, t.Raarmenian = 1356, t.Racute = 340, t.Rcaron = 344, t.Rcedilla = 342, t.Rcircle = 9415, t.Rcommaaccent = 342, t.Rdblgrave = 528, t.Rdotaccent = 7768, t.Rdotbelow = 7770, t.Rdotbelowmacron = 7772, t.Reharmenian = 1360, t.Rfraktur = 8476, t.Rho = 929, t.Ringsmall = 63228, t.Rinvertedbreve = 530, t.Rlinebelow = 7774, t.Rmonospace = 65330, t.Rsmall = 63346, t.Rsmallinverted = 641, t.Rsmallinvertedsuperior = 694, t.S = 83, t.SF010000 = 9484, t.SF020000 = 9492, t.SF030000 = 9488, t.SF040000 = 9496, t.SF050000 = 9532, t.SF060000 = 9516, t.SF070000 = 9524, t.SF080000 = 9500, t.SF090000 = 9508, t.SF100000 = 9472, t.SF110000 = 9474, t.SF190000 = 9569, t.SF200000 = 9570, t.SF210000 = 9558, t.SF220000 = 9557, t.SF230000 = 9571, t.SF240000 = 9553, t.SF250000 = 9559, t.SF260000 = 9565, t.SF270000 = 9564, t.SF280000 = 9563, t.SF360000 = 9566, t.SF370000 = 9567, t.SF380000 = 9562, t.SF390000 = 9556, t.SF400000 = 9577, t.SF410000 = 9574, t.SF420000 = 9568, t.SF430000 = 9552, t.SF440000 = 9580, t.SF450000 = 9575, t.SF460000 = 9576, t.SF470000 = 9572, t.SF480000 = 9573, t.SF490000 = 9561, t.SF500000 = 9560, t.SF510000 = 9554, t.SF520000 = 9555, t.SF530000 = 9579, t.SF540000 = 9578, t.Sacute = 346, t.Sacutedotaccent = 7780, t.Sampigreek = 992, t.Scaron = 352, t.Scarondotaccent = 7782, t.Scaronsmall = 63229, t.Scedilla = 350, t.Schwa = 399, t.Schwacyrillic = 1240, t.Schwadieresiscyrillic = 1242, t.Scircle = 9416, t.Scircumflex = 348, t.Scommaaccent = 536, t.Sdotaccent = 7776, t.Sdotbelow = 7778, t.Sdotbelowdotaccent = 7784, t.Seharmenian = 1357, t.Sevenroman = 8550, t.Shaarmenian = 1351, t.Shacyrillic = 1064, t.Shchacyrillic = 1065, t.Sheicoptic = 994, t.Shhacyrillic = 1210, t.Shimacoptic = 1004, t.Sigma = 931, t.Sixroman = 8549, t.Smonospace = 65331, t.Softsigncyrillic = 1068, t.Ssmall = 63347, t.Stigmagreek = 986, t.T = 84, t.Tau = 932, t.Tbar = 358, t.Tcaron = 356, t.Tcedilla = 354, t.Tcircle = 9417, t.Tcircumflexbelow = 7792, t.Tcommaaccent = 354, t.Tdotaccent = 7786, t.Tdotbelow = 7788, t.Tecyrillic = 1058, t.Tedescendercyrillic = 1196, t.Tenroman = 8553, t.Tetsecyrillic = 1204, t.Theta = 920, t.Thook = 428, t.Thorn = 222, t.Thornsmall = 63486, t.Threeroman = 8546, t.Tildesmall = 63230, t.Tiwnarmenian = 1359, t.Tlinebelow = 7790, t.Tmonospace = 65332, t.Toarmenian = 1337, t.Tonefive = 444, t.Tonesix = 388, t.Tonetwo = 423, t.Tretroflexhook = 430, t.Tsecyrillic = 1062, t.Tshecyrillic = 1035, t.Tsmall = 63348, t.Twelveroman = 8555, t.Tworoman = 8545, t.U = 85, t.Uacute = 218, t.Uacutesmall = 63482, t.Ubreve = 364, t.Ucaron = 467, t.Ucircle = 9418, t.Ucircumflex = 219, t.Ucircumflexbelow = 7798, t.Ucircumflexsmall = 63483, t.Ucyrillic = 1059, t.Udblacute = 368, t.Udblgrave = 532, t.Udieresis = 220, t.Udieresisacute = 471, t.Udieresisbelow = 7794, t.Udieresiscaron = 473, t.Udieresiscyrillic = 1264, t.Udieresisgrave = 475, t.Udieresismacron = 469, t.Udieresissmall = 63484, t.Udotbelow = 7908, t.Ugrave = 217, t.Ugravesmall = 63481, t.Uhookabove = 7910, t.Uhorn = 431, t.Uhornacute = 7912, t.Uhorndotbelow = 7920, t.Uhorngrave = 7914, t.Uhornhookabove = 7916, t.Uhorntilde = 7918, t.Uhungarumlaut = 368, t.Uhungarumlautcyrillic = 1266, t.Uinvertedbreve = 534, t.Ukcyrillic = 1144, t.Umacron = 362, t.Umacroncyrillic = 1262, t.Umacrondieresis = 7802, t.Umonospace = 65333, t.Uogonek = 370, t.Upsilon = 933, t.Upsilon1 = 978, t.Upsilonacutehooksymbolgreek = 979, t.Upsilonafrican = 433, t.Upsilondieresis = 939, t.Upsilondieresishooksymbolgreek = 980, t.Upsilonhooksymbol = 978, t.Upsilontonos = 910, t.Uring = 366, t.Ushortcyrillic = 1038, t.Usmall = 63349, t.Ustraightcyrillic = 1198, t.Ustraightstrokecyrillic = 1200, t.Utilde = 360, t.Utildeacute = 7800, t.Utildebelow = 7796, t.V = 86, t.Vcircle = 9419, t.Vdotbelow = 7806, t.Vecyrillic = 1042, t.Vewarmenian = 1358, t.Vhook = 434, t.Vmonospace = 65334, t.Voarmenian = 1352, t.Vsmall = 63350, t.Vtilde = 7804, t.W = 87, t.Wacute = 7810, t.Wcircle = 9420, t.Wcircumflex = 372, t.Wdieresis = 7812, t.Wdotaccent = 7814, t.Wdotbelow = 7816, t.Wgrave = 7808, t.Wmonospace = 65335, t.Wsmall = 63351, t.X = 88, t.Xcircle = 9421, t.Xdieresis = 7820, t.Xdotaccent = 7818, t.Xeharmenian = 1341, t.Xi = 926, t.Xmonospace = 65336, t.Xsmall = 63352, t.Y = 89, t.Yacute = 221, t.Yacutesmall = 63485, t.Yatcyrillic = 1122, t.Ycircle = 9422, t.Ycircumflex = 374, t.Ydieresis = 376, t.Ydieresissmall = 63487, t.Ydotaccent = 7822, t.Ydotbelow = 7924, t.Yericyrillic = 1067, t.Yerudieresiscyrillic = 1272, t.Ygrave = 7922, t.Yhook = 435, t.Yhookabove = 7926, t.Yiarmenian = 1349, t.Yicyrillic = 1031, t.Yiwnarmenian = 1362, t.Ymonospace = 65337, t.Ysmall = 63353, t.Ytilde = 7928, t.Yusbigcyrillic = 1130, t.Yusbigiotifiedcyrillic = 1132, t.Yuslittlecyrillic = 1126, t.Yuslittleiotifiedcyrillic = 1128, t.Z = 90, t.Zaarmenian = 1334, t.Zacute = 377, t.Zcaron = 381, t.Zcaronsmall = 63231, t.Zcircle = 9423, t.Zcircumflex = 7824, t.Zdot = 379, t.Zdotaccent = 379, t.Zdotbelow = 7826, t.Zecyrillic = 1047, t.Zedescendercyrillic = 1176, t.Zedieresiscyrillic = 1246, t.Zeta = 918, t.Zhearmenian = 1338, t.Zhebrevecyrillic = 1217, t.Zhecyrillic = 1046, t.Zhedescendercyrillic = 1174, t.Zhedieresiscyrillic = 1244, t.Zlinebelow = 7828, t.Zmonospace = 65338, t.Zsmall = 63354, t.Zstroke = 437, t.a = 97, t.aabengali = 2438, t.aacute = 225, t.aadeva = 2310, t.aagujarati = 2694, t.aagurmukhi = 2566, t.aamatragurmukhi = 2622, t.aarusquare = 13059, t.aavowelsignbengali = 2494, t.aavowelsigndeva = 2366, t.aavowelsigngujarati = 2750, t.abbreviationmarkarmenian = 1375, t.abbreviationsigndeva = 2416, t.abengali = 2437, t.abopomofo = 12570, t.abreve = 259, t.abreveacute = 7855, t.abrevecyrillic = 1233, t.abrevedotbelow = 7863, t.abrevegrave = 7857, t.abrevehookabove = 7859, t.abrevetilde = 7861, t.acaron = 462, t.acircle = 9424, t.acircumflex = 226, t.acircumflexacute = 7845, t.acircumflexdotbelow = 7853, t.acircumflexgrave = 7847, t.acircumflexhookabove = 7849, t.acircumflextilde = 7851, t.acute = 180, t.acutebelowcmb = 791, t.acutecmb = 769, t.acutecomb = 769, t.acutedeva = 2388, t.acutelowmod = 719, t.acutetonecmb = 833, t.acyrillic = 1072, t.adblgrave = 513, t.addakgurmukhi = 2673, t.adeva = 2309, t.adieresis = 228, t.adieresiscyrillic = 1235, t.adieresismacron = 479, t.adotbelow = 7841, t.adotmacron = 481, t.ae = 230, t.aeacute = 509, t.aekorean = 12624, t.aemacron = 483, t.afii00208 = 8213, t.afii08941 = 8356, t.afii10017 = 1040, t.afii10018 = 1041, t.afii10019 = 1042, t.afii10020 = 1043, t.afii10021 = 1044, t.afii10022 = 1045, t.afii10023 = 1025, t.afii10024 = 1046, t.afii10025 = 1047, t.afii10026 = 1048, t.afii10027 = 1049, t.afii10028 = 1050, t.afii10029 = 1051, t.afii10030 = 1052, t.afii10031 = 1053, t.afii10032 = 1054, t.afii10033 = 1055, t.afii10034 = 1056, t.afii10035 = 1057, t.afii10036 = 1058, t.afii10037 = 1059, t.afii10038 = 1060, t.afii10039 = 1061, t.afii10040 = 1062, t.afii10041 = 1063, t.afii10042 = 1064, t.afii10043 = 1065, t.afii10044 = 1066, t.afii10045 = 1067, t.afii10046 = 1068, t.afii10047 = 1069, t.afii10048 = 1070, t.afii10049 = 1071, t.afii10050 = 1168, t.afii10051 = 1026, t.afii10052 = 1027, t.afii10053 = 1028, t.afii10054 = 1029, t.afii10055 = 1030, t.afii10056 = 1031, t.afii10057 = 1032, t.afii10058 = 1033, t.afii10059 = 1034, t.afii10060 = 1035, t.afii10061 = 1036, t.afii10062 = 1038, t.afii10063 = 63172, t.afii10064 = 63173, t.afii10065 = 1072, t.afii10066 = 1073, t.afii10067 = 1074, t.afii10068 = 1075, t.afii10069 = 1076, t.afii10070 = 1077, t.afii10071 = 1105, t.afii10072 = 1078, t.afii10073 = 1079, t.afii10074 = 1080, t.afii10075 = 1081, t.afii10076 = 1082, t.afii10077 = 1083, t.afii10078 = 1084, t.afii10079 = 1085, t.afii10080 = 1086, t.afii10081 = 1087, t.afii10082 = 1088, t.afii10083 = 1089, t.afii10084 = 1090, t.afii10085 = 1091, t.afii10086 = 1092, t.afii10087 = 1093, t.afii10088 = 1094, t.afii10089 = 1095, t.afii10090 = 1096, t.afii10091 = 1097, t.afii10092 = 1098, t.afii10093 = 1099, t.afii10094 = 1100, t.afii10095 = 1101, t.afii10096 = 1102, t.afii10097 = 1103, t.afii10098 = 1169, t.afii10099 = 1106, t.afii10100 = 1107, t.afii10101 = 1108, t.afii10102 = 1109, t.afii10103 = 1110, t.afii10104 = 1111, t.afii10105 = 1112, t.afii10106 = 1113, t.afii10107 = 1114, t.afii10108 = 1115, t.afii10109 = 1116, t.afii10110 = 1118, t.afii10145 = 1039, t.afii10146 = 1122, t.afii10147 = 1138, t.afii10148 = 1140, t.afii10192 = 63174, t.afii10193 = 1119, t.afii10194 = 1123, t.afii10195 = 1139, t.afii10196 = 1141, t.afii10831 = 63175, t.afii10832 = 63176, t.afii10846 = 1241, t.afii299 = 8206, t.afii300 = 8207, t.afii301 = 8205, t.afii57381 = 1642, t.afii57388 = 1548, t.afii57392 = 1632, t.afii57393 = 1633, t.afii57394 = 1634, t.afii57395 = 1635, t.afii57396 = 1636, t.afii57397 = 1637, t.afii57398 = 1638, t.afii57399 = 1639, t.afii57400 = 1640, t.afii57401 = 1641, t.afii57403 = 1563, t.afii57407 = 1567, t.afii57409 = 1569, t.afii57410 = 1570, t.afii57411 = 1571, t.afii57412 = 1572, t.afii57413 = 1573, t.afii57414 = 1574, t.afii57415 = 1575, t.afii57416 = 1576, t.afii57417 = 1577, t.afii57418 = 1578, t.afii57419 = 1579, t.afii57420 = 1580, t.afii57421 = 1581, t.afii57422 = 1582, t.afii57423 = 1583, t.afii57424 = 1584, t.afii57425 = 1585, t.afii57426 = 1586, t.afii57427 = 1587, t.afii57428 = 1588, t.afii57429 = 1589, t.afii57430 = 1590, t.afii57431 = 1591, t.afii57432 = 1592, t.afii57433 = 1593, t.afii57434 = 1594, t.afii57440 = 1600, t.afii57441 = 1601, t.afii57442 = 1602, t.afii57443 = 1603, t.afii57444 = 1604, t.afii57445 = 1605, t.afii57446 = 1606, t.afii57448 = 1608, t.afii57449 = 1609, t.afii57450 = 1610, t.afii57451 = 1611, t.afii57452 = 1612, t.afii57453 = 1613, t.afii57454 = 1614, t.afii57455 = 1615, t.afii57456 = 1616, t.afii57457 = 1617, t.afii57458 = 1618, t.afii57470 = 1607, t.afii57505 = 1700, t.afii57506 = 1662, t.afii57507 = 1670, t.afii57508 = 1688, t.afii57509 = 1711, t.afii57511 = 1657, t.afii57512 = 1672, t.afii57513 = 1681, t.afii57514 = 1722, t.afii57519 = 1746, t.afii57534 = 1749, t.afii57636 = 8362, t.afii57645 = 1470, t.afii57658 = 1475, t.afii57664 = 1488, t.afii57665 = 1489, t.afii57666 = 1490, t.afii57667 = 1491, t.afii57668 = 1492, t.afii57669 = 1493, t.afii57670 = 1494, t.afii57671 = 1495, t.afii57672 = 1496, t.afii57673 = 1497, t.afii57674 = 1498, t.afii57675 = 1499, t.afii57676 = 1500, t.afii57677 = 1501, t.afii57678 = 1502, t.afii57679 = 1503, t.afii57680 = 1504, t.afii57681 = 1505, t.afii57682 = 1506, t.afii57683 = 1507, t.afii57684 = 1508, t.afii57685 = 1509, t.afii57686 = 1510, t.afii57687 = 1511, t.afii57688 = 1512, t.afii57689 = 1513, t.afii57690 = 1514, t.afii57694 = 64298, t.afii57695 = 64299, t.afii57700 = 64331, t.afii57705 = 64287, t.afii57716 = 1520, t.afii57717 = 1521, t.afii57718 = 1522, t.afii57723 = 64309, t.afii57793 = 1460, t.afii57794 = 1461, t.afii57795 = 1462, t.afii57796 = 1467, t.afii57797 = 1464, t.afii57798 = 1463, t.afii57799 = 1456, t.afii57800 = 1458, t.afii57801 = 1457, t.afii57802 = 1459, t.afii57803 = 1474, t.afii57804 = 1473, t.afii57806 = 1465, t.afii57807 = 1468, t.afii57839 = 1469, t.afii57841 = 1471, t.afii57842 = 1472, t.afii57929 = 700, t.afii61248 = 8453, t.afii61289 = 8467, t.afii61352 = 8470, t.afii61573 = 8236, t.afii61574 = 8237, t.afii61575 = 8238, t.afii61664 = 8204, t.afii63167 = 1645, t.afii64937 = 701, t.agrave = 224, t.agujarati = 2693, t.agurmukhi = 2565, t.ahiragana = 12354, t.ahookabove = 7843, t.aibengali = 2448, t.aibopomofo = 12574, t.aideva = 2320, t.aiecyrillic = 1237, t.aigujarati = 2704, t.aigurmukhi = 2576, t.aimatragurmukhi = 2632, t.ainarabic = 1593, t.ainfinalarabic = 65226, t.aininitialarabic = 65227, t.ainmedialarabic = 65228, t.ainvertedbreve = 515, t.aivowelsignbengali = 2504, t.aivowelsigndeva = 2376, t.aivowelsigngujarati = 2760, t.akatakana = 12450, t.akatakanahalfwidth = 65393, t.akorean = 12623, t.alef = 1488, t.alefarabic = 1575, t.alefdageshhebrew = 64304, t.aleffinalarabic = 65166, t.alefhamzaabovearabic = 1571, t.alefhamzaabovefinalarabic = 65156, t.alefhamzabelowarabic = 1573, t.alefhamzabelowfinalarabic = 65160, t.alefhebrew = 1488, t.aleflamedhebrew = 64335, t.alefmaddaabovearabic = 1570, t.alefmaddaabovefinalarabic = 65154, t.alefmaksuraarabic = 1609, t.alefmaksurafinalarabic = 65264, t.alefmaksurainitialarabic = 65267, t.alefmaksuramedialarabic = 65268, t.alefpatahhebrew = 64302, t.alefqamatshebrew = 64303, t.aleph = 8501, t.allequal = 8780, t.alpha = 945, t.alphatonos = 940, t.amacron = 257, t.amonospace = 65345, t.ampersand = 38, t.ampersandmonospace = 65286, t.ampersandsmall = 63270, t.amsquare = 13250, t.anbopomofo = 12578, t.angbopomofo = 12580, t.angbracketleft = 12296, t.angbracketright = 12297, t.angkhankhuthai = 3674, t.angle = 8736, t.anglebracketleft = 12296, t.anglebracketleftvertical = 65087, t.anglebracketright = 12297, t.anglebracketrightvertical = 65088, t.angleleft = 9001, t.angleright = 9002, t.angstrom = 8491, t.anoteleia = 903, t.anudattadeva = 2386, t.anusvarabengali = 2434, t.anusvaradeva = 2306, t.anusvaragujarati = 2690, t.aogonek = 261, t.apaatosquare = 13056, t.aparen = 9372, t.apostrophearmenian = 1370, t.apostrophemod = 700, t.apple = 63743, t.approaches = 8784, t.approxequal = 8776, t.approxequalorimage = 8786, t.approximatelyequal = 8773, t.araeaekorean = 12686, t.araeakorean = 12685, t.arc = 8978, t.arighthalfring = 7834, t.aring = 229, t.aringacute = 507, t.aringbelow = 7681, t.arrowboth = 8596, t.arrowdashdown = 8675, t.arrowdashleft = 8672, t.arrowdashright = 8674, t.arrowdashup = 8673, t.arrowdblboth = 8660, t.arrowdbldown = 8659, t.arrowdblleft = 8656, t.arrowdblright = 8658, t.arrowdblup = 8657, t.arrowdown = 8595, t.arrowdownleft = 8601, t.arrowdownright = 8600, t.arrowdownwhite = 8681, t.arrowheaddownmod = 709, t.arrowheadleftmod = 706, t.arrowheadrightmod = 707, t.arrowheadupmod = 708, t.arrowhorizex = 63719, t.arrowleft = 8592, t.arrowleftdbl = 8656, t.arrowleftdblstroke = 8653, t.arrowleftoverright = 8646, t.arrowleftwhite = 8678, t.arrowright = 8594, t.arrowrightdblstroke = 8655, t.arrowrightheavy = 10142, t.arrowrightoverleft = 8644, t.arrowrightwhite = 8680, t.arrowtableft = 8676, t.arrowtabright = 8677, t.arrowup = 8593, t.arrowupdn = 8597, t.arrowupdnbse = 8616, t.arrowupdownbase = 8616, t.arrowupleft = 8598, t.arrowupleftofdown = 8645, t.arrowupright = 8599, t.arrowupwhite = 8679, t.arrowvertex = 63718, t.asciicircum = 94, t.asciicircummonospace = 65342, t.asciitilde = 126, t.asciitildemonospace = 65374, t.ascript = 593, t.ascriptturned = 594, t.asmallhiragana = 12353, t.asmallkatakana = 12449, t.asmallkatakanahalfwidth = 65383, t.asterisk = 42, t.asteriskaltonearabic = 1645, t.asteriskarabic = 1645, t.asteriskmath = 8727, t.asteriskmonospace = 65290, t.asterisksmall = 65121, t.asterism = 8258, t.asuperior = 63209, t.asymptoticallyequal = 8771, t.at = 64, t.atilde = 227, t.atmonospace = 65312, t.atsmall = 65131, t.aturned = 592, t.aubengali = 2452, t.aubopomofo = 12576, t.audeva = 2324, t.augujarati = 2708, t.augurmukhi = 2580, t.aulengthmarkbengali = 2519, t.aumatragurmukhi = 2636, t.auvowelsignbengali = 2508, t.auvowelsigndeva = 2380, t.auvowelsigngujarati = 2764, t.avagrahadeva = 2365, t.aybarmenian = 1377, t.ayin = 1506, t.ayinaltonehebrew = 64288, t.ayinhebrew = 1506, t.b = 98, t.babengali = 2476, t.backslash = 92, t.backslashmonospace = 65340, t.badeva = 2348, t.bagujarati = 2732, t.bagurmukhi = 2604, t.bahiragana = 12400, t.bahtthai = 3647, t.bakatakana = 12496, t.bar = 124, t.barmonospace = 65372, t.bbopomofo = 12549, t.bcircle = 9425, t.bdotaccent = 7683, t.bdotbelow = 7685, t.beamedsixteenthnotes = 9836, t.because = 8757, t.becyrillic = 1073, t.beharabic = 1576, t.behfinalarabic = 65168, t.behinitialarabic = 65169, t.behiragana = 12409, t.behmedialarabic = 65170, t.behmeeminitialarabic = 64671, t.behmeemisolatedarabic = 64520, t.behnoonfinalarabic = 64621, t.bekatakana = 12505, t.benarmenian = 1378, t.bet = 1489, t.beta = 946, t.betasymbolgreek = 976, t.betdagesh = 64305, t.betdageshhebrew = 64305, t.bethebrew = 1489, t.betrafehebrew = 64332, t.bhabengali = 2477, t.bhadeva = 2349, t.bhagujarati = 2733, t.bhagurmukhi = 2605, t.bhook = 595, t.bihiragana = 12403, t.bikatakana = 12499, t.bilabialclick = 664, t.bindigurmukhi = 2562, t.birusquare = 13105, t.blackcircle = 9679, t.blackdiamond = 9670, t.blackdownpointingtriangle = 9660, t.blackleftpointingpointer = 9668, t.blackleftpointingtriangle = 9664, t.blacklenticularbracketleft = 12304, t.blacklenticularbracketleftvertical = 65083, t.blacklenticularbracketright = 12305, t.blacklenticularbracketrightvertical = 65084, t.blacklowerlefttriangle = 9699, t.blacklowerrighttriangle = 9698, t.blackrectangle = 9644, t.blackrightpointingpointer = 9658, t.blackrightpointingtriangle = 9654, t.blacksmallsquare = 9642, t.blacksmilingface = 9787, t.blacksquare = 9632, t.blackstar = 9733, t.blackupperlefttriangle = 9700, t.blackupperrighttriangle = 9701, t.blackuppointingsmalltriangle = 9652, t.blackuppointingtriangle = 9650, t.blank = 9251, t.blinebelow = 7687, t.block = 9608, t.bmonospace = 65346, t.bobaimaithai = 3610, t.bohiragana = 12412, t.bokatakana = 12508, t.bparen = 9373, t.bqsquare = 13251, t.braceex = 63732, t.braceleft = 123, t.braceleftbt = 63731, t.braceleftmid = 63730, t.braceleftmonospace = 65371, t.braceleftsmall = 65115, t.bracelefttp = 63729, t.braceleftvertical = 65079, t.braceright = 125, t.bracerightbt = 63742, t.bracerightmid = 63741, t.bracerightmonospace = 65373, t.bracerightsmall = 65116, t.bracerighttp = 63740, t.bracerightvertical = 65080, t.bracketleft = 91, t.bracketleftbt = 63728, t.bracketleftex = 63727, t.bracketleftmonospace = 65339, t.bracketlefttp = 63726, t.bracketright = 93, t.bracketrightbt = 63739, t.bracketrightex = 63738, t.bracketrightmonospace = 65341, t.bracketrighttp = 63737, t.breve = 728, t.brevebelowcmb = 814, t.brevecmb = 774, t.breveinvertedbelowcmb = 815, t.breveinvertedcmb = 785, t.breveinverteddoublecmb = 865, t.bridgebelowcmb = 810, t.bridgeinvertedbelowcmb = 826, t.brokenbar = 166, t.bstroke = 384, t.bsuperior = 63210, t.btopbar = 387, t.buhiragana = 12406, t.bukatakana = 12502, t.bullet = 8226, t.bulletinverse = 9688, t.bulletoperator = 8729, t.bullseye = 9678, t.c = 99, t.caarmenian = 1390, t.cabengali = 2458, t.cacute = 263, t.cadeva = 2330, t.cagujarati = 2714, t.cagurmukhi = 2586, t.calsquare = 13192, t.candrabindubengali = 2433, t.candrabinducmb = 784, t.candrabindudeva = 2305, t.candrabindugujarati = 2689, t.capslock = 8682, t.careof = 8453, t.caron = 711, t.caronbelowcmb = 812, t.caroncmb = 780, t.carriagereturn = 8629, t.cbopomofo = 12568, t.ccaron = 269, t.ccedilla = 231, t.ccedillaacute = 7689, t.ccircle = 9426, t.ccircumflex = 265, t.ccurl = 597, t.cdot = 267, t.cdotaccent = 267, t.cdsquare = 13253, t.cedilla = 184, t.cedillacmb = 807, t.cent = 162, t.centigrade = 8451, t.centinferior = 63199, t.centmonospace = 65504, t.centoldstyle = 63394, t.centsuperior = 63200, t.chaarmenian = 1401, t.chabengali = 2459, t.chadeva = 2331, t.chagujarati = 2715, t.chagurmukhi = 2587, t.chbopomofo = 12564, t.cheabkhasiancyrillic = 1213, t.checkmark = 10003, t.checyrillic = 1095, t.chedescenderabkhasiancyrillic = 1215, t.chedescendercyrillic = 1207, t.chedieresiscyrillic = 1269, t.cheharmenian = 1395, t.chekhakassiancyrillic = 1228, t.cheverticalstrokecyrillic = 1209, t.chi = 967, t.chieuchacirclekorean = 12919, t.chieuchaparenkorean = 12823, t.chieuchcirclekorean = 12905, t.chieuchkorean = 12618, t.chieuchparenkorean = 12809, t.chochangthai = 3594, t.chochanthai = 3592, t.chochingthai = 3593, t.chochoethai = 3596, t.chook = 392, t.cieucacirclekorean = 12918, t.cieucaparenkorean = 12822, t.cieuccirclekorean = 12904, t.cieuckorean = 12616, t.cieucparenkorean = 12808, t.cieucuparenkorean = 12828, t.circle = 9675, t.circlecopyrt = 169, t.circlemultiply = 8855, t.circleot = 8857, t.circleplus = 8853, t.circlepostalmark = 12342, t.circlewithlefthalfblack = 9680, t.circlewithrighthalfblack = 9681, t.circumflex = 710, t.circumflexbelowcmb = 813, t.circumflexcmb = 770, t.clear = 8999, t.clickalveolar = 450, t.clickdental = 448, t.clicklateral = 449, t.clickretroflex = 451, t.club = 9827, t.clubsuitblack = 9827, t.clubsuitwhite = 9831, t.cmcubedsquare = 13220, t.cmonospace = 65347, t.cmsquaredsquare = 13216, t.coarmenian = 1409, t.colon = 58, t.colonmonetary = 8353, t.colonmonospace = 65306, t.colonsign = 8353, t.colonsmall = 65109, t.colontriangularhalfmod = 721, t.colontriangularmod = 720, t.comma = 44, t.commaabovecmb = 787, t.commaaboverightcmb = 789, t.commaaccent = 63171, t.commaarabic = 1548, t.commaarmenian = 1373, t.commainferior = 63201, t.commamonospace = 65292, t.commareversedabovecmb = 788, t.commareversedmod = 701, t.commasmall = 65104, t.commasuperior = 63202, t.commaturnedabovecmb = 786, t.commaturnedmod = 699, t.compass = 9788, t.congruent = 8773, t.contourintegral = 8750, t.control = 8963, t.controlACK = 6, t.controlBEL = 7, t.controlBS = 8, t.controlCAN = 24, t.controlCR = 13, t.controlDC1 = 17, t.controlDC2 = 18, t.controlDC3 = 19, t.controlDC4 = 20, t.controlDEL = 127, t.controlDLE = 16, t.controlEM = 25, t.controlENQ = 5, t.controlEOT = 4, t.controlESC = 27, t.controlETB = 23, t.controlETX = 3, t.controlFF = 12, t.controlFS = 28, t.controlGS = 29, t.controlHT = 9, t.controlLF = 10, t.controlNAK = 21, t.controlNULL = 0, t.controlRS = 30, t.controlSI = 15, t.controlSO = 14, t.controlSOT = 2, t.controlSTX = 1, t.controlSUB = 26, t.controlSYN = 22, t.controlUS = 31, t.controlVT = 11, t.copyright = 169, t.copyrightsans = 63721, t.copyrightserif = 63193, t.cornerbracketleft = 12300, t.cornerbracketlefthalfwidth = 65378, t.cornerbracketleftvertical = 65089, t.cornerbracketright = 12301, t.cornerbracketrighthalfwidth = 65379, t.cornerbracketrightvertical = 65090, t.corporationsquare = 13183, t.cosquare = 13255, t.coverkgsquare = 13254, t.cparen = 9374, t.cruzeiro = 8354, t.cstretched = 663, t.curlyand = 8911, t.curlyor = 8910, t.currency = 164, t.cyrBreve = 63185, t.cyrFlex = 63186, t.cyrbreve = 63188, t.cyrflex = 63189, t.d = 100, t.daarmenian = 1380, t.dabengali = 2470, t.dadarabic = 1590, t.dadeva = 2342, t.dadfinalarabic = 65214, t.dadinitialarabic = 65215, t.dadmedialarabic = 65216, t.dagesh = 1468, t.dageshhebrew = 1468, t.dagger = 8224, t.daggerdbl = 8225, t.dagujarati = 2726, t.dagurmukhi = 2598, t.dahiragana = 12384, t.dakatakana = 12480, t.dalarabic = 1583, t.dalet = 1491, t.daletdagesh = 64307, t.daletdageshhebrew = 64307, t.dalethebrew = 1491, t.dalfinalarabic = 65194, t.dammaarabic = 1615, t.dammalowarabic = 1615, t.dammatanaltonearabic = 1612, t.dammatanarabic = 1612, t.danda = 2404, t.dargahebrew = 1447, t.dargalefthebrew = 1447, t.dasiapneumatacyrilliccmb = 1157, t.dblGrave = 63187, t.dblanglebracketleft = 12298, t.dblanglebracketleftvertical = 65085, t.dblanglebracketright = 12299, t.dblanglebracketrightvertical = 65086, t.dblarchinvertedbelowcmb = 811, t.dblarrowleft = 8660, t.dblarrowright = 8658, t.dbldanda = 2405, t.dblgrave = 63190, t.dblgravecmb = 783, t.dblintegral = 8748, t.dbllowline = 8215, t.dbllowlinecmb = 819, t.dbloverlinecmb = 831, t.dblprimemod = 698, t.dblverticalbar = 8214, t.dblverticallineabovecmb = 782, t.dbopomofo = 12553, t.dbsquare = 13256, t.dcaron = 271, t.dcedilla = 7697, t.dcircle = 9427, t.dcircumflexbelow = 7699, t.dcroat = 273, t.ddabengali = 2465, t.ddadeva = 2337, t.ddagujarati = 2721, t.ddagurmukhi = 2593, t.ddalarabic = 1672, t.ddalfinalarabic = 64393, t.dddhadeva = 2396, t.ddhabengali = 2466, t.ddhadeva = 2338, t.ddhagujarati = 2722, t.ddhagurmukhi = 2594, t.ddotaccent = 7691, t.ddotbelow = 7693, t.decimalseparatorarabic = 1643, t.decimalseparatorpersian = 1643, t.decyrillic = 1076, t.degree = 176, t.dehihebrew = 1453, t.dehiragana = 12391, t.deicoptic = 1007, t.dekatakana = 12487, t.deleteleft = 9003, t.deleteright = 8998, t.delta = 948, t.deltaturned = 397, t.denominatorminusonenumeratorbengali = 2552, t.dezh = 676, t.dhabengali = 2471, t.dhadeva = 2343, t.dhagujarati = 2727, t.dhagurmukhi = 2599, t.dhook = 599, t.dialytikatonos = 901, t.dialytikatonoscmb = 836, t.diamond = 9830, t.diamondsuitwhite = 9826, t.dieresis = 168, t.dieresisacute = 63191, t.dieresisbelowcmb = 804, t.dieresiscmb = 776, t.dieresisgrave = 63192, t.dieresistonos = 901, t.dihiragana = 12386, t.dikatakana = 12482, t.dittomark = 12291, t.divide = 247, t.divides = 8739, t.divisionslash = 8725, t.djecyrillic = 1106, t.dkshade = 9619, t.dlinebelow = 7695, t.dlsquare = 13207, t.dmacron = 273, t.dmonospace = 65348, t.dnblock = 9604, t.dochadathai = 3598, t.dodekthai = 3604, t.dohiragana = 12393, t.dokatakana = 12489, t.dollar = 36, t.dollarinferior = 63203, t.dollarmonospace = 65284, t.dollaroldstyle = 63268, t.dollarsmall = 65129, t.dollarsuperior = 63204, t.dong = 8363, t.dorusquare = 13094, t.dotaccent = 729, t.dotaccentcmb = 775, t.dotbelowcmb = 803, t.dotbelowcomb = 803, t.dotkatakana = 12539, t.dotlessi = 305, t.dotlessj = 63166, t.dotlessjstrokehook = 644, t.dotmath = 8901, t.dottedcircle = 9676, t.doubleyodpatah = 64287, t.doubleyodpatahhebrew = 64287, t.downtackbelowcmb = 798, t.downtackmod = 725, t.dparen = 9375, t.dsuperior = 63211, t.dtail = 598, t.dtopbar = 396, t.duhiragana = 12389, t.dukatakana = 12485, t.dz = 499, t.dzaltone = 675, t.dzcaron = 454, t.dzcurl = 677, t.dzeabkhasiancyrillic = 1249, t.dzecyrillic = 1109, t.dzhecyrillic = 1119, t.e = 101, t.eacute = 233, t.earth = 9793, t.ebengali = 2447, t.ebopomofo = 12572, t.ebreve = 277, t.ecandradeva = 2317, t.ecandragujarati = 2701, t.ecandravowelsigndeva = 2373, t.ecandravowelsigngujarati = 2757, t.ecaron = 283, t.ecedillabreve = 7709, t.echarmenian = 1381, t.echyiwnarmenian = 1415, t.ecircle = 9428, t.ecircumflex = 234, t.ecircumflexacute = 7871, t.ecircumflexbelow = 7705, t.ecircumflexdotbelow = 7879, t.ecircumflexgrave = 7873, t.ecircumflexhookabove = 7875, t.ecircumflextilde = 7877, t.ecyrillic = 1108, t.edblgrave = 517, t.edeva = 2319, t.edieresis = 235, t.edot = 279, t.edotaccent = 279, t.edotbelow = 7865, t.eegurmukhi = 2575, t.eematragurmukhi = 2631, t.efcyrillic = 1092, t.egrave = 232, t.egujarati = 2703, t.eharmenian = 1383, t.ehbopomofo = 12573, t.ehiragana = 12360, t.ehookabove = 7867, t.eibopomofo = 12575, t.eight = 56, t.eightarabic = 1640, t.eightbengali = 2542, t.eightcircle = 9319, t.eightcircleinversesansserif = 10129, t.eightdeva = 2414, t.eighteencircle = 9329, t.eighteenparen = 9349, t.eighteenperiod = 9369, t.eightgujarati = 2798, t.eightgurmukhi = 2670, t.eighthackarabic = 1640, t.eighthangzhou = 12328, t.eighthnotebeamed = 9835, t.eightideographicparen = 12839, t.eightinferior = 8328, t.eightmonospace = 65304, t.eightoldstyle = 63288, t.eightparen = 9339, t.eightperiod = 9359, t.eightpersian = 1784, t.eightroman = 8567, t.eightsuperior = 8312, t.eightthai = 3672, t.einvertedbreve = 519, t.eiotifiedcyrillic = 1125, t.ekatakana = 12456, t.ekatakanahalfwidth = 65396, t.ekonkargurmukhi = 2676, t.ekorean = 12628, t.elcyrillic = 1083, t.element = 8712, t.elevencircle = 9322, t.elevenparen = 9342, t.elevenperiod = 9362, t.elevenroman = 8570, t.ellipsis = 8230, t.ellipsisvertical = 8942, t.emacron = 275, t.emacronacute = 7703, t.emacrongrave = 7701, t.emcyrillic = 1084, t.emdash = 8212, t.emdashvertical = 65073, t.emonospace = 65349, t.emphasismarkarmenian = 1371, t.emptyset = 8709, t.enbopomofo = 12579, t.encyrillic = 1085, t.endash = 8211, t.endashvertical = 65074, t.endescendercyrillic = 1187, t.eng = 331, t.engbopomofo = 12581, t.enghecyrillic = 1189, t.enhookcyrillic = 1224, t.enspace = 8194, t.eogonek = 281, t.eokorean = 12627, t.eopen = 603, t.eopenclosed = 666, t.eopenreversed = 604, t.eopenreversedclosed = 606, t.eopenreversedhook = 605, t.eparen = 9376, t.epsilon = 949, t.epsilontonos = 941, t.equal = 61, t.equalmonospace = 65309, t.equalsmall = 65126, t.equalsuperior = 8316, t.equivalence = 8801, t.erbopomofo = 12582, t.ercyrillic = 1088, t.ereversed = 600, t.ereversedcyrillic = 1101, t.escyrillic = 1089, t.esdescendercyrillic = 1195, t.esh = 643, t.eshcurl = 646, t.eshortdeva = 2318, t.eshortvowelsigndeva = 2374, t.eshreversedloop = 426, t.eshsquatreversed = 645, t.esmallhiragana = 12359, t.esmallkatakana = 12455, t.esmallkatakanahalfwidth = 65386, t.estimated = 8494, t.esuperior = 63212, t.eta = 951, t.etarmenian = 1384, t.etatonos = 942, t.eth = 240, t.etilde = 7869, t.etildebelow = 7707, t.etnahtafoukhhebrew = 1425, t.etnahtafoukhlefthebrew = 1425, t.etnahtahebrew = 1425, t.etnahtalefthebrew = 1425, t.eturned = 477, t.eukorean = 12641, t.euro = 8364, t.evowelsignbengali = 2503, t.evowelsigndeva = 2375, t.evowelsigngujarati = 2759, t.exclam = 33, t.exclamarmenian = 1372, t.exclamdbl = 8252, t.exclamdown = 161, t.exclamdownsmall = 63393, t.exclammonospace = 65281, t.exclamsmall = 63265, t.existential = 8707, t.ezh = 658, t.ezhcaron = 495, t.ezhcurl = 659, t.ezhreversed = 441, t.ezhtail = 442, t.f = 102, t.fadeva = 2398, t.fagurmukhi = 2654, t.fahrenheit = 8457, t.fathaarabic = 1614, t.fathalowarabic = 1614, t.fathatanarabic = 1611, t.fbopomofo = 12552, t.fcircle = 9429, t.fdotaccent = 7711, t.feharabic = 1601, t.feharmenian = 1414, t.fehfinalarabic = 65234, t.fehinitialarabic = 65235, t.fehmedialarabic = 65236, t.feicoptic = 997, t.female = 9792, t.ff = 64256, t.f_f = 64256, t.ffi = 64259, t.f_f_i = 64259, t.ffl = 64260, t.f_f_l = 64260, t.fi = 64257, t.f_i = 64257, t.fifteencircle = 9326, t.fifteenparen = 9346, t.fifteenperiod = 9366, t.figuredash = 8210, t.filledbox = 9632, t.filledrect = 9644, t.finalkaf = 1498, t.finalkafdagesh = 64314, t.finalkafdageshhebrew = 64314, t.finalkafhebrew = 1498, t.finalmem = 1501, t.finalmemhebrew = 1501, t.finalnun = 1503, t.finalnunhebrew = 1503, t.finalpe = 1507, t.finalpehebrew = 1507, t.finaltsadi = 1509, t.finaltsadihebrew = 1509, t.firsttonechinese = 713, t.fisheye = 9673, t.fitacyrillic = 1139, t.five = 53, t.fivearabic = 1637, t.fivebengali = 2539, t.fivecircle = 9316, t.fivecircleinversesansserif = 10126, t.fivedeva = 2411, t.fiveeighths = 8541, t.fivegujarati = 2795, t.fivegurmukhi = 2667, t.fivehackarabic = 1637, t.fivehangzhou = 12325, t.fiveideographicparen = 12836, t.fiveinferior = 8325, t.fivemonospace = 65301, t.fiveoldstyle = 63285, t.fiveparen = 9336, t.fiveperiod = 9356, t.fivepersian = 1781, t.fiveroman = 8564, t.fivesuperior = 8309, t.fivethai = 3669, t.fl = 64258, t.f_l = 64258, t.florin = 402, t.fmonospace = 65350, t.fmsquare = 13209, t.fofanthai = 3615, t.fofathai = 3613, t.fongmanthai = 3663, t.forall = 8704, t.four = 52, t.fourarabic = 1636, t.fourbengali = 2538, t.fourcircle = 9315, t.fourcircleinversesansserif = 10125, t.fourdeva = 2410, t.fourgujarati = 2794, t.fourgurmukhi = 2666, t.fourhackarabic = 1636, t.fourhangzhou = 12324, t.fourideographicparen = 12835, t.fourinferior = 8324, t.fourmonospace = 65300, t.fournumeratorbengali = 2551, t.fouroldstyle = 63284, t.fourparen = 9335, t.fourperiod = 9355, t.fourpersian = 1780, t.fourroman = 8563, t.foursuperior = 8308, t.fourteencircle = 9325, t.fourteenparen = 9345, t.fourteenperiod = 9365, t.fourthai = 3668, t.fourthtonechinese = 715, t.fparen = 9377, t.fraction = 8260, t.franc = 8355, t.g = 103, t.gabengali = 2455, t.gacute = 501, t.gadeva = 2327, t.gafarabic = 1711, t.gaffinalarabic = 64403, t.gafinitialarabic = 64404, t.gafmedialarabic = 64405, t.gagujarati = 2711, t.gagurmukhi = 2583, t.gahiragana = 12364, t.gakatakana = 12460, t.gamma = 947, t.gammalatinsmall = 611, t.gammasuperior = 736, t.gangiacoptic = 1003, t.gbopomofo = 12557, t.gbreve = 287, t.gcaron = 487, t.gcedilla = 291, t.gcircle = 9430, t.gcircumflex = 285, t.gcommaaccent = 291, t.gdot = 289, t.gdotaccent = 289, t.gecyrillic = 1075, t.gehiragana = 12370, t.gekatakana = 12466, t.geometricallyequal = 8785, t.gereshaccenthebrew = 1436, t.gereshhebrew = 1523, t.gereshmuqdamhebrew = 1437, t.germandbls = 223, t.gershayimaccenthebrew = 1438, t.gershayimhebrew = 1524, t.getamark = 12307, t.ghabengali = 2456, t.ghadarmenian = 1394, t.ghadeva = 2328, t.ghagujarati = 2712, t.ghagurmukhi = 2584, t.ghainarabic = 1594, t.ghainfinalarabic = 65230, t.ghaininitialarabic = 65231, t.ghainmedialarabic = 65232, t.ghemiddlehookcyrillic = 1173, t.ghestrokecyrillic = 1171, t.gheupturncyrillic = 1169, t.ghhadeva = 2394, t.ghhagurmukhi = 2650, t.ghook = 608, t.ghzsquare = 13203, t.gihiragana = 12366, t.gikatakana = 12462, t.gimarmenian = 1379, t.gimel = 1490, t.gimeldagesh = 64306, t.gimeldageshhebrew = 64306, t.gimelhebrew = 1490, t.gjecyrillic = 1107, t.glottalinvertedstroke = 446, t.glottalstop = 660, t.glottalstopinverted = 662, t.glottalstopmod = 704, t.glottalstopreversed = 661, t.glottalstopreversedmod = 705, t.glottalstopreversedsuperior = 740, t.glottalstopstroke = 673, t.glottalstopstrokereversed = 674, t.gmacron = 7713, t.gmonospace = 65351, t.gohiragana = 12372, t.gokatakana = 12468, t.gparen = 9378, t.gpasquare = 13228, t.gradient = 8711, t.grave = 96, t.gravebelowcmb = 790, t.gravecmb = 768, t.gravecomb = 768, t.gravedeva = 2387, t.gravelowmod = 718, t.gravemonospace = 65344, t.gravetonecmb = 832, t.greater = 62, t.greaterequal = 8805, t.greaterequalorless = 8923, t.greatermonospace = 65310, t.greaterorequivalent = 8819, t.greaterorless = 8823, t.greateroverequal = 8807, t.greatersmall = 65125, t.gscript = 609, t.gstroke = 485, t.guhiragana = 12368, t.guillemotleft = 171, t.guillemotright = 187, t.guilsinglleft = 8249, t.guilsinglright = 8250, t.gukatakana = 12464, t.guramusquare = 13080, t.gysquare = 13257, t.h = 104, t.haabkhasiancyrillic = 1193, t.haaltonearabic = 1729, t.habengali = 2489, t.hadescendercyrillic = 1203, t.hadeva = 2361, t.hagujarati = 2745, t.hagurmukhi = 2617, t.haharabic = 1581, t.hahfinalarabic = 65186, t.hahinitialarabic = 65187, t.hahiragana = 12399, t.hahmedialarabic = 65188, t.haitusquare = 13098, t.hakatakana = 12495, t.hakatakanahalfwidth = 65418, t.halantgurmukhi = 2637, t.hamzaarabic = 1569, t.hamzalowarabic = 1569, t.hangulfiller = 12644, t.hardsigncyrillic = 1098, t.harpoonleftbarbup = 8636, t.harpoonrightbarbup = 8640, t.hasquare = 13258, t.hatafpatah = 1458, t.hatafpatah16 = 1458, t.hatafpatah23 = 1458, t.hatafpatah2f = 1458, t.hatafpatahhebrew = 1458, t.hatafpatahnarrowhebrew = 1458, t.hatafpatahquarterhebrew = 1458, t.hatafpatahwidehebrew = 1458, t.hatafqamats = 1459, t.hatafqamats1b = 1459, t.hatafqamats28 = 1459, t.hatafqamats34 = 1459, t.hatafqamatshebrew = 1459, t.hatafqamatsnarrowhebrew = 1459, t.hatafqamatsquarterhebrew = 1459, t.hatafqamatswidehebrew = 1459, t.hatafsegol = 1457, t.hatafsegol17 = 1457, t.hatafsegol24 = 1457, t.hatafsegol30 = 1457, t.hatafsegolhebrew = 1457, t.hatafsegolnarrowhebrew = 1457, t.hatafsegolquarterhebrew = 1457, t.hatafsegolwidehebrew = 1457, t.hbar = 295, t.hbopomofo = 12559, t.hbrevebelow = 7723, t.hcedilla = 7721, t.hcircle = 9431, t.hcircumflex = 293, t.hdieresis = 7719, t.hdotaccent = 7715, t.hdotbelow = 7717, t.he = 1492, t.heart = 9829, t.heartsuitblack = 9829, t.heartsuitwhite = 9825, t.hedagesh = 64308, t.hedageshhebrew = 64308, t.hehaltonearabic = 1729, t.heharabic = 1607, t.hehebrew = 1492, t.hehfinalaltonearabic = 64423, t.hehfinalalttwoarabic = 65258, t.hehfinalarabic = 65258, t.hehhamzaabovefinalarabic = 64421, t.hehhamzaaboveisolatedarabic = 64420, t.hehinitialaltonearabic = 64424, t.hehinitialarabic = 65259, t.hehiragana = 12408, t.hehmedialaltonearabic = 64425, t.hehmedialarabic = 65260, t.heiseierasquare = 13179, t.hekatakana = 12504, t.hekatakanahalfwidth = 65421, t.hekutaarusquare = 13110, t.henghook = 615, t.herutusquare = 13113, t.het = 1495, t.hethebrew = 1495, t.hhook = 614, t.hhooksuperior = 689, t.hieuhacirclekorean = 12923, t.hieuhaparenkorean = 12827, t.hieuhcirclekorean = 12909, t.hieuhkorean = 12622, t.hieuhparenkorean = 12813, t.hihiragana = 12402, t.hikatakana = 12498, t.hikatakanahalfwidth = 65419, t.hiriq = 1460, t.hiriq14 = 1460, t.hiriq21 = 1460, t.hiriq2d = 1460, t.hiriqhebrew = 1460, t.hiriqnarrowhebrew = 1460, t.hiriqquarterhebrew = 1460, t.hiriqwidehebrew = 1460, t.hlinebelow = 7830, t.hmonospace = 65352, t.hoarmenian = 1392, t.hohipthai = 3627, t.hohiragana = 12411, t.hokatakana = 12507, t.hokatakanahalfwidth = 65422, t.holam = 1465, t.holam19 = 1465, t.holam26 = 1465, t.holam32 = 1465, t.holamhebrew = 1465, t.holamnarrowhebrew = 1465, t.holamquarterhebrew = 1465, t.holamwidehebrew = 1465, t.honokhukthai = 3630, t.hookabovecomb = 777, t.hookcmb = 777, t.hookpalatalizedbelowcmb = 801, t.hookretroflexbelowcmb = 802, t.hoonsquare = 13122, t.horicoptic = 1001, t.horizontalbar = 8213, t.horncmb = 795, t.hotsprings = 9832, t.house = 8962, t.hparen = 9379, t.hsuperior = 688, t.hturned = 613, t.huhiragana = 12405, t.huiitosquare = 13107, t.hukatakana = 12501, t.hukatakanahalfwidth = 65420, t.hungarumlaut = 733, t.hungarumlautcmb = 779, t.hv = 405, t.hyphen = 45, t.hypheninferior = 63205, t.hyphenmonospace = 65293, t.hyphensmall = 65123, t.hyphensuperior = 63206, t.hyphentwo = 8208, t.i = 105, t.iacute = 237, t.iacyrillic = 1103, t.ibengali = 2439, t.ibopomofo = 12583, t.ibreve = 301, t.icaron = 464, t.icircle = 9432, t.icircumflex = 238, t.icyrillic = 1110, t.idblgrave = 521, t.ideographearthcircle = 12943, t.ideographfirecircle = 12939, t.ideographicallianceparen = 12863, t.ideographiccallparen = 12858, t.ideographiccentrecircle = 12965, t.ideographicclose = 12294, t.ideographiccomma = 12289, t.ideographiccommaleft = 65380, t.ideographiccongratulationparen = 12855, t.ideographiccorrectcircle = 12963, t.ideographicearthparen = 12847, t.ideographicenterpriseparen = 12861, t.ideographicexcellentcircle = 12957, t.ideographicfestivalparen = 12864, t.ideographicfinancialcircle = 12950, t.ideographicfinancialparen = 12854, t.ideographicfireparen = 12843, t.ideographichaveparen = 12850, t.ideographichighcircle = 12964, t.ideographiciterationmark = 12293, t.ideographiclaborcircle = 12952, t.ideographiclaborparen = 12856, t.ideographicleftcircle = 12967, t.ideographiclowcircle = 12966, t.ideographicmedicinecircle = 12969, t.ideographicmetalparen = 12846, t.ideographicmoonparen = 12842, t.ideographicnameparen = 12852, t.ideographicperiod = 12290, t.ideographicprintcircle = 12958, t.ideographicreachparen = 12867, t.ideographicrepresentparen = 12857, t.ideographicresourceparen = 12862, t.ideographicrightcircle = 12968, t.ideographicsecretcircle = 12953, t.ideographicselfparen = 12866, t.ideographicsocietyparen = 12851, t.ideographicspace = 12288, t.ideographicspecialparen = 12853, t.ideographicstockparen = 12849, t.ideographicstudyparen = 12859, t.ideographicsunparen = 12848, t.ideographicsuperviseparen = 12860, t.ideographicwaterparen = 12844, t.ideographicwoodparen = 12845, t.ideographiczero = 12295, t.ideographmetalcircle = 12942, t.ideographmooncircle = 12938, t.ideographnamecircle = 12948, t.ideographsuncircle = 12944, t.ideographwatercircle = 12940, t.ideographwoodcircle = 12941, t.ideva = 2311, t.idieresis = 239, t.idieresisacute = 7727, t.idieresiscyrillic = 1253, t.idotbelow = 7883, t.iebrevecyrillic = 1239, t.iecyrillic = 1077, t.ieungacirclekorean = 12917, t.ieungaparenkorean = 12821, t.ieungcirclekorean = 12903, t.ieungkorean = 12615, t.ieungparenkorean = 12807, t.igrave = 236, t.igujarati = 2695, t.igurmukhi = 2567, t.ihiragana = 12356, t.ihookabove = 7881, t.iibengali = 2440, t.iicyrillic = 1080, t.iideva = 2312, t.iigujarati = 2696, t.iigurmukhi = 2568, t.iimatragurmukhi = 2624, t.iinvertedbreve = 523, t.iishortcyrillic = 1081, t.iivowelsignbengali = 2496, t.iivowelsigndeva = 2368, t.iivowelsigngujarati = 2752, t.ij = 307, t.ikatakana = 12452, t.ikatakanahalfwidth = 65394, t.ikorean = 12643, t.ilde = 732, t.iluyhebrew = 1452, t.imacron = 299, t.imacroncyrillic = 1251, t.imageorapproximatelyequal = 8787, t.imatragurmukhi = 2623, t.imonospace = 65353, t.increment = 8710, t.infinity = 8734, t.iniarmenian = 1387, t.integral = 8747, t.integralbottom = 8993, t.integralbt = 8993, t.integralex = 63733, t.integraltop = 8992, t.integraltp = 8992, t.intersection = 8745, t.intisquare = 13061, t.invbullet = 9688, t.invcircle = 9689, t.invsmileface = 9787, t.iocyrillic = 1105, t.iogonek = 303, t.iota = 953, t.iotadieresis = 970, t.iotadieresistonos = 912, t.iotalatin = 617, t.iotatonos = 943, t.iparen = 9380, t.irigurmukhi = 2674, t.ismallhiragana = 12355, t.ismallkatakana = 12451, t.ismallkatakanahalfwidth = 65384, t.issharbengali = 2554, t.istroke = 616, t.isuperior = 63213, t.iterationhiragana = 12445, t.iterationkatakana = 12541, t.itilde = 297, t.itildebelow = 7725, t.iubopomofo = 12585, t.iucyrillic = 1102, t.ivowelsignbengali = 2495, t.ivowelsigndeva = 2367, t.ivowelsigngujarati = 2751, t.izhitsacyrillic = 1141, t.izhitsadblgravecyrillic = 1143, t.j = 106, t.jaarmenian = 1393, t.jabengali = 2460, t.jadeva = 2332, t.jagujarati = 2716, t.jagurmukhi = 2588, t.jbopomofo = 12560, t.jcaron = 496, t.jcircle = 9433, t.jcircumflex = 309, t.jcrossedtail = 669, t.jdotlessstroke = 607, t.jecyrillic = 1112, t.jeemarabic = 1580, t.jeemfinalarabic = 65182, t.jeeminitialarabic = 65183, t.jeemmedialarabic = 65184, t.jeharabic = 1688, t.jehfinalarabic = 64395, t.jhabengali = 2461, t.jhadeva = 2333, t.jhagujarati = 2717, t.jhagurmukhi = 2589, t.jheharmenian = 1403, t.jis = 12292, t.jmonospace = 65354, t.jparen = 9381, t.jsuperior = 690, t.k = 107, t.kabashkircyrillic = 1185, t.kabengali = 2453, t.kacute = 7729, t.kacyrillic = 1082, t.kadescendercyrillic = 1179, t.kadeva = 2325, t.kaf = 1499, t.kafarabic = 1603, t.kafdagesh = 64315, t.kafdageshhebrew = 64315, t.kaffinalarabic = 65242, t.kafhebrew = 1499, t.kafinitialarabic = 65243, t.kafmedialarabic = 65244, t.kafrafehebrew = 64333, t.kagujarati = 2709, t.kagurmukhi = 2581, t.kahiragana = 12363, t.kahookcyrillic = 1220, t.kakatakana = 12459, t.kakatakanahalfwidth = 65398, t.kappa = 954, t.kappasymbolgreek = 1008, t.kapyeounmieumkorean = 12657, t.kapyeounphieuphkorean = 12676, t.kapyeounpieupkorean = 12664, t.kapyeounssangpieupkorean = 12665, t.karoriisquare = 13069, t.kashidaautoarabic = 1600, t.kashidaautonosidebearingarabic = 1600, t.kasmallkatakana = 12533, t.kasquare = 13188, t.kasraarabic = 1616, t.kasratanarabic = 1613, t.kastrokecyrillic = 1183, t.katahiraprolongmarkhalfwidth = 65392, t.kaverticalstrokecyrillic = 1181, t.kbopomofo = 12558, t.kcalsquare = 13193, t.kcaron = 489, t.kcedilla = 311, t.kcircle = 9434, t.kcommaaccent = 311, t.kdotbelow = 7731, t.keharmenian = 1412, t.kehiragana = 12369, t.kekatakana = 12465, t.kekatakanahalfwidth = 65401, t.kenarmenian = 1391, t.kesmallkatakana = 12534, t.kgreenlandic = 312, t.khabengali = 2454, t.khacyrillic = 1093, t.khadeva = 2326, t.khagujarati = 2710, t.khagurmukhi = 2582, t.khaharabic = 1582, t.khahfinalarabic = 65190, t.khahinitialarabic = 65191, t.khahmedialarabic = 65192, t.kheicoptic = 999, t.khhadeva = 2393, t.khhagurmukhi = 2649, t.khieukhacirclekorean = 12920, t.khieukhaparenkorean = 12824, t.khieukhcirclekorean = 12906, t.khieukhkorean = 12619, t.khieukhparenkorean = 12810, t.khokhaithai = 3586, t.khokhonthai = 3589, t.khokhuatthai = 3587, t.khokhwaithai = 3588, t.khomutthai = 3675, t.khook = 409, t.khorakhangthai = 3590, t.khzsquare = 13201, t.kihiragana = 12365, t.kikatakana = 12461, t.kikatakanahalfwidth = 65399, t.kiroguramusquare = 13077, t.kiromeetorusquare = 13078, t.kirosquare = 13076, t.kiyeokacirclekorean = 12910, t.kiyeokaparenkorean = 12814, t.kiyeokcirclekorean = 12896, t.kiyeokkorean = 12593, t.kiyeokparenkorean = 12800, t.kiyeoksioskorean = 12595, t.kjecyrillic = 1116, t.klinebelow = 7733, t.klsquare = 13208, t.kmcubedsquare = 13222, t.kmonospace = 65355, t.kmsquaredsquare = 13218, t.kohiragana = 12371, t.kohmsquare = 13248, t.kokaithai = 3585, t.kokatakana = 12467, t.kokatakanahalfwidth = 65402, t.kooposquare = 13086, t.koppacyrillic = 1153, t.koreanstandardsymbol = 12927, t.koroniscmb = 835, t.kparen = 9382, t.kpasquare = 13226, t.ksicyrillic = 1135, t.ktsquare = 13263, t.kturned = 670, t.kuhiragana = 12367, t.kukatakana = 12463, t.kukatakanahalfwidth = 65400, t.kvsquare = 13240, t.kwsquare = 13246, t.l = 108, t.labengali = 2482, t.lacute = 314, t.ladeva = 2354, t.lagujarati = 2738, t.lagurmukhi = 2610, t.lakkhangyaothai = 3653, t.lamaleffinalarabic = 65276, t.lamalefhamzaabovefinalarabic = 65272, t.lamalefhamzaaboveisolatedarabic = 65271, t.lamalefhamzabelowfinalarabic = 65274, t.lamalefhamzabelowisolatedarabic = 65273, t.lamalefisolatedarabic = 65275, t.lamalefmaddaabovefinalarabic = 65270, t.lamalefmaddaaboveisolatedarabic = 65269, t.lamarabic = 1604, t.lambda = 955, t.lambdastroke = 411, t.lamed = 1500, t.lameddagesh = 64316, t.lameddageshhebrew = 64316, t.lamedhebrew = 1500, t.lamfinalarabic = 65246, t.lamhahinitialarabic = 64714, t.laminitialarabic = 65247, t.lamjeeminitialarabic = 64713, t.lamkhahinitialarabic = 64715, t.lamlamhehisolatedarabic = 65010, t.lammedialarabic = 65248, t.lammeemhahinitialarabic = 64904, t.lammeeminitialarabic = 64716, t.largecircle = 9711, t.lbar = 410, t.lbelt = 620, t.lbopomofo = 12556, t.lcaron = 318, t.lcedilla = 316, t.lcircle = 9435, t.lcircumflexbelow = 7741, t.lcommaaccent = 316, t.ldot = 320, t.ldotaccent = 320, t.ldotbelow = 7735, t.ldotbelowmacron = 7737, t.leftangleabovecmb = 794, t.lefttackbelowcmb = 792, t.less = 60, t.lessequal = 8804, t.lessequalorgreater = 8922, t.lessmonospace = 65308, t.lessorequivalent = 8818, t.lessorgreater = 8822, t.lessoverequal = 8806, t.lesssmall = 65124, t.lezh = 622, t.lfblock = 9612, t.lhookretroflex = 621, t.lira = 8356, t.liwnarmenian = 1388, t.lj = 457, t.ljecyrillic = 1113, t.ll = 63168, t.lladeva = 2355, t.llagujarati = 2739, t.llinebelow = 7739, t.llladeva = 2356, t.llvocalicbengali = 2529, t.llvocalicdeva = 2401, t.llvocalicvowelsignbengali = 2531, t.llvocalicvowelsigndeva = 2403, t.lmiddletilde = 619, t.lmonospace = 65356, t.lmsquare = 13264, t.lochulathai = 3628, t.logicaland = 8743, t.logicalnot = 172, t.logicalnotreversed = 8976, t.logicalor = 8744, t.lolingthai = 3621, t.longs = 383, t.lowlinecenterline = 65102, t.lowlinecmb = 818, t.lowlinedashed = 65101, t.lozenge = 9674, t.lparen = 9383, t.lslash = 322, t.lsquare = 8467, t.lsuperior = 63214, t.ltshade = 9617, t.luthai = 3622, t.lvocalicbengali = 2444, t.lvocalicdeva = 2316, t.lvocalicvowelsignbengali = 2530, t.lvocalicvowelsigndeva = 2402, t.lxsquare = 13267, t.m = 109, t.mabengali = 2478, t.macron = 175, t.macronbelowcmb = 817, t.macroncmb = 772, t.macronlowmod = 717, t.macronmonospace = 65507, t.macute = 7743, t.madeva = 2350, t.magujarati = 2734, t.magurmukhi = 2606, t.mahapakhhebrew = 1444, t.mahapakhlefthebrew = 1444, t.mahiragana = 12414, t.maichattawalowleftthai = 63637, t.maichattawalowrightthai = 63636, t.maichattawathai = 3659, t.maichattawaupperleftthai = 63635, t.maieklowleftthai = 63628, t.maieklowrightthai = 63627, t.maiekthai = 3656, t.maiekupperleftthai = 63626, t.maihanakatleftthai = 63620, t.maihanakatthai = 3633, t.maitaikhuleftthai = 63625, t.maitaikhuthai = 3655, t.maitholowleftthai = 63631, t.maitholowrightthai = 63630, t.maithothai = 3657, t.maithoupperleftthai = 63629, t.maitrilowleftthai = 63634, t.maitrilowrightthai = 63633, t.maitrithai = 3658, t.maitriupperleftthai = 63632, t.maiyamokthai = 3654, t.makatakana = 12510, t.makatakanahalfwidth = 65423, t.male = 9794, t.mansyonsquare = 13127, t.maqafhebrew = 1470, t.mars = 9794, t.masoracirclehebrew = 1455, t.masquare = 13187, t.mbopomofo = 12551, t.mbsquare = 13268, t.mcircle = 9436, t.mcubedsquare = 13221, t.mdotaccent = 7745, t.mdotbelow = 7747, t.meemarabic = 1605, t.meemfinalarabic = 65250, t.meeminitialarabic = 65251, t.meemmedialarabic = 65252, t.meemmeeminitialarabic = 64721, t.meemmeemisolatedarabic = 64584, t.meetorusquare = 13133, t.mehiragana = 12417, t.meizierasquare = 13182, t.mekatakana = 12513, t.mekatakanahalfwidth = 65426, t.mem = 1502, t.memdagesh = 64318, t.memdageshhebrew = 64318, t.memhebrew = 1502, t.menarmenian = 1396, t.merkhahebrew = 1445, t.merkhakefulahebrew = 1446, t.merkhakefulalefthebrew = 1446, t.merkhalefthebrew = 1445, t.mhook = 625, t.mhzsquare = 13202, t.middledotkatakanahalfwidth = 65381, t.middot = 183, t.mieumacirclekorean = 12914, t.mieumaparenkorean = 12818, t.mieumcirclekorean = 12900, t.mieumkorean = 12609, t.mieumpansioskorean = 12656, t.mieumparenkorean = 12804, t.mieumpieupkorean = 12654, t.mieumsioskorean = 12655, t.mihiragana = 12415, t.mikatakana = 12511, t.mikatakanahalfwidth = 65424, t.minus = 8722, t.minusbelowcmb = 800, t.minuscircle = 8854, t.minusmod = 727, t.minusplus = 8723, t.minute = 8242, t.miribaarusquare = 13130, t.mirisquare = 13129, t.mlonglegturned = 624, t.mlsquare = 13206, t.mmcubedsquare = 13219, t.mmonospace = 65357, t.mmsquaredsquare = 13215, t.mohiragana = 12418, t.mohmsquare = 13249, t.mokatakana = 12514, t.mokatakanahalfwidth = 65427, t.molsquare = 13270, t.momathai = 3617, t.moverssquare = 13223, t.moverssquaredsquare = 13224, t.mparen = 9384, t.mpasquare = 13227, t.mssquare = 13235, t.msuperior = 63215, t.mturned = 623, t.mu = 181, t.mu1 = 181, t.muasquare = 13186, t.muchgreater = 8811, t.muchless = 8810, t.mufsquare = 13196, t.mugreek = 956, t.mugsquare = 13197, t.muhiragana = 12416, t.mukatakana = 12512, t.mukatakanahalfwidth = 65425, t.mulsquare = 13205, t.multiply = 215, t.mumsquare = 13211, t.munahhebrew = 1443, t.munahlefthebrew = 1443, t.musicalnote = 9834, t.musicalnotedbl = 9835, t.musicflatsign = 9837, t.musicsharpsign = 9839, t.mussquare = 13234, t.muvsquare = 13238, t.muwsquare = 13244, t.mvmegasquare = 13241, t.mvsquare = 13239, t.mwmegasquare = 13247, t.mwsquare = 13245, t.n = 110, t.nabengali = 2472, t.nabla = 8711, t.nacute = 324, t.nadeva = 2344, t.nagujarati = 2728, t.nagurmukhi = 2600, t.nahiragana = 12394, t.nakatakana = 12490, t.nakatakanahalfwidth = 65413, t.napostrophe = 329, t.nasquare = 13185, t.nbopomofo = 12555, t.nbspace = 160, t.ncaron = 328, t.ncedilla = 326, t.ncircle = 9437, t.ncircumflexbelow = 7755, t.ncommaaccent = 326, t.ndotaccent = 7749, t.ndotbelow = 7751, t.nehiragana = 12397, t.nekatakana = 12493, t.nekatakanahalfwidth = 65416, t.newsheqelsign = 8362, t.nfsquare = 13195, t.ngabengali = 2457, t.ngadeva = 2329, t.ngagujarati = 2713, t.ngagurmukhi = 2585, t.ngonguthai = 3591, t.nhiragana = 12435, t.nhookleft = 626, t.nhookretroflex = 627, t.nieunacirclekorean = 12911, t.nieunaparenkorean = 12815, t.nieuncieuckorean = 12597, t.nieuncirclekorean = 12897, t.nieunhieuhkorean = 12598, t.nieunkorean = 12596, t.nieunpansioskorean = 12648, t.nieunparenkorean = 12801, t.nieunsioskorean = 12647, t.nieuntikeutkorean = 12646, t.nihiragana = 12395, t.nikatakana = 12491, t.nikatakanahalfwidth = 65414, t.nikhahitleftthai = 63641, t.nikhahitthai = 3661, t.nine = 57, t.ninearabic = 1641, t.ninebengali = 2543, t.ninecircle = 9320, t.ninecircleinversesansserif = 10130, t.ninedeva = 2415, t.ninegujarati = 2799, t.ninegurmukhi = 2671, t.ninehackarabic = 1641, t.ninehangzhou = 12329, t.nineideographicparen = 12840, t.nineinferior = 8329, t.ninemonospace = 65305, t.nineoldstyle = 63289, t.nineparen = 9340, t.nineperiod = 9360, t.ninepersian = 1785, t.nineroman = 8568, t.ninesuperior = 8313, t.nineteencircle = 9330, t.nineteenparen = 9350, t.nineteenperiod = 9370, t.ninethai = 3673, t.nj = 460, t.njecyrillic = 1114, t.nkatakana = 12531, t.nkatakanahalfwidth = 65437, t.nlegrightlong = 414, t.nlinebelow = 7753, t.nmonospace = 65358, t.nmsquare = 13210, t.nnabengali = 2467, t.nnadeva = 2339, t.nnagujarati = 2723, t.nnagurmukhi = 2595, t.nnnadeva = 2345, t.nohiragana = 12398, t.nokatakana = 12494, t.nokatakanahalfwidth = 65417, t.nonbreakingspace = 160, t.nonenthai = 3603, t.nonuthai = 3609, t.noonarabic = 1606, t.noonfinalarabic = 65254, t.noonghunnaarabic = 1722, t.noonghunnafinalarabic = 64415, t.nooninitialarabic = 65255, t.noonjeeminitialarabic = 64722, t.noonjeemisolatedarabic = 64587, t.noonmedialarabic = 65256, t.noonmeeminitialarabic = 64725, t.noonmeemisolatedarabic = 64590, t.noonnoonfinalarabic = 64653, t.notcontains = 8716, t.notelement = 8713, t.notelementof = 8713, t.notequal = 8800, t.notgreater = 8815, t.notgreaternorequal = 8817, t.notgreaternorless = 8825, t.notidentical = 8802, t.notless = 8814, t.notlessnorequal = 8816, t.notparallel = 8742, t.notprecedes = 8832, t.notsubset = 8836, t.notsucceeds = 8833, t.notsuperset = 8837, t.nowarmenian = 1398, t.nparen = 9385, t.nssquare = 13233, t.nsuperior = 8319, t.ntilde = 241, t.nu = 957, t.nuhiragana = 12396, t.nukatakana = 12492, t.nukatakanahalfwidth = 65415, t.nuktabengali = 2492, t.nuktadeva = 2364, t.nuktagujarati = 2748, t.nuktagurmukhi = 2620, t.numbersign = 35, t.numbersignmonospace = 65283, t.numbersignsmall = 65119, t.numeralsigngreek = 884, t.numeralsignlowergreek = 885, t.numero = 8470, t.nun = 1504, t.nundagesh = 64320, t.nundageshhebrew = 64320, t.nunhebrew = 1504, t.nvsquare = 13237, t.nwsquare = 13243, t.nyabengali = 2462, t.nyadeva = 2334, t.nyagujarati = 2718, t.nyagurmukhi = 2590, t.o = 111, t.oacute = 243, t.oangthai = 3629, t.obarred = 629, t.obarredcyrillic = 1257, t.obarreddieresiscyrillic = 1259, t.obengali = 2451, t.obopomofo = 12571, t.obreve = 335, t.ocandradeva = 2321, t.ocandragujarati = 2705, t.ocandravowelsigndeva = 2377, t.ocandravowelsigngujarati = 2761, t.ocaron = 466, t.ocircle = 9438, t.ocircumflex = 244, t.ocircumflexacute = 7889, t.ocircumflexdotbelow = 7897, t.ocircumflexgrave = 7891, t.ocircumflexhookabove = 7893, t.ocircumflextilde = 7895, t.ocyrillic = 1086, t.odblacute = 337, t.odblgrave = 525, t.odeva = 2323, t.odieresis = 246, t.odieresiscyrillic = 1255, t.odotbelow = 7885, t.oe = 339, t.oekorean = 12634, t.ogonek = 731, t.ogonekcmb = 808, t.ograve = 242, t.ogujarati = 2707, t.oharmenian = 1413, t.ohiragana = 12362, t.ohookabove = 7887, t.ohorn = 417, t.ohornacute = 7899, t.ohorndotbelow = 7907, t.ohorngrave = 7901, t.ohornhookabove = 7903, t.ohorntilde = 7905, t.ohungarumlaut = 337, t.oi = 419, t.oinvertedbreve = 527, t.okatakana = 12458, t.okatakanahalfwidth = 65397, t.okorean = 12631, t.olehebrew = 1451, t.omacron = 333, t.omacronacute = 7763, t.omacrongrave = 7761, t.omdeva = 2384, t.omega = 969, t.omega1 = 982, t.omegacyrillic = 1121, t.omegalatinclosed = 631, t.omegaroundcyrillic = 1147, t.omegatitlocyrillic = 1149, t.omegatonos = 974, t.omgujarati = 2768, t.omicron = 959, t.omicrontonos = 972, t.omonospace = 65359, t.one = 49, t.onearabic = 1633, t.onebengali = 2535, t.onecircle = 9312, t.onecircleinversesansserif = 10122, t.onedeva = 2407, t.onedotenleader = 8228, t.oneeighth = 8539, t.onefitted = 63196, t.onegujarati = 2791, t.onegurmukhi = 2663, t.onehackarabic = 1633, t.onehalf = 189, t.onehangzhou = 12321, t.oneideographicparen = 12832, t.oneinferior = 8321, t.onemonospace = 65297, t.onenumeratorbengali = 2548, t.oneoldstyle = 63281, t.oneparen = 9332, t.oneperiod = 9352, t.onepersian = 1777, t.onequarter = 188, t.oneroman = 8560, t.onesuperior = 185, t.onethai = 3665, t.onethird = 8531, t.oogonek = 491, t.oogonekmacron = 493, t.oogurmukhi = 2579, t.oomatragurmukhi = 2635, t.oopen = 596, t.oparen = 9386, t.openbullet = 9702, t.option = 8997, t.ordfeminine = 170, t.ordmasculine = 186, t.orthogonal = 8735, t.oshortdeva = 2322, t.oshortvowelsigndeva = 2378, t.oslash = 248, t.oslashacute = 511, t.osmallhiragana = 12361, t.osmallkatakana = 12457, t.osmallkatakanahalfwidth = 65387, t.ostrokeacute = 511, t.osuperior = 63216, t.otcyrillic = 1151, t.otilde = 245, t.otildeacute = 7757, t.otildedieresis = 7759, t.oubopomofo = 12577, t.overline = 8254, t.overlinecenterline = 65098, t.overlinecmb = 773, t.overlinedashed = 65097, t.overlinedblwavy = 65100, t.overlinewavy = 65099, t.overscore = 175, t.ovowelsignbengali = 2507, t.ovowelsigndeva = 2379, t.ovowelsigngujarati = 2763, t.p = 112, t.paampssquare = 13184, t.paasentosquare = 13099, t.pabengali = 2474, t.pacute = 7765, t.padeva = 2346, t.pagedown = 8671, t.pageup = 8670, t.pagujarati = 2730, t.pagurmukhi = 2602, t.pahiragana = 12401, t.paiyannoithai = 3631, t.pakatakana = 12497, t.palatalizationcyrilliccmb = 1156, t.palochkacyrillic = 1216, t.pansioskorean = 12671, t.paragraph = 182, t.parallel = 8741, t.parenleft = 40, t.parenleftaltonearabic = 64830, t.parenleftbt = 63725, t.parenleftex = 63724, t.parenleftinferior = 8333, t.parenleftmonospace = 65288, t.parenleftsmall = 65113, t.parenleftsuperior = 8317, t.parenlefttp = 63723, t.parenleftvertical = 65077, t.parenright = 41, t.parenrightaltonearabic = 64831, t.parenrightbt = 63736, t.parenrightex = 63735, t.parenrightinferior = 8334, t.parenrightmonospace = 65289, t.parenrightsmall = 65114, t.parenrightsuperior = 8318, t.parenrighttp = 63734, t.parenrightvertical = 65078, t.partialdiff = 8706, t.paseqhebrew = 1472, t.pashtahebrew = 1433, t.pasquare = 13225, t.patah = 1463, t.patah11 = 1463, t.patah1d = 1463, t.patah2a = 1463, t.patahhebrew = 1463, t.patahnarrowhebrew = 1463, t.patahquarterhebrew = 1463, t.patahwidehebrew = 1463, t.pazerhebrew = 1441, t.pbopomofo = 12550, t.pcircle = 9439, t.pdotaccent = 7767, t.pe = 1508, t.pecyrillic = 1087, t.pedagesh = 64324, t.pedageshhebrew = 64324, t.peezisquare = 13115, t.pefinaldageshhebrew = 64323, t.peharabic = 1662, t.peharmenian = 1402, t.pehebrew = 1508, t.pehfinalarabic = 64343, t.pehinitialarabic = 64344, t.pehiragana = 12410, t.pehmedialarabic = 64345, t.pekatakana = 12506, t.pemiddlehookcyrillic = 1191, t.perafehebrew = 64334, t.percent = 37, t.percentarabic = 1642, t.percentmonospace = 65285, t.percentsmall = 65130, t.period = 46, t.periodarmenian = 1417, t.periodcentered = 183, t.periodhalfwidth = 65377, t.periodinferior = 63207, t.periodmonospace = 65294, t.periodsmall = 65106, t.periodsuperior = 63208, t.perispomenigreekcmb = 834, t.perpendicular = 8869, t.perthousand = 8240, t.peseta = 8359, t.pfsquare = 13194, t.phabengali = 2475, t.phadeva = 2347, t.phagujarati = 2731, t.phagurmukhi = 2603, t.phi = 966, t.phi1 = 981, t.phieuphacirclekorean = 12922, t.phieuphaparenkorean = 12826, t.phieuphcirclekorean = 12908, t.phieuphkorean = 12621, t.phieuphparenkorean = 12812, t.philatin = 632, t.phinthuthai = 3642, t.phisymbolgreek = 981, t.phook = 421, t.phophanthai = 3614, t.phophungthai = 3612, t.phosamphaothai = 3616, t.pi = 960, t.pieupacirclekorean = 12915, t.pieupaparenkorean = 12819, t.pieupcieuckorean = 12662, t.pieupcirclekorean = 12901, t.pieupkiyeokkorean = 12658, t.pieupkorean = 12610, t.pieupparenkorean = 12805, t.pieupsioskiyeokkorean = 12660, t.pieupsioskorean = 12612, t.pieupsiostikeutkorean = 12661, t.pieupthieuthkorean = 12663, t.pieuptikeutkorean = 12659, t.pihiragana = 12404, t.pikatakana = 12500, t.pisymbolgreek = 982, t.piwrarmenian = 1411, t.planckover2pi = 8463, t.planckover2pi1 = 8463, t.plus = 43, t.plusbelowcmb = 799, t.pluscircle = 8853, t.plusminus = 177, t.plusmod = 726, t.plusmonospace = 65291, t.plussmall = 65122, t.plussuperior = 8314, t.pmonospace = 65360, t.pmsquare = 13272, t.pohiragana = 12413, t.pointingindexdownwhite = 9759, t.pointingindexleftwhite = 9756, t.pointingindexrightwhite = 9758, t.pointingindexupwhite = 9757, t.pokatakana = 12509, t.poplathai = 3611, t.postalmark = 12306, t.postalmarkface = 12320, t.pparen = 9387, t.precedes = 8826, t.prescription = 8478, t.primemod = 697, t.primereversed = 8245, t.product = 8719, t.projective = 8965, t.prolongedkana = 12540, t.propellor = 8984, t.propersubset = 8834, t.propersuperset = 8835, t.proportion = 8759, t.proportional = 8733, t.psi = 968, t.psicyrillic = 1137, t.psilipneumatacyrilliccmb = 1158, t.pssquare = 13232, t.puhiragana = 12407, t.pukatakana = 12503, t.pvsquare = 13236, t.pwsquare = 13242, t.q = 113, t.qadeva = 2392, t.qadmahebrew = 1448, t.qafarabic = 1602, t.qaffinalarabic = 65238, t.qafinitialarabic = 65239, t.qafmedialarabic = 65240, t.qamats = 1464, t.qamats10 = 1464, t.qamats1a = 1464, t.qamats1c = 1464, t.qamats27 = 1464, t.qamats29 = 1464, t.qamats33 = 1464, t.qamatsde = 1464, t.qamatshebrew = 1464, t.qamatsnarrowhebrew = 1464, t.qamatsqatanhebrew = 1464, t.qamatsqatannarrowhebrew = 1464, t.qamatsqatanquarterhebrew = 1464, t.qamatsqatanwidehebrew = 1464, t.qamatsquarterhebrew = 1464, t.qamatswidehebrew = 1464, t.qarneyparahebrew = 1439, t.qbopomofo = 12561, t.qcircle = 9440, t.qhook = 672, t.qmonospace = 65361, t.qof = 1511, t.qofdagesh = 64327, t.qofdageshhebrew = 64327, t.qofhebrew = 1511, t.qparen = 9388, t.quarternote = 9833, t.qubuts = 1467, t.qubuts18 = 1467, t.qubuts25 = 1467, t.qubuts31 = 1467, t.qubutshebrew = 1467, t.qubutsnarrowhebrew = 1467, t.qubutsquarterhebrew = 1467, t.qubutswidehebrew = 1467, t.question = 63, t.questionarabic = 1567, t.questionarmenian = 1374, t.questiondown = 191, t.questiondownsmall = 63423, t.questiongreek = 894, t.questionmonospace = 65311, t.questionsmall = 63295, t.quotedbl = 34, t.quotedblbase = 8222, t.quotedblleft = 8220, t.quotedblmonospace = 65282, t.quotedblprime = 12318, t.quotedblprimereversed = 12317, t.quotedblright = 8221, t.quoteleft = 8216, t.quoteleftreversed = 8219, t.quotereversed = 8219, t.quoteright = 8217, t.quoterightn = 329, t.quotesinglbase = 8218, t.quotesingle = 39, t.quotesinglemonospace = 65287, t.r = 114, t.raarmenian = 1404, t.rabengali = 2480, t.racute = 341, t.radeva = 2352, t.radical = 8730, t.radicalex = 63717, t.radoverssquare = 13230, t.radoverssquaredsquare = 13231, t.radsquare = 13229, t.rafe = 1471, t.rafehebrew = 1471, t.ragujarati = 2736, t.ragurmukhi = 2608, t.rahiragana = 12425, t.rakatakana = 12521, t.rakatakanahalfwidth = 65431, t.ralowerdiagonalbengali = 2545, t.ramiddlediagonalbengali = 2544, t.ramshorn = 612, t.ratio = 8758, t.rbopomofo = 12566, t.rcaron = 345, t.rcedilla = 343, t.rcircle = 9441, t.rcommaaccent = 343, t.rdblgrave = 529, t.rdotaccent = 7769, t.rdotbelow = 7771, t.rdotbelowmacron = 7773, t.referencemark = 8251, t.reflexsubset = 8838, t.reflexsuperset = 8839, t.registered = 174, t.registersans = 63720, t.registerserif = 63194, t.reharabic = 1585, t.reharmenian = 1408, t.rehfinalarabic = 65198, t.rehiragana = 12428, t.rekatakana = 12524, t.rekatakanahalfwidth = 65434, t.resh = 1512, t.reshdageshhebrew = 64328, t.reshhebrew = 1512, t.reversedtilde = 8765, t.reviahebrew = 1431, t.reviamugrashhebrew = 1431, t.revlogicalnot = 8976, t.rfishhook = 638, t.rfishhookreversed = 639, t.rhabengali = 2525, t.rhadeva = 2397, t.rho = 961, t.rhook = 637, t.rhookturned = 635, t.rhookturnedsuperior = 693, t.rhosymbolgreek = 1009, t.rhotichookmod = 734, t.rieulacirclekorean = 12913, t.rieulaparenkorean = 12817, t.rieulcirclekorean = 12899, t.rieulhieuhkorean = 12608, t.rieulkiyeokkorean = 12602, t.rieulkiyeoksioskorean = 12649, t.rieulkorean = 12601, t.rieulmieumkorean = 12603, t.rieulpansioskorean = 12652, t.rieulparenkorean = 12803, t.rieulphieuphkorean = 12607, t.rieulpieupkorean = 12604, t.rieulpieupsioskorean = 12651, t.rieulsioskorean = 12605, t.rieulthieuthkorean = 12606, t.rieultikeutkorean = 12650, t.rieulyeorinhieuhkorean = 12653, t.rightangle = 8735, t.righttackbelowcmb = 793, t.righttriangle = 8895, t.rihiragana = 12426, t.rikatakana = 12522, t.rikatakanahalfwidth = 65432, t.ring = 730, t.ringbelowcmb = 805, t.ringcmb = 778, t.ringhalfleft = 703, t.ringhalfleftarmenian = 1369, t.ringhalfleftbelowcmb = 796, t.ringhalfleftcentered = 723, t.ringhalfright = 702, t.ringhalfrightbelowcmb = 825, t.ringhalfrightcentered = 722, t.rinvertedbreve = 531, t.rittorusquare = 13137, t.rlinebelow = 7775, t.rlongleg = 636, t.rlonglegturned = 634, t.rmonospace = 65362, t.rohiragana = 12429, t.rokatakana = 12525, t.rokatakanahalfwidth = 65435, t.roruathai = 3619, t.rparen = 9389, t.rrabengali = 2524, t.rradeva = 2353, t.rragurmukhi = 2652, t.rreharabic = 1681, t.rrehfinalarabic = 64397, t.rrvocalicbengali = 2528, t.rrvocalicdeva = 2400, t.rrvocalicgujarati = 2784, t.rrvocalicvowelsignbengali = 2500, t.rrvocalicvowelsigndeva = 2372, t.rrvocalicvowelsigngujarati = 2756, t.rsuperior = 63217, t.rtblock = 9616, t.rturned = 633, t.rturnedsuperior = 692, t.ruhiragana = 12427, t.rukatakana = 12523, t.rukatakanahalfwidth = 65433, t.rupeemarkbengali = 2546, t.rupeesignbengali = 2547, t.rupiah = 63197, t.ruthai = 3620, t.rvocalicbengali = 2443, t.rvocalicdeva = 2315, t.rvocalicgujarati = 2699, t.rvocalicvowelsignbengali = 2499, t.rvocalicvowelsigndeva = 2371, t.rvocalicvowelsigngujarati = 2755, t.s = 115, t.sabengali = 2488, t.sacute = 347, t.sacutedotaccent = 7781, t.sadarabic = 1589, t.sadeva = 2360, t.sadfinalarabic = 65210, t.sadinitialarabic = 65211, t.sadmedialarabic = 65212, t.sagujarati = 2744, t.sagurmukhi = 2616, t.sahiragana = 12373, t.sakatakana = 12469, t.sakatakanahalfwidth = 65403, t.sallallahoualayhewasallamarabic = 65018, t.samekh = 1505, t.samekhdagesh = 64321, t.samekhdageshhebrew = 64321, t.samekhhebrew = 1505, t.saraaathai = 3634, t.saraaethai = 3649, t.saraaimaimalaithai = 3652, t.saraaimaimuanthai = 3651, t.saraamthai = 3635, t.saraathai = 3632, t.saraethai = 3648, t.saraiileftthai = 63622, t.saraiithai = 3637, t.saraileftthai = 63621, t.saraithai = 3636, t.saraothai = 3650, t.saraueeleftthai = 63624, t.saraueethai = 3639, t.saraueleftthai = 63623, t.sarauethai = 3638, t.sarauthai = 3640, t.sarauuthai = 3641, t.sbopomofo = 12569, t.scaron = 353, t.scarondotaccent = 7783, t.scedilla = 351, t.schwa = 601, t.schwacyrillic = 1241, t.schwadieresiscyrillic = 1243, t.schwahook = 602, t.scircle = 9442, t.scircumflex = 349, t.scommaaccent = 537, t.sdotaccent = 7777, t.sdotbelow = 7779, t.sdotbelowdotaccent = 7785, t.seagullbelowcmb = 828, t.second = 8243, t.secondtonechinese = 714, t.section = 167, t.seenarabic = 1587, t.seenfinalarabic = 65202, t.seeninitialarabic = 65203, t.seenmedialarabic = 65204, t.segol = 1462, t.segol13 = 1462, t.segol1f = 1462, t.segol2c = 1462, t.segolhebrew = 1462, t.segolnarrowhebrew = 1462, t.segolquarterhebrew = 1462, t.segoltahebrew = 1426, t.segolwidehebrew = 1462, t.seharmenian = 1405, t.sehiragana = 12379, t.sekatakana = 12475, t.sekatakanahalfwidth = 65406, t.semicolon = 59, t.semicolonarabic = 1563, t.semicolonmonospace = 65307, t.semicolonsmall = 65108, t.semivoicedmarkkana = 12444, t.semivoicedmarkkanahalfwidth = 65439, t.sentisquare = 13090, t.sentosquare = 13091, t.seven = 55, t.sevenarabic = 1639, t.sevenbengali = 2541, t.sevencircle = 9318, t.sevencircleinversesansserif = 10128, t.sevendeva = 2413, t.seveneighths = 8542, t.sevengujarati = 2797, t.sevengurmukhi = 2669, t.sevenhackarabic = 1639, t.sevenhangzhou = 12327, t.sevenideographicparen = 12838, t.seveninferior = 8327, t.sevenmonospace = 65303, t.sevenoldstyle = 63287, t.sevenparen = 9338, t.sevenperiod = 9358, t.sevenpersian = 1783, t.sevenroman = 8566, t.sevensuperior = 8311, t.seventeencircle = 9328, t.seventeenparen = 9348, t.seventeenperiod = 9368, t.seventhai = 3671, t.sfthyphen = 173, t.shaarmenian = 1399, t.shabengali = 2486, t.shacyrillic = 1096, t.shaddaarabic = 1617, t.shaddadammaarabic = 64609, t.shaddadammatanarabic = 64606, t.shaddafathaarabic = 64608, t.shaddakasraarabic = 64610, t.shaddakasratanarabic = 64607, t.shade = 9618, t.shadedark = 9619, t.shadelight = 9617, t.shademedium = 9618, t.shadeva = 2358, t.shagujarati = 2742, t.shagurmukhi = 2614, t.shalshelethebrew = 1427, t.shbopomofo = 12565, t.shchacyrillic = 1097, t.sheenarabic = 1588, t.sheenfinalarabic = 65206, t.sheeninitialarabic = 65207, t.sheenmedialarabic = 65208, t.sheicoptic = 995, t.sheqel = 8362, t.sheqelhebrew = 8362, t.sheva = 1456, t.sheva115 = 1456, t.sheva15 = 1456, t.sheva22 = 1456, t.sheva2e = 1456, t.shevahebrew = 1456, t.shevanarrowhebrew = 1456, t.shevaquarterhebrew = 1456, t.shevawidehebrew = 1456, t.shhacyrillic = 1211, t.shimacoptic = 1005, t.shin = 1513, t.shindagesh = 64329, t.shindageshhebrew = 64329, t.shindageshshindot = 64300, t.shindageshshindothebrew = 64300, t.shindageshsindot = 64301, t.shindageshsindothebrew = 64301, t.shindothebrew = 1473, t.shinhebrew = 1513, t.shinshindot = 64298, t.shinshindothebrew = 64298, t.shinsindot = 64299, t.shinsindothebrew = 64299, t.shook = 642, t.sigma = 963, t.sigma1 = 962, t.sigmafinal = 962, t.sigmalunatesymbolgreek = 1010, t.sihiragana = 12375, t.sikatakana = 12471, t.sikatakanahalfwidth = 65404, t.siluqhebrew = 1469, t.siluqlefthebrew = 1469, t.similar = 8764, t.sindothebrew = 1474, t.siosacirclekorean = 12916, t.siosaparenkorean = 12820, t.sioscieuckorean = 12670, t.sioscirclekorean = 12902, t.sioskiyeokkorean = 12666, t.sioskorean = 12613, t.siosnieunkorean = 12667, t.siosparenkorean = 12806, t.siospieupkorean = 12669, t.siostikeutkorean = 12668, t.six = 54, t.sixarabic = 1638, t.sixbengali = 2540, t.sixcircle = 9317, t.sixcircleinversesansserif = 10127, t.sixdeva = 2412, t.sixgujarati = 2796, t.sixgurmukhi = 2668, t.sixhackarabic = 1638, t.sixhangzhou = 12326, t.sixideographicparen = 12837, t.sixinferior = 8326, t.sixmonospace = 65302, t.sixoldstyle = 63286, t.sixparen = 9337, t.sixperiod = 9357, t.sixpersian = 1782, t.sixroman = 8565, t.sixsuperior = 8310, t.sixteencircle = 9327, t.sixteencurrencydenominatorbengali = 2553, t.sixteenparen = 9347, t.sixteenperiod = 9367, t.sixthai = 3670, t.slash = 47, t.slashmonospace = 65295, t.slong = 383, t.slongdotaccent = 7835, t.smileface = 9786, t.smonospace = 65363, t.sofpasuqhebrew = 1475, t.softhyphen = 173, t.softsigncyrillic = 1100, t.sohiragana = 12381, t.sokatakana = 12477, t.sokatakanahalfwidth = 65407, t.soliduslongoverlaycmb = 824, t.solidusshortoverlaycmb = 823, t.sorusithai = 3625, t.sosalathai = 3624, t.sosothai = 3595, t.sosuathai = 3626, t.space = 32, t.spacehackarabic = 32, t.spade = 9824, t.spadesuitblack = 9824, t.spadesuitwhite = 9828, t.sparen = 9390, t.squarebelowcmb = 827, t.squarecc = 13252, t.squarecm = 13213, t.squarediagonalcrosshatchfill = 9641, t.squarehorizontalfill = 9636, t.squarekg = 13199, t.squarekm = 13214, t.squarekmcapital = 13262, t.squareln = 13265, t.squarelog = 13266, t.squaremg = 13198, t.squaremil = 13269, t.squaremm = 13212, t.squaremsquared = 13217, t.squareorthogonalcrosshatchfill = 9638, t.squareupperlefttolowerrightfill = 9639, t.squareupperrighttolowerleftfill = 9640, t.squareverticalfill = 9637, t.squarewhitewithsmallblack = 9635, t.srsquare = 13275, t.ssabengali = 2487, t.ssadeva = 2359, t.ssagujarati = 2743, t.ssangcieuckorean = 12617, t.ssanghieuhkorean = 12677, t.ssangieungkorean = 12672, t.ssangkiyeokkorean = 12594, t.ssangnieunkorean = 12645, t.ssangpieupkorean = 12611, t.ssangsioskorean = 12614, t.ssangtikeutkorean = 12600, t.ssuperior = 63218, t.sterling = 163, t.sterlingmonospace = 65505, t.strokelongoverlaycmb = 822, t.strokeshortoverlaycmb = 821, t.subset = 8834, t.subsetnotequal = 8842, t.subsetorequal = 8838, t.succeeds = 8827, t.suchthat = 8715, t.suhiragana = 12377, t.sukatakana = 12473, t.sukatakanahalfwidth = 65405, t.sukunarabic = 1618, t.summation = 8721, t.sun = 9788, t.superset = 8835, t.supersetnotequal = 8843, t.supersetorequal = 8839, t.svsquare = 13276, t.syouwaerasquare = 13180, t.t = 116, t.tabengali = 2468, t.tackdown = 8868, t.tackleft = 8867, t.tadeva = 2340, t.tagujarati = 2724, t.tagurmukhi = 2596, t.taharabic = 1591, t.tahfinalarabic = 65218, t.tahinitialarabic = 65219, t.tahiragana = 12383, t.tahmedialarabic = 65220, t.taisyouerasquare = 13181, t.takatakana = 12479, t.takatakanahalfwidth = 65408, t.tatweelarabic = 1600, t.tau = 964, t.tav = 1514, t.tavdages = 64330, t.tavdagesh = 64330, t.tavdageshhebrew = 64330, t.tavhebrew = 1514, t.tbar = 359, t.tbopomofo = 12554, t.tcaron = 357, t.tccurl = 680, t.tcedilla = 355, t.tcheharabic = 1670, t.tchehfinalarabic = 64379, t.tchehinitialarabic = 64380, t.tchehmedialarabic = 64381, t.tcircle = 9443, t.tcircumflexbelow = 7793, t.tcommaaccent = 355, t.tdieresis = 7831, t.tdotaccent = 7787, t.tdotbelow = 7789, t.tecyrillic = 1090, t.tedescendercyrillic = 1197, t.teharabic = 1578, t.tehfinalarabic = 65174, t.tehhahinitialarabic = 64674, t.tehhahisolatedarabic = 64524, t.tehinitialarabic = 65175, t.tehiragana = 12390, t.tehjeeminitialarabic = 64673, t.tehjeemisolatedarabic = 64523, t.tehmarbutaarabic = 1577, t.tehmarbutafinalarabic = 65172, t.tehmedialarabic = 65176, t.tehmeeminitialarabic = 64676, t.tehmeemisolatedarabic = 64526, t.tehnoonfinalarabic = 64627, t.tekatakana = 12486, t.tekatakanahalfwidth = 65411, t.telephone = 8481, t.telephoneblack = 9742, t.telishagedolahebrew = 1440, t.telishaqetanahebrew = 1449, t.tencircle = 9321, t.tenideographicparen = 12841, t.tenparen = 9341, t.tenperiod = 9361, t.tenroman = 8569, t.tesh = 679, t.tet = 1496, t.tetdagesh = 64312, t.tetdageshhebrew = 64312, t.tethebrew = 1496, t.tetsecyrillic = 1205, t.tevirhebrew = 1435, t.tevirlefthebrew = 1435, t.thabengali = 2469, t.thadeva = 2341, t.thagujarati = 2725, t.thagurmukhi = 2597, t.thalarabic = 1584, t.thalfinalarabic = 65196, t.thanthakhatlowleftthai = 63640, t.thanthakhatlowrightthai = 63639, t.thanthakhatthai = 3660, t.thanthakhatupperleftthai = 63638, t.theharabic = 1579, t.thehfinalarabic = 65178, t.thehinitialarabic = 65179, t.thehmedialarabic = 65180, t.thereexists = 8707, t.therefore = 8756, t.theta = 952, t.theta1 = 977, t.thetasymbolgreek = 977, t.thieuthacirclekorean = 12921, t.thieuthaparenkorean = 12825, t.thieuthcirclekorean = 12907, t.thieuthkorean = 12620, t.thieuthparenkorean = 12811, t.thirteencircle = 9324, t.thirteenparen = 9344, t.thirteenperiod = 9364, t.thonangmonthothai = 3601, t.thook = 429, t.thophuthaothai = 3602, t.thorn = 254, t.thothahanthai = 3607, t.thothanthai = 3600, t.thothongthai = 3608, t.thothungthai = 3606, t.thousandcyrillic = 1154, t.thousandsseparatorarabic = 1644, t.thousandsseparatorpersian = 1644, t.three = 51, t.threearabic = 1635, t.threebengali = 2537, t.threecircle = 9314, t.threecircleinversesansserif = 10124, t.threedeva = 2409, t.threeeighths = 8540, t.threegujarati = 2793, t.threegurmukhi = 2665, t.threehackarabic = 1635, t.threehangzhou = 12323, t.threeideographicparen = 12834, t.threeinferior = 8323, t.threemonospace = 65299, t.threenumeratorbengali = 2550, t.threeoldstyle = 63283, t.threeparen = 9334, t.threeperiod = 9354, t.threepersian = 1779, t.threequarters = 190, t.threequartersemdash = 63198, t.threeroman = 8562, t.threesuperior = 179, t.threethai = 3667, t.thzsquare = 13204, t.tihiragana = 12385, t.tikatakana = 12481, t.tikatakanahalfwidth = 65409, t.tikeutacirclekorean = 12912, t.tikeutaparenkorean = 12816, t.tikeutcirclekorean = 12898, t.tikeutkorean = 12599, t.tikeutparenkorean = 12802, t.tilde = 732, t.tildebelowcmb = 816, t.tildecmb = 771, t.tildecomb = 771, t.tildedoublecmb = 864, t.tildeoperator = 8764, t.tildeoverlaycmb = 820, t.tildeverticalcmb = 830, t.timescircle = 8855, t.tipehahebrew = 1430, t.tipehalefthebrew = 1430, t.tippigurmukhi = 2672, t.titlocyrilliccmb = 1155, t.tiwnarmenian = 1407, t.tlinebelow = 7791, t.tmonospace = 65364, t.toarmenian = 1385, t.tohiragana = 12392, t.tokatakana = 12488, t.tokatakanahalfwidth = 65412, t.tonebarextrahighmod = 741, t.tonebarextralowmod = 745, t.tonebarhighmod = 742, t.tonebarlowmod = 744, t.tonebarmidmod = 743, t.tonefive = 445, t.tonesix = 389, t.tonetwo = 424, t.tonos = 900, t.tonsquare = 13095, t.topatakthai = 3599, t.tortoiseshellbracketleft = 12308, t.tortoiseshellbracketleftsmall = 65117, t.tortoiseshellbracketleftvertical = 65081, t.tortoiseshellbracketright = 12309, t.tortoiseshellbracketrightsmall = 65118, t.tortoiseshellbracketrightvertical = 65082, t.totaothai = 3605, t.tpalatalhook = 427, t.tparen = 9391, t.trademark = 8482, t.trademarksans = 63722, t.trademarkserif = 63195, t.tretroflexhook = 648, t.triagdn = 9660, t.triaglf = 9668, t.triagrt = 9658, t.triagup = 9650, t.ts = 678, t.tsadi = 1510, t.tsadidagesh = 64326, t.tsadidageshhebrew = 64326, t.tsadihebrew = 1510, t.tsecyrillic = 1094, t.tsere = 1461, t.tsere12 = 1461, t.tsere1e = 1461, t.tsere2b = 1461, t.tserehebrew = 1461, t.tserenarrowhebrew = 1461, t.tserequarterhebrew = 1461, t.tserewidehebrew = 1461, t.tshecyrillic = 1115, t.tsuperior = 63219, t.ttabengali = 2463, t.ttadeva = 2335, t.ttagujarati = 2719, t.ttagurmukhi = 2591, t.tteharabic = 1657, t.ttehfinalarabic = 64359, t.ttehinitialarabic = 64360, t.ttehmedialarabic = 64361, t.tthabengali = 2464, t.tthadeva = 2336, t.tthagujarati = 2720, t.tthagurmukhi = 2592, t.tturned = 647, t.tuhiragana = 12388, t.tukatakana = 12484, t.tukatakanahalfwidth = 65410, t.tusmallhiragana = 12387, t.tusmallkatakana = 12483, t.tusmallkatakanahalfwidth = 65391, t.twelvecircle = 9323, t.twelveparen = 9343, t.twelveperiod = 9363, t.twelveroman = 8571, t.twentycircle = 9331, t.twentyhangzhou = 21316, t.twentyparen = 9351, t.twentyperiod = 9371, t.two = 50, t.twoarabic = 1634, t.twobengali = 2536, t.twocircle = 9313, t.twocircleinversesansserif = 10123, t.twodeva = 2408, t.twodotenleader = 8229, t.twodotleader = 8229, t.twodotleadervertical = 65072, t.twogujarati = 2792, t.twogurmukhi = 2664, t.twohackarabic = 1634, t.twohangzhou = 12322, t.twoideographicparen = 12833, t.twoinferior = 8322, t.twomonospace = 65298, t.twonumeratorbengali = 2549, t.twooldstyle = 63282, t.twoparen = 9333, t.twoperiod = 9353, t.twopersian = 1778, t.tworoman = 8561, t.twostroke = 443, t.twosuperior = 178, t.twothai = 3666, t.twothirds = 8532, t.u = 117, t.uacute = 250, t.ubar = 649, t.ubengali = 2441, t.ubopomofo = 12584, t.ubreve = 365, t.ucaron = 468, t.ucircle = 9444, t.ucircumflex = 251, t.ucircumflexbelow = 7799, t.ucyrillic = 1091, t.udattadeva = 2385, t.udblacute = 369, t.udblgrave = 533, t.udeva = 2313, t.udieresis = 252, t.udieresisacute = 472, t.udieresisbelow = 7795, t.udieresiscaron = 474, t.udieresiscyrillic = 1265, t.udieresisgrave = 476, t.udieresismacron = 470, t.udotbelow = 7909, t.ugrave = 249, t.ugujarati = 2697, t.ugurmukhi = 2569, t.uhiragana = 12358, t.uhookabove = 7911, t.uhorn = 432, t.uhornacute = 7913, t.uhorndotbelow = 7921, t.uhorngrave = 7915, t.uhornhookabove = 7917, t.uhorntilde = 7919, t.uhungarumlaut = 369, t.uhungarumlautcyrillic = 1267, t.uinvertedbreve = 535, t.ukatakana = 12454, t.ukatakanahalfwidth = 65395, t.ukcyrillic = 1145, t.ukorean = 12636, t.umacron = 363, t.umacroncyrillic = 1263, t.umacrondieresis = 7803, t.umatragurmukhi = 2625, t.umonospace = 65365, t.underscore = 95, t.underscoredbl = 8215, t.underscoremonospace = 65343, t.underscorevertical = 65075, t.underscorewavy = 65103, t.union = 8746, t.universal = 8704, t.uogonek = 371, t.uparen = 9392, t.upblock = 9600, t.upperdothebrew = 1476, t.upsilon = 965, t.upsilondieresis = 971, t.upsilondieresistonos = 944, t.upsilonlatin = 650, t.upsilontonos = 973, t.uptackbelowcmb = 797, t.uptackmod = 724, t.uragurmukhi = 2675, t.uring = 367, t.ushortcyrillic = 1118, t.usmallhiragana = 12357, t.usmallkatakana = 12453, t.usmallkatakanahalfwidth = 65385, t.ustraightcyrillic = 1199, t.ustraightstrokecyrillic = 1201, t.utilde = 361, t.utildeacute = 7801, t.utildebelow = 7797, t.uubengali = 2442, t.uudeva = 2314, t.uugujarati = 2698, t.uugurmukhi = 2570, t.uumatragurmukhi = 2626, t.uuvowelsignbengali = 2498, t.uuvowelsigndeva = 2370, t.uuvowelsigngujarati = 2754, t.uvowelsignbengali = 2497, t.uvowelsigndeva = 2369, t.uvowelsigngujarati = 2753, t.v = 118, t.vadeva = 2357, t.vagujarati = 2741, t.vagurmukhi = 2613, t.vakatakana = 12535, t.vav = 1493, t.vavdagesh = 64309, t.vavdagesh65 = 64309, t.vavdageshhebrew = 64309, t.vavhebrew = 1493, t.vavholam = 64331, t.vavholamhebrew = 64331, t.vavvavhebrew = 1520, t.vavyodhebrew = 1521, t.vcircle = 9445, t.vdotbelow = 7807, t.vecyrillic = 1074, t.veharabic = 1700, t.vehfinalarabic = 64363, t.vehinitialarabic = 64364, t.vehmedialarabic = 64365, t.vekatakana = 12537, t.venus = 9792, t.verticalbar = 124, t.verticallineabovecmb = 781, t.verticallinebelowcmb = 809, t.verticallinelowmod = 716, t.verticallinemod = 712, t.vewarmenian = 1406, t.vhook = 651, t.vikatakana = 12536, t.viramabengali = 2509, t.viramadeva = 2381, t.viramagujarati = 2765, t.visargabengali = 2435, t.visargadeva = 2307, t.visargagujarati = 2691, t.vmonospace = 65366, t.voarmenian = 1400, t.voicediterationhiragana = 12446, t.voicediterationkatakana = 12542, t.voicedmarkkana = 12443, t.voicedmarkkanahalfwidth = 65438, t.vokatakana = 12538, t.vparen = 9393, t.vtilde = 7805, t.vturned = 652, t.vuhiragana = 12436, t.vukatakana = 12532, t.w = 119, t.wacute = 7811, t.waekorean = 12633, t.wahiragana = 12431, t.wakatakana = 12527, t.wakatakanahalfwidth = 65436, t.wakorean = 12632, t.wasmallhiragana = 12430, t.wasmallkatakana = 12526, t.wattosquare = 13143, t.wavedash = 12316, t.wavyunderscorevertical = 65076, t.wawarabic = 1608, t.wawfinalarabic = 65262, t.wawhamzaabovearabic = 1572, t.wawhamzaabovefinalarabic = 65158, t.wbsquare = 13277, t.wcircle = 9446, t.wcircumflex = 373, t.wdieresis = 7813, t.wdotaccent = 7815, t.wdotbelow = 7817, t.wehiragana = 12433, t.weierstrass = 8472, t.wekatakana = 12529, t.wekorean = 12638, t.weokorean = 12637, t.wgrave = 7809, t.whitebullet = 9702, t.whitecircle = 9675, t.whitecircleinverse = 9689, t.whitecornerbracketleft = 12302, t.whitecornerbracketleftvertical = 65091, t.whitecornerbracketright = 12303, t.whitecornerbracketrightvertical = 65092, t.whitediamond = 9671, t.whitediamondcontainingblacksmalldiamond = 9672, t.whitedownpointingsmalltriangle = 9663, t.whitedownpointingtriangle = 9661, t.whiteleftpointingsmalltriangle = 9667, t.whiteleftpointingtriangle = 9665, t.whitelenticularbracketleft = 12310, t.whitelenticularbracketright = 12311, t.whiterightpointingsmalltriangle = 9657, t.whiterightpointingtriangle = 9655, t.whitesmallsquare = 9643, t.whitesmilingface = 9786, t.whitesquare = 9633, t.whitestar = 9734, t.whitetelephone = 9743, t.whitetortoiseshellbracketleft = 12312, t.whitetortoiseshellbracketright = 12313, t.whiteuppointingsmalltriangle = 9653, t.whiteuppointingtriangle = 9651, t.wihiragana = 12432, t.wikatakana = 12528, t.wikorean = 12639, t.wmonospace = 65367, t.wohiragana = 12434, t.wokatakana = 12530, t.wokatakanahalfwidth = 65382, t.won = 8361, t.wonmonospace = 65510, t.wowaenthai = 3623, t.wparen = 9394, t.wring = 7832, t.wsuperior = 695, t.wturned = 653, t.wynn = 447, t.x = 120, t.xabovecmb = 829, t.xbopomofo = 12562, t.xcircle = 9447, t.xdieresis = 7821, t.xdotaccent = 7819, t.xeharmenian = 1389, t.xi = 958, t.xmonospace = 65368, t.xparen = 9395, t.xsuperior = 739, t.y = 121, t.yaadosquare = 13134, t.yabengali = 2479, t.yacute = 253, t.yadeva = 2351, t.yaekorean = 12626, t.yagujarati = 2735, t.yagurmukhi = 2607, t.yahiragana = 12420, t.yakatakana = 12516, t.yakatakanahalfwidth = 65428, t.yakorean = 12625, t.yamakkanthai = 3662, t.yasmallhiragana = 12419, t.yasmallkatakana = 12515, t.yasmallkatakanahalfwidth = 65388, t.yatcyrillic = 1123, t.ycircle = 9448, t.ycircumflex = 375, t.ydieresis = 255, t.ydotaccent = 7823, t.ydotbelow = 7925, t.yeharabic = 1610, t.yehbarreearabic = 1746, t.yehbarreefinalarabic = 64431, t.yehfinalarabic = 65266, t.yehhamzaabovearabic = 1574, t.yehhamzaabovefinalarabic = 65162, t.yehhamzaaboveinitialarabic = 65163, t.yehhamzaabovemedialarabic = 65164, t.yehinitialarabic = 65267, t.yehmedialarabic = 65268, t.yehmeeminitialarabic = 64733, t.yehmeemisolatedarabic = 64600, t.yehnoonfinalarabic = 64660, t.yehthreedotsbelowarabic = 1745, t.yekorean = 12630, t.yen = 165, t.yenmonospace = 65509, t.yeokorean = 12629, t.yeorinhieuhkorean = 12678, t.yerahbenyomohebrew = 1450, t.yerahbenyomolefthebrew = 1450, t.yericyrillic = 1099, t.yerudieresiscyrillic = 1273, t.yesieungkorean = 12673, t.yesieungpansioskorean = 12675, t.yesieungsioskorean = 12674, t.yetivhebrew = 1434, t.ygrave = 7923, t.yhook = 436, t.yhookabove = 7927, t.yiarmenian = 1397, t.yicyrillic = 1111, t.yikorean = 12642, t.yinyang = 9775, t.yiwnarmenian = 1410, t.ymonospace = 65369, t.yod = 1497, t.yoddagesh = 64313, t.yoddageshhebrew = 64313, t.yodhebrew = 1497, t.yodyodhebrew = 1522, t.yodyodpatahhebrew = 64287, t.yohiragana = 12424, t.yoikorean = 12681, t.yokatakana = 12520, t.yokatakanahalfwidth = 65430, t.yokorean = 12635, t.yosmallhiragana = 12423, t.yosmallkatakana = 12519, t.yosmallkatakanahalfwidth = 65390, t.yotgreek = 1011, t.yoyaekorean = 12680, t.yoyakorean = 12679, t.yoyakthai = 3618, t.yoyingthai = 3597, t.yparen = 9396, t.ypogegrammeni = 890, t.ypogegrammenigreekcmb = 837, t.yr = 422, t.yring = 7833, t.ysuperior = 696, t.ytilde = 7929, t.yturned = 654, t.yuhiragana = 12422, t.yuikorean = 12684, t.yukatakana = 12518, t.yukatakanahalfwidth = 65429, t.yukorean = 12640, t.yusbigcyrillic = 1131, t.yusbigiotifiedcyrillic = 1133, t.yuslittlecyrillic = 1127, t.yuslittleiotifiedcyrillic = 1129, t.yusmallhiragana = 12421, t.yusmallkatakana = 12517, t.yusmallkatakanahalfwidth = 65389, t.yuyekorean = 12683, t.yuyeokorean = 12682, t.yyabengali = 2527, t.yyadeva = 2399, t.z = 122, t.zaarmenian = 1382, t.zacute = 378, t.zadeva = 2395, t.zagurmukhi = 2651, t.zaharabic = 1592, t.zahfinalarabic = 65222, t.zahinitialarabic = 65223, t.zahiragana = 12374, t.zahmedialarabic = 65224, t.zainarabic = 1586, t.zainfinalarabic = 65200, t.zakatakana = 12470, t.zaqefgadolhebrew = 1429, t.zaqefqatanhebrew = 1428, t.zarqahebrew = 1432, t.zayin = 1494, t.zayindagesh = 64310, t.zayindageshhebrew = 64310, t.zayinhebrew = 1494, t.zbopomofo = 12567, t.zcaron = 382, t.zcircle = 9449, t.zcircumflex = 7825, t.zcurl = 657, t.zdot = 380, t.zdotaccent = 380, t.zdotbelow = 7827, t.zecyrillic = 1079, t.zedescendercyrillic = 1177, t.zedieresiscyrillic = 1247, t.zehiragana = 12380, t.zekatakana = 12476, t.zero = 48, t.zeroarabic = 1632, t.zerobengali = 2534, t.zerodeva = 2406, t.zerogujarati = 2790, t.zerogurmukhi = 2662, t.zerohackarabic = 1632, t.zeroinferior = 8320, t.zeromonospace = 65296, t.zerooldstyle = 63280, t.zeropersian = 1776, t.zerosuperior = 8304, t.zerothai = 3664, t.zerowidthjoiner = 65279, t.zerowidthnonjoiner = 8204, t.zerowidthspace = 8203, t.zeta = 950, t.zhbopomofo = 12563, t.zhearmenian = 1386, t.zhebrevecyrillic = 1218, t.zhecyrillic = 1078, t.zhedescendercyrillic = 1175, t.zhedieresiscyrillic = 1245, t.zihiragana = 12376, t.zikatakana = 12472, t.zinorhebrew = 1454, t.zlinebelow = 7829, t.zmonospace = 65370, t.zohiragana = 12382, t.zokatakana = 12478, t.zparen = 9397, t.zretroflexhook = 656, t.zstroke = 438, t.zuhiragana = 12378, t.zukatakana = 12474, t[".notdef"] = 0, t.angbracketleftbig = 9001, t.angbracketleftBig = 9001, t.angbracketleftbigg = 9001, t.angbracketleftBigg = 9001, t.angbracketrightBig = 9002, t.angbracketrightbig = 9002, t.angbracketrightBigg = 9002, t.angbracketrightbigg = 9002, t.arrowhookleft = 8618, t.arrowhookright = 8617, t.arrowlefttophalf = 8636, t.arrowleftbothalf = 8637, t.arrownortheast = 8599, t.arrownorthwest = 8598, t.arrowrighttophalf = 8640, t.arrowrightbothalf = 8641, t.arrowsoutheast = 8600, t.arrowsouthwest = 8601, t.backslashbig = 8726, t.backslashBig = 8726, t.backslashBigg = 8726, t.backslashbigg = 8726, t.bardbl = 8214, t.bracehtipdownleft = 65079, t.bracehtipdownright = 65079, t.bracehtipupleft = 65080, t.bracehtipupright = 65080, t.braceleftBig = 123, t.braceleftbig = 123, t.braceleftbigg = 123, t.braceleftBigg = 123, t.bracerightBig = 125, t.bracerightbig = 125, t.bracerightbigg = 125, t.bracerightBigg = 125, t.bracketleftbig = 91, t.bracketleftBig = 91, t.bracketleftbigg = 91, t.bracketleftBigg = 91, t.bracketrightBig = 93, t.bracketrightbig = 93, t.bracketrightbigg = 93, t.bracketrightBigg = 93, t.ceilingleftbig = 8968, t.ceilingleftBig = 8968, t.ceilingleftBigg = 8968, t.ceilingleftbigg = 8968, t.ceilingrightbig = 8969, t.ceilingrightBig = 8969, t.ceilingrightbigg = 8969, t.ceilingrightBigg = 8969, t.circledotdisplay = 8857, t.circledottext = 8857, t.circlemultiplydisplay = 8855, t.circlemultiplytext = 8855, t.circleplusdisplay = 8853, t.circleplustext = 8853, t.contintegraldisplay = 8750, t.contintegraltext = 8750, t.coproductdisplay = 8720, t.coproducttext = 8720, t.floorleftBig = 8970, t.floorleftbig = 8970, t.floorleftbigg = 8970, t.floorleftBigg = 8970, t.floorrightbig = 8971, t.floorrightBig = 8971, t.floorrightBigg = 8971, t.floorrightbigg = 8971, t.hatwide = 770, t.hatwider = 770, t.hatwidest = 770, t.intercal = 7488, t.integraldisplay = 8747, t.integraltext = 8747, t.intersectiondisplay = 8898, t.intersectiontext = 8898, t.logicalanddisplay = 8743, t.logicalandtext = 8743, t.logicalordisplay = 8744, t.logicalortext = 8744, t.parenleftBig = 40, t.parenleftbig = 40, t.parenleftBigg = 40, t.parenleftbigg = 40, t.parenrightBig = 41, t.parenrightbig = 41, t.parenrightBigg = 41, t.parenrightbigg = 41, t.prime = 8242, t.productdisplay = 8719, t.producttext = 8719, t.radicalbig = 8730, t.radicalBig = 8730, t.radicalBigg = 8730, t.radicalbigg = 8730, t.radicalbt = 8730, t.radicaltp = 8730, t.radicalvertex = 8730, t.slashbig = 47, t.slashBig = 47, t.slashBigg = 47, t.slashbigg = 47, t.summationdisplay = 8721, t.summationtext = 8721, t.tildewide = 732, t.tildewider = 732, t.tildewidest = 732, t.uniondisplay = 8899, t.unionmultidisplay = 8846, t.unionmultitext = 8846, t.unionsqdisplay = 8852, t.unionsqtext = 8852, t.uniontext = 8899, t.vextenddouble = 8741, t.vextendsingle = 8739;
}), rQ = jA(function(t) {
  t.space = 32, t.a1 = 9985, t.a2 = 9986, t.a202 = 9987, t.a3 = 9988, t.a4 = 9742, t.a5 = 9990, t.a119 = 9991, t.a118 = 9992, t.a117 = 9993, t.a11 = 9755, t.a12 = 9758, t.a13 = 9996, t.a14 = 9997, t.a15 = 9998, t.a16 = 9999, t.a105 = 1e4, t.a17 = 10001, t.a18 = 10002, t.a19 = 10003, t.a20 = 10004, t.a21 = 10005, t.a22 = 10006, t.a23 = 10007, t.a24 = 10008, t.a25 = 10009, t.a26 = 10010, t.a27 = 10011, t.a28 = 10012, t.a6 = 10013, t.a7 = 10014, t.a8 = 10015, t.a9 = 10016, t.a10 = 10017, t.a29 = 10018, t.a30 = 10019, t.a31 = 10020, t.a32 = 10021, t.a33 = 10022, t.a34 = 10023, t.a35 = 9733, t.a36 = 10025, t.a37 = 10026, t.a38 = 10027, t.a39 = 10028, t.a40 = 10029, t.a41 = 10030, t.a42 = 10031, t.a43 = 10032, t.a44 = 10033, t.a45 = 10034, t.a46 = 10035, t.a47 = 10036, t.a48 = 10037, t.a49 = 10038, t.a50 = 10039, t.a51 = 10040, t.a52 = 10041, t.a53 = 10042, t.a54 = 10043, t.a55 = 10044, t.a56 = 10045, t.a57 = 10046, t.a58 = 10047, t.a59 = 10048, t.a60 = 10049, t.a61 = 10050, t.a62 = 10051, t.a63 = 10052, t.a64 = 10053, t.a65 = 10054, t.a66 = 10055, t.a67 = 10056, t.a68 = 10057, t.a69 = 10058, t.a70 = 10059, t.a71 = 9679, t.a72 = 10061, t.a73 = 9632, t.a74 = 10063, t.a203 = 10064, t.a75 = 10065, t.a204 = 10066, t.a76 = 9650, t.a77 = 9660, t.a78 = 9670, t.a79 = 10070, t.a81 = 9687, t.a82 = 10072, t.a83 = 10073, t.a84 = 10074, t.a97 = 10075, t.a98 = 10076, t.a99 = 10077, t.a100 = 10078, t.a101 = 10081, t.a102 = 10082, t.a103 = 10083, t.a104 = 10084, t.a106 = 10085, t.a107 = 10086, t.a108 = 10087, t.a112 = 9827, t.a111 = 9830, t.a110 = 9829, t.a109 = 9824, t.a120 = 9312, t.a121 = 9313, t.a122 = 9314, t.a123 = 9315, t.a124 = 9316, t.a125 = 9317, t.a126 = 9318, t.a127 = 9319, t.a128 = 9320, t.a129 = 9321, t.a130 = 10102, t.a131 = 10103, t.a132 = 10104, t.a133 = 10105, t.a134 = 10106, t.a135 = 10107, t.a136 = 10108, t.a137 = 10109, t.a138 = 10110, t.a139 = 10111, t.a140 = 10112, t.a141 = 10113, t.a142 = 10114, t.a143 = 10115, t.a144 = 10116, t.a145 = 10117, t.a146 = 10118, t.a147 = 10119, t.a148 = 10120, t.a149 = 10121, t.a150 = 10122, t.a151 = 10123, t.a152 = 10124, t.a153 = 10125, t.a154 = 10126, t.a155 = 10127, t.a156 = 10128, t.a157 = 10129, t.a158 = 10130, t.a159 = 10131, t.a160 = 10132, t.a161 = 8594, t.a163 = 8596, t.a164 = 8597, t.a196 = 10136, t.a165 = 10137, t.a192 = 10138, t.a166 = 10139, t.a167 = 10140, t.a168 = 10141, t.a169 = 10142, t.a170 = 10143, t.a171 = 10144, t.a172 = 10145, t.a173 = 10146, t.a162 = 10147, t.a174 = 10148, t.a175 = 10149, t.a176 = 10150, t.a177 = 10151, t.a178 = 10152, t.a179 = 10153, t.a193 = 10154, t.a180 = 10155, t.a199 = 10156, t.a181 = 10157, t.a200 = 10158, t.a182 = 10159, t.a201 = 10161, t.a183 = 10162, t.a184 = 10163, t.a197 = 10164, t.a185 = 10165, t.a194 = 10166, t.a198 = 10167, t.a186 = 10168, t.a195 = 10169, t.a187 = 10170, t.a188 = 10171, t.a189 = 10172, t.a190 = 10173, t.a191 = 10174, t.a89 = 10088, t.a90 = 10089, t.a93 = 10090, t.a94 = 10091, t.a91 = 10092, t.a92 = 10093, t.a205 = 10094, t.a85 = 10095, t.a206 = 10096, t.a86 = 10097, t.a87 = 10098, t.a88 = 10099, t.a95 = 10100, t.a96 = 10101, t[".notdef"] = 0;
}), gQ = jA(function(t) {
  t[63721] = 169, t[63193] = 169, t[63720] = 174, t[63194] = 174, t[63722] = 8482, t[63195] = 8482, t[63729] = 9127, t[63730] = 9128, t[63731] = 9129, t[63740] = 9131, t[63741] = 9132, t[63742] = 9133, t[63726] = 9121, t[63727] = 9122, t[63728] = 9123, t[63737] = 9124, t[63738] = 9125, t[63739] = 9126, t[63723] = 9115, t[63724] = 9116, t[63725] = 9117, t[63734] = 9118, t[63735] = 9119, t[63736] = 9120;
});
function xa(t, A) {
  let e = A[t];
  if (e !== void 0) return e;
  if (!t) return -1;
  if (t[0] === "u") {
    const i = t.length;
    let a;
    if (i === 7 && t[1] === "n" && t[2] === "i") a = t.substring(3);
    else {
      if (!(i >= 5 && i <= 7)) return -1;
      a = t.substring(1);
    }
    if (a === a.toUpperCase() && (e = parseInt(a, 16), e >= 0))
      return e;
  }
  return -1;
}
const ug = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function oQ(t, A = -1) {
  if (A !== -1) {
    const e = ug[A];
    for (let i = 0, a = e.length; i < a; i += 2) if (t >= e[i] && t <= e[i + 1]) return A;
  }
  for (let e = 0, i = ug.length; e < i; e++) {
    const a = ug[e];
    for (let s = 0, r = a.length; s < r; s += 2) if (t >= a[s] && t <= a[s + 1]) return e;
  }
  return -1;
}
const IQ = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), co = /* @__PURE__ */ new Map(), Ss = !0, On = 1, q1 = 2, ur = 4, uc = 32, dc = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function T1(t, A) {
  if (A[t] !== void 0) return t;
  const e = xa(t, A);
  if (e !== -1) {
    for (const i in A) if (A[i] === e) return i;
  }
  return RA("Unable to recover a standard glyph name for: " + t), t;
}
function P1(t, A, e) {
  const i = /* @__PURE__ */ Object.create(null);
  let a, s, r;
  const n = !!(t.flags & ur);
  if (t.isInternalFont)
    for (r = A, s = 0; s < r.length; s++)
      a = e.indexOf(r[s]), i[s] = a >= 0 ? a : 0;
  else if (t.baseEncodingName)
    for (r = bs(t.baseEncodingName), s = 0; s < r.length; s++)
      a = e.indexOf(r[s]), i[s] = a >= 0 ? a : 0;
  else if (n) for (s in A) i[s] = A[s];
  else
    for (r = ve, s = 0; s < r.length; s++)
      a = e.indexOf(r[s]), i[s] = a >= 0 ? a : 0;
  const g = t.differences;
  let o;
  if (g) for (s in g) {
    const I = g[s];
    if (a = e.indexOf(I), a === -1) {
      o || (o = fe());
      const C = T1(I, o);
      C !== I && (a = e.indexOf(C));
    }
    i[s] = a >= 0 ? a : 0;
  }
  return i;
}
function sn(t) {
  return t.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const cQ = jA((t) => {
  t[8211] = 65074, t[8212] = 65073, t[8229] = 65072, t[8230] = 65049, t[12289] = 65041, t[12290] = 65042, t[12296] = 65087, t[12297] = 65088, t[12298] = 65085, t[12299] = 65086, t[12300] = 65089, t[12301] = 65090, t[12302] = 65091, t[12303] = 65092, t[12304] = 65083, t[12305] = 65084, t[12308] = 65081, t[12309] = 65082, t[12310] = 65047, t[12311] = 65048, t[65103] = 65076, t[65281] = 65045, t[65288] = 65077, t[65289] = 65078, t[65292] = 65040, t[65306] = 65043, t[65307] = 65044, t[65311] = 65046, t[65339] = 65095, t[65341] = 65096, t[65343] = 65075, t[65371] = 65079, t[65373] = 65080;
}), Xr = jA(function(t) {
  t["Times-Roman"] = "Times-Roman", t.Helvetica = "Helvetica", t.Courier = "Courier", t.Symbol = "Symbol", t["Times-Bold"] = "Times-Bold", t["Helvetica-Bold"] = "Helvetica-Bold", t["Courier-Bold"] = "Courier-Bold", t.ZapfDingbats = "ZapfDingbats", t["Times-Italic"] = "Times-Italic", t["Helvetica-Oblique"] = "Helvetica-Oblique", t["Courier-Oblique"] = "Courier-Oblique", t["Times-BoldItalic"] = "Times-BoldItalic", t["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", t["Courier-BoldOblique"] = "Courier-BoldOblique", t.ArialNarrow = "Helvetica", t["ArialNarrow-Bold"] = "Helvetica-Bold", t["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", t["ArialNarrow-Italic"] = "Helvetica-Oblique", t.ArialBlack = "Helvetica", t["ArialBlack-Bold"] = "Helvetica-Bold", t["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", t["ArialBlack-Italic"] = "Helvetica-Oblique", t["Arial-Black"] = "Helvetica", t["Arial-Black-Bold"] = "Helvetica-Bold", t["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-Black-Italic"] = "Helvetica-Oblique", t.Arial = "Helvetica", t["Arial-Bold"] = "Helvetica-Bold", t["Arial-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-Italic"] = "Helvetica-Oblique", t.ArialMT = "Helvetica", t["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", t["Arial-BoldMT"] = "Helvetica-Bold", t["Arial-ItalicMT"] = "Helvetica-Oblique", t["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", t["Arial-BoldMT-Bold"] = "Helvetica-Bold", t["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", t.ArialUnicodeMS = "Helvetica", t["ArialUnicodeMS-Bold"] = "Helvetica-Bold", t["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", t["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", t["Courier-BoldItalic"] = "Courier-BoldOblique", t["Courier-Italic"] = "Courier-Oblique", t.CourierNew = "Courier", t["CourierNew-Bold"] = "Courier-Bold", t["CourierNew-BoldItalic"] = "Courier-BoldOblique", t["CourierNew-Italic"] = "Courier-Oblique", t["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", t["CourierNewPS-BoldMT"] = "Courier-Bold", t["CourierNewPS-ItalicMT"] = "Courier-Oblique", t.CourierNewPSMT = "Courier", t["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", t["Helvetica-Italic"] = "Helvetica-Oblique", t["Symbol-Bold"] = "Symbol", t["Symbol-BoldItalic"] = "Symbol", t["Symbol-Italic"] = "Symbol", t.TimesNewRoman = "Times-Roman", t["TimesNewRoman-Bold"] = "Times-Bold", t["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", t["TimesNewRoman-Italic"] = "Times-Italic", t.TimesNewRomanPS = "Times-Roman", t["TimesNewRomanPS-Bold"] = "Times-Bold", t["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", t["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", t["TimesNewRomanPS-BoldMT"] = "Times-Bold", t["TimesNewRomanPS-Italic"] = "Times-Italic", t["TimesNewRomanPS-ItalicMT"] = "Times-Italic", t.TimesNewRomanPSMT = "Times-Roman", t["TimesNewRomanPSMT-Bold"] = "Times-Bold", t["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", t["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), CQ = jA(function(t) {
  t.Courier = "FoxitFixed.pfb", t["Courier-Bold"] = "FoxitFixedBold.pfb", t["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", t["Courier-Oblique"] = "FoxitFixedItalic.pfb", t.Helvetica = "LiberationSans-Regular.ttf", t["Helvetica-Bold"] = "LiberationSans-Bold.ttf", t["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", t["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", t["Times-Roman"] = "FoxitSerif.pfb", t["Times-Bold"] = "FoxitSerifBold.pfb", t["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", t["Times-Italic"] = "FoxitSerifItalic.pfb", t.Symbol = "FoxitSymbol.pfb", t.ZapfDingbats = "FoxitDingbats.pfb", t["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", t["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", t["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", t["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), W1 = jA(function(t) {
  t.Calibri = "Helvetica", t["Calibri-Bold"] = "Helvetica-Bold", t["Calibri-BoldItalic"] = "Helvetica-BoldOblique", t["Calibri-Italic"] = "Helvetica-Oblique", t.CenturyGothic = "Helvetica", t["CenturyGothic-Bold"] = "Helvetica-Bold", t["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", t["CenturyGothic-Italic"] = "Helvetica-Oblique", t.ComicSansMS = "Comic Sans MS", t["ComicSansMS-Bold"] = "Comic Sans MS-Bold", t["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", t["ComicSansMS-Italic"] = "Comic Sans MS-Italic", t.GillSansMT = "Helvetica", t["GillSansMT-Bold"] = "Helvetica-Bold", t["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", t["GillSansMT-Italic"] = "Helvetica-Oblique", t.Impact = "Helvetica", t["ItcSymbol-Bold"] = "Helvetica-Bold", t["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", t["ItcSymbol-Book"] = "Helvetica", t["ItcSymbol-BookItalic"] = "Helvetica-Oblique", t["ItcSymbol-Medium"] = "Helvetica", t["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", t.LucidaConsole = "Courier", t["LucidaConsole-Bold"] = "Courier-Bold", t["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", t["LucidaConsole-Italic"] = "Courier-Oblique", t["LucidaSans-Demi"] = "Helvetica-Bold", t["MS-Gothic"] = "MS Gothic", t["MS-Gothic-Bold"] = "MS Gothic-Bold", t["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", t["MS-Gothic-Italic"] = "MS Gothic-Italic", t["MS-Mincho"] = "MS Mincho", t["MS-Mincho-Bold"] = "MS Mincho-Bold", t["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", t["MS-Mincho-Italic"] = "MS Mincho-Italic", t["MS-PGothic"] = "MS PGothic", t["MS-PGothic-Bold"] = "MS PGothic-Bold", t["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", t["MS-PGothic-Italic"] = "MS PGothic-Italic", t["MS-PMincho"] = "MS PMincho", t["MS-PMincho-Bold"] = "MS PMincho-Bold", t["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", t["MS-PMincho-Italic"] = "MS PMincho-Italic", t.NuptialScript = "Times-Italic", t.SegoeUISymbol = "Helvetica";
}), aI = jA(function(t) {
  t["Adobe Jenson"] = !0, t["Adobe Text"] = !0, t.Albertus = !0, t.Aldus = !0, t.Alexandria = !0, t.Algerian = !0, t["American Typewriter"] = !0, t.Antiqua = !0, t.Apex = !0, t.Arno = !0, t.Aster = !0, t.Aurora = !0, t.Baskerville = !0, t.Bell = !0, t.Bembo = !0, t["Bembo Schoolbook"] = !0, t.Benguiat = !0, t["Berkeley Old Style"] = !0, t["Bernhard Modern"] = !0, t["Berthold City"] = !0, t.Bodoni = !0, t["Bauer Bodoni"] = !0, t["Book Antiqua"] = !0, t.Bookman = !0, t["Bordeaux Roman"] = !0, t["Californian FB"] = !0, t.Calisto = !0, t.Calvert = !0, t.Capitals = !0, t.Cambria = !0, t.Cartier = !0, t.Caslon = !0, t.Catull = !0, t.Centaur = !0, t["Century Old Style"] = !0, t["Century Schoolbook"] = !0, t.Chaparral = !0, t["Charis SIL"] = !0, t.Cheltenham = !0, t["Cholla Slab"] = !0, t.Clarendon = !0, t.Clearface = !0, t.Cochin = !0, t.Colonna = !0, t["Computer Modern"] = !0, t["Concrete Roman"] = !0, t.Constantia = !0, t["Cooper Black"] = !0, t.Corona = !0, t.Ecotype = !0, t.Egyptienne = !0, t.Elephant = !0, t.Excelsior = !0, t.Fairfield = !0, t["FF Scala"] = !0, t.Folkard = !0, t.Footlight = !0, t.FreeSerif = !0, t["Friz Quadrata"] = !0, t.Garamond = !0, t.Gentium = !0, t.Georgia = !0, t.Gloucester = !0, t["Goudy Old Style"] = !0, t["Goudy Schoolbook"] = !0, t["Goudy Pro Font"] = !0, t.Granjon = !0, t["Guardian Egyptian"] = !0, t.Heather = !0, t.Hercules = !0, t["High Tower Text"] = !0, t.Hiroshige = !0, t["Hoefler Text"] = !0, t["Humana Serif"] = !0, t.Imprint = !0, t["Ionic No. 5"] = !0, t.Janson = !0, t.Joanna = !0, t.Korinna = !0, t.Lexicon = !0, t.LiberationSerif = !0, t["Liberation Serif"] = !0, t["Linux Libertine"] = !0, t.Literaturnaya = !0, t.Lucida = !0, t["Lucida Bright"] = !0, t.Melior = !0, t.Memphis = !0, t.Miller = !0, t.Minion = !0, t.Modern = !0, t["Mona Lisa"] = !0, t["Mrs Eaves"] = !0, t["MS Serif"] = !0, t["Museo Slab"] = !0, t["New York"] = !0, t["Nimbus Roman"] = !0, t["NPS Rawlinson Roadway"] = !0, t.NuptialScript = !0, t.Palatino = !0, t.Perpetua = !0, t.Plantin = !0, t["Plantin Schoolbook"] = !0, t.Playbill = !0, t["Poor Richard"] = !0, t["Rawlinson Roadway"] = !0, t.Renault = !0, t.Requiem = !0, t.Rockwell = !0, t.Roman = !0, t["Rotis Serif"] = !0, t.Sabon = !0, t.Scala = !0, t.Seagull = !0, t.Sistina = !0, t.Souvenir = !0, t.STIX = !0, t["Stone Informal"] = !0, t["Stone Serif"] = !0, t.Sylfaen = !0, t.Times = !0, t.Trajan = !0, t.Trinité = !0, t["Trump Mediaeval"] = !0, t.Utopia = !0, t["Vale Type"] = !0, t["Bitstream Vera"] = !0, t["Vera Serif"] = !0, t.Versailles = !0, t.Wanted = !0, t.Weiss = !0, t["Wide Latin"] = !0, t.Windsor = !0, t.XITS = !0;
}), Co = jA(function(t) {
  t.Dingbats = !0, t.Symbol = !0, t.ZapfDingbats = !0, t.Wingdings = !0, t["Wingdings-Bold"] = !0, t["Wingdings-Regular"] = !0;
}), fc = jA(function(t) {
  t[2] = 10, t[3] = 32, t[4] = 33, t[5] = 34, t[6] = 35, t[7] = 36, t[8] = 37, t[9] = 38, t[10] = 39, t[11] = 40, t[12] = 41, t[13] = 42, t[14] = 43, t[15] = 44, t[16] = 45, t[17] = 46, t[18] = 47, t[19] = 48, t[20] = 49, t[21] = 50, t[22] = 51, t[23] = 52, t[24] = 53, t[25] = 54, t[26] = 55, t[27] = 56, t[28] = 57, t[29] = 58, t[30] = 894, t[31] = 60, t[32] = 61, t[33] = 62, t[34] = 63, t[35] = 64, t[36] = 65, t[37] = 66, t[38] = 67, t[39] = 68, t[40] = 69, t[41] = 70, t[42] = 71, t[43] = 72, t[44] = 73, t[45] = 74, t[46] = 75, t[47] = 76, t[48] = 77, t[49] = 78, t[50] = 79, t[51] = 80, t[52] = 81, t[53] = 82, t[54] = 83, t[55] = 84, t[56] = 85, t[57] = 86, t[58] = 87, t[59] = 88, t[60] = 89, t[61] = 90, t[62] = 91, t[63] = 92, t[64] = 93, t[65] = 94, t[66] = 95, t[67] = 96, t[68] = 97, t[69] = 98, t[70] = 99, t[71] = 100, t[72] = 101, t[73] = 102, t[74] = 103, t[75] = 104, t[76] = 105, t[77] = 106, t[78] = 107, t[79] = 108, t[80] = 109, t[81] = 110, t[82] = 111, t[83] = 112, t[84] = 113, t[85] = 114, t[86] = 115, t[87] = 116, t[88] = 117, t[89] = 118, t[90] = 119, t[91] = 120, t[92] = 121, t[93] = 122, t[94] = 123, t[95] = 124, t[96] = 125, t[97] = 126, t[98] = 196, t[99] = 197, t[100] = 199, t[101] = 201, t[102] = 209, t[103] = 214, t[104] = 220, t[105] = 225, t[106] = 224, t[107] = 226, t[108] = 228, t[109] = 227, t[110] = 229, t[111] = 231, t[112] = 233, t[113] = 232, t[114] = 234, t[115] = 235, t[116] = 237, t[117] = 236, t[118] = 238, t[119] = 239, t[120] = 241, t[121] = 243, t[122] = 242, t[123] = 244, t[124] = 246, t[125] = 245, t[126] = 250, t[127] = 249, t[128] = 251, t[129] = 252, t[130] = 8224, t[131] = 176, t[132] = 162, t[133] = 163, t[134] = 167, t[135] = 8226, t[136] = 182, t[137] = 223, t[138] = 174, t[139] = 169, t[140] = 8482, t[141] = 180, t[142] = 168, t[143] = 8800, t[144] = 198, t[145] = 216, t[146] = 8734, t[147] = 177, t[148] = 8804, t[149] = 8805, t[150] = 165, t[151] = 181, t[152] = 8706, t[153] = 8721, t[154] = 8719, t[156] = 8747, t[157] = 170, t[158] = 186, t[159] = 8486, t[160] = 230, t[161] = 248, t[162] = 191, t[163] = 161, t[164] = 172, t[165] = 8730, t[166] = 402, t[167] = 8776, t[168] = 8710, t[169] = 171, t[170] = 187, t[171] = 8230, t[179] = 8220, t[180] = 8221, t[181] = 8216, t[182] = 8217, t[200] = 193, t[203] = 205, t[207] = 211, t[210] = 218, t[223] = 711, t[224] = 321, t[225] = 322, t[226] = 352, t[227] = 353, t[228] = 381, t[229] = 382, t[233] = 221, t[234] = 253, t[252] = 263, t[253] = 268, t[254] = 269, t[258] = 258, t[260] = 260, t[261] = 261, t[265] = 280, t[266] = 281, t[267] = 282, t[268] = 283, t[269] = 313, t[275] = 323, t[276] = 324, t[278] = 328, t[283] = 344, t[284] = 345, t[285] = 346, t[286] = 347, t[292] = 367, t[295] = 377, t[296] = 378, t[298] = 380, t[305] = 963, t[306] = 964, t[307] = 966, t[308] = 8215, t[309] = 8252, t[310] = 8319, t[311] = 8359, t[312] = 8592, t[313] = 8593, t[337] = 9552, t[493] = 1039, t[494] = 1040, t[672] = 1488, t[673] = 1489, t[674] = 1490, t[675] = 1491, t[676] = 1492, t[677] = 1493, t[678] = 1494, t[679] = 1495, t[680] = 1496, t[681] = 1497, t[682] = 1498, t[683] = 1499, t[684] = 1500, t[685] = 1501, t[686] = 1502, t[687] = 1503, t[688] = 1504, t[689] = 1505, t[690] = 1506, t[691] = 1507, t[692] = 1508, t[693] = 1509, t[694] = 1510, t[695] = 1511, t[696] = 1512, t[697] = 1513, t[698] = 1514, t[705] = 1524, t[706] = 8362, t[710] = 64288, t[711] = 64298, t[759] = 1617, t[761] = 1776, t[763] = 1778, t[775] = 1652, t[777] = 1764, t[778] = 1780, t[779] = 1781, t[780] = 1782, t[782] = 771, t[783] = 64726, t[786] = 8363, t[788] = 8532, t[790] = 768, t[791] = 769, t[792] = 768, t[795] = 803, t[797] = 64336, t[798] = 64337, t[799] = 64342, t[800] = 64343, t[801] = 64344, t[802] = 64345, t[803] = 64362, t[804] = 64363, t[805] = 64364, t[2424] = 7821, t[2425] = 7822, t[2426] = 7823, t[2427] = 7824, t[2428] = 7825, t[2429] = 7826, t[2430] = 7827, t[2433] = 7682, t[2678] = 8045, t[2679] = 8046, t[2830] = 1552, t[2838] = 686, t[2840] = 751, t[2842] = 753, t[2843] = 754, t[2844] = 755, t[2846] = 757, t[2856] = 767, t[2857] = 848, t[2858] = 849, t[2862] = 853, t[2863] = 854, t[2864] = 855, t[2865] = 861, t[2866] = 862, t[2906] = 7460, t[2908] = 7462, t[2909] = 7463, t[2910] = 7464, t[2912] = 7466, t[2913] = 7467, t[2914] = 7468, t[2916] = 7470, t[2917] = 7471, t[2918] = 7472, t[2920] = 7474, t[2921] = 7475, t[2922] = 7476, t[2924] = 7478, t[2925] = 7479, t[2926] = 7480, t[2928] = 7482, t[2929] = 7483, t[2930] = 7484, t[2932] = 7486, t[2933] = 7487, t[2934] = 7488, t[2936] = 7490, t[2937] = 7491, t[2938] = 7492, t[2940] = 7494, t[2941] = 7495, t[2942] = 7496, t[2944] = 7498, t[2946] = 7500, t[2948] = 7502, t[2950] = 7504, t[2951] = 7505, t[2952] = 7506, t[2954] = 7508, t[2955] = 7509, t[2956] = 7510, t[2958] = 7512, t[2959] = 7513, t[2960] = 7514, t[2962] = 7516, t[2963] = 7517, t[2964] = 7518, t[2966] = 7520, t[2967] = 7521, t[2968] = 7522, t[2970] = 7524, t[2971] = 7525, t[2972] = 7526, t[2974] = 7528, t[2975] = 7529, t[2976] = 7530, t[2978] = 1537, t[2979] = 1538, t[2980] = 1539, t[2982] = 1549, t[2983] = 1551, t[2984] = 1552, t[2986] = 1554, t[2987] = 1555, t[2988] = 1556, t[2990] = 1623, t[2991] = 1624, t[2995] = 1775, t[2999] = 1791, t[3002] = 64290, t[3003] = 64291, t[3004] = 64292, t[3006] = 64294, t[3007] = 64295, t[3008] = 64296, t[3011] = 1900, t[3014] = 8223, t[3015] = 8244, t[3017] = 7532, t[3018] = 7533, t[3019] = 7534, t[3075] = 7590, t[3076] = 7591, t[3079] = 7594, t[3080] = 7595, t[3083] = 7598, t[3084] = 7599, t[3087] = 7602, t[3088] = 7603, t[3091] = 7606, t[3092] = 7607, t[3095] = 7610, t[3096] = 7611, t[3099] = 7614, t[3100] = 7615, t[3103] = 7618, t[3104] = 7619, t[3107] = 8337, t[3108] = 8338, t[3116] = 1884, t[3119] = 1885, t[3120] = 1885, t[3123] = 1886, t[3124] = 1886, t[3127] = 1887, t[3128] = 1887, t[3131] = 1888, t[3132] = 1888, t[3135] = 1889, t[3136] = 1889, t[3139] = 1890, t[3140] = 1890, t[3143] = 1891, t[3144] = 1891, t[3147] = 1892, t[3148] = 1892, t[3153] = 580, t[3154] = 581, t[3157] = 584, t[3158] = 585, t[3161] = 588, t[3162] = 589, t[3165] = 891, t[3166] = 892, t[3169] = 1274, t[3170] = 1275, t[3173] = 1278, t[3174] = 1279, t[3181] = 7622, t[3182] = 7623, t[3282] = 11799, t[3316] = 578, t[3379] = 42785, t[3393] = 1159, t[3416] = 8377;
}), hQ = jA(function(t) {
  t[227] = 322, t[264] = 261, t[291] = 346;
}), BQ = jA(function(t) {
  t[1] = 32, t[4] = 65, t[5] = 192, t[6] = 193, t[9] = 196, t[17] = 66, t[18] = 67, t[21] = 268, t[24] = 68, t[28] = 69, t[29] = 200, t[30] = 201, t[32] = 282, t[38] = 70, t[39] = 71, t[44] = 72, t[47] = 73, t[48] = 204, t[49] = 205, t[58] = 74, t[60] = 75, t[62] = 76, t[68] = 77, t[69] = 78, t[75] = 79, t[76] = 210, t[80] = 214, t[87] = 80, t[89] = 81, t[90] = 82, t[92] = 344, t[94] = 83, t[97] = 352, t[100] = 84, t[104] = 85, t[109] = 220, t[115] = 86, t[116] = 87, t[121] = 88, t[122] = 89, t[124] = 221, t[127] = 90, t[129] = 381, t[258] = 97, t[259] = 224, t[260] = 225, t[263] = 228, t[268] = 261, t[271] = 98, t[272] = 99, t[273] = 263, t[275] = 269, t[282] = 100, t[286] = 101, t[287] = 232, t[288] = 233, t[290] = 283, t[295] = 281, t[296] = 102, t[336] = 103, t[346] = 104, t[349] = 105, t[350] = 236, t[351] = 237, t[361] = 106, t[364] = 107, t[367] = 108, t[371] = 322, t[373] = 109, t[374] = 110, t[381] = 111, t[382] = 242, t[383] = 243, t[386] = 246, t[393] = 112, t[395] = 113, t[396] = 114, t[398] = 345, t[400] = 115, t[401] = 347, t[403] = 353, t[410] = 116, t[437] = 117, t[442] = 252, t[448] = 118, t[449] = 119, t[454] = 120, t[455] = 121, t[457] = 253, t[460] = 122, t[462] = 382, t[463] = 380, t[853] = 44, t[855] = 58, t[856] = 46, t[876] = 47, t[878] = 45, t[882] = 45, t[894] = 40, t[895] = 41, t[896] = 91, t[897] = 93, t[923] = 64, t[1004] = 48, t[1005] = 49, t[1006] = 50, t[1007] = 51, t[1008] = 52, t[1009] = 53, t[1010] = 54, t[1011] = 55, t[1012] = 56, t[1013] = 57, t[1081] = 37, t[1085] = 43, t[1086] = 45;
});
function pc(t) {
  const A = sn(t);
  return Xr()[A];
}
function mc(t) {
  const A = sn(t);
  return !!(Xr()[A] || W1()[A] || aI()[A] || Co()[A]);
}
class ns {
  constructor(A = []) {
    this._map = A;
  }
  get length() {
    return this._map.length;
  }
  forEach(A) {
    for (const e in this._map) A(e, this._map[e].charCodeAt(0));
  }
  has(A) {
    return this._map[A] !== void 0;
  }
  get(A) {
    return this._map[A];
  }
  charCodeOf(A) {
    const e = this._map;
    if (e.length <= 65536) return e.indexOf(A);
    for (const i in e) if (e[i] === A) return 0 | i;
    return -1;
  }
  amend(A) {
    for (const e in A) this._map[e] = A[e];
  }
}
class Ae {
  constructor(A, e) {
    this.firstChar = A, this.lastChar = e;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(A) {
    for (let e = this.firstChar, i = this.lastChar; e <= i; e++) A(e, e);
  }
  has(A) {
    return this.firstChar <= A && A <= this.lastChar;
  }
  get(A) {
    if (this.firstChar <= A && A <= this.lastChar) return String.fromCharCode(A);
  }
  charCodeOf(A) {
    return Number.isInteger(A) && A >= this.firstChar && A <= this.lastChar ? A : -1;
  }
  amend(A) {
    xA("Should not call amend()");
  }
}
class dg {
  constructor(A, e) {
    this.properties = e;
    const i = new eI(A, e, Ss);
    this.cff = i.parse(), this.cff.duplicateFirstGlyph();
    const a = new an(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = a.compile();
    } catch {
      G("Failed to compile font " + e.loadedName), this.data = A;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const A = this.cff, e = this.properties, { cidToGidMap: i, cMap: a } = e, s = A.charset.charset;
    let r, n;
    if (e.composite) {
      let o, I;
      if ((i == null ? void 0 : i.length) > 0) {
        o = /* @__PURE__ */ Object.create(null);
        for (let C = 0, h = i.length; C < h; C++) {
          const c = i[C];
          c !== void 0 && (o[c] = C);
        }
      }
      if (r = /* @__PURE__ */ Object.create(null), A.isCIDFont) for (n = 0; n < s.length; n++) {
        const C = s[n];
        I = a.charCodeOf(C), (o == null ? void 0 : o[I]) !== void 0 && (I = o[I]), r[I] = n;
      }
      else for (n = 0; n < A.charStrings.count; n++)
        I = a.charCodeOf(n), r[I] = n;
      return r;
    }
    let g = A.encoding ? A.encoding.encoding : null;
    return e.isInternalFont && (g = e.defaultEncoding), r = P1(e, g, s), r;
  }
  hasGlyphId(A) {
    return this.cff.hasGlyphId(A);
  }
  _createBuiltInEncoding() {
    const { charset: A, encoding: e } = this.cff;
    if (!A || !e) return;
    const i = A.charset, a = e.encoding, s = [];
    for (const r in a) {
      const n = a[r];
      if (n >= 0) {
        const g = i[n];
        g && (s[r] = g);
      }
    }
    s.length > 0 && (this.properties.builtInEncoding = s);
  }
}
function Me(t, A) {
  return (t[A] << 24 | t[A + 1] << 16 | t[A + 2] << 8 | t[A + 3]) >>> 0;
}
function Ct(t, A) {
  return t[A] << 8 | t[A + 1];
}
function ra(t, A) {
  return (t[A] << 24 | t[A + 1] << 16) >> 16;
}
function yc(t, A) {
  return t[A] << 24 >> 24;
}
function mi(t, A) {
  return ra(t, A) / 16384;
}
function ho(t) {
  const A = t.length;
  let e = 32768;
  return A < 1240 ? e = 107 : A < 33900 && (e = 1131), e;
}
function lQ(t, A, e) {
  const i = Ct(t, A + 2) === 1 ? Me(t, A + 8) : Me(t, A + 16), a = Ct(t, A + i);
  let s, r, n;
  if (a === 4) {
    Ct(t, A + i + 2);
    const g = Ct(t, A + i + 6) >> 1;
    for (r = A + i + 14, s = [], n = 0; n < g; n++, r += 2) s[n] = { end: Ct(t, r) };
    for (r += 2, n = 0; n < g; n++, r += 2) s[n].start = Ct(t, r);
    for (n = 0; n < g; n++, r += 2) s[n].idDelta = Ct(t, r);
    for (n = 0; n < g; n++, r += 2) {
      let o = Ct(t, r);
      if (o !== 0) {
        s[n].ids = [];
        for (let I = 0, C = s[n].end - s[n].start + 1; I < C; I++)
          s[n].ids[I] = Ct(t, r + o), o += 2;
      }
    }
    return s;
  }
  if (a === 12) {
    const g = Me(t, A + i + 12);
    for (r = A + i + 16, s = [], n = 0; n < g; n++)
      A = Me(t, r), s.push({ start: A, end: Me(t, r + 4), idDelta: Me(t, r + 8) - A }), r += 12;
    return s;
  }
  throw new X(`unsupported cmap: ${a}`);
}
function QQ(t, A, e, i) {
  var s, r, n;
  const a = new eI(new At(t, A, e - A), {}, i).parse();
  return { glyphs: a.charStrings.objects, subrs: (r = (s = a.topDict.privateDict) == null ? void 0 : s.subrsIndex) == null ? void 0 : r.objects, gsubrs: (n = a.globalSubrIndex) == null ? void 0 : n.objects, isCFFCIDFont: a.isCIDFont, fdSelect: a.fdSelect, fdArray: a.fdArray };
}
function dr(t, A) {
  const e = A.codePointAt(0);
  let i = 0, a = 0, s = t.length - 1;
  for (; a < s; ) {
    const r = a + s + 1 >> 1;
    e < t[r].start ? s = r - 1 : a = r;
  }
  return t[a].start <= e && e <= t[a].end && (i = t[a].idDelta + (t[a].ids ? t[a].ids[e - t[a].start] : e) & 65535), { charCode: e, glyphId: i };
}
function Z1(t, A, e) {
  function i(C, h) {
    A.add(h1, [C, h]);
  }
  function a(C, h) {
    A.add(B1, [C, h]);
  }
  function s(C, h, c, B) {
    A.add(KB, [C, h, c, B]);
  }
  let r = 0;
  const n = ra(t, r);
  let g, o = 0, I = 0;
  if (r += 10, n < 0) do {
    g = Ct(t, r);
    const C = Ct(t, r + 2);
    r += 4;
    let h, c;
    1 & g ? (2 & g ? (h = ra(t, r), c = ra(t, r + 2)) : (h = Ct(t, r), c = Ct(t, r + 2)), r += 4) : 2 & g ? (h = yc(t, r++), c = yc(t, r++)) : (h = t[r++], c = t[r++]), 2 & g ? (o = h, I = c) : (o = 0, I = 0);
    let B = 1, l = 1, Q = 0, E = 0;
    8 & g ? (B = l = mi(t, r), r += 2) : 64 & g ? (B = mi(t, r), l = mi(t, r + 2), r += 4) : 128 & g && (B = mi(t, r), Q = mi(t, r + 2), E = mi(t, r + 4), l = mi(t, r + 6), r += 8);
    const u = e.glyphs[C];
    u && (A.add(jo), A.add(l1, [B, Q, E, l, o, I]), Z1(u, A, e), A.add(Vo));
  } while (32 & g);
  else {
    const C = [];
    let h, c;
    for (h = 0; h < n; h++)
      C.push(Ct(t, r)), r += 2;
    r += 2 + Ct(t, r);
    const B = C.at(-1) + 1, l = [];
    for (; l.length < B; ) {
      g = t[r++];
      let E = 1;
      for (8 & g && (E += t[r++]); E-- > 0; ) l.push({ flags: g });
    }
    for (h = 0; h < B; h++) {
      switch (18 & l[h].flags) {
        case 0:
          o += ra(t, r), r += 2;
          break;
        case 2:
          o -= t[r++];
          break;
        case 18:
          o += t[r++];
      }
      l[h].x = o;
    }
    for (h = 0; h < B; h++) {
      switch (36 & l[h].flags) {
        case 0:
          I += ra(t, r), r += 2;
          break;
        case 4:
          I -= t[r++];
          break;
        case 36:
          I += t[r++];
      }
      l[h].y = I;
    }
    let Q = 0;
    for (r = 0; r < n; r++) {
      const E = C[r], u = l.slice(Q, E + 1);
      if (1 & u[0].flags) u.push(u[0]);
      else if (1 & u.at(-1).flags) u.unshift(u.at(-1));
      else {
        const f = { flags: 1, x: (u[0].x + u.at(-1).x) / 2, y: (u[0].y + u.at(-1).y) / 2 };
        u.unshift(f), u.push(f);
      }
      for (i(u[0].x, u[0].y), h = 1, c = u.length; h < c; h++) 1 & u[h].flags ? a(u[h].x, u[h].y) : 1 & u[h + 1].flags ? (s(u[h].x, u[h].y, u[h + 1].x, u[h + 1].y), h++) : s(u[h].x, u[h].y, (u[h].x + u[h + 1].x) / 2, (u[h].y + u[h + 1].y) / 2);
      Q = E + 1;
    }
  }
}
function Bo(t, A, e, i) {
  function a(C, h) {
    A.add(h1, [C, h]);
  }
  function s(C, h) {
    A.add(B1, [C, h]);
  }
  function r(C, h, c, B, l, Q) {
    A.add(vB, [C, h, c, B, l, Q]);
  }
  const n = [];
  let g = 0, o = 0, I = 0;
  (function C(h) {
    var B;
    let c = 0;
    for (; c < h.length; ) {
      let l, Q, E, u, f, d, p, m, y, b = !1, D = h[c++];
      switch (D) {
        case 1:
        case 3:
        case 18:
        case 23:
          I += n.length >> 1, b = !0;
          break;
        case 4:
          o += n.pop(), a(g, o), b = !0;
          break;
        case 5:
          for (; n.length > 0; )
            g += n.shift(), o += n.shift(), s(g, o);
          break;
        case 6:
          for (; n.length > 0 && (g += n.shift(), s(g, o), n.length !== 0); )
            o += n.shift(), s(g, o);
          break;
        case 7:
          for (; n.length > 0 && (o += n.shift(), s(g, o), n.length !== 0); )
            g += n.shift(), s(g, o);
          break;
        case 8:
          for (; n.length > 0; )
            l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o);
          break;
        case 10:
          if (m = n.pop(), y = null, e.isCFFCIDFont) {
            const R = e.fdSelect.getFDIndex(i);
            if (R >= 0 && R < e.fdArray.length) {
              const k = e.fdArray[R];
              let Y;
              (B = k.privateDict) != null && B.subrsIndex && (Y = k.privateDict.subrsIndex.objects), Y && (m += ho(Y), y = Y[m]);
            } else G("Invalid fd index for glyph index.");
          } else y = e.subrs[m + e.subrsBias];
          y && C(y);
          break;
        case 11:
          return;
        case 12:
          switch (D = h[c++], D) {
            case 34:
              l = g + n.shift(), Q = l + n.shift(), f = o + n.shift(), g = Q + n.shift(), r(l, o, Q, f, g, f), l = g + n.shift(), Q = l + n.shift(), g = Q + n.shift(), r(l, f, Q, o, g, o);
              break;
            case 35:
              l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o), l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o), n.pop();
              break;
            case 36:
              l = g + n.shift(), f = o + n.shift(), Q = l + n.shift(), d = f + n.shift(), g = Q + n.shift(), r(l, f, Q, d, g, d), l = g + n.shift(), Q = l + n.shift(), p = d + n.shift(), g = Q + n.shift(), r(l, d, Q, p, g, o);
              break;
            case 37:
              const R = g, k = o;
              l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o), l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q, o = u, Math.abs(g - R) > Math.abs(o - k) ? g += n.shift() : o += n.shift(), r(l, E, Q, u, g, o);
              break;
            default:
              throw new X(`unknown operator: 12 ${D}`);
          }
          break;
        case 14:
          if (n.length >= 4) {
            const R = n.pop(), k = n.pop();
            o = n.pop(), g = n.pop(), A.add(jo), A.add(TB, [g, o]);
            let Y = dr(e.cmap, String.fromCharCode(e.glyphNameMap[ve[R]]));
            Bo(e.glyphs[Y.glyphId], A, e, Y.glyphId), A.add(Vo), Y = dr(e.cmap, String.fromCharCode(e.glyphNameMap[ve[k]])), Bo(e.glyphs[Y.glyphId], A, e, Y.glyphId);
          }
          return;
        case 19:
        case 20:
          I += n.length >> 1, c += I + 7 >> 3, b = !0;
          break;
        case 21:
          o += n.pop(), g += n.pop(), a(g, o), b = !0;
          break;
        case 22:
          g += n.pop(), a(g, o), b = !0;
          break;
        case 24:
          for (; n.length > 2; )
            l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o);
          g += n.shift(), o += n.shift(), s(g, o);
          break;
        case 25:
          for (; n.length > 6; )
            g += n.shift(), o += n.shift(), s(g, o);
          l = g + n.shift(), E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + n.shift(), r(l, E, Q, u, g, o);
          break;
        case 26:
          for (n.length % 2 && (g += n.shift()); n.length > 0; )
            l = g, E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q, o = u + n.shift(), r(l, E, Q, u, g, o);
          break;
        case 27:
          for (n.length % 2 && (o += n.shift()); n.length > 0; )
            l = g + n.shift(), E = o, Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u, r(l, E, Q, u, g, o);
          break;
        case 28:
          n.push((h[c] << 24 | h[c + 1] << 16) >> 16), c += 2;
          break;
        case 29:
          m = n.pop() + e.gsubrsBias, y = e.gsubrs[m], y && C(y);
          break;
        case 30:
          for (; n.length > 0 && (l = g, E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + (n.length === 1 ? n.shift() : 0), r(l, E, Q, u, g, o), n.length !== 0); )
            l = g + n.shift(), E = o, Q = l + n.shift(), u = E + n.shift(), o = u + n.shift(), g = Q + (n.length === 1 ? n.shift() : 0), r(l, E, Q, u, g, o);
          break;
        case 31:
          for (; n.length > 0 && (l = g + n.shift(), E = o, Q = l + n.shift(), u = E + n.shift(), o = u + n.shift(), g = Q + (n.length === 1 ? n.shift() : 0), r(l, E, Q, u, g, o), n.length !== 0); )
            l = g, E = o + n.shift(), Q = l + n.shift(), u = E + n.shift(), g = Q + n.shift(), o = u + (n.length === 1 ? n.shift() : 0), r(l, E, Q, u, g, o);
          break;
        default:
          if (D < 32) throw new X(`unknown operator: ${D}`);
          D < 247 ? n.push(D - 139) : D < 251 ? n.push(256 * (D - 247) + h[c++] + 108) : D < 255 ? n.push(256 * -(D - 251) - h[c++] - 108) : (n.push((h[c] << 24 | h[c + 1] << 16 | h[c + 2] << 8 | h[c + 3]) / 65536), c += 4);
      }
      b && (n.length = 0);
    }
  })(t);
}
const wc = [];
class EQ {
  constructor() {
    Ft(this, "cmds", []);
  }
  add(A, e) {
    if (e) if (Gt(e, null)) this.cmds.push(A, ...e);
    else {
      G(`Commands.add - "${A}" has at least one non-number arg: "${e}".`);
      const i = e.map((a) => typeof a == "number" ? a : 0);
      this.cmds.push(A, ...i);
    }
    else this.cmds.push(A);
  }
}
class O1 {
  constructor(A) {
    this.fontMatrix = A, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(A) {
    var r;
    const { charCode: e, glyphId: i } = dr(this.cmap, A);
    let a, s = this.compiledGlyphs[i];
    if (!s) {
      try {
        s = this.compileGlyph(this.glyphs[i], i);
      } catch (n) {
        s = wc, a = n;
      }
      this.compiledGlyphs[i] = s;
    }
    if ((r = this.compiledCharCodeToGlyphId)[e] ?? (r[e] = i), a) throw a;
    return s;
  }
  compileGlyph(A, e) {
    if (!A || A.length === 0 || A[0] === 14) return wc;
    let i = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const s = this.fdSelect.getFDIndex(e);
      s >= 0 && s < this.fdArray.length ? i = this.fdArray[s].getByName("FontMatrix") || Ji : G("Invalid fd index for glyph index.");
    }
    const a = new EQ();
    return a.add(jo), a.add(l1, i.slice()), a.add(qB), this.compileGlyphImpl(A, a, e), a.add(Vo), a.cmds;
  }
  compileGlyphImpl() {
    xA("Children classes should implement this.");
  }
  hasBuiltPath(A) {
    const { charCode: e, glyphId: i } = dr(this.cmap, A);
    return this.compiledGlyphs[i] !== void 0 && this.compiledCharCodeToGlyphId[e] !== void 0;
  }
}
class uQ extends O1 {
  constructor(A, e, i) {
    super(i || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = A, this.cmap = e;
  }
  compileGlyphImpl(A, e) {
    Z1(A, e, this);
  }
}
class dQ extends O1 {
  constructor(A, e, i, a) {
    super(i || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = A.glyphs, this.gsubrs = A.gsubrs || [], this.subrs = A.subrs || [], this.cmap = e, this.glyphNameMap = a || fe(), this.gsubrsBias = ho(this.gsubrs), this.subrsBias = ho(this.subrs), this.isCFFCIDFont = A.isCFFCIDFont, this.fdSelect = A.fdSelect, this.fdArray = A.fdArray;
  }
  compileGlyphImpl(A, e, i) {
    Bo(A, e, this, i);
  }
}
class fQ {
  static create(A, e) {
    const i = new Uint8Array(A.data);
    let a, s, r, n, g, o;
    const I = Ct(i, 4);
    for (let C = 0, h = 12; C < I; C++, h += 16) {
      const c = Mt(i.subarray(h, h + 4)), B = Me(i, h + 8), l = Me(i, h + 12);
      switch (c) {
        case "cmap":
          a = lQ(i, B);
          break;
        case "glyf":
          s = i.subarray(B, B + l);
          break;
        case "loca":
          r = i.subarray(B, B + l);
          break;
        case "head":
          o = Ct(i, B + 18), g = Ct(i, B + 50);
          break;
        case "CFF ":
          n = QQ(i, B, B + l, e);
      }
    }
    if (s) {
      const C = o ? [1 / o, 0, 0, 1 / o, 0, 0] : A.fontMatrix;
      return new uQ(function(c, B, l) {
        let Q, E;
        l ? (Q = 4, E = Me) : (Q = 2, E = (d, p) => 2 * Ct(d, p));
        const u = [];
        let f = E(B, 0);
        for (let d = Q; d < B.length; d += Q) {
          const p = E(B, d);
          u.push(c.subarray(f, p)), f = p;
        }
        return u;
      }(s, r, g), a, C);
    }
    return new dQ(n, a, A.fontMatrix, A.glyphNameMap);
  }
}
const pQ = jA(function(t) {
  t.Courier = 600, t["Courier-Bold"] = 600, t["Courier-BoldOblique"] = 600, t["Courier-Oblique"] = 600, t.Helvetica = jA(function(A) {
    A.space = 278, A.exclam = 278, A.quotedbl = 355, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 667, A.quoteright = 222, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 278, A.semicolon = 278, A.less = 584, A.equal = 584, A.greater = 584, A.question = 556, A.at = 1015, A.A = 667, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 500, A.K = 667, A.L = 556, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 278, A.backslash = 278, A.bracketright = 278, A.asciicircum = 469, A.underscore = 556, A.quoteleft = 222, A.a = 556, A.b = 556, A.c = 500, A.d = 556, A.e = 556, A.f = 278, A.g = 556, A.h = 556, A.i = 222, A.j = 222, A.k = 500, A.l = 222, A.m = 833, A.n = 556, A.o = 556, A.p = 556, A.q = 556, A.r = 333, A.s = 500, A.t = 278, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 500, A.braceleft = 334, A.bar = 260, A.braceright = 334, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 191, A.quotedblleft = 333, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 537, A.bullet = 350, A.quotesinglbase = 222, A.quotedblbase = 333, A.quotedblright = 333, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 556, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 222, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 556, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 667, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 500, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 500, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 222, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 500, A.scedilla = 500, A.iacute = 278, A.lozenge = 471, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 556, A.Amacron = 667, A.rcaron = 333, A.ccedilla = 500, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 643, A.Umacron = 722, A.uring = 556, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 667, A.Abreve = 667, A.multiply = 584, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 500, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 260, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 333, A.omacron = 556, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 222, A.tcaron = 317, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 556, A.zacute = 500, A.iogonek = 222, A.Oacute = 778, A.oacute = 556, A.amacron = 556, A.sacute = 500, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 333, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 556, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 299, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 556, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 556, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 556, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 556, A.Ccaron = 722, A.ugrave = 556, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 556, A.Rcommaaccent = 722, A.Lcommaaccent = 556, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 500, A.minus = 584, A.Icircumflex = 278, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 584, A.odieresis = 556, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 556, A.eth = 556, A.zcaron = 500, A.ncommaaccent = 556, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), t["Helvetica-Bold"] = jA(function(A) {
    A.space = 278, A.exclam = 333, A.quotedbl = 474, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 722, A.quoteright = 278, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 333, A.semicolon = 333, A.less = 584, A.equal = 584, A.greater = 584, A.question = 611, A.at = 975, A.A = 722, A.B = 722, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 556, A.K = 722, A.L = 611, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 584, A.underscore = 556, A.quoteleft = 278, A.a = 556, A.b = 611, A.c = 556, A.d = 611, A.e = 556, A.f = 333, A.g = 611, A.h = 611, A.i = 278, A.j = 278, A.k = 556, A.l = 278, A.m = 889, A.n = 611, A.o = 611, A.p = 611, A.q = 611, A.r = 389, A.s = 556, A.t = 333, A.u = 611, A.v = 556, A.w = 778, A.x = 556, A.y = 556, A.z = 500, A.braceleft = 389, A.bar = 280, A.braceright = 389, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 238, A.quotedblleft = 500, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 611, A.fl = 611, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 556, A.bullet = 350, A.quotesinglbase = 278, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 611, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 278, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 611, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 722, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 556, A.scommaaccent = 556, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 611, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 556, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 556, A.scedilla = 556, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 611, A.acircumflex = 556, A.Amacron = 722, A.rcaron = 389, A.ccedilla = 556, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 743, A.Umacron = 722, A.uring = 611, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 584, A.uacute = 611, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 556, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 556, A.nacute = 611, A.umacron = 611, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 280, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 611, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 389, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 556, A.zacute = 500, A.iogonek = 278, A.Oacute = 778, A.oacute = 611, A.amacron = 556, A.sacute = 556, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 611, A.twosuperior = 333, A.Odieresis = 778, A.mu = 611, A.igrave = 278, A.ohungarumlaut = 611, A.Eogonek = 667, A.dcroat = 611, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 400, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 611, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 611, A.ntilde = 611, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 611, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 611, A.Ccaron = 722, A.ugrave = 611, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 611, A.Rcommaaccent = 722, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 556, A.minus = 584, A.Icircumflex = 278, A.ncaron = 611, A.tcommaaccent = 333, A.logicalnot = 584, A.odieresis = 611, A.udieresis = 611, A.notequal = 549, A.gcommaaccent = 611, A.eth = 611, A.zcaron = 500, A.ncommaaccent = 611, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), t["Helvetica-BoldOblique"] = jA(function(A) {
    A.space = 278, A.exclam = 333, A.quotedbl = 474, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 722, A.quoteright = 278, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 333, A.semicolon = 333, A.less = 584, A.equal = 584, A.greater = 584, A.question = 611, A.at = 975, A.A = 722, A.B = 722, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 556, A.K = 722, A.L = 611, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 584, A.underscore = 556, A.quoteleft = 278, A.a = 556, A.b = 611, A.c = 556, A.d = 611, A.e = 556, A.f = 333, A.g = 611, A.h = 611, A.i = 278, A.j = 278, A.k = 556, A.l = 278, A.m = 889, A.n = 611, A.o = 611, A.p = 611, A.q = 611, A.r = 389, A.s = 556, A.t = 333, A.u = 611, A.v = 556, A.w = 778, A.x = 556, A.y = 556, A.z = 500, A.braceleft = 389, A.bar = 280, A.braceright = 389, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 238, A.quotedblleft = 500, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 611, A.fl = 611, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 556, A.bullet = 350, A.quotesinglbase = 278, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 611, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 278, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 611, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 722, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 556, A.scommaaccent = 556, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 611, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 556, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 556, A.scedilla = 556, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 611, A.acircumflex = 556, A.Amacron = 722, A.rcaron = 389, A.ccedilla = 556, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 743, A.Umacron = 722, A.uring = 611, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 584, A.uacute = 611, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 556, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 556, A.nacute = 611, A.umacron = 611, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 280, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 611, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 389, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 556, A.zacute = 500, A.iogonek = 278, A.Oacute = 778, A.oacute = 611, A.amacron = 556, A.sacute = 556, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 611, A.twosuperior = 333, A.Odieresis = 778, A.mu = 611, A.igrave = 278, A.ohungarumlaut = 611, A.Eogonek = 667, A.dcroat = 611, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 400, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 611, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 611, A.ntilde = 611, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 611, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 611, A.Ccaron = 722, A.ugrave = 611, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 611, A.Rcommaaccent = 722, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 556, A.minus = 584, A.Icircumflex = 278, A.ncaron = 611, A.tcommaaccent = 333, A.logicalnot = 584, A.odieresis = 611, A.udieresis = 611, A.notequal = 549, A.gcommaaccent = 611, A.eth = 611, A.zcaron = 500, A.ncommaaccent = 611, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), t["Helvetica-Oblique"] = jA(function(A) {
    A.space = 278, A.exclam = 278, A.quotedbl = 355, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 667, A.quoteright = 222, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 278, A.semicolon = 278, A.less = 584, A.equal = 584, A.greater = 584, A.question = 556, A.at = 1015, A.A = 667, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 500, A.K = 667, A.L = 556, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 278, A.backslash = 278, A.bracketright = 278, A.asciicircum = 469, A.underscore = 556, A.quoteleft = 222, A.a = 556, A.b = 556, A.c = 500, A.d = 556, A.e = 556, A.f = 278, A.g = 556, A.h = 556, A.i = 222, A.j = 222, A.k = 500, A.l = 222, A.m = 833, A.n = 556, A.o = 556, A.p = 556, A.q = 556, A.r = 333, A.s = 500, A.t = 278, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 500, A.braceleft = 334, A.bar = 260, A.braceright = 334, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 191, A.quotedblleft = 333, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 537, A.bullet = 350, A.quotesinglbase = 222, A.quotedblbase = 333, A.quotedblright = 333, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 556, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 222, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 556, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 667, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 500, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 500, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 222, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 500, A.scedilla = 500, A.iacute = 278, A.lozenge = 471, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 556, A.Amacron = 667, A.rcaron = 333, A.ccedilla = 500, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 643, A.Umacron = 722, A.uring = 556, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 667, A.Abreve = 667, A.multiply = 584, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 500, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 260, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 333, A.omacron = 556, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 222, A.tcaron = 317, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 556, A.zacute = 500, A.iogonek = 222, A.Oacute = 778, A.oacute = 556, A.amacron = 556, A.sacute = 500, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 333, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 556, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 299, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 556, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 556, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 556, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 556, A.Ccaron = 722, A.ugrave = 556, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 556, A.Rcommaaccent = 722, A.Lcommaaccent = 556, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 500, A.minus = 584, A.Icircumflex = 278, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 584, A.odieresis = 556, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 556, A.eth = 556, A.zcaron = 500, A.ncommaaccent = 556, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), t.Symbol = jA(function(A) {
    A.space = 250, A.exclam = 333, A.universal = 713, A.numbersign = 500, A.existential = 549, A.percent = 833, A.ampersand = 778, A.suchthat = 439, A.parenleft = 333, A.parenright = 333, A.asteriskmath = 500, A.plus = 549, A.comma = 250, A.minus = 549, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 278, A.semicolon = 278, A.less = 549, A.equal = 549, A.greater = 549, A.question = 444, A.congruent = 549, A.Alpha = 722, A.Beta = 667, A.Chi = 722, A.Delta = 612, A.Epsilon = 611, A.Phi = 763, A.Gamma = 603, A.Eta = 722, A.Iota = 333, A.theta1 = 631, A.Kappa = 722, A.Lambda = 686, A.Mu = 889, A.Nu = 722, A.Omicron = 722, A.Pi = 768, A.Theta = 741, A.Rho = 556, A.Sigma = 592, A.Tau = 611, A.Upsilon = 690, A.sigma1 = 439, A.Omega = 768, A.Xi = 645, A.Psi = 795, A.Zeta = 611, A.bracketleft = 333, A.therefore = 863, A.bracketright = 333, A.perpendicular = 658, A.underscore = 500, A.radicalex = 500, A.alpha = 631, A.beta = 549, A.chi = 549, A.delta = 494, A.epsilon = 439, A.phi = 521, A.gamma = 411, A.eta = 603, A.iota = 329, A.phi1 = 603, A.kappa = 549, A.lambda = 549, A.mu = 576, A.nu = 521, A.omicron = 549, A.pi = 549, A.theta = 521, A.rho = 549, A.sigma = 603, A.tau = 439, A.upsilon = 576, A.omega1 = 713, A.omega = 686, A.xi = 493, A.psi = 686, A.zeta = 494, A.braceleft = 480, A.bar = 200, A.braceright = 480, A.similar = 549, A.Euro = 750, A.Upsilon1 = 620, A.minute = 247, A.lessequal = 549, A.fraction = 167, A.infinity = 713, A.florin = 500, A.club = 753, A.diamond = 753, A.heart = 753, A.spade = 753, A.arrowboth = 1042, A.arrowleft = 987, A.arrowup = 603, A.arrowright = 987, A.arrowdown = 603, A.degree = 400, A.plusminus = 549, A.second = 411, A.greaterequal = 549, A.multiply = 549, A.proportional = 713, A.partialdiff = 494, A.bullet = 460, A.divide = 549, A.notequal = 549, A.equivalence = 549, A.approxequal = 549, A.ellipsis = 1e3, A.arrowvertex = 603, A.arrowhorizex = 1e3, A.carriagereturn = 658, A.aleph = 823, A.Ifraktur = 686, A.Rfraktur = 795, A.weierstrass = 987, A.circlemultiply = 768, A.circleplus = 768, A.emptyset = 823, A.intersection = 768, A.union = 768, A.propersuperset = 713, A.reflexsuperset = 713, A.notsubset = 713, A.propersubset = 713, A.reflexsubset = 713, A.element = 713, A.notelement = 713, A.angle = 768, A.gradient = 713, A.registerserif = 790, A.copyrightserif = 790, A.trademarkserif = 890, A.product = 823, A.radical = 549, A.dotmath = 250, A.logicalnot = 713, A.logicaland = 603, A.logicalor = 603, A.arrowdblboth = 1042, A.arrowdblleft = 987, A.arrowdblup = 603, A.arrowdblright = 987, A.arrowdbldown = 603, A.lozenge = 494, A.angleleft = 329, A.registersans = 790, A.copyrightsans = 790, A.trademarksans = 786, A.summation = 713, A.parenlefttp = 384, A.parenleftex = 384, A.parenleftbt = 384, A.bracketlefttp = 384, A.bracketleftex = 384, A.bracketleftbt = 384, A.bracelefttp = 494, A.braceleftmid = 494, A.braceleftbt = 494, A.braceex = 494, A.angleright = 329, A.integral = 274, A.integraltp = 686, A.integralex = 686, A.integralbt = 686, A.parenrighttp = 384, A.parenrightex = 384, A.parenrightbt = 384, A.bracketrighttp = 384, A.bracketrightex = 384, A.bracketrightbt = 384, A.bracerighttp = 494, A.bracerightmid = 494, A.bracerightbt = 494, A.apple = 790;
  }), t["Times-Roman"] = jA(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 408, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 564, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 278, A.semicolon = 278, A.less = 564, A.equal = 564, A.greater = 564, A.question = 444, A.at = 921, A.A = 722, A.B = 667, A.C = 667, A.D = 722, A.E = 611, A.F = 556, A.G = 722, A.H = 722, A.I = 333, A.J = 389, A.K = 722, A.L = 611, A.M = 889, A.N = 722, A.O = 722, A.P = 556, A.Q = 722, A.R = 667, A.S = 556, A.T = 611, A.U = 722, A.V = 722, A.W = 944, A.X = 722, A.Y = 722, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 469, A.underscore = 500, A.quoteleft = 333, A.a = 444, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 333, A.g = 500, A.h = 500, A.i = 278, A.j = 278, A.k = 500, A.l = 278, A.m = 778, A.n = 500, A.o = 500, A.p = 500, A.q = 500, A.r = 333, A.s = 389, A.t = 278, A.u = 500, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 444, A.braceleft = 480, A.bar = 200, A.braceright = 480, A.asciitilde = 541, A.exclamdown = 333, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 180, A.quotedblleft = 444, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 453, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 444, A.quotedblright = 444, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 444, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 889, A.ordfeminine = 276, A.Lslash = 611, A.Oslash = 722, A.OE = 889, A.ordmasculine = 310, A.ae = 667, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 500, A.Idieresis = 333, A.eacute = 444, A.abreve = 444, A.uhungarumlaut = 500, A.ecaron = 444, A.Ydieresis = 722, A.divide = 564, A.Yacute = 722, A.Acircumflex = 722, A.aacute = 444, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 444, A.Uacute = 722, A.uogonek = 500, A.Edieresis = 611, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 760, A.Emacron = 611, A.ccaron = 444, A.aring = 444, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 444, A.Tcommaaccent = 611, A.Cacute = 667, A.atilde = 444, A.Edotaccent = 611, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 471, A.Rcaron = 667, A.Gcommaaccent = 722, A.ucircumflex = 500, A.acircumflex = 444, A.Amacron = 722, A.rcaron = 333, A.ccedilla = 444, A.Zdotaccent = 611, A.Thorn = 556, A.Omacron = 722, A.Racute = 667, A.Sacute = 556, A.dcaron = 588, A.Umacron = 722, A.uring = 500, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 722, A.Abreve = 722, A.multiply = 564, A.uacute = 500, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 611, A.adieresis = 444, A.edieresis = 444, A.cacute = 444, A.nacute = 500, A.umacron = 500, A.Ncaron = 722, A.Iacute = 333, A.plusminus = 564, A.brokenbar = 200, A.registered = 760, A.Gbreve = 722, A.Idotaccent = 333, A.summation = 600, A.Egrave = 611, A.racute = 333, A.omacron = 500, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 326, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 444, A.zacute = 444, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 444, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 500, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 611, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 344, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 980, A.edotaccent = 444, A.Igrave = 333, A.Imacron = 333, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 500, A.Uhungarumlaut = 722, A.Eacute = 611, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 500, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 667, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 722, A.zdotaccent = 444, A.Ecaron = 611, A.Iogonek = 333, A.kcommaaccent = 500, A.minus = 564, A.Icircumflex = 333, A.ncaron = 500, A.tcommaaccent = 278, A.logicalnot = 564, A.odieresis = 500, A.udieresis = 500, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 444, A.ncommaaccent = 500, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), t["Times-Bold"] = jA(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 555, A.numbersign = 500, A.dollar = 500, A.percent = 1e3, A.ampersand = 833, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 570, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 570, A.equal = 570, A.greater = 570, A.question = 500, A.at = 930, A.A = 722, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 778, A.I = 389, A.J = 500, A.K = 778, A.L = 667, A.M = 944, A.N = 722, A.O = 778, A.P = 611, A.Q = 778, A.R = 722, A.S = 556, A.T = 667, A.U = 722, A.V = 722, A.W = 1e3, A.X = 722, A.Y = 722, A.Z = 667, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 581, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 556, A.c = 444, A.d = 556, A.e = 444, A.f = 333, A.g = 500, A.h = 556, A.i = 278, A.j = 333, A.k = 556, A.l = 278, A.m = 833, A.n = 556, A.o = 500, A.p = 556, A.q = 556, A.r = 444, A.s = 389, A.t = 333, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 444, A.braceleft = 394, A.bar = 220, A.braceright = 394, A.asciitilde = 520, A.exclamdown = 333, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 278, A.quotedblleft = 500, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 540, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 300, A.Lslash = 667, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 330, A.ae = 722, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 556, A.Idieresis = 389, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 556, A.ecaron = 444, A.Ydieresis = 722, A.divide = 570, A.Yacute = 722, A.Acircumflex = 722, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 747, A.Emacron = 667, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 667, A.Cacute = 722, A.atilde = 500, A.Edotaccent = 667, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 500, A.Amacron = 722, A.rcaron = 444, A.ccedilla = 444, A.Zdotaccent = 667, A.Thorn = 611, A.Omacron = 778, A.Racute = 722, A.Sacute = 556, A.dcaron = 672, A.Umacron = 722, A.uring = 556, A.threesuperior = 300, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 570, A.uacute = 556, A.Tcaron = 667, A.partialdiff = 494, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 389, A.plusminus = 570, A.brokenbar = 220, A.registered = 747, A.Gbreve = 778, A.Idotaccent = 389, A.summation = 600, A.Egrave = 667, A.racute = 444, A.omacron = 500, A.Zacute = 667, A.Zcaron = 667, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 416, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 444, A.zacute = 444, A.iogonek = 278, A.Oacute = 778, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 300, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 394, A.Kcommaaccent = 778, A.Lacute = 667, A.trademark = 1e3, A.edotaccent = 444, A.Igrave = 389, A.Imacron = 389, A.Lcaron = 667, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 500, A.Ccaron = 722, A.ugrave = 556, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 444, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 722, A.Lcommaaccent = 667, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 444, A.Ecaron = 667, A.Iogonek = 389, A.kcommaaccent = 556, A.minus = 570, A.Icircumflex = 389, A.ncaron = 556, A.tcommaaccent = 333, A.logicalnot = 570, A.odieresis = 500, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 444, A.ncommaaccent = 556, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), t["Times-BoldItalic"] = jA(function(A) {
    A.space = 250, A.exclam = 389, A.quotedbl = 555, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 570, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 570, A.equal = 570, A.greater = 570, A.question = 500, A.at = 832, A.A = 667, A.B = 667, A.C = 667, A.D = 722, A.E = 667, A.F = 667, A.G = 722, A.H = 778, A.I = 389, A.J = 500, A.K = 667, A.L = 611, A.M = 889, A.N = 722, A.O = 722, A.P = 611, A.Q = 722, A.R = 667, A.S = 556, A.T = 611, A.U = 722, A.V = 667, A.W = 889, A.X = 667, A.Y = 611, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 570, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 333, A.g = 500, A.h = 556, A.i = 278, A.j = 278, A.k = 500, A.l = 278, A.m = 778, A.n = 556, A.o = 500, A.p = 500, A.q = 500, A.r = 389, A.s = 389, A.t = 278, A.u = 556, A.v = 444, A.w = 667, A.x = 500, A.y = 444, A.z = 389, A.braceleft = 348, A.bar = 220, A.braceright = 348, A.asciitilde = 570, A.exclamdown = 389, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 278, A.quotedblleft = 500, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 500, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 944, A.ordfeminine = 266, A.Lslash = 611, A.Oslash = 722, A.OE = 944, A.ordmasculine = 300, A.ae = 722, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 500, A.Idieresis = 389, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 556, A.ecaron = 444, A.Ydieresis = 611, A.divide = 570, A.Yacute = 611, A.Acircumflex = 667, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 444, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 747, A.Emacron = 667, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 611, A.Cacute = 667, A.atilde = 500, A.Edotaccent = 667, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 494, A.Rcaron = 667, A.Gcommaaccent = 722, A.ucircumflex = 556, A.acircumflex = 500, A.Amacron = 667, A.rcaron = 389, A.ccedilla = 444, A.Zdotaccent = 611, A.Thorn = 611, A.Omacron = 722, A.Racute = 667, A.Sacute = 556, A.dcaron = 608, A.Umacron = 722, A.uring = 556, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 667, A.Abreve = 667, A.multiply = 570, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 444, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 389, A.plusminus = 570, A.brokenbar = 220, A.registered = 747, A.Gbreve = 722, A.Idotaccent = 389, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 500, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 366, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 444, A.zacute = 389, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 576, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 667, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 382, A.Kcommaaccent = 667, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 444, A.Igrave = 389, A.Imacron = 389, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 556, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 667, A.Lcommaaccent = 611, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 722, A.zdotaccent = 389, A.Ecaron = 667, A.Iogonek = 389, A.kcommaaccent = 500, A.minus = 606, A.Icircumflex = 389, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 606, A.odieresis = 500, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 389, A.ncommaaccent = 556, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), t["Times-Italic"] = jA(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 420, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 675, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 675, A.equal = 675, A.greater = 675, A.question = 500, A.at = 920, A.A = 611, A.B = 611, A.C = 667, A.D = 722, A.E = 611, A.F = 611, A.G = 722, A.H = 722, A.I = 333, A.J = 444, A.K = 667, A.L = 556, A.M = 833, A.N = 667, A.O = 722, A.P = 611, A.Q = 722, A.R = 611, A.S = 500, A.T = 556, A.U = 722, A.V = 611, A.W = 833, A.X = 611, A.Y = 556, A.Z = 556, A.bracketleft = 389, A.backslash = 278, A.bracketright = 389, A.asciicircum = 422, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 278, A.g = 500, A.h = 500, A.i = 278, A.j = 278, A.k = 444, A.l = 278, A.m = 722, A.n = 500, A.o = 500, A.p = 500, A.q = 500, A.r = 389, A.s = 389, A.t = 278, A.u = 500, A.v = 444, A.w = 667, A.x = 444, A.y = 444, A.z = 389, A.braceleft = 400, A.bar = 275, A.braceright = 400, A.asciitilde = 541, A.exclamdown = 389, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 214, A.quotedblleft = 556, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 523, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 556, A.quotedblright = 556, A.guillemotright = 500, A.ellipsis = 889, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 889, A.AE = 889, A.ordfeminine = 276, A.Lslash = 556, A.Oslash = 722, A.OE = 944, A.ordmasculine = 310, A.ae = 667, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 667, A.germandbls = 500, A.Idieresis = 333, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 500, A.ecaron = 444, A.Ydieresis = 556, A.divide = 675, A.Yacute = 556, A.Acircumflex = 611, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 444, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 500, A.Edieresis = 611, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 760, A.Emacron = 611, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 667, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 556, A.Cacute = 667, A.atilde = 500, A.Edotaccent = 611, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 471, A.Rcaron = 611, A.Gcommaaccent = 722, A.ucircumflex = 500, A.acircumflex = 500, A.Amacron = 611, A.rcaron = 389, A.ccedilla = 444, A.Zdotaccent = 556, A.Thorn = 611, A.Omacron = 722, A.Racute = 611, A.Sacute = 500, A.dcaron = 544, A.Umacron = 722, A.uring = 500, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 611, A.Abreve = 611, A.multiply = 675, A.uacute = 500, A.Tcaron = 556, A.partialdiff = 476, A.ydieresis = 444, A.Nacute = 667, A.icircumflex = 278, A.Ecircumflex = 611, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 500, A.umacron = 500, A.Ncaron = 667, A.Iacute = 333, A.plusminus = 675, A.brokenbar = 275, A.registered = 760, A.Gbreve = 722, A.Idotaccent = 333, A.summation = 600, A.Egrave = 611, A.racute = 389, A.omacron = 500, A.Zacute = 556, A.Zcaron = 556, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 300, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 611, A.Adieresis = 611, A.egrave = 444, A.zacute = 389, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 500, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 611, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 500, A.lcaron = 300, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 980, A.edotaccent = 444, A.Igrave = 333, A.Imacron = 333, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 500, A.Uhungarumlaut = 722, A.Eacute = 611, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 500, A.Scommaaccent = 500, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 500, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 667, A.otilde = 500, A.Rcommaaccent = 611, A.Lcommaaccent = 556, A.Atilde = 611, A.Aogonek = 611, A.Aring = 611, A.Otilde = 722, A.zdotaccent = 389, A.Ecaron = 611, A.Iogonek = 333, A.kcommaaccent = 444, A.minus = 675, A.Icircumflex = 333, A.ncaron = 500, A.tcommaaccent = 278, A.logicalnot = 675, A.odieresis = 500, A.udieresis = 500, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 389, A.ncommaaccent = 500, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), t.ZapfDingbats = jA(function(A) {
    A.space = 278, A.a1 = 974, A.a2 = 961, A.a202 = 974, A.a3 = 980, A.a4 = 719, A.a5 = 789, A.a119 = 790, A.a118 = 791, A.a117 = 690, A.a11 = 960, A.a12 = 939, A.a13 = 549, A.a14 = 855, A.a15 = 911, A.a16 = 933, A.a105 = 911, A.a17 = 945, A.a18 = 974, A.a19 = 755, A.a20 = 846, A.a21 = 762, A.a22 = 761, A.a23 = 571, A.a24 = 677, A.a25 = 763, A.a26 = 760, A.a27 = 759, A.a28 = 754, A.a6 = 494, A.a7 = 552, A.a8 = 537, A.a9 = 577, A.a10 = 692, A.a29 = 786, A.a30 = 788, A.a31 = 788, A.a32 = 790, A.a33 = 793, A.a34 = 794, A.a35 = 816, A.a36 = 823, A.a37 = 789, A.a38 = 841, A.a39 = 823, A.a40 = 833, A.a41 = 816, A.a42 = 831, A.a43 = 923, A.a44 = 744, A.a45 = 723, A.a46 = 749, A.a47 = 790, A.a48 = 792, A.a49 = 695, A.a50 = 776, A.a51 = 768, A.a52 = 792, A.a53 = 759, A.a54 = 707, A.a55 = 708, A.a56 = 682, A.a57 = 701, A.a58 = 826, A.a59 = 815, A.a60 = 789, A.a61 = 789, A.a62 = 707, A.a63 = 687, A.a64 = 696, A.a65 = 689, A.a66 = 786, A.a67 = 787, A.a68 = 713, A.a69 = 791, A.a70 = 785, A.a71 = 791, A.a72 = 873, A.a73 = 761, A.a74 = 762, A.a203 = 762, A.a75 = 759, A.a204 = 759, A.a76 = 892, A.a77 = 892, A.a78 = 788, A.a79 = 784, A.a81 = 438, A.a82 = 138, A.a83 = 277, A.a84 = 415, A.a97 = 392, A.a98 = 392, A.a99 = 668, A.a100 = 668, A.a89 = 390, A.a90 = 390, A.a93 = 317, A.a94 = 317, A.a91 = 276, A.a92 = 276, A.a205 = 509, A.a85 = 509, A.a206 = 410, A.a86 = 410, A.a87 = 234, A.a88 = 234, A.a95 = 334, A.a96 = 334, A.a101 = 732, A.a102 = 544, A.a103 = 544, A.a104 = 910, A.a106 = 667, A.a107 = 760, A.a108 = 760, A.a112 = 776, A.a111 = 595, A.a110 = 694, A.a109 = 626, A.a120 = 788, A.a121 = 788, A.a122 = 788, A.a123 = 788, A.a124 = 788, A.a125 = 788, A.a126 = 788, A.a127 = 788, A.a128 = 788, A.a129 = 788, A.a130 = 788, A.a131 = 788, A.a132 = 788, A.a133 = 788, A.a134 = 788, A.a135 = 788, A.a136 = 788, A.a137 = 788, A.a138 = 788, A.a139 = 788, A.a140 = 788, A.a141 = 788, A.a142 = 788, A.a143 = 788, A.a144 = 788, A.a145 = 788, A.a146 = 788, A.a147 = 788, A.a148 = 788, A.a149 = 788, A.a150 = 788, A.a151 = 788, A.a152 = 788, A.a153 = 788, A.a154 = 788, A.a155 = 788, A.a156 = 788, A.a157 = 788, A.a158 = 788, A.a159 = 788, A.a160 = 894, A.a161 = 838, A.a163 = 1016, A.a164 = 458, A.a196 = 748, A.a165 = 924, A.a192 = 748, A.a166 = 918, A.a167 = 927, A.a168 = 928, A.a169 = 928, A.a170 = 834, A.a171 = 873, A.a172 = 828, A.a173 = 924, A.a162 = 924, A.a174 = 917, A.a175 = 930, A.a176 = 931, A.a177 = 463, A.a178 = 883, A.a179 = 836, A.a193 = 836, A.a180 = 867, A.a199 = 867, A.a181 = 696, A.a200 = 696, A.a182 = 874, A.a201 = 874, A.a183 = 760, A.a184 = 946, A.a197 = 771, A.a185 = 865, A.a194 = 771, A.a198 = 888, A.a186 = 967, A.a195 = 888, A.a187 = 831, A.a188 = 873, A.a189 = 927, A.a190 = 970, A.a191 = 918;
  });
}), mQ = jA(function(t) {
  t.Courier = { ascent: 629, descent: -157, capHeight: 562, xHeight: -426 }, t["Courier-Bold"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 439 }, t["Courier-Oblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, t["Courier-BoldOblique"] = { ascent: 629, descent: -157, capHeight: 562, xHeight: 426 }, t.Helvetica = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, t["Helvetica-Bold"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, t["Helvetica-Oblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 523 }, t["Helvetica-BoldOblique"] = { ascent: 718, descent: -207, capHeight: 718, xHeight: 532 }, t["Times-Roman"] = { ascent: 683, descent: -217, capHeight: 662, xHeight: 450 }, t["Times-Bold"] = { ascent: 683, descent: -217, capHeight: 676, xHeight: 461 }, t["Times-Italic"] = { ascent: 683, descent: -217, capHeight: 653, xHeight: 441 }, t["Times-BoldItalic"] = { ascent: 683, descent: -217, capHeight: 669, xHeight: 462 }, t.Symbol = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN }, t.ZapfDingbats = { ascent: Math.NaN, descent: Math.NaN, capHeight: Math.NaN, xHeight: Math.NaN };
});
class yQ {
  constructor({ glyfTable: A, isGlyphLocationsLong: e, locaTable: i, numGlyphs: a }) {
    this.glyphs = [];
    const s = new DataView(i.buffer, i.byteOffset, i.byteLength), r = new DataView(A.buffer, A.byteOffset, A.byteLength), n = e ? 4 : 2;
    let g = e ? s.getUint32(0) : 2 * s.getUint16(0), o = 0;
    for (let I = 0; I < a; I++) {
      o += n;
      const C = e ? s.getUint32(o) : 2 * s.getUint16(o);
      if (C === g) {
        this.glyphs.push(new Rs({}));
        continue;
      }
      const h = Rs.parse(g, r);
      this.glyphs.push(h), g = C;
    }
  }
  getSize() {
    return this.glyphs.reduce((A, e) => A + (e.getSize() + 3 & -4), 0);
  }
  write() {
    const A = this.getSize(), e = new DataView(new ArrayBuffer(A)), i = A > 131070, a = i ? 4 : 2, s = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a));
    i ? s.setUint32(0, 0) : s.setUint16(0, 0);
    let r = 0, n = 0;
    for (const g of this.glyphs)
      r += g.write(r, e), r = r + 3 & -4, n += a, i ? s.setUint32(n, r) : s.setUint16(n, r >> 1);
    return { isLocationLong: i, loca: new Uint8Array(s.buffer), glyf: new Uint8Array(e.buffer) };
  }
  scale(A) {
    for (let e = 0, i = this.glyphs.length; e < i; e++) this.glyphs[e].scale(A[e]);
  }
}
class Rs {
  constructor({ header: A = null, simple: e = null, composites: i = null }) {
    this.header = A, this.simple = e, this.composites = i;
  }
  static parse(A, e) {
    const [i, a] = sI.parse(A, e);
    if (A += i, a.numberOfContours < 0) {
      const r = [];
      for (; ; ) {
        const [n, g] = rI.parse(A, e);
        if (A += n, r.push(g), !(32 & g.flags)) break;
      }
      return new Rs({ header: a, composites: r });
    }
    const s = nI.parse(A, e, a.numberOfContours);
    return new Rs({ header: a, simple: s });
  }
  getSize() {
    if (!this.header) return 0;
    const A = this.simple ? this.simple.getSize() : this.composites.reduce((e, i) => e + i.getSize(), 0);
    return this.header.getSize() + A;
  }
  write(A, e) {
    if (!this.header) return 0;
    const i = A;
    if (A += this.header.write(A, e), this.simple) A += this.simple.write(A, e);
    else for (const a of this.composites) A += a.write(A, e);
    return A - i;
  }
  scale(A) {
    if (!this.header) return;
    const e = (this.header.xMin + this.header.xMax) / 2;
    if (this.header.scale(e, A), this.simple) this.simple.scale(e, A);
    else for (const i of this.composites) i.scale(e, A);
  }
}
class sI {
  constructor({ numberOfContours: A, xMin: e, yMin: i, xMax: a, yMax: s }) {
    this.numberOfContours = A, this.xMin = e, this.yMin = i, this.xMax = a, this.yMax = s;
  }
  static parse(A, e) {
    return [10, new sI({ numberOfContours: e.getInt16(A), xMin: e.getInt16(A + 2), yMin: e.getInt16(A + 4), xMax: e.getInt16(A + 6), yMax: e.getInt16(A + 8) })];
  }
  getSize() {
    return 10;
  }
  write(A, e) {
    return e.setInt16(A, this.numberOfContours), e.setInt16(A + 2, this.xMin), e.setInt16(A + 4, this.yMin), e.setInt16(A + 6, this.xMax), e.setInt16(A + 8, this.yMax), 10;
  }
  scale(A, e) {
    this.xMin = Math.round(A + (this.xMin - A) * e), this.xMax = Math.round(A + (this.xMax - A) * e);
  }
}
class wQ {
  constructor({ flags: A, xCoordinates: e, yCoordinates: i }) {
    this.xCoordinates = e, this.yCoordinates = i, this.flags = A;
  }
}
class nI {
  constructor({ contours: A, instructions: e }) {
    this.contours = A, this.instructions = e;
  }
  static parse(A, e, i) {
    const a = [];
    for (let Q = 0; Q < i; Q++) {
      const E = e.getUint16(A);
      A += 2, a.push(E);
    }
    const s = a[i - 1] + 1, r = e.getUint16(A);
    A += 2;
    const n = new Uint8Array(e).slice(A, A + r);
    A += r;
    const g = [];
    for (let Q = 0; Q < s; A++, Q++) {
      let E = e.getUint8(A);
      if (g.push(E), 8 & E) {
        const u = e.getUint8(++A);
        E ^= 8;
        for (let f = 0; f < u; f++) g.push(E);
        Q += u;
      }
    }
    const o = [];
    let I = [], C = [], h = [];
    const c = [];
    let B = 0, l = 0;
    for (let Q = 0; Q < s; Q++) {
      const E = g[Q];
      if (2 & E) {
        const u = e.getUint8(A++);
        l += 16 & E ? u : -u, I.push(l);
      } else 16 & E || (l += e.getInt16(A), A += 2), I.push(l);
      a[B] === Q && (B++, o.push(I), I = []);
    }
    l = 0, B = 0;
    for (let Q = 0; Q < s; Q++) {
      const E = g[Q];
      if (4 & E) {
        const u = e.getUint8(A++);
        l += 32 & E ? u : -u, C.push(l);
      } else 32 & E || (l += e.getInt16(A), A += 2), C.push(l);
      h.push(1 & E | 64 & E), a[B] === Q && (I = o[B], B++, c.push(new wQ({ flags: h, xCoordinates: I, yCoordinates: C })), C = [], h = []);
    }
    return new nI({ contours: c, instructions: n });
  }
  getSize() {
    let A = 2 * this.contours.length + 2 + this.instructions.length, e = 0, i = 0;
    for (const a of this.contours) {
      A += a.flags.length;
      for (let s = 0, r = a.xCoordinates.length; s < r; s++) {
        const n = a.xCoordinates[s], g = a.yCoordinates[s];
        let o = Math.abs(n - e);
        o > 255 ? A += 2 : o > 0 && (A += 1), e = n, o = Math.abs(g - i), o > 255 ? A += 2 : o > 0 && (A += 1), i = g;
      }
    }
    return A;
  }
  write(A, e) {
    const i = A, a = [], s = [], r = [];
    let n = 0, g = 0;
    for (const o of this.contours) {
      for (let I = 0, C = o.xCoordinates.length; I < C; I++) {
        let h = o.flags[I];
        const c = o.xCoordinates[I];
        let B = c - n;
        if (B === 0)
          h |= 16, a.push(0);
        else {
          const Q = Math.abs(B);
          Q <= 255 ? (h |= B >= 0 ? 18 : 2, a.push(Q)) : a.push(B);
        }
        n = c;
        const l = o.yCoordinates[I];
        if (B = l - g, B === 0)
          h |= 32, s.push(0);
        else {
          const Q = Math.abs(B);
          Q <= 255 ? (h |= B >= 0 ? 36 : 4, s.push(Q)) : s.push(B);
        }
        g = l, r.push(h);
      }
      e.setUint16(A, a.length - 1), A += 2;
    }
    e.setUint16(A, this.instructions.length), A += 2, this.instructions.length && (new Uint8Array(e.buffer, 0, e.buffer.byteLength).set(this.instructions, A), A += this.instructions.length);
    for (const o of r) e.setUint8(A++, o);
    for (let o = 0, I = a.length; o < I; o++) {
      const C = a[o], h = r[o];
      2 & h ? e.setUint8(A++, C) : 16 & h || (e.setInt16(A, C), A += 2);
    }
    for (let o = 0, I = s.length; o < I; o++) {
      const C = s[o], h = r[o];
      4 & h ? e.setUint8(A++, C) : 32 & h || (e.setInt16(A, C), A += 2);
    }
    return A - i;
  }
  scale(A, e) {
    for (const i of this.contours) if (i.xCoordinates.length !== 0) for (let a = 0, s = i.xCoordinates.length; a < s; a++) i.xCoordinates[a] = Math.round(A + (i.xCoordinates[a] - A) * e);
  }
}
class rI {
  constructor({ flags: A, glyphIndex: e, argument1: i, argument2: a, transf: s, instructions: r }) {
    this.flags = A, this.glyphIndex = e, this.argument1 = i, this.argument2 = a, this.transf = s, this.instructions = r;
  }
  static parse(A, e) {
    const i = A, a = [];
    let s = e.getUint16(A);
    const r = e.getUint16(A + 2);
    A += 4;
    let n, g;
    1 & s ? (2 & s ? (n = e.getInt16(A), g = e.getInt16(A + 2)) : (n = e.getUint16(A), g = e.getUint16(A + 2)), A += 4, s ^= 1) : (2 & s ? (n = e.getInt8(A), g = e.getInt8(A + 1)) : (n = e.getUint8(A), g = e.getUint8(A + 1)), A += 2), 8 & s ? (a.push(e.getUint16(A)), A += 2) : 64 & s ? (a.push(e.getUint16(A), e.getUint16(A + 2)), A += 4) : 128 & s && (a.push(e.getUint16(A), e.getUint16(A + 2), e.getUint16(A + 4), e.getUint16(A + 6)), A += 8);
    let o = null;
    if (256 & s) {
      const I = e.getUint16(A);
      A += 2, o = new Uint8Array(e).slice(A, A + I), A += I;
    }
    return [A - i, new rI({ flags: s, glyphIndex: r, argument1: n, argument2: g, transf: a, instructions: o })];
  }
  getSize() {
    let A = 4 + 2 * this.transf.length;
    return 256 & this.flags && (A += 2 + this.instructions.length), A += 2, 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (A += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (A += 2), A;
  }
  write(A, e) {
    const i = A;
    return 2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1), e.setUint16(A, this.flags), e.setUint16(A + 2, this.glyphIndex), A += 4, 1 & this.flags ? (2 & this.flags ? (e.setInt16(A, this.argument1), e.setInt16(A + 2, this.argument2)) : (e.setUint16(A, this.argument1), e.setUint16(A + 2, this.argument2)), A += 4) : (e.setUint8(A, this.argument1), e.setUint8(A + 1, this.argument2), A += 2), 256 & this.flags && (e.setUint16(A, this.instructions.length), A += 2, this.instructions.length && (new Uint8Array(e.buffer, 0, e.buffer.byteLength).set(this.instructions, A), A += this.instructions.length)), A - i;
  }
  scale(A, e) {
  }
}
function yn(t, A, e) {
  t[A] = e >> 8 & 255, t[A + 1] = 255 & e;
}
function fg(t, A, e) {
  t[A] = e >> 24 & 255, t[A + 1] = e >> 16 & 255, t[A + 2] = e >> 8 & 255, t[A + 3] = 255 & e;
}
function DQ(t, A, e) {
  if (e instanceof Uint8Array) t.set(e, A);
  else if (typeof e == "string") for (let i = 0, a = e.length; i < a; i++) t[A++] = 255 & e.charCodeAt(i);
  else for (const i of e) t[A++] = 255 & i;
}
class Gs {
  constructor(A) {
    this.sfnt = A, this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(A, e) {
    let i = 1, a = 0;
    for (; (i ^ A) > i; )
      i <<= 1, a++;
    const s = i * e;
    return { range: s, entry: a, rangeShift: e * A - s };
  }
  toArray() {
    let A = this.sfnt;
    const e = this.tables, i = Object.keys(e);
    i.sort();
    const a = i.length;
    let s, r, n, g, o, I = 12 + 16 * a;
    const C = [I];
    for (s = 0; s < a; s++)
      g = e[i[s]], I += (g.length + 3 & -4) >>> 0, C.push(I);
    const h = new Uint8Array(I);
    for (s = 0; s < a; s++)
      g = e[i[s]], DQ(h, C[s], g);
    A === "true" && (A = Et(65536)), h[0] = 255 & A.charCodeAt(0), h[1] = 255 & A.charCodeAt(1), h[2] = 255 & A.charCodeAt(2), h[3] = 255 & A.charCodeAt(3), yn(h, 4, a);
    const c = Gs.getSearchParams(a, 16);
    for (yn(h, 6, c.range), yn(h, 8, c.entry), yn(h, 10, c.rangeShift), I = 12, s = 0; s < a; s++) {
      o = i[s], h[I] = 255 & o.charCodeAt(0), h[I + 1] = 255 & o.charCodeAt(1), h[I + 2] = 255 & o.charCodeAt(2), h[I + 3] = 255 & o.charCodeAt(3);
      let B = 0;
      for (r = C[s], n = C[s + 1]; r < n; r += 4)
        B = B + VA(h, r) >>> 0;
      fg(h, I + 4, B), fg(h, I + 8, C[s]), fg(h, I + 12, e[o].length), I += 16;
    }
    return h;
  }
  addTable(A, e) {
    if (A in this.tables) throw new Error("Table " + A + " already exists");
    this.tables[A] = e;
  }
}
const bQ = [4], kQ = [5], FQ = [6], SQ = [7], RQ = [8], GQ = [12, 35], pg = [14], Dc = [21], bc = [22], NQ = [30], xQ = [31];
class UQ {
  constructor() {
    this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
  }
  convert(A, e, i) {
    const a = A.length;
    let s, r, n, g = !1;
    for (let o = 0; o < a; o++) {
      let I = A[o];
      if (I < 32) {
        switch (I === 12 && (I = (I << 8) + A[++o]), I) {
          case 1:
          case 3:
          case 9:
          case 3072:
          case 3073:
          case 3074:
          case 3105:
            this.stack = [];
            break;
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                g = !0;
                break;
              }
              const l = this.stack.pop();
              this.stack.push(0, l);
              break;
            }
            g = this.executeCommand(1, bQ);
            break;
          case 5:
            g = this.executeCommand(2, kQ);
            break;
          case 6:
            g = this.executeCommand(1, FQ);
            break;
          case 7:
            g = this.executeCommand(1, SQ);
            break;
          case 8:
            g = this.executeCommand(6, RQ);
            break;
          case 10:
            if (this.stack.length < 1) {
              g = !0;
              break;
            }
            if (n = this.stack.pop(), !e[n]) {
              g = !0;
              break;
            }
            g = this.convert(e[n], e, i);
            break;
          case 11:
            return g;
          case 13:
            if (this.stack.length < 2) {
              g = !0;
              break;
            }
            s = this.stack.pop(), r = this.stack.pop(), this.lsb = r, this.width = s, this.stack.push(s, r), g = this.executeCommand(2, bc);
            break;
          case 14:
            this.output.push(pg[0]);
            break;
          case 21:
            if (this.flexing) break;
            g = this.executeCommand(2, Dc);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            g = this.executeCommand(1, bc);
            break;
          case 30:
            g = this.executeCommand(4, NQ);
            break;
          case 31:
            g = this.executeCommand(4, xQ);
            break;
          case 3078:
            if (i) {
              const l = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - l, g = this.executeCommand(0, pg);
            } else g = this.executeCommand(4, pg);
            break;
          case 3079:
            if (this.stack.length < 4) {
              g = !0;
              break;
            }
            this.stack.pop(), s = this.stack.pop();
            const C = this.stack.pop();
            r = this.stack.pop(), this.lsb = r, this.width = s, this.stack.push(s, r, C), g = this.executeCommand(3, Dc);
            break;
          case 3084:
            if (this.stack.length < 2) {
              g = !0;
              break;
            }
            const h = this.stack.pop(), c = this.stack.pop();
            this.stack.push(c / h);
            break;
          case 3088:
            if (this.stack.length < 2) {
              g = !0;
              break;
            }
            n = this.stack.pop();
            const B = this.stack.pop();
            if (n === 0 && B === 3) {
              const l = this.stack.splice(-17, 17);
              this.stack.push(l[2] + l[0], l[3] + l[1], l[4], l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12], l[13], l[14]), g = this.executeCommand(13, GQ, !0), this.flexing = !1, this.stack.push(l[15], l[16]);
            } else n === 1 && B === 0 && (this.flexing = !0);
            break;
          case 3089:
            break;
          default:
            G('Unknown type 1 charstring command of "' + I + '"');
        }
        if (g) break;
      } else
        I <= 246 ? I -= 139 : I = I <= 250 ? 256 * (I - 247) + A[++o] + 108 : I <= 254 ? -256 * (I - 251) - A[++o] - 108 : (255 & A[++o]) << 24 | (255 & A[++o]) << 16 | (255 & A[++o]) << 8 | (255 & A[++o]) << 0, this.stack.push(I);
    }
    return g;
  }
  executeCommand(A, e, i) {
    const a = this.stack.length;
    if (A > a) return !0;
    const s = a - A;
    for (let r = s; r < a; r++) {
      let n = this.stack[r];
      Number.isInteger(n) ? this.output.push(28, n >> 8 & 255, 255 & n) : (n = 65536 * n | 0, this.output.push(255, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n));
    }
    return this.output.push(...e), i ? this.stack.splice(s, A) : this.stack.length = 0, !1;
  }
}
function de(t) {
  return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
}
function kc(t, A, e) {
  if (e >= t.length) return new Uint8Array(0);
  let i, a, s = 0 | A;
  for (i = 0; i < e; i++) s = 52845 * (t[i] + s) + 22719 & 65535;
  const r = t.length - e, n = new Uint8Array(r);
  for (i = e, a = 0; a < r; i++, a++) {
    const g = t[i];
    n[a] = g ^ s >> 8, s = 52845 * (g + s) + 22719 & 65535;
  }
  return n;
}
function Fc(t) {
  return t === 47 || t === 91 || t === 93 || t === 123 || t === 125 || t === 40 || t === 41;
}
class Sc {
  constructor(A, e, i) {
    if (e) {
      const a = A.getBytes(), s = !((de(a[0]) || Zt(a[0])) && de(a[1]) && de(a[2]) && de(a[3]) && de(a[4]) && de(a[5]) && de(a[6]) && de(a[7]));
      A = new At(s ? kc(a, 55665, 4) : function(n, g, o) {
        let I = 0 | g;
        const C = n.length, h = new Uint8Array(C >>> 1);
        let c, B;
        for (c = 0, B = 0; c < C; c++) {
          const l = n[c];
          if (!de(l)) continue;
          c++;
          let Q;
          for (; c < C && !de(Q = n[c]); ) c++;
          if (c < C) {
            const E = parseInt(String.fromCharCode(l, Q), 16);
            h[B++] = E ^ I >> 8, I = 52845 * (E + I) + 22719 & 65535;
          }
        }
        return h.slice(o, B);
      }(a, 55665, 4));
    }
    this.seacAnalysisEnabled = !!i, this.stream = A, this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const A = [];
    for (; ; ) {
      const e = this.getToken();
      if (e === null || e === "]" || e === "}") break;
      A.push(parseFloat(e || 0));
    }
    return A;
  }
  readNumber() {
    const A = this.getToken();
    return parseFloat(A || 0);
  }
  readInt() {
    const A = this.getToken();
    return 0 | parseInt(A || 0, 10);
  }
  readBoolean() {
    return this.getToken() === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    return this.stream.skip(-2), this.currentChar = this.stream.getByte();
  }
  getToken() {
    let A = !1, e = this.currentChar;
    for (; ; ) {
      if (e === -1) return null;
      if (A) e !== 10 && e !== 13 || (A = !1);
      else if (e === 37) A = !0;
      else if (!Zt(e)) break;
      e = this.nextChar();
    }
    if (Fc(e))
      return this.nextChar(), String.fromCharCode(e);
    let i = "";
    do
      i += String.fromCharCode(e), e = this.nextChar();
    while (e >= 0 && !Zt(e) && !Fc(e));
    return i;
  }
  readCharStrings(A, e) {
    return e === -1 ? A : kc(A, 4330, e);
  }
  extractFontProgram(A) {
    const e = this.stream, i = [], a = [], s = /* @__PURE__ */ Object.create(null);
    s.lenIV = 4;
    const r = { subrs: [], charstrings: [], properties: { privateData: s } };
    let n, g, o, I;
    for (; (n = this.getToken()) !== null; ) if (n === "/")
      switch (n = this.getToken(), n) {
        case "CharStrings":
          for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); n = this.getToken(), !(n === null || n === "end"); ) {
            if (n !== "/") continue;
            const h = this.getToken();
            g = this.readInt(), this.getToken(), o = g > 0 ? e.getBytes(g) : new Uint8Array(0), I = r.properties.privateData.lenIV;
            const c = this.readCharStrings(o, I);
            this.nextChar(), n = this.getToken(), n === "noaccess" ? this.getToken() : n === "/" && this.prevChar(), a.push({ glyph: h, encoded: c });
          }
          break;
        case "Subrs":
          for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
            const h = this.readInt();
            g = this.readInt(), this.getToken(), o = g > 0 ? e.getBytes(g) : new Uint8Array(0), I = r.properties.privateData.lenIV;
            const c = this.readCharStrings(o, I);
            this.nextChar(), n = this.getToken(), n === "noaccess" && this.getToken(), i[h] = c;
          }
          break;
        case "BlueValues":
        case "OtherBlues":
        case "FamilyBlues":
        case "FamilyOtherBlues":
          const C = this.readNumberArray();
          C.length > 0 && C.length;
          break;
        case "StemSnapH":
        case "StemSnapV":
          r.properties.privateData[n] = this.readNumberArray();
          break;
        case "StdHW":
        case "StdVW":
          r.properties.privateData[n] = this.readNumberArray()[0];
          break;
        case "BlueShift":
        case "lenIV":
        case "BlueFuzz":
        case "BlueScale":
        case "LanguageGroup":
          r.properties.privateData[n] = this.readNumber();
          break;
        case "ExpansionFactor":
          r.properties.privateData[n] = this.readNumber() || 0.06;
          break;
        case "ForceBold":
          r.properties.privateData[n] = this.readBoolean();
      }
    for (const { encoded: C, glyph: h } of a) {
      const c = new UQ(), B = c.convert(C, i, this.seacAnalysisEnabled);
      let l = c.output;
      B && (l = [14]);
      const Q = { glyphName: h, charstring: l, width: c.width, lsb: c.lsb, seac: c.seac };
      if (h === ".notdef" ? r.charstrings.unshift(Q) : r.charstrings.push(Q), A.builtInEncoding) {
        const E = A.builtInEncoding.indexOf(h);
        E > -1 && A.widths[E] === void 0 && E >= A.firstChar && E <= A.lastChar && (A.widths[E] = c.width);
      }
    }
    return r;
  }
  extractFontHeader(A) {
    let e;
    for (; (e = this.getToken()) !== null; ) if (e === "/")
      switch (e = this.getToken(), e) {
        case "FontMatrix":
          const i = this.readNumberArray();
          A.fontMatrix = i;
          break;
        case "Encoding":
          const a = this.getToken();
          let s;
          if (/^\d+$/.test(a)) {
            s = [];
            const n = 0 | parseInt(a, 10);
            this.getToken();
            for (let g = 0; g < n; g++) {
              for (e = this.getToken(); e !== "dup" && e !== "def"; )
                if (e = this.getToken(), e === null) return;
              if (e === "def") break;
              const o = this.readInt();
              this.getToken();
              const I = this.getToken();
              s[o] = I, this.getToken();
            }
          } else s = bs(a);
          A.builtInEncoding = s;
          break;
        case "FontBBox":
          const r = this.readNumberArray();
          A.ascent = Math.max(r[3], r[1]), A.descent = Math.min(r[1], r[3]), A.ascentScaled = !0;
      }
  }
}
function Rc(t, A, e) {
  const i = t.length, a = A.length, s = i - a;
  let r = e, n = !1;
  for (; r < s; ) {
    let g = 0;
    for (; g < a && t[r + g] === A[g]; ) g++;
    if (g >= a) {
      for (r += g; r < i && Zt(t[r]); ) r++;
      n = !0;
      break;
    }
    r++;
  }
  return { found: n, length: r };
}
class MQ {
  constructor(A, e, i) {
    let a = i.length1;
    i.length2;
    let s = e.peekBytes(6);
    const r = s[0] === 128 && s[1] === 1;
    r && (e.skip(6), a = s[5] << 24 | s[4] << 16 | s[3] << 8 | s[2]);
    const n = function(B, l) {
      const Q = [101, 101, 120, 101, 99], E = B.pos;
      let u, f, d, p;
      try {
        u = B.getBytes(l), f = u.length;
      } catch {
      }
      if (f === l && (d = Rc(u, Q, l - 2 * Q.length), d.found && d.length === l))
        return { stream: new At(u), length: l };
      for (G('Invalid "Length1" property in Type1 font -- trying to recover.'), B.pos = E; d = Rc(B.peekBytes(2048), Q, 0), d.length !== 0; )
        if (B.pos += d.length, d.found) {
          p = B.pos - E;
          break;
        }
      return B.pos = E, p ? { stream: new At(B.getBytes(p)), length: p } : (G('Unable to recover "Length1" property in Type1 font -- using as is.'), { stream: new At(B.getBytes(l)), length: l });
    }(e, a);
    new Sc(n.stream, !1, Ss).extractFontHeader(i), r && (s = e.getBytes(6), s[5] << 24 | s[4] << 16 | s[3] << 8 | s[2]);
    const g = function(B, l) {
      const Q = B.getBytes();
      if (Q.length === 0) throw new X("getEexecBlock - no font program found.");
      return { stream: new At(Q), length: Q.length };
    }(e), o = new Sc(g.stream, !0, Ss).extractFontProgram(i);
    for (const c in o.properties) i[c] = o.properties[c];
    const I = o.charstrings, C = this.getType2Charstrings(I), h = this.getType2Subrs(o.subrs);
    this.charstrings = I, this.data = this.wrap(A, C, this.charstrings, h, i), this.seacs = this.getSeacs(o.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const A = [".notdef"];
    for (const { glyphName: e } of this.charstrings) A.push(e);
    return A;
  }
  getGlyphMapping(A) {
    const e = this.charstrings;
    if (A.composite) {
      const n = /* @__PURE__ */ Object.create(null);
      for (let g = 0, o = e.length; g < o; g++)
        n[A.cMap.charCodeOf(g)] = g + 1;
      return n;
    }
    const i = [".notdef"];
    let a, s;
    for (s = 0; s < e.length; s++) i.push(e[s].glyphName);
    const r = A.builtInEncoding;
    if (r) {
      a = /* @__PURE__ */ Object.create(null);
      for (const n in r)
        s = i.indexOf(r[n]), s >= 0 && (a[n] = s);
    }
    return P1(A, a, i);
  }
  hasGlyphId(A) {
    return A < 0 || A >= this.numGlyphs ? !1 : A === 0 ? !0 : this.charstrings[A - 1].charstring.length > 0;
  }
  getSeacs(A) {
    const e = [];
    for (let i = 0, a = A.length; i < a; i++) {
      const s = A[i];
      s.seac && (e[i + 1] = s.seac);
    }
    return e;
  }
  getType2Charstrings(A) {
    const e = [];
    for (const i of A) e.push(i.charstring);
    return e;
  }
  getType2Subrs(A) {
    let e = 0;
    const i = A.length;
    e = i < 1133 ? 107 : i < 33769 ? 1131 : 32768;
    const a = [];
    let s;
    for (s = 0; s < e; s++) a.push([11]);
    for (s = 0; s < i; s++) a.push(A[s]);
    return a;
  }
  wrap(A, e, i, a, s) {
    const r = new Y1();
    r.header = new v1(1, 0, 4, 4), r.names = [A];
    const n = new ks();
    n.setByName("version", 391), n.setByName("Notice", 392), n.setByName("FullName", 393), n.setByName("FamilyName", 394), n.setByName("Weight", 395), n.setByName("Encoding", null), n.setByName("FontMatrix", s.fontMatrix), n.setByName("FontBBox", s.bbox), n.setByName("charset", null), n.setByName("CharStrings", null), n.setByName("Private", null), r.topDict = n;
    const g = new iI();
    g.add("Version 0.11"), g.add("See original notice"), g.add(A), g.add(A), g.add("Medium"), r.strings = g, r.globalSubrIndex = new Ci();
    const o = e.length, I = [".notdef"];
    let C, h;
    for (C = 0; C < o; C++) {
      const E = i[C].glyphName;
      Zn.indexOf(E) === -1 && g.add(E), I.push(E);
    }
    r.charset = new ss(!1, 0, I);
    const c = new Ci();
    for (c.add([139, 14]), C = 0; C < o; C++) c.add(e[C]);
    r.charStrings = c;
    const B = new Fs();
    B.setByName("Subrs", null);
    const l = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (C = 0, h = l.length; C < h; C++) {
      const E = l[C];
      if (!(E in s.privateData)) continue;
      const u = s.privateData[E];
      if (Array.isArray(u)) for (let f = u.length - 1; f > 0; f--) u[f] -= u[f - 1];
      B.setByName(E, u);
    }
    r.topDict.privateDict = B;
    const Q = new Ci();
    for (C = 0, h = a.length; C < h; C++) Q.add(a[C]);
    return B.subrsIndex = Q, new an(r).compile();
  }
}
const Ne = [[57344, 63743], [1048576, 1114109]], Fi = 1e3, Gc = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], LQ = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function mg(t) {
  if (!t.fontMatrix || t.fontMatrix[0] === Ji[0]) return;
  const A = 1e-3 / t.fontMatrix[0], e = t.widths;
  for (const i in e) e[i] *= A;
  t.defaultWidth *= A;
}
function Nc(t) {
  if (!t.fallbackToUnicode || t.toUnicode instanceof Ae) return;
  const A = [];
  for (const e in t.fallbackToUnicode) t.toUnicode.has(e) || (A[e] = t.fallbackToUnicode[e]);
  A.length > 0 && t.toUnicode.amend(A);
}
class JQ {
  constructor(A, e, i, a, s, r, n, g, o) {
    this.originalCharCode = A, this.fontChar = e, this.unicode = i, this.accent = a, this.width = s, this.vmetric = r, this.operatorListId = n, this.isSpace = g, this.isInFont = o;
  }
  get category() {
    return sA(this, "category", function(e) {
      const i = co.get(e);
      if (i) return i;
      const a = e.match(IQ), s = { isWhitespace: !!(a != null && a[1]), isZeroWidthDiacritic: !!(a != null && a[2]), isInvisibleFormatMark: !!(a != null && a[3]) };
      return co.set(e, s), s;
    }(this.unicode), !0);
  }
}
function yi(t, A) {
  return (t << 8) + A;
}
function Za(t, A, e) {
  t[A + 1] = e, t[A] = e >>> 8;
}
function qt(t, A) {
  const e = (t << 8) + A;
  return 32768 & e ? e - 65536 : e;
}
function qA(t) {
  return String.fromCharCode(t >> 8 & 255, 255 & t);
}
function wi(t) {
  return t > 32767 ? t = 32767 : t < -32768 && (t = -32768), String.fromCharCode(t >> 8 & 255, 255 & t);
}
function X1(t) {
  return Mt(t.peekBytes(4)) === "ttcf";
}
function HQ(t, { type: A, subtype: e, composite: i }) {
  let a, s;
  return function(n) {
    const g = n.peekBytes(4);
    return VA(g, 0) === 65536 || Mt(g) === "true";
  }(t) || X1(t) ? a = i ? "CIDFontType2" : "TrueType" : function(n) {
    return Mt(n.peekBytes(4)) === "OTTO";
  }(t) ? a = i ? "CIDFontType2" : "OpenType" : function(n) {
    const g = n.peekBytes(2);
    return g[0] === 37 && g[1] === 33 || g[0] === 128 && g[1] === 1;
  }(t) ? a = i ? "CIDFontType0" : A === "MMType1" ? "MMType1" : "Type1" : function(n) {
    const g = n.peekBytes(4);
    return g[0] >= 1 && g[3] >= 1 && g[3] <= 4;
  }(t) ? i ? (a = "CIDFontType0", s = "CIDFontType0C") : (a = A === "MMType1" ? "MMType1" : "Type1", s = "Type1C") : (G("getFontFileType: Unable to detect correct font file Type/Subtype."), a = A, s = e), [a, s];
}
function wn(t, A) {
  for (const e in A) t[+e] = A[e];
}
function yg(t, A, e) {
  const i = [];
  let a;
  for (let s = 0, r = t.length; s < r; s++)
    a = xa(t[s], A), a !== -1 && (i[s] = a);
  for (const s in e)
    a = xa(e[s], A), a !== -1 && (i[+s] = a);
  return i;
}
function YQ(t) {
  return t.platform === 1 && t.encoding === 0 && t.language === 0;
}
function xc(t) {
  return t.platform === 3 && t.encoding === 1 && t.language === 1033;
}
function wg(t, A, e = !1) {
  switch (A.length) {
    case 1:
      return A.charCodeAt(0);
    case 2:
      return A.charCodeAt(0) << 8 | A.charCodeAt(1);
  }
  const i = `Unsupported CID string (charCode ${t}): "${A}".`;
  if (e) throw new X(i);
  return G(i), A;
}
function Uc(t, A, e, i) {
  const a = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map(), r = [], n = /* @__PURE__ */ new Set();
  let g = 0, o = Ne[g][0], I = Ne[g][1];
  for (const h in t) {
    let c = t[h];
    if (!A(c)) continue;
    if (o > I) {
      if (g++, g >= Ne.length) {
        G("Ran out of space in font private use area.");
        break;
      }
      o = Ne[g][0], I = Ne[g][1];
    }
    const B = o++;
    c === 0 && (c = e);
    let l = i.get(h);
    typeof l == "string" && (l = l.codePointAt(0)), l && (C = l, !(Ne[0][0] <= C && C <= Ne[0][1] || Ne[1][0] <= C && C <= Ne[1][1])) && !n.has(c) && (s.set(l, c), n.add(c)), a[B] = c, r[h] = B;
  }
  var C;
  return { toFontChar: r, charCodeToGlyphId: a, toUnicodeExtraMap: s, nextAvailableFontCharCode: o };
}
function Mc(t, A, e) {
  const i = function(Y, V, eA) {
    const AA = [];
    for (const v in Y) Y[v] >= eA || AA.push({ fontCharCode: 0 | v, glyphId: Y[v] });
    if (V) for (const [v, W] of V) W >= eA || AA.push({ fontCharCode: v, glyphId: W });
    AA.length === 0 && AA.push({ fontCharCode: 0, glyphId: 0 }), AA.sort(function(W, K) {
      return W.fontCharCode - K.fontCharCode;
    });
    const O = [], L = AA.length;
    for (let v = 0; v < L; ) {
      const W = AA[v].fontCharCode, K = [AA[v].glyphId];
      ++v;
      let q = W;
      for (; v < L && q + 1 === AA[v].fontCharCode && (K.push(AA[v].glyphId), ++q, ++v, q !== 65535); )
        ;
      O.push([W, q, K]);
    }
    return O;
  }(t, A, e), a = i.at(-1)[1] > 65535 ? 2 : 1;
  let s, r, n, g, o = "\0\0" + qA(a) + "\0\0" + Et(4 + 8 * a);
  for (s = i.length - 1; s >= 0 && !(i[s][0] <= 65535); --s) ;
  const I = s + 1;
  i[s][0] < 65535 && i[s][1] === 65535 && (i[s][1] = 65534);
  const C = i[s][1] < 65535 ? 1 : 0, h = I + C, c = Gs.getSearchParams(h, 2);
  let B, l, Q, E, u = "", f = "", d = "", p = "", m = "", y = 0;
  for (s = 0, r = I; s < r; s++) {
    B = i[s], l = B[0], Q = B[1], u += qA(l), f += qA(Q), E = B[2];
    let k = !0;
    for (n = 1, g = E.length; n < g; ++n) if (E[n] !== E[n - 1] + 1) {
      k = !1;
      break;
    }
    if (k)
      d += qA(E[0] - l & 65535), p += qA(0);
    else {
      const Y = 2 * (h - s) + 2 * y;
      for (y += Q - l + 1, d += qA(0), p += qA(Y), n = 0, g = E.length; n < g; ++n) m += qA(E[n]);
    }
  }
  C > 0 && (f += "ÿÿ", u += "ÿÿ", d += "\0", p += "\0\0");
  const b = "\0\0" + qA(2 * h) + qA(c.range) + qA(c.entry) + qA(c.rangeShift) + f + "\0\0" + u + d + p + m;
  let D = "", R = "";
  if (a > 1) {
    for (o += `\0\0
` + Et(4 + 8 * a + 4 + b.length), D = "", s = 0, r = i.length; s < r; s++) {
      B = i[s], l = B[0], E = B[2];
      let k = E[0];
      for (n = 1, g = E.length; n < g; ++n) E[n] !== E[n - 1] + 1 && (Q = B[0] + n - 1, D += Et(l) + Et(Q) + Et(k), l = Q + 1, k = E[n]);
      D += Et(l) + Et(B[1]) + Et(k);
    }
    R = "\0\f\0\0" + Et(D.length + 16) + "\0\0\0\0" + Et(D.length / 12);
  }
  return o + "\0" + qA(b.length + 4) + b + R + D;
}
function Lc(t, A, e) {
  e || (e = { unitsPerEm: 0, yMax: 0, yMin: 0, ascent: 0, descent: 0 });
  let i = 0, a = 0, s = 0, r = 0, n = null, g = 0, o = -1;
  if (A) {
    for (let E in A)
      if (E |= 0, (n > E || !n) && (n = E), g < E && (g = E), o = oQ(E, o), o < 32) i |= 1 << o;
      else if (o < 64) a |= 1 << o - 32;
      else if (o < 96) s |= 1 << o - 64;
      else {
        if (!(o < 123)) throw new X("Unicode ranges Bits > 123 are reserved for internal usage");
        r |= 1 << o - 96;
      }
    g > 65535 && (g = 65535);
  } else
    n = 0, g = 255;
  const I = t.bbox || [0, 0, 0, 0], C = e.unitsPerEm || (t.fontMatrix ? 1 / Math.max(...t.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), h = t.ascentScaled ? 1 : C / Fi, c = e.ascent || Math.round(h * (t.ascent || I[3]));
  let B = e.descent || Math.round(h * (t.descent || I[1]));
  B > 0 && t.descent > 0 && I[1] < 0 && (B = -B);
  const l = e.yMax || c, Q = -e.yMin || -B;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(t.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + Et(i) + Et(a) + Et(s) + Et(r) + "*21*" + qA(t.italicAngle ? 1 : 0) + qA(n || t.firstChar) + qA(g || t.lastChar) + qA(c) + qA(B) + "\0d" + qA(l) + qA(Q) + "\0\0\0\0\0\0\0\0" + qA(t.xHeight) + qA(t.capHeight) + qA(0) + qA(n || t.firstChar) + "\0";
}
function Jc(t) {
  return "\0\0\0" + Et(Math.floor(65536 * t.italicAngle)) + "\0\0\0\0" + Et(t.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function vQ(t) {
  return t.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function Dg(t, A) {
  A || (A = [[], []]);
  const e = [A[0][0] || "Original licence", A[0][1] || t, A[0][2] || "Unknown", A[0][3] || "uniqueID", A[0][4] || t, A[0][5] || "Version 0.11", A[0][6] || vQ(t), A[0][7] || "Unknown", A[0][8] || "Unknown", A[0][9] || "Unknown"], i = [];
  let a, s, r, n, g;
  for (a = 0, s = e.length; a < s; a++) {
    g = A[1][a] || e[a];
    const Q = [];
    for (r = 0, n = g.length; r < n; r++) Q.push(qA(g.charCodeAt(r)));
    i.push(Q.join(""));
  }
  const o = [e, i], I = ["\0", "\0"], C = ["\0\0", "\0"], h = ["\0\0", "	"], c = e.length * I.length;
  let B = "\0\0" + qA(c) + qA(12 * c + 6), l = 0;
  for (a = 0, s = I.length; a < s; a++) {
    const Q = o[a];
    for (r = 0, n = Q.length; r < n; r++)
      g = Q[r], B += I[a] + C[a] + h[a] + qA(r) + qA(g.length) + qA(l), l += g.length;
  }
  return B += e.join("") + i.join(""), B;
}
class Hc {
  constructor(A, e, i) {
    var o;
    this.name = A, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = i.loadedName, this.isType3Font = i.isType3Font, this.missingFile = !1, this.cssFontInfo = i.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
    let a = !!(i.flags & q1);
    if (!a && !i.isSimulatedFlags) {
      const I = A.replaceAll(/[,_]/g, "-").split("-", 1)[0], C = aI();
      for (const h of I.split("+")) if (C[h]) {
        a = !0;
        break;
      }
    }
    this.isSerifFont = a, this.isSymbolicFont = !!(i.flags & ur), this.isMonospace = !!(i.flags & On);
    let { type: s, subtype: r } = i;
    this.type = s, this.subtype = r, this.systemFontInfo = i.systemFontInfo;
    const n = A.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    if (this.isInvalidPDFjsFont = !!n, this.isInvalidPDFjsFont ? this.fallbackName = n[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", (o = this.systemFontInfo) != null && o.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i.differences, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.composite = i.composite, this.cMap = i.cMap, this.capHeight = i.capHeight / Fi, this.ascent = i.ascent / Fi, this.descent = i.descent / Fi, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i.fontMatrix, this.bbox = i.bbox, this.defaultEncoding = i.defaultEncoding, this.toUnicode = i.toUnicode, this.toFontChar = [], i.type === "Type3") {
      for (let I = 0; I < 256; I++) this.toFontChar[I] = this.differences[I] || i.defaultEncoding[I];
      return;
    }
    if (this.cidEncoding = i.cidEncoding || "", this.vertical = !!i.vertical, this.vertical && (this.vmetrics = i.vmetrics, this.defaultVMetrics = i.defaultVMetrics), !e || e.isEmpty) {
      e && G('Font file is empty in "' + A + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(i);
      return;
    }
    [s, r] = HQ(e, i), s === this.type && r === this.subtype || RA(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${s}/${r}.`);
    let g;
    try {
      switch (s) {
        case "MMType1":
          RA("MMType1 font (" + A + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const I = r === "Type1C" || r === "CIDFontType0C" ? new dg(e, i) : new MQ(A, e, i);
          mg(i), g = this.convert(A, I, i);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype", g = this.checkAndRepair(A, e, i), this.isOpenType && (mg(i), s = "OpenType");
          break;
        default:
          throw new X(`Font ${s} is not supported`);
      }
    } catch (I) {
      G(I), this.fallbackToSystemFont(i);
      return;
    }
    Nc(i), this.data = g, this.type = s, this.subtype = r, this.fontMatrix = i.fontMatrix, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.toUnicode = i.toUnicode, this.seacMap = i.seacMap;
  }
  get renderer() {
    return sA(this, "renderer", fQ.create(this, Ss));
  }
  exportData(A = !1) {
    const e = A ? [...Gc, ...LQ] : Gc, i = /* @__PURE__ */ Object.create(null);
    let a, s;
    for (a of e)
      s = this[a], s !== void 0 && (i[a] = s);
    return i;
  }
  fallbackToSystemFont(A) {
    this.missingFile = !0;
    const { name: e, type: i } = this;
    let a = sn(e);
    const s = Xr(), r = W1(), n = !!s[a], g = !(!r[a] || !s[r[a]]);
    a = s[a] || r[a] || a;
    const o = mQ()[a];
    o && (isNaN(this.ascent) && (this.ascent = o.ascent / Fi), isNaN(this.descent) && (this.descent = o.descent / Fi), isNaN(this.capHeight) && (this.capHeight = o.capHeight / Fi)), this.bold = /bold/gi.test(a), this.italic = /oblique|italic/gi.test(a), this.black = /Black/g.test(e);
    const I = /Narrow/g.test(e);
    if (this.remeasure = (!n || I) && Object.keys(this.widths).length > 0, (n || g) && i === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const C = A.cidToGidMap, h = [];
      if (wn(h, fc()), /Arial-?Black/i.test(e) ? wn(h, hQ()) : /Calibri/i.test(e) && wn(h, BQ()), C) {
        for (const c in h) {
          const B = h[c];
          C[B] !== void 0 && (h[+c] = C[B]);
        }
        C.length !== this.toUnicode.length && A.hasIncludedToUnicodeMap && this.toUnicode instanceof Ae && this.toUnicode.forEach(function(c, B) {
          const l = h[c];
          C[l] === void 0 && (h[+c] = B);
        });
      }
      this.toUnicode instanceof Ae || this.toUnicode.forEach(function(c, B) {
        h[+c] = B;
      }), this.toFontChar = h, this.toUnicode = new ns(h);
    } else if (/Symbol/i.test(a)) this.toFontChar = yg(AI, fe(), this.differences);
    else if (/Dingbats/i.test(a)) this.toFontChar = yg(tI, rQ(), this.differences);
    else if (n || g) {
      const C = yg(this.defaultEncoding, fe(), this.differences);
      i !== "CIDFontType2" || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof Ae || this.toUnicode.forEach(function(h, c) {
        C[+h] = c;
      }), this.toFontChar = C;
    } else {
      const C = fe(), h = [];
      this.toUnicode.forEach((c, B) => {
        if (!this.composite) {
          const l = xa(this.differences[c] || this.defaultEncoding[c], C);
          l !== -1 && (B = l);
        }
        h[+c] = B;
      }), this.composite && this.toUnicode instanceof Ae && /Tahoma|Verdana/i.test(e) && wn(h, fc()), this.toFontChar = h;
    }
    Nc(A), this.loadedName = a.split("-", 1)[0];
  }
  checkAndRepair(A, e, i) {
    var eA, AA, O;
    const a = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function s(L, v) {
      const W = /* @__PURE__ */ Object.create(null);
      W["OS/2"] = null, W.cmap = null, W.head = null, W.hhea = null, W.hmtx = null, W.maxp = null, W.name = null, W.post = null;
      for (let K = 0; K < v; K++) {
        const q = r(L);
        a.includes(q.tag) && q.length !== 0 && (W[q.tag] = q);
      }
      return W;
    }
    function r(L) {
      const v = L.getString(4), W = L.getInt32() >>> 0, K = L.getInt32() >>> 0, q = L.getInt32() >>> 0, N = L.pos;
      L.pos = L.start || 0, L.skip(K);
      const F = L.getBytes(q);
      return L.pos = N, v === "head" && (F[8] = F[9] = F[10] = F[11] = 0, F[17] |= 32), { tag: v, checksum: W, length: q, offset: K, data: F };
    }
    function n(L) {
      return { version: L.getString(4), numTables: L.getUint16(), searchRange: L.getUint16(), entrySelector: L.getUint16(), rangeShift: L.getUint16() };
    }
    function g(L, v, W, K, q, N) {
      const F = { length: 0, sizeOfInstructions: 0 };
      if (v < 0 || v >= L.length || W > L.length || W - v <= 12) return F;
      const w = L.subarray(v, W), x = qt(w[2], w[3]), J = qt(w[4], w[5]), M = qt(w[6], w[7]), H = qt(w[8], w[9]);
      x > M && (Za(w, 2, M), Za(w, 6, x)), J > H && (Za(w, 4, H), Za(w, 8, J));
      const z = qt(w[0], w[1]);
      if (z < 0)
        return z < -1 || (K.set(w, q), F.length = w.length), F;
      let aA, tA = 10, hA = 0;
      for (aA = 0; aA < z; aA++)
        hA = (w[tA] << 8 | w[tA + 1]) + 1, tA += 2;
      const BA = tA, gA = w[tA] << 8 | w[tA + 1];
      F.sizeOfInstructions = gA, tA += 2 + gA;
      const wA = tA;
      let EA = 0;
      for (aA = 0; aA < hA; aA++) {
        const cA = w[tA++];
        192 & cA && (w[tA - 1] = 63 & cA);
        let bA = 2;
        2 & cA ? bA = 1 : 16 & cA && (bA = 0);
        let DA = 2;
        4 & cA ? DA = 1 : 32 & cA && (DA = 0);
        const QA = bA + DA;
        if (EA += QA, 8 & cA) {
          const dA = w[tA++];
          dA === 0 && (w[tA - 1] ^= 8), aA += dA, EA += dA * QA;
        }
      }
      if (EA === 0) return F;
      let IA = tA + EA;
      return IA > w.length ? F : !N && gA > 0 ? (K.set(w.subarray(0, BA), q), K.set([0, 0], q + BA), K.set(w.subarray(wA, IA), q + BA + 2), IA -= gA, w.length - IA > 3 && (IA = IA + 3 & -4), F.length = IA, F) : w.length - IA > 3 ? (IA = IA + 3 & -4, K.set(w.subarray(0, IA), q), F.length = IA, F) : (K.set(w, q), F.length = w.length, F);
    }
    function o(L) {
      const v = (e.start || 0) + L.offset;
      e.pos = v;
      const W = [[], []], K = [], q = L.length, N = v + q;
      if (e.getUint16() !== 0 || q < 6) return [W, K];
      const F = e.getUint16(), w = e.getUint16();
      let x, J;
      for (x = 0; x < F && e.pos + 12 <= N; x++) {
        const M = { platform: e.getUint16(), encoding: e.getUint16(), language: e.getUint16(), name: e.getUint16(), length: e.getUint16(), offset: e.getUint16() };
        (YQ(M) || xc(M)) && K.push(M);
      }
      for (x = 0, J = K.length; x < J; x++) {
        const M = K[x];
        if (M.length <= 0) continue;
        const H = v + w + M.offset;
        if (H + M.length > N) continue;
        e.pos = H;
        const z = M.name;
        if (M.encoding) {
          let aA = "";
          for (let tA = 0, hA = M.length; tA < hA; tA += 2) aA += String.fromCharCode(e.getUint16());
          W[1][z] = aA;
        } else W[0][z] = e.getString(M.length);
      }
      return [W, K];
    }
    const I = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function C(L, v) {
      let W, K, q, N, F, w = L.data, x = 0, J = 0, M = 0;
      const H = [], z = [], aA = [];
      let tA = v.tooComplexToFollowFunctions, hA = !1, BA = 0, gA = 0;
      for (let EA = w.length; x < EA; ) {
        const IA = w[x++];
        if (IA === 64)
          if (K = w[x++], hA || gA) x += K;
          else for (W = 0; W < K; W++) H.push(w[x++]);
        else if (IA === 65)
          if (K = w[x++], hA || gA) x += 2 * K;
          else for (W = 0; W < K; W++)
            q = w[x++], H.push(q << 8 | w[x++]);
        else if ((248 & IA) == 176)
          if (K = IA - 176 + 1, hA || gA) x += K;
          else for (W = 0; W < K; W++) H.push(w[x++]);
        else if ((248 & IA) == 184)
          if (K = IA - 184 + 1, hA || gA) x += 2 * K;
          else for (W = 0; W < K; W++)
            q = w[x++], H.push(qt(q, w[x++]));
        else if (IA !== 43 || tA) if (IA !== 44 || tA) {
          if (IA === 45) if (hA)
            hA = !1, J = x;
          else {
            if (F = z.pop(), !F) {
              G("TT: ENDF bad stack"), v.hintsValid = !1;
              return;
            }
            N = aA.pop(), w = F.data, x = F.i, v.functionsStackDeltas[N] = H.length - F.stackTop;
          }
          else if (IA === 137)
            (hA || gA) && (G("TT: nested IDEFs not allowed"), tA = !0), hA = !0, M = x;
          else if (IA === 88) ++BA;
          else if (IA === 27) gA = BA;
          else if (IA === 89)
            gA === BA && (gA = 0), --BA;
          else if (IA === 28 && !hA && !gA) {
            const cA = H.at(-1);
            cA > 0 && (x += cA - 1);
          }
        } else
          (hA || gA) && (G("TT: nested FDEFs not allowed"), tA = !0), hA = !0, M = x, N = H.pop(), v.functionsDefined[N] = { data: w, i: x };
        else if (!hA && !gA) {
          if (N = H.at(-1), isNaN(N)) RA("TT: CALL empty stack (or invalid entry).");
          else if (v.functionsUsed[N] = !0, N in v.functionsStackDeltas) {
            const cA = H.length + v.functionsStackDeltas[N];
            if (cA < 0) {
              G("TT: CALL invalid functions stack delta."), v.hintsValid = !1;
              return;
            }
            H.length = cA;
          } else if (N in v.functionsDefined && !aA.includes(N)) {
            if (z.push({ data: w, i: x, stackTop: H.length - 1 }), aA.push(N), F = v.functionsDefined[N], !F) {
              G("TT: CALL non-existent function"), v.hintsValid = !1;
              return;
            }
            w = F.data, x = F.i;
          }
        }
        if (!hA && !gA) {
          let cA = 0;
          for (IA <= 142 ? cA = I[IA] : IA >= 192 && IA <= 223 ? cA = -1 : IA >= 224 && (cA = -2), IA >= 113 && IA <= 117 && (K = H.pop(), isNaN(K) || (cA = 2 * -K)); cA < 0 && H.length > 0; )
            H.pop(), cA++;
          for (; cA > 0; )
            H.push(NaN), cA--;
        }
      }
      v.tooComplexToFollowFunctions = tA;
      const wA = [w];
      x > w.length && wA.push(new Uint8Array(x - w.length)), M > J && (G("TT: complementing a missing function tail"), wA.push(new Uint8Array([34, 45]))), function(IA, cA) {
        if (cA.length > 1) {
          let bA, DA, QA = 0;
          for (bA = 0, DA = cA.length; bA < DA; bA++) QA += cA[bA].length;
          QA = QA + 3 & -4;
          const dA = new Uint8Array(QA);
          let mA = 0;
          for (bA = 0, DA = cA.length; bA < DA; bA++)
            dA.set(cA[bA], mA), mA += cA[bA].length;
          IA.data = dA, IA.length = QA;
        }
      }(L, wA);
    }
    let h, c, B, l;
    if (X1(e = new At(new Uint8Array(e.getBytes())))) {
      const L = function(W, K) {
        var x;
        const { numFonts: q, offsetTable: N } = function(M) {
          const H = M.getString(4);
          Rt(H === "ttcf", "Must be a TrueType Collection font.");
          const z = M.getUint16(), aA = M.getUint16(), tA = M.getInt32() >>> 0, hA = [];
          for (let gA = 0; gA < tA; gA++) hA.push(M.getInt32() >>> 0);
          const BA = { ttcTag: H, majorVersion: z, minorVersion: aA, numFonts: tA, offsetTable: hA };
          switch (z) {
            case 1:
              return BA;
            case 2:
              return BA.dsigTag = M.getInt32() >>> 0, BA.dsigLength = M.getInt32() >>> 0, BA.dsigOffset = M.getInt32() >>> 0, BA;
          }
          throw new X(`Invalid TrueType Collection majorVersion: ${z}.`);
        }(W), F = K.split("+");
        let w;
        for (let J = 0; J < q; J++) {
          W.pos = (W.start || 0) + N[J];
          const M = n(W), H = s(W, M.numTables);
          if (!H.name) throw new X('TrueType Collection font must contain a "name" table.');
          const [z] = o(H.name);
          for (let aA = 0, tA = z.length; aA < tA; aA++) for (let hA = 0, BA = z[aA].length; hA < BA; hA++) {
            const gA = (x = z[aA][hA]) == null ? void 0 : x.replaceAll(/\s/g, "");
            if (gA) {
              if (gA === K) return { header: M, tables: H };
              if (!(F.length < 2)) for (const wA of F) gA === wA && (w = { name: wA, header: M, tables: H });
            }
          }
        }
        if (w)
          return G(`TrueType Collection does not contain "${K}" font, falling back to "${w.name}" font instead.`), { header: w.header, tables: w.tables };
        throw new X(`TrueType Collection does not contain "${K}" font.`);
      }(e, this.name);
      h = L.header, c = L.tables;
    } else
      h = n(e), c = s(e, h.numTables);
    const Q = !c["CFF "];
    if (Q) {
      if (!c.loca) throw new X('Required "loca" table is not found');
      c.glyf || (G('Required "glyf" table is not found -- trying to recover.'), c.glyf = { tag: "glyf", data: new Uint8Array(0) }), this.isOpenType = !1;
    } else {
      const L = i.composite && (((eA = i.cidToGidMap) == null ? void 0 : eA.length) > 0 || !(i.cMap instanceof ma));
      if (h.version === "OTTO" && !L || !c.head || !c.hhea || !c.maxp || !c.post)
        return l = new At(c["CFF "].data), B = new dg(l, i), mg(i), this.convert(A, B, i);
      delete c.glyf, delete c.loca, delete c.fpgm, delete c.prep, delete c["cvt "], this.isOpenType = !0;
    }
    if (!c.maxp) throw new X('Required "maxp" table is not found');
    e.pos = (e.start || 0) + c.maxp.offset;
    let E = e.getInt32();
    const u = e.getUint16();
    if (E !== 65536 && E !== 20480) {
      if (c.maxp.length === 6) E = 20480;
      else {
        if (!(c.maxp.length >= 32)) throw new X('"maxp" table has a wrong version number');
        E = 65536;
      }
      (function(v, W, K) {
        v[W + 3] = 255 & K, v[W + 2] = K >>> 8, v[W + 1] = K >>> 16, v[W] = K >>> 24;
      })(c.maxp.data, 0, E);
    }
    if (((AA = i.scaleFactors) == null ? void 0 : AA.length) === u && Q) {
      const { scaleFactors: L } = i, v = yi(c.head.data[50], c.head.data[51]), W = new yQ({ glyfTable: c.glyf.data, isGlyphLocationsLong: v, locaTable: c.loca.data, numGlyphs: u });
      W.scale(L);
      const { glyf: K, loca: q, isLocationLong: N } = W.write();
      c.glyf.data = K, c.loca.data = q, N !== !!v && (c.head.data[50] = 0, c.head.data[51] = N ? 1 : 0);
      const F = c.hmtx.data;
      for (let w = 0; w < u; w++) {
        const x = 4 * w, J = Math.round(L[w] * yi(F[x], F[x + 1]));
        F[x] = J >> 8 & 255, F[x + 1] = 255 & J, Za(F, x + 2, Math.round(L[w] * qt(F[x + 2], F[x + 3])));
      }
    }
    let f = u + 1, d = !0;
    f > 65535 && (d = !1, f = u, G("Not enough space in glyfs to duplicate first glyph."));
    let p = 0, m = 0;
    E >= 65536 && c.maxp.length >= 32 && (e.pos += 8, e.getUint16() > 2 && (c.maxp.data[14] = 0, c.maxp.data[15] = 2), e.pos += 4, p = e.getUint16(), e.pos += 4, m = e.getUint16()), c.maxp.data[4] = f >> 8, c.maxp.data[5] = 255 & f;
    const y = function(v, W, K, q) {
      const N = { functionsDefined: [], functionsUsed: [], functionsStackDeltas: [], tooComplexToFollowFunctions: !1, hintsValid: !0 };
      if (v && C(v, N), W && C(W, N), v && function(w, x) {
        if (!w.tooComplexToFollowFunctions) if (w.functionsDefined.length > x)
          G("TT: more functions defined than expected"), w.hintsValid = !1;
        else for (let J = 0, M = w.functionsUsed.length; J < M; J++) {
          if (J > x) {
            G("TT: invalid function id: " + J), w.hintsValid = !1;
            return;
          }
          if (w.functionsUsed[J] && !w.functionsDefined[J]) {
            G("TT: undefined function: " + J), w.hintsValid = !1;
            return;
          }
        }
      }(N, q), K && 1 & K.length) {
        const F = new Uint8Array(K.length + 1);
        F.set(K.data), K.data = F;
      }
      return N.hintsValid;
    }(c.fpgm, c.prep, c["cvt "], p);
    if (y || (delete c.fpgm, delete c.prep, delete c["cvt "]), function(v, W, K, q, N, F) {
      if (!W) {
        K && (K.data = null);
        return;
      }
      v.pos = (v.start || 0) + W.offset, v.pos += 4, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2, v.pos += 2;
      const w = v.getUint16();
      v.pos += 8, v.pos += 2;
      let x = v.getUint16();
      w !== 0 && (2 & yi(q.data[44], q.data[45]) || (W.data[22] = 0, W.data[23] = 0)), x > N && (RA(`The numOfMetrics (${x}) should not be greater than the numGlyphs (${N}).`), x = N, W.data[34] = (65280 & x) >> 8, W.data[35] = 255 & x);
      const J = N - x - (K.length - 4 * x >> 1);
      if (J > 0) {
        const M = new Uint8Array(K.length + 2 * J);
        M.set(K.data), F && (M[K.length] = K.data[2], M[K.length + 1] = K.data[3]), K.data = M;
      }
    }(e, c.hhea, c.hmtx, c.head, f, d), !c.head) throw new X('Required "head" table is not found');
    (function(v, W, K) {
      const q = v.data, N = function(x, J, M, H) {
        return (x << 24) + (J << 16) + (M << 8) + H;
      }(q[0], q[1], q[2], q[3]);
      N >> 16 != 1 && (RA("Attempting to fix invalid version in head table: " + N), q[0] = 0, q[1] = 1, q[2] = 0, q[3] = 0);
      const F = yi(q[50], q[51]);
      if (F < 0 || F > 1) {
        RA("Attempting to fix invalid indexToLocFormat in head table: " + F);
        const w = W + 1;
        if (K === w << 1)
          q[50] = 0, q[51] = 0;
        else {
          if (K !== w << 2) throw new X("Could not fix indexToLocFormat: " + F);
          q[50] = 0, q[51] = 1;
        }
      }
    })(c.head, u, Q ? c.loca.length : 0);
    let b = /* @__PURE__ */ Object.create(null);
    if (Q) {
      const L = yi(c.head.data[50], c.head.data[51]), v = function(K, q, N, F, w, x, J) {
        let M, H, z;
        F ? (M = 4, H = function(mA, KA) {
          return mA[KA] << 24 | mA[KA + 1] << 16 | mA[KA + 2] << 8 | mA[KA + 3];
        }, z = function(mA, KA, kt) {
          mA[KA] = kt >>> 24 & 255, mA[KA + 1] = kt >> 16 & 255, mA[KA + 2] = kt >> 8 & 255, mA[KA + 3] = 255 & kt;
        }) : (M = 2, H = function(mA, KA) {
          return mA[KA] << 9 | mA[KA + 1] << 1;
        }, z = function(mA, KA, kt) {
          mA[KA] = kt >> 9 & 255, mA[KA + 1] = kt >> 1 & 255;
        });
        const aA = x ? N + 1 : N, tA = M * (1 + aA), hA = new Uint8Array(tA);
        hA.set(K.data.subarray(0, tA)), K.data = hA;
        const BA = q.data, gA = BA.length, wA = new Uint8Array(gA);
        let EA, IA;
        const cA = [];
        for (EA = 0, IA = 0; EA < N + 1; EA++, IA += M) {
          let dA = H(hA, IA);
          dA > gA && (dA = gA), cA.push({ index: EA, offset: dA, endOffset: 0 });
        }
        for (cA.sort((dA, mA) => dA.offset - mA.offset), EA = 0; EA < N; EA++) cA[EA].endOffset = cA[EA + 1].offset;
        for (cA.sort((dA, mA) => dA.index - mA.index), EA = 0; EA < N; EA++) {
          const { offset: dA, endOffset: mA } = cA[EA];
          if (dA !== 0 || mA !== 0) break;
          const KA = cA[EA + 1].offset;
          if (KA !== 0) {
            cA[EA].endOffset = KA;
            break;
          }
        }
        const bA = cA.at(-2);
        bA.offset !== 0 && bA.endOffset === 0 && (bA.endOffset = gA);
        const DA = /* @__PURE__ */ Object.create(null);
        let QA = 0;
        for (z(hA, 0, QA), EA = 0, IA = M; EA < N; EA++, IA += M) {
          const dA = g(BA, cA[EA].offset, cA[EA].endOffset, wA, QA, w), mA = dA.length;
          mA === 0 && (DA[EA] = !0), dA.sizeOfInstructions > J && (J = dA.sizeOfInstructions), QA += mA, z(hA, IA, QA);
        }
        if (QA === 0) {
          const dA = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
          for (EA = 0, IA = M; EA < aA; EA++, IA += M) z(hA, IA, dA.length);
          q.data = dA;
        } else if (x) {
          const dA = H(hA, M);
          wA.length > dA + QA ? q.data = wA.subarray(0, dA + QA) : (q.data = new Uint8Array(dA + QA), q.data.set(wA.subarray(0, QA))), q.data.set(wA.subarray(0, dA), QA), z(K.data, hA.length - M, QA + dA);
        } else q.data = wA.subarray(0, QA);
        return { missingGlyphs: DA, maxSizeOfInstructions: J };
      }(c.loca, c.glyf, u, L, y, d, m);
      b = v.missingGlyphs, E >= 65536 && c.maxp.length >= 32 && (c.maxp.data[26] = v.maxSizeOfInstructions >> 8, c.maxp.data[27] = 255 & v.maxSizeOfInstructions);
    }
    if (!c.hhea) throw new X('Required "hhea" table is not found');
    c.hhea.data[10] === 0 && c.hhea.data[11] === 0 && (c.hhea.data[10] = 255, c.hhea.data[11] = 255);
    const D = { unitsPerEm: yi(c.head.data[18], c.head.data[19]), yMax: qt(c.head.data[42], c.head.data[43]), yMin: qt(c.head.data[38], c.head.data[39]), ascent: qt(c.hhea.data[4], c.hhea.data[5]), descent: qt(c.hhea.data[6], c.hhea.data[7]), lineGap: qt(c.hhea.data[8], c.hhea.data[9]) };
    this.ascent = D.ascent / D.unitsPerEm, this.descent = D.descent / D.unitsPerEm, this.lineGap = D.lineGap / D.unitsPerEm, (O = this.cssFontInfo) != null && O.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, c.post && function(v, W, K) {
      const q = (e.start || 0) + v.offset;
      e.pos = q;
      const N = q + v.length, F = e.getInt32();
      e.skip(28);
      let w, x, J = !0;
      switch (F) {
        case 65536:
          w = dc;
          break;
        case 131072:
          const M = e.getUint16();
          if (M !== K) {
            J = !1;
            break;
          }
          const H = [];
          for (x = 0; x < M; ++x) {
            const tA = e.getUint16();
            if (tA >= 32768) {
              J = !1;
              break;
            }
            H.push(tA);
          }
          if (!J) break;
          const z = [], aA = [];
          for (; e.pos < N; ) {
            const tA = e.getByte();
            for (aA.length = tA, x = 0; x < tA; ++x) aA[x] = String.fromCharCode(e.getByte());
            z.push(aA.join(""));
          }
          for (w = [], x = 0; x < M; ++x) {
            const tA = H[x];
            tA < 258 ? w.push(dc[tA]) : w.push(z[tA - 258]);
          }
          break;
        case 196608:
          break;
        default:
          G("Unknown/unsupported post table version " + F), J = !1, W.defaultEncoding && (w = W.defaultEncoding);
      }
      return W.glyphNames = w, J;
    }(c.post, i, u), c.post = { tag: "post", data: Jc(i) };
    const R = /* @__PURE__ */ Object.create(null);
    function k(L) {
      return !b[L];
    }
    if (i.composite) {
      const L = i.cidToGidMap || [], v = L.length === 0;
      i.cMap.forEach(function(W, K) {
        if (typeof K == "string" && (K = wg(W, K, !0)), K > 65535) throw new X("Max size of CID is 65,535");
        let q = -1;
        v ? q = K : L[K] !== void 0 && (q = L[K]), q >= 0 && q < u && k(q) && (R[W] = q);
      });
    } else {
      const L = function(w, x, J, M) {
        if (!w)
          return G("No cmap table available."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
        let H, z = (x.start || 0) + w.offset;
        x.pos = z, x.skip(2);
        const aA = x.getUint16();
        let tA, hA = !1;
        for (let cA = 0; cA < aA; cA++) {
          const bA = x.getUint16(), DA = x.getUint16(), QA = x.getInt32() >>> 0;
          let dA = !1;
          if ((tA == null ? void 0 : tA.platformId) !== bA || (tA == null ? void 0 : tA.encodingId) !== DA) {
            if (bA !== 0 || DA !== 0 && DA !== 1 && DA !== 3) if (bA === 1 && DA === 0) dA = !0;
            else if (bA !== 3 || DA !== 1 || !M && tA) {
              if (J && bA === 3 && DA === 0) {
                dA = !0;
                let mA = !0;
                if (cA < aA - 1) {
                  const KA = x.peekBytes(2);
                  yi(KA[0], KA[1]) < bA && (mA = !1);
                }
                mA && (hA = !0);
              }
            } else
              dA = !0, J || (hA = !0);
            else dA = !0;
            if (dA && (tA = { platformId: bA, encodingId: DA, offset: QA }), hA) break;
          }
        }
        if (tA && (x.pos = z + tA.offset), !tA || x.peekByte() === -1)
          return G("Could not find a preferred cmap table."), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
        const BA = x.getUint16();
        let gA = !1;
        const wA = [];
        let EA, IA;
        if (BA === 0) {
          for (x.skip(4), EA = 0; EA < 256; EA++) {
            const cA = x.getByte();
            cA && wA.push({ charCode: EA, glyphId: cA });
          }
          gA = !0;
        } else if (BA === 2) {
          x.skip(4);
          const cA = [];
          let bA = 0;
          for (let QA = 0; QA < 256; QA++) {
            const dA = x.getUint16() >> 3;
            cA.push(dA), bA = Math.max(dA, bA);
          }
          const DA = [];
          for (let QA = 0; QA <= bA; QA++) DA.push({ firstCode: x.getUint16(), entryCount: x.getUint16(), idDelta: qt(x.getByte(), x.getByte()), idRangePos: x.pos + x.getUint16() });
          for (let QA = 0; QA < 256; QA++) if (cA[QA] === 0)
            x.pos = DA[0].idRangePos + 2 * QA, IA = x.getUint16(), wA.push({ charCode: QA, glyphId: IA });
          else {
            const dA = DA[cA[QA]];
            for (EA = 0; EA < dA.entryCount; EA++) {
              const mA = (QA << 8) + EA + dA.firstCode;
              x.pos = dA.idRangePos + 2 * EA, IA = x.getUint16(), IA !== 0 && (IA = (IA + dA.idDelta) % 65536), wA.push({ charCode: mA, glyphId: IA });
            }
          }
        } else if (BA === 4) {
          x.skip(4);
          const cA = x.getUint16() >> 1;
          x.skip(6);
          const bA = [];
          let DA;
          for (DA = 0; DA < cA; DA++) bA.push({ end: x.getUint16() });
          for (x.skip(2), DA = 0; DA < cA; DA++) bA[DA].start = x.getUint16();
          for (DA = 0; DA < cA; DA++) bA[DA].delta = x.getUint16();
          let QA, dA = 0;
          for (DA = 0; DA < cA; DA++) {
            H = bA[DA];
            const KA = x.getUint16();
            KA ? (QA = (KA >> 1) - (cA - DA), H.offsetIndex = QA, dA = Math.max(dA, QA + H.end - H.start + 1)) : H.offsetIndex = -1;
          }
          const mA = [];
          for (EA = 0; EA < dA; EA++) mA.push(x.getUint16());
          for (DA = 0; DA < cA; DA++) {
            H = bA[DA], z = H.start;
            const KA = H.end, kt = H.delta;
            for (QA = H.offsetIndex, EA = z; EA <= KA; EA++) EA !== 65535 && (IA = QA < 0 ? EA : mA[QA + EA - z], IA = IA + kt & 65535, wA.push({ charCode: EA, glyphId: IA }));
          }
        } else if (BA === 6) {
          x.skip(4);
          const cA = x.getUint16(), bA = x.getUint16();
          for (EA = 0; EA < bA; EA++) {
            IA = x.getUint16();
            const DA = cA + EA;
            wA.push({ charCode: DA, glyphId: IA });
          }
        } else {
          if (BA !== 12)
            return G("cmap table has unsupported format: " + BA), { platformId: -1, encodingId: -1, mappings: [], hasShortCmap: !1 };
          {
            x.skip(10);
            const cA = x.getInt32() >>> 0;
            for (EA = 0; EA < cA; EA++) {
              const bA = x.getInt32() >>> 0, DA = x.getInt32() >>> 0;
              let QA = x.getInt32() >>> 0;
              for (let dA = bA; dA <= DA; dA++) wA.push({ charCode: dA, glyphId: QA++ });
            }
          }
        }
        wA.sort(function(cA, bA) {
          return cA.charCode - bA.charCode;
        });
        for (let cA = 1; cA < wA.length; cA++) wA[cA - 1].charCode === wA[cA].charCode && (wA.splice(cA, 1), cA--);
        return { platformId: tA.platformId, encodingId: tA.encodingId, mappings: wA, hasShortCmap: gA };
      }(c.cmap, e, this.isSymbolicFont, i.hasEncoding), v = L.platformId, W = L.encodingId, K = L.mappings;
      let q = [], N = !1;
      if (!i.hasEncoding || i.baseEncodingName !== "MacRomanEncoding" && i.baseEncodingName !== "WinAnsiEncoding" || (q = bs(i.baseEncodingName)), i.hasEncoding && !this.isSymbolicFont && (v === 3 && W === 1 || v === 1 && W === 0)) {
        const F = fe();
        for (let w = 0; w < 256; w++) {
          let x;
          if (x = this.differences[w] !== void 0 ? this.differences[w] : q.length && q[w] !== "" ? q[w] : ve[w], !x) continue;
          const J = T1(x, F);
          let M;
          if (v === 3 && W === 1 ? M = F[J] : v === 1 && W === 0 && (M = $o.indexOf(J)), M === void 0) {
            if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof Ae)) {
              const H = this.toUnicode.get(w);
              H && (M = H.codePointAt(0));
            }
            if (M === void 0) continue;
          }
          for (const H of K) if (H.charCode === M) {
            R[w] = H.glyphId;
            break;
          }
        }
      } else if (v === 0) {
        for (const F of K) R[F.charCode] = F.glyphId;
        N = !0;
      } else if (v === 3 && W === 0) for (const F of K) {
        let w = F.charCode;
        w >= 61440 && w <= 61695 && (w &= 255), R[w] = F.glyphId;
      }
      else for (const F of K) R[F.charCode] = F.glyphId;
      if (i.glyphNames && (q.length || this.differences.length)) for (let F = 0; F < 256; ++F) {
        if (!N && R[F] !== void 0) continue;
        const w = this.differences[F] || q[F];
        if (!w) continue;
        const x = i.glyphNames.indexOf(w);
        x > 0 && k(x) && (R[F] = x);
      }
    }
    R.length === 0 && (R[0] = 0);
    let Y = f - 1;
    if (d || (Y = 0), !i.cssFontInfo) {
      const L = Uc(R, k, Y, this.toUnicode);
      this.toFontChar = L.toFontChar, c.cmap = { tag: "cmap", data: Mc(L.charCodeToGlyphId, L.toUnicodeExtraMap, f) }, c["OS/2"] && function(W, K) {
        K.pos = (K.start || 0) + W.offset;
        const q = K.getUint16();
        K.skip(60);
        const N = K.getUint16();
        return q < 4 && 768 & N || K.getUint16() > K.getUint16() || (K.skip(6), K.getUint16() === 0) ? !1 : (W.data[8] = W.data[9] = 0, !0);
      }(c["OS/2"], e) || (c["OS/2"] = { tag: "OS/2", data: Lc(i, L.charCodeToGlyphId, D) });
    }
    if (!Q) try {
      l = new At(c["CFF "].data), B = new eI(l, i, Ss).parse(), B.duplicateFirstGlyph();
      const L = new an(B);
      c["CFF "].data = L.compile();
    } catch {
      G("Failed to compile font " + i.loadedName);
    }
    if (c.name) {
      const [L, v] = o(c.name);
      c.name.data = Dg(A, L), this.psName = L[0][6] || null, i.composite || function(K, q, N) {
        if (K.isInternalFont || K.hasIncludedToUnicodeMap || K.hasEncoding || K.toUnicode instanceof Ae || !q || N.length === 0 || K.defaultEncoding === Ds) return;
        for (const J of N) if (!xc(J)) return;
        const F = Ds, w = [], x = fe();
        for (const J in F) {
          const M = F[J];
          if (M === "") continue;
          const H = x[M];
          H !== void 0 && (w[J] = String.fromCharCode(H));
        }
        w.length > 0 && K.toUnicode.amend(w);
      }(i, this.isSymbolicFont, v);
    } else c.name = { tag: "name", data: Dg(this.name) };
    const V = new Gs(h.version);
    for (const L in c) V.addTable(L, c[L].data);
    return V.toArray();
  }
  convert(A, e, i) {
    i.fixedPitch = !1, i.builtInEncoding && function(Q, E) {
      if (Q.isInternalFont || Q.hasIncludedToUnicodeMap || E === Q.defaultEncoding || Q.toUnicode instanceof Ae) return;
      const u = [], f = fe();
      for (const d in E) {
        if (Q.hasEncoding && (Q.baseEncodingName || Q.differences[d] !== void 0)) continue;
        const p = xa(E[d], f);
        p !== -1 && (u[d] = String.fromCharCode(p));
      }
      u.length > 0 && Q.toUnicode.amend(u);
    }(i, i.builtInEncoding);
    let a = 1;
    e instanceof dg && (a = e.numGlyphs - 1);
    const s = e.getGlyphMapping(i);
    let r = null, n = s, g = null;
    i.cssFontInfo || (r = Uc(s, e.hasGlyphId.bind(e), a, this.toUnicode), this.toFontChar = r.toFontChar, n = r.charCodeToGlyphId, g = r.toUnicodeExtraMap);
    const o = e.numGlyphs;
    function I(l, Q) {
      let E = null;
      for (const u in l) Q === l[u] && (E || (E = [])).push(0 | u);
      return E;
    }
    function C(l, Q) {
      for (const E in l) if (Q === l[E]) return 0 | E;
      return r.charCodeToGlyphId[r.nextAvailableFontCharCode] = Q, r.nextAvailableFontCharCode++;
    }
    const h = e.seacs;
    if (r && (h != null && h.length)) {
      const l = i.fontMatrix || Ji, Q = e.getCharset(), E = /* @__PURE__ */ Object.create(null);
      for (let u in h) {
        u |= 0;
        const f = h[u], d = ve[f[2]], p = ve[f[3]], m = Q.indexOf(d), y = Q.indexOf(p);
        if (m < 0 || y < 0) continue;
        const b = { x: f[0] * l[0] + f[1] * l[2] + l[4], y: f[0] * l[1] + f[1] * l[3] + l[5] }, D = I(s, u);
        if (D) for (const R of D) {
          const k = r.charCodeToGlyphId, Y = C(k, m), V = C(k, y);
          E[R] = { baseFontCharCode: Y, accentFontCharCode: V, accentOffset: b };
        }
      }
      i.seacMap = E;
    }
    const c = i.fontMatrix ? 1 / Math.max(...i.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, B = new Gs("OTTO");
    return B.addTable("CFF ", e.data), B.addTable("OS/2", Lc(i, n)), B.addTable("cmap", Mc(n, g, o)), B.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + wi(c) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + wi(i.descent) + "ÿ" + wi(i.ascent) + qA(i.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), B.addTable("hhea", "\0\0\0" + wi(i.ascent) + wi(i.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + wi(i.capHeight) + wi(Math.tan(i.italicAngle) * i.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + qA(o)), B.addTable("hmtx", function() {
      const Q = e.charstrings, E = e.cff ? e.cff.widths : null;
      let u = "\0\0\0\0";
      for (let f = 1, d = o; f < d; f++) {
        let p = 0;
        if (Q) {
          const m = Q[f - 1];
          p = "width" in m ? m.width : 0;
        } else E && (p = Math.ceil(E[f] || 0));
        u += qA(p) + qA(0);
      }
      return u;
    }()), B.addTable("maxp", "\0\0P\0" + qA(o)), B.addTable("name", Dg(A)), B.addTable("post", Jc(i)), B.toArray();
  }
  get _spaceWidth() {
    const A = ["space", "minus", "one", "i", "I"];
    let e;
    for (const i of A) {
      if (i in this.widths) {
        e = this.widths[i];
        break;
      }
      const a = fe()[i];
      let s = 0;
      if (this.composite && this.cMap.contains(a) && (s = this.cMap.lookup(a), typeof s == "string" && (s = wg(a, s))), !s && this.toUnicode && (s = this.toUnicode.charCodeOf(a)), s <= 0 && (s = a), e = this.widths[s], e) break;
    }
    return sA(this, "_spaceWidth", e || this.defaultWidth);
  }
  _charToGlyph(A, e = !1) {
    var c, B, l;
    let i, a, s, r = this._glyphCache[A];
    if ((r == null ? void 0 : r.isSpace) === e) return r;
    let n = A;
    (c = this.cMap) != null && c.contains(A) && (n = this.cMap.lookup(A), typeof n == "string" && (n = wg(A, n))), a = this.widths[n], typeof a != "number" && (a = this.defaultWidth);
    const g = (B = this.vmetrics) == null ? void 0 : B[n];
    let o = this.toUnicode.get(A) || A;
    typeof o == "number" && (o = String.fromCharCode(o));
    let I = this.toFontChar[A] !== void 0;
    if (i = this.toFontChar[A] || A, this.missingFile) {
      const Q = this.differences[A] || this.defaultEncoding[A];
      (Q === ".notdef" || Q === "") && this.type === "Type1" && (i = 32, Q === "" && (a || (a = this._spaceWidth), o = String.fromCharCode(i))), i = function(u) {
        return u >= 65520 && u <= 65535 ? 0 : u >= 62976 && u <= 63743 ? gQ()[u] || u : u === 173 ? 45 : u;
      }(i);
    }
    this.isType3Font && (s = i);
    let C = null;
    if ((l = this.seacMap) != null && l[A]) {
      I = !0;
      const Q = this.seacMap[A];
      i = Q.baseFontCharCode, C = { fontChar: String.fromCodePoint(Q.accentFontCharCode), offset: Q.accentOffset };
    }
    let h = "";
    if (typeof i == "number" && (i <= 1114111 ? h = String.fromCodePoint(i) : G(`charToGlyph - invalid fontCharCode: ${i}`)), this.missingFile && this.vertical && h.length === 1) {
      const Q = cQ()[h.charCodeAt(0)];
      Q && (h = o = String.fromCharCode(Q));
    }
    return r = new JQ(A, h, o, C, a, g, s, e, I), this._glyphCache[A] = r;
  }
  charsToGlyphs(A) {
    let e = this._charsCache[A];
    if (e) return e;
    if (e = [], this.cMap) {
      const i = /* @__PURE__ */ Object.create(null), a = A.length;
      let s = 0;
      for (; s < a; ) {
        this.cMap.readCharCode(A, s, i);
        const { charcode: r, length: n } = i;
        s += n;
        const g = this._charToGlyph(r, n === 1 && A.charCodeAt(s - 1) === 32);
        e.push(g);
      }
    } else for (let i = 0, a = A.length; i < a; ++i) {
      const s = A.charCodeAt(i), r = this._charToGlyph(s, s === 32);
      e.push(r);
    }
    return this._charsCache[A] = e;
  }
  getCharPositions(A) {
    const e = [];
    if (this.cMap) {
      const i = /* @__PURE__ */ Object.create(null);
      let a = 0;
      for (; a < A.length; ) {
        this.cMap.readCharCode(A, a, i);
        const s = i.length;
        e.push([a, a + s]), a += s;
      }
    } else for (let i = 0, a = A.length; i < a; ++i) e.push([i, i + 1]);
    return e;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(A) {
    const e = [], i = [], a = () => e.length % 2 == 1, s = this.toUnicode instanceof Ae ? (r) => this.toUnicode.charCodeOf(r) : (r) => this.toUnicode.charCodeOf(String.fromCodePoint(r));
    for (let r = 0, n = A.length; r < n; r++) {
      const g = A.codePointAt(r);
      if (g > 55295 && (g < 57344 || g > 65533) && r++, this.toUnicode) {
        const o = s(g);
        if (o !== -1) {
          a() && (e.push(i.join("")), i.length = 0);
          for (let I = (this.cMap ? this.cMap.getCharCodeLength(o) : 1) - 1; I >= 0; I--) i.push(String.fromCharCode(o >> 8 * I & 255));
          continue;
        }
      }
      a() || (e.push(i.join("")), i.length = 0), i.push(String.fromCodePoint(g));
    }
    return e.push(i.join("")), e;
  }
}
class bg {
  constructor(A) {
    this.error = A, this.loadedName = "g_font_error", this.missingFile = !0;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(A) {
    return [A];
  }
  exportData(A = !1) {
    return { error: this.error };
  }
}
const lo = 2, Xn = 3, V1 = 4, j1 = 5, z1 = 6, _1 = 7;
class KQ {
  constructor() {
    xA("Cannot initialize Pattern.");
  }
  static parseShading(A, e, i, a, s) {
    const r = A instanceof FA ? A.dict : A, n = r.get("ShadingType");
    try {
      switch (n) {
        case lo:
        case Xn:
          return new qQ(r, e, i, a, s);
        case V1:
        case j1:
        case z1:
        case _1:
          return new Qo(A, e, i, a, s);
        default:
          throw new X("Unsupported ShadingType: " + n);
      }
    } catch (g) {
      if (g instanceof OA) throw g;
      return G(g), new PQ();
    }
  }
}
class ya {
  getIR() {
    xA("Abstract method `getIR` called.");
  }
}
Ft(ya, "SMALL_NUMBER", 1e-6);
class qQ extends ya {
  constructor(A, e, i, a, s) {
    super(), this.shadingType = A.get("ShadingType");
    let r = 0;
    if (this.shadingType === lo ? r = 4 : this.shadingType === Xn && (r = 6), this.coordsArr = A.getArray("Coords"), !Gt(this.coordsArr, r)) throw new X("RadialAxialShading: Invalid /Coords array.");
    const n = kA.parse({ cs: A.getRaw("CS") || A.getRaw("ColorSpace"), xref: e, resources: i, pdfFunctionFactory: a, localColorSpaceCache: s });
    this.bbox = be(A.getArray("BBox"), null);
    let g = 0, o = 1;
    const I = A.getArray("Domain");
    Gt(I, 2) && ([g, o] = I);
    let C = !1, h = !1;
    const c = A.getArray("Extend");
    if (function(W, K) {
      return Array.isArray(W) && W.length === K && W.every((q) => typeof q == "boolean");
    }(c, 2) && ([C, h] = c), !(this.shadingType !== Xn || C && h)) {
      const [v, W, K, q, N, F] = this.coordsArr, w = Math.hypot(v - q, W - N);
      K <= F + w && F <= K + w && G("Unsupported radial gradient.");
    }
    this.extendStart = C, this.extendEnd = h;
    const B = A.getRaw("Function"), l = a.createFromArray(B), Q = (o - g) / 840, E = this.colorStops = [];
    if (g >= o || Q <= 0) {
      RA("Bad shading domain.");
      return;
    }
    const u = new Float32Array(n.numComps), f = new Float32Array(1);
    let d, p = 0;
    f[0] = g, l(f, 0, u, 0);
    let m = n.getRgb(u, 0);
    const y = nt.makeHexColor(m[0], m[1], m[2]);
    E.push([0, y]);
    let b = 1;
    f[0] = g + Q, l(f, 0, u, 0);
    let D = n.getRgb(u, 0), R = D[0] - m[0] + 1, k = D[1] - m[1] + 1, Y = D[2] - m[2] + 1, V = D[0] - m[0] - 1, eA = D[1] - m[1] - 1, AA = D[2] - m[2] - 1;
    for (let v = 2; v < 840; v++) {
      f[0] = g + v * Q, l(f, 0, u, 0), d = n.getRgb(u, 0);
      const W = v - p;
      if (R = Math.min(R, (d[0] - m[0] + 1) / W), k = Math.min(k, (d[1] - m[1] + 1) / W), Y = Math.min(Y, (d[2] - m[2] + 1) / W), V = Math.max(V, (d[0] - m[0] - 1) / W), eA = Math.max(eA, (d[1] - m[1] - 1) / W), AA = Math.max(AA, (d[2] - m[2] - 1) / W), !(V <= R && eA <= k && AA <= Y)) {
        const K = nt.makeHexColor(D[0], D[1], D[2]);
        E.push([b / 840, K]), R = d[0] - D[0] + 1, k = d[1] - D[1] + 1, Y = d[2] - D[2] + 1, V = d[0] - D[0] - 1, eA = d[1] - D[1] - 1, AA = d[2] - D[2] - 1, p = b, m = D;
      }
      b = v, D = d;
    }
    const O = nt.makeHexColor(D[0], D[1], D[2]);
    E.push([1, O]);
    let L = "transparent";
    A.has("Background") && (d = n.getRgb(A.get("Background"), 0), L = nt.makeHexColor(d[0], d[1], d[2])), C || (E.unshift([0, L]), E[1][0] += ya.SMALL_NUMBER), h || (E.at(-1)[0] -= ya.SMALL_NUMBER, E.push([1, L])), this.colorStops = E;
  }
  getIR() {
    const { coordsArr: A, shadingType: e } = this;
    let i, a, s, r, n;
    return e === lo ? (a = [A[0], A[1]], s = [A[2], A[3]], r = null, n = null, i = "axial") : e === Xn ? (a = [A[0], A[1]], s = [A[3], A[4]], r = A[2], n = A[5], i = "radial") : xA(`getPattern type unknown: ${e}`), ["RadialAxial", i, this.bbox, this.colorStops, a, s, r, n];
  }
}
class TQ {
  constructor(A, e) {
    this.stream = A, this.context = e, this.buffer = 0, this.bufferLength = 0;
    const i = e.numComps;
    this.tmpCompsBuf = new Float32Array(i);
    const a = e.colorSpace.numComps;
    this.tmpCsCompsBuf = e.colorFn ? new Float32Array(a) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end) return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0) return !0;
    const A = this.stream.getByte();
    return A < 0 ? !1 : (this.buffer = A, this.bufferLength = 8, !0);
  }
  readBits(A) {
    let e = this.buffer, i = this.bufferLength;
    if (A === 32) {
      if (i === 0) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      e = e << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const a = this.stream.getByte();
      return this.buffer = a & (1 << i) - 1, (e << 8 - i | (255 & a) >> i) >>> 0;
    }
    if (A === 8 && i === 0) return this.stream.getByte();
    for (; i < A; )
      e = e << 8 | this.stream.getByte(), i += 8;
    return i -= A, this.bufferLength = i, this.buffer = e & (1 << i) - 1, e >> i;
  }
  align() {
    this.buffer = 0, this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const A = this.context.bitsPerCoordinate, e = this.readBits(A), i = this.readBits(A), a = this.context.decode, s = A < 32 ? 1 / ((1 << A) - 1) : 23283064365386963e-26;
    return [e * s * (a[1] - a[0]) + a[0], i * s * (a[3] - a[2]) + a[2]];
  }
  readComponents() {
    const A = this.context.numComps, e = this.context.bitsPerComponent, i = e < 32 ? 1 / ((1 << e) - 1) : 23283064365386963e-26, a = this.context.decode, s = this.tmpCompsBuf;
    for (let n = 0, g = 4; n < A; n++, g += 2) {
      const o = this.readBits(e);
      s[n] = o * i * (a[g + 1] - a[g]) + a[g];
    }
    const r = this.tmpCsCompsBuf;
    return this.context.colorFn && this.context.colorFn(s, 0, r, 0), this.context.colorSpace.getRgb(r, 0);
  }
}
let Vn = /* @__PURE__ */ Object.create(null);
function Yc(t) {
  return Vn[t] || (Vn[t] = function(e) {
    const i = [];
    for (let a = 0; a <= e; a++) {
      const s = a / e, r = 1 - s;
      i.push(new Float32Array([r ** 3, 3 * s * r ** 2, 3 * s ** 2 * r, s ** 3]));
    }
    return i;
  }(t));
}
const oe = class oe extends ya {
  constructor(A, e, i, a, s) {
    if (super(), !(A instanceof FA)) throw new X("Mesh data is not a stream");
    const r = A.dict;
    this.shadingType = r.get("ShadingType"), this.bbox = be(r.getArray("BBox"), null);
    const n = kA.parse({ cs: r.getRaw("CS") || r.getRaw("ColorSpace"), xref: e, resources: i, pdfFunctionFactory: a, localColorSpaceCache: s });
    this.background = r.has("Background") ? n.getRgb(r.get("Background"), 0) : null;
    const g = r.getRaw("Function"), o = g ? a.createFromArray(g) : null;
    this.coords = [], this.colors = [], this.figures = [];
    const I = { bitsPerCoordinate: r.get("BitsPerCoordinate"), bitsPerComponent: r.get("BitsPerComponent"), bitsPerFlag: r.get("BitsPerFlag"), decode: r.getArray("Decode"), colorFn: o, colorSpace: n, numComps: o ? 1 : n.numComps }, C = new TQ(A, I);
    let h = !1;
    switch (this.shadingType) {
      case V1:
        this._decodeType4Shading(C);
        break;
      case j1:
        const c = 0 | r.get("VerticesPerRow");
        if (c < 2) throw new X("Invalid VerticesPerRow");
        this._decodeType5Shading(C, c);
        break;
      case z1:
        this._decodeType6Shading(C), h = !0;
        break;
      case _1:
        this._decodeType7Shading(C), h = !0;
        break;
      default:
        xA("Unsupported mesh type.");
    }
    if (h) {
      this._updateBounds();
      for (let c = 0, B = this.figures.length; c < B; c++) this._buildFigureFromPatch(c);
    }
    this._updateBounds(), this._packData();
  }
  _decodeType4Shading(A) {
    const e = this.coords, i = this.colors, a = [];
    let s = 0;
    for (; A.hasData; ) {
      const r = A.readFlag(), n = A.readCoordinate(), g = A.readComponents();
      if (s === 0) {
        if (!(0 <= r && r <= 2)) throw new X("Unknown type4 flag");
        switch (r) {
          case 0:
            s = 3;
            break;
          case 1:
            a.push(a.at(-2), a.at(-1)), s = 1;
            break;
          case 2:
            a.push(a.at(-3), a.at(-1)), s = 1;
        }
      }
      a.push(e.length), e.push(n), i.push(g), s--, A.align();
    }
    this.figures.push({ type: "triangles", coords: new Int32Array(a), colors: new Int32Array(a) });
  }
  _decodeType5Shading(A, e) {
    const i = this.coords, a = this.colors, s = [];
    for (; A.hasData; ) {
      const r = A.readCoordinate(), n = A.readComponents();
      s.push(i.length), i.push(r), a.push(n);
    }
    this.figures.push({ type: "lattice", coords: new Int32Array(s), colors: new Int32Array(s), verticesPerRow: e });
  }
  _decodeType6Shading(A) {
    const e = this.coords, i = this.colors, a = new Int32Array(16), s = new Int32Array(4);
    for (; A.hasData; ) {
      const r = A.readFlag();
      if (!(0 <= r && r <= 3)) throw new X("Unknown type6 flag");
      const n = e.length;
      for (let c = 0, B = r !== 0 ? 8 : 12; c < B; c++) e.push(A.readCoordinate());
      const g = i.length;
      for (let c = 0, B = r !== 0 ? 2 : 4; c < B; c++) i.push(A.readComponents());
      let o, I, C, h;
      switch (r) {
        case 0:
          a[12] = n + 3, a[13] = n + 4, a[14] = n + 5, a[15] = n + 6, a[8] = n + 2, a[11] = n + 7, a[4] = n + 1, a[7] = n + 8, a[0] = n, a[1] = n + 11, a[2] = n + 10, a[3] = n + 9, s[2] = g + 1, s[3] = g + 2, s[0] = g, s[1] = g + 3;
          break;
        case 1:
          o = a[12], I = a[13], C = a[14], h = a[15], a[12] = h, a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = C, a[11] = n + 3, a[4] = I, a[7] = n + 4, a[0] = o, a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, o = s[2], I = s[3], s[2] = I, s[3] = g, s[0] = o, s[1] = g + 1;
          break;
        case 2:
          o = a[15], I = a[11], a[12] = a[3], a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = a[7], a[11] = n + 3, a[4] = I, a[7] = n + 4, a[0] = o, a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, o = s[3], s[2] = s[1], s[3] = g, s[0] = o, s[1] = g + 1;
          break;
        case 3:
          a[12] = a[0], a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = a[1], a[11] = n + 3, a[4] = a[2], a[7] = n + 4, a[0] = a[3], a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, s[2] = s[0], s[3] = g, s[0] = s[1], s[1] = g + 1;
      }
      a[5] = e.length, e.push([(-4 * e[a[0]][0] - e[a[15]][0] + 6 * (e[a[4]][0] + e[a[1]][0]) - 2 * (e[a[12]][0] + e[a[3]][0]) + 3 * (e[a[13]][0] + e[a[7]][0])) / 9, (-4 * e[a[0]][1] - e[a[15]][1] + 6 * (e[a[4]][1] + e[a[1]][1]) - 2 * (e[a[12]][1] + e[a[3]][1]) + 3 * (e[a[13]][1] + e[a[7]][1])) / 9]), a[6] = e.length, e.push([(-4 * e[a[3]][0] - e[a[12]][0] + 6 * (e[a[2]][0] + e[a[7]][0]) - 2 * (e[a[0]][0] + e[a[15]][0]) + 3 * (e[a[4]][0] + e[a[14]][0])) / 9, (-4 * e[a[3]][1] - e[a[12]][1] + 6 * (e[a[2]][1] + e[a[7]][1]) - 2 * (e[a[0]][1] + e[a[15]][1]) + 3 * (e[a[4]][1] + e[a[14]][1])) / 9]), a[9] = e.length, e.push([(-4 * e[a[12]][0] - e[a[3]][0] + 6 * (e[a[8]][0] + e[a[13]][0]) - 2 * (e[a[0]][0] + e[a[15]][0]) + 3 * (e[a[11]][0] + e[a[1]][0])) / 9, (-4 * e[a[12]][1] - e[a[3]][1] + 6 * (e[a[8]][1] + e[a[13]][1]) - 2 * (e[a[0]][1] + e[a[15]][1]) + 3 * (e[a[11]][1] + e[a[1]][1])) / 9]), a[10] = e.length, e.push([(-4 * e[a[15]][0] - e[a[0]][0] + 6 * (e[a[11]][0] + e[a[14]][0]) - 2 * (e[a[12]][0] + e[a[3]][0]) + 3 * (e[a[2]][0] + e[a[8]][0])) / 9, (-4 * e[a[15]][1] - e[a[0]][1] + 6 * (e[a[11]][1] + e[a[14]][1]) - 2 * (e[a[12]][1] + e[a[3]][1]) + 3 * (e[a[2]][1] + e[a[8]][1])) / 9]), this.figures.push({ type: "patch", coords: new Int32Array(a), colors: new Int32Array(s) });
    }
  }
  _decodeType7Shading(A) {
    const e = this.coords, i = this.colors, a = new Int32Array(16), s = new Int32Array(4);
    for (; A.hasData; ) {
      const r = A.readFlag();
      if (!(0 <= r && r <= 3)) throw new X("Unknown type7 flag");
      const n = e.length;
      for (let c = 0, B = r !== 0 ? 12 : 16; c < B; c++) e.push(A.readCoordinate());
      const g = i.length;
      for (let c = 0, B = r !== 0 ? 2 : 4; c < B; c++) i.push(A.readComponents());
      let o, I, C, h;
      switch (r) {
        case 0:
          a[12] = n + 3, a[13] = n + 4, a[14] = n + 5, a[15] = n + 6, a[8] = n + 2, a[9] = n + 13, a[10] = n + 14, a[11] = n + 7, a[4] = n + 1, a[5] = n + 12, a[6] = n + 15, a[7] = n + 8, a[0] = n, a[1] = n + 11, a[2] = n + 10, a[3] = n + 9, s[2] = g + 1, s[3] = g + 2, s[0] = g, s[1] = g + 3;
          break;
        case 1:
          o = a[12], I = a[13], C = a[14], h = a[15], a[12] = h, a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = C, a[9] = n + 9, a[10] = n + 10, a[11] = n + 3, a[4] = I, a[5] = n + 8, a[6] = n + 11, a[7] = n + 4, a[0] = o, a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, o = s[2], I = s[3], s[2] = I, s[3] = g, s[0] = o, s[1] = g + 1;
          break;
        case 2:
          o = a[15], I = a[11], a[12] = a[3], a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = a[7], a[9] = n + 9, a[10] = n + 10, a[11] = n + 3, a[4] = I, a[5] = n + 8, a[6] = n + 11, a[7] = n + 4, a[0] = o, a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, o = s[3], s[2] = s[1], s[3] = g, s[0] = o, s[1] = g + 1;
          break;
        case 3:
          a[12] = a[0], a[13] = n + 0, a[14] = n + 1, a[15] = n + 2, a[8] = a[1], a[9] = n + 9, a[10] = n + 10, a[11] = n + 3, a[4] = a[2], a[5] = n + 8, a[6] = n + 11, a[7] = n + 4, a[0] = a[3], a[1] = n + 7, a[2] = n + 6, a[3] = n + 5, s[2] = s[0], s[3] = g, s[0] = s[1], s[1] = g + 1;
      }
      this.figures.push({ type: "patch", coords: new Int32Array(a), colors: new Int32Array(s) });
    }
  }
  _buildFigureFromPatch(A) {
    const e = this.figures[A];
    Rt(e.type === "patch", "Unexpected patch mesh figure");
    const i = this.coords, a = this.colors, s = e.coords, r = e.colors, n = Math.min(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]), g = Math.min(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]), o = Math.max(i[s[0]][0], i[s[3]][0], i[s[12]][0], i[s[15]][0]), I = Math.max(i[s[0]][1], i[s[3]][1], i[s[12]][1], i[s[15]][1]);
    let C = Math.ceil((o - n) * oe.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    C = Math.max(oe.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(oe.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C));
    let h = Math.ceil((I - g) * oe.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    h = Math.max(oe.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(oe.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h));
    const c = C + 1, B = new Int32Array((h + 1) * c), l = new Int32Array((h + 1) * c);
    let Q = 0;
    const E = new Uint8Array(3), u = new Uint8Array(3), f = a[r[0]], d = a[r[1]], p = a[r[2]], m = a[r[3]], y = Yc(h), b = Yc(C);
    for (let D = 0; D <= h; D++) {
      E[0] = (f[0] * (h - D) + p[0] * D) / h | 0, E[1] = (f[1] * (h - D) + p[1] * D) / h | 0, E[2] = (f[2] * (h - D) + p[2] * D) / h | 0, u[0] = (d[0] * (h - D) + m[0] * D) / h | 0, u[1] = (d[1] * (h - D) + m[1] * D) / h | 0, u[2] = (d[2] * (h - D) + m[2] * D) / h | 0;
      for (let R = 0; R <= C; R++, Q++) {
        if (!(D !== 0 && D !== h || R !== 0 && R !== C)) continue;
        let k = 0, Y = 0, V = 0;
        for (let AA = 0; AA <= 3; AA++) for (let O = 0; O <= 3; O++, V++) {
          const L = y[D][AA] * b[R][O];
          k += i[s[V]][0] * L, Y += i[s[V]][1] * L;
        }
        B[Q] = i.length, i.push([k, Y]), l[Q] = a.length;
        const eA = new Uint8Array(3);
        eA[0] = (E[0] * (C - R) + u[0] * R) / C | 0, eA[1] = (E[1] * (C - R) + u[1] * R) / C | 0, eA[2] = (E[2] * (C - R) + u[2] * R) / C | 0, a.push(eA);
      }
    }
    B[0] = s[0], l[0] = r[0], B[C] = s[3], l[C] = r[1], B[c * h] = s[12], l[c * h] = r[2], B[c * h + C] = s[15], l[c * h + C] = r[3], this.figures[A] = { type: "lattice", coords: B, colors: l, verticesPerRow: c };
  }
  _updateBounds() {
    let A = this.coords[0][0], e = this.coords[0][1], i = A, a = e;
    for (let s = 1, r = this.coords.length; s < r; s++) {
      const n = this.coords[s][0], g = this.coords[s][1];
      A = A > n ? n : A, e = e > g ? g : e, i = i < n ? n : i, a = a < g ? g : a;
    }
    this.bounds = [A, e, i, a];
  }
  _packData() {
    let A, e, i, a;
    const s = this.coords, r = new Float32Array(2 * s.length);
    for (A = 0, i = 0, e = s.length; A < e; A++) {
      const I = s[A];
      r[i++] = I[0], r[i++] = I[1];
    }
    this.coords = r;
    const n = this.colors, g = new Uint8Array(3 * n.length);
    for (A = 0, i = 0, e = n.length; A < e; A++) {
      const I = n[A];
      g[i++] = I[0], g[i++] = I[1], g[i++] = I[2];
    }
    this.colors = g;
    const o = this.figures;
    for (A = 0, e = o.length; A < e; A++) {
      const I = o[A], C = I.coords, h = I.colors;
      for (i = 0, a = C.length; i < a; i++)
        C[i] *= 2, h[i] *= 3;
    }
  }
  getIR() {
    const { bounds: A } = this;
    if (A[2] - A[0] == 0 || A[3] - A[1] == 0) throw new X(`Invalid MeshShading bounds: [${A}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, A, this.bbox, this.background];
  }
};
Ft(oe, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3), Ft(oe, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20), Ft(oe, "TRIANGLE_DENSITY", 20);
let Qo = oe;
class PQ extends ya {
  getIR() {
    return ["Dummy"];
  }
}
function vc(t, A, e) {
  const i = ci(A.getArray("Matrix"), Be), a = be(A.getArray("BBox"), null);
  if (!a || a[2] - a[0] == 0 || a[3] - a[1] == 0) throw new X("Invalid getTilingPatternIR /BBox array.");
  const s = A.get("XStep");
  if (typeof s != "number") throw new X("Invalid getTilingPatternIR /XStep value.");
  const r = A.get("YStep");
  if (typeof r != "number") throw new X("Invalid getTilingPatternIR /YStep value.");
  const n = A.get("PaintType");
  if (!Number.isInteger(n)) throw new X("Invalid getTilingPatternIR /PaintType value.");
  const g = A.get("TilingType");
  if (!Number.isInteger(g)) throw new X("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", e, t, i, a, s, r, n, g];
}
const WQ = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ZQ = { lineHeight: 1.2207, lineGap: 0.2207 }, OQ = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], XQ = { lineHeight: 1.2207, lineGap: 0.2207 }, VQ = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], jQ = { lineHeight: 1.2207, lineGap: 0.2207 }, zQ = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], _Q = { lineHeight: 1.2207, lineGap: 0.2207 }, $Q = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], AE = { lineHeight: 1.2, lineGap: 0.2 }, tE = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], eE = { lineHeight: 1.35, lineGap: 0.2 }, iE = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], aE = { lineHeight: 1.35, lineGap: 0.2 }, sE = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], nE = { lineHeight: 1.2, lineGap: 0.2 }, Oa = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], Xa = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], Va = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], ja = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], za = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], _a = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], $a = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], As = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], rE = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], gE = { lineHeight: 1.2, lineGap: 0.2 }, oE = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], IE = { lineHeight: 1.2, lineGap: 0.2 }, cE = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], CE = { lineHeight: 1.2, lineGap: 0.2 }, hE = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], BE = { lineHeight: 1.2, lineGap: 0.2 }, lE = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], QE = { lineHeight: 1.33008, lineGap: 0 }, EE = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], uE = { lineHeight: 1.33008, lineGap: 0 }, dE = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], fE = { lineHeight: 1.33008, lineGap: 0 }, pE = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], mE = { lineHeight: 1.33008, lineGap: 0 }, yE = jA(function(t) {
  t["MyriadPro-Regular"] = t["PdfJS-Fallback-Regular"] = { name: "LiberationSans-Regular", factors: hE, baseWidths: $a, baseMapping: As, metrics: BE }, t["MyriadPro-Bold"] = t["PdfJS-Fallback-Bold"] = { name: "LiberationSans-Bold", factors: rE, baseWidths: Oa, baseMapping: Xa, metrics: gE }, t["MyriadPro-It"] = t["MyriadPro-Italic"] = t["PdfJS-Fallback-Italic"] = { name: "LiberationSans-Italic", factors: cE, baseWidths: za, baseMapping: _a, metrics: CE }, t["MyriadPro-BoldIt"] = t["MyriadPro-BoldItalic"] = t["PdfJS-Fallback-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: oE, baseWidths: Va, baseMapping: ja, metrics: IE }, t.ArialMT = t.Arial = t["Arial-Regular"] = { name: "LiberationSans-Regular", baseWidths: $a, baseMapping: As }, t["Arial-BoldMT"] = t["Arial-Bold"] = { name: "LiberationSans-Bold", baseWidths: Oa, baseMapping: Xa }, t["Arial-ItalicMT"] = t["Arial-Italic"] = { name: "LiberationSans-Italic", baseWidths: za, baseMapping: _a }, t["Arial-BoldItalicMT"] = t["Arial-BoldItalic"] = { name: "LiberationSans-BoldItalic", baseWidths: Va, baseMapping: ja }, t["Calibri-Regular"] = { name: "LiberationSans-Regular", factors: zQ, baseWidths: $a, baseMapping: As, metrics: _Q }, t["Calibri-Bold"] = { name: "LiberationSans-Bold", factors: WQ, baseWidths: Oa, baseMapping: Xa, metrics: ZQ }, t["Calibri-Italic"] = { name: "LiberationSans-Italic", factors: VQ, baseWidths: za, baseMapping: _a, metrics: jQ }, t["Calibri-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: OQ, baseWidths: Va, baseMapping: ja, metrics: XQ }, t["Segoeui-Regular"] = { name: "LiberationSans-Regular", factors: pE, baseWidths: $a, baseMapping: As, metrics: mE }, t["Segoeui-Bold"] = { name: "LiberationSans-Bold", factors: lE, baseWidths: Oa, baseMapping: Xa, metrics: QE }, t["Segoeui-Italic"] = { name: "LiberationSans-Italic", factors: dE, baseWidths: za, baseMapping: _a, metrics: fE }, t["Segoeui-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: EE, baseWidths: Va, baseMapping: ja, metrics: uE }, t["Helvetica-Regular"] = t.Helvetica = { name: "LiberationSans-Regular", factors: sE, baseWidths: $a, baseMapping: As, metrics: nE }, t["Helvetica-Bold"] = { name: "LiberationSans-Bold", factors: $Q, baseWidths: Oa, baseMapping: Xa, metrics: AE }, t["Helvetica-Italic"] = { name: "LiberationSans-Italic", factors: iE, baseWidths: za, baseMapping: _a, metrics: aE }, t["Helvetica-BoldItalic"] = { name: "LiberationSans-BoldItalic", factors: tE, baseWidths: Va, baseMapping: ja, metrics: eE };
});
function gI(t) {
  const A = sn(t);
  return yE()[A];
}
function $1(t) {
  const A = function(r) {
    const n = gI(r);
    if (!n) return null;
    const { baseWidths: g, baseMapping: o, factors: I } = n, C = I ? g.map((l, Q) => l * I[Q]) : g;
    let h, c = -2;
    const B = [];
    for (const [l, Q] of o.map((E, u) => [E, u]).sort(([E], [u]) => E - u)) l !== -1 && (l === c + 1 ? (h.push(C[Q]), c += 1) : (c = l, h = [C[Q]], B.push(l, h)));
    return B;
  }(t), e = new U(null);
  e.set("BaseFont", T.get(t)), e.set("Type", T.get("Font")), e.set("Subtype", T.get("CIDFontType2")), e.set("Encoding", T.get("Identity-H")), e.set("CIDToGIDMap", T.get("Identity")), e.set("W", A), e.set("FirstChar", A[0]), e.set("LastChar", A.at(-2) + A.at(-1).length - 1);
  const i = new U(null);
  e.set("FontDescriptor", i);
  const a = new U(null);
  return a.set("Ordering", "Identity"), a.set("Registry", "Adobe"), a.set("Supplement", 0), e.set("CIDSystemInfo", a), e;
}
class wE {
  constructor(A) {
    this.lexer = A, this.operators = [], this.token = null, this.prev = null;
  }
  nextToken() {
    this.prev = this.token, this.token = this.lexer.getToken();
  }
  accept(A) {
    return this.token.type === A ? (this.nextToken(), !0) : !1;
  }
  expect(A) {
    if (this.accept(A)) return !0;
    throw new X(`Unexpected symbol: found ${this.token.type} expected ${A}.`);
  }
  parse() {
    return this.nextToken(), this.expect(yt.LBRACE), this.parseBlock(), this.expect(yt.RBRACE), this.operators;
  }
  parseBlock() {
    for (; ; ) if (this.accept(yt.NUMBER)) this.operators.push(this.prev.value);
    else if (this.accept(yt.OPERATOR)) this.operators.push(this.prev.value);
    else {
      if (!this.accept(yt.LBRACE)) return;
      this.parseCondition();
    }
  }
  parseCondition() {
    const A = this.operators.length;
    if (this.operators.push(null, null), this.parseBlock(), this.expect(yt.RBRACE), this.accept(yt.IF))
      this.operators[A] = this.operators.length, this.operators[A + 1] = "jz";
    else {
      if (!this.accept(yt.LBRACE)) throw new X("PS Function: error parsing conditional.");
      {
        const e = this.operators.length;
        this.operators.push(null, null);
        const i = this.operators.length;
        this.parseBlock(), this.expect(yt.RBRACE), this.expect(yt.IFELSE), this.operators[e] = this.operators.length, this.operators[e + 1] = "j", this.operators[A] = i, this.operators[A + 1] = "jz";
      }
    }
  }
}
const yt = { LBRACE: 0, RBRACE: 1, NUMBER: 2, OPERATOR: 3, IF: 4, IFELSE: 5 };
class Tt {
  static get opCache() {
    return sA(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(A, e) {
    this.type = A, this.value = e;
  }
  static getOperator(A) {
    var e;
    return (e = Tt.opCache)[A] || (e[A] = new Tt(yt.OPERATOR, A));
  }
  static get LBRACE() {
    return sA(this, "LBRACE", new Tt(yt.LBRACE, "{"));
  }
  static get RBRACE() {
    return sA(this, "RBRACE", new Tt(yt.RBRACE, "}"));
  }
  static get IF() {
    return sA(this, "IF", new Tt(yt.IF, "IF"));
  }
  static get IFELSE() {
    return sA(this, "IFELSE", new Tt(yt.IFELSE, "IFELSE"));
  }
}
class DE {
  constructor(A) {
    this.stream = A, this.nextChar(), this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let A = !1, e = this.currentChar;
    for (; ; ) {
      if (e < 0) return lt;
      if (A) e !== 10 && e !== 13 || (A = !1);
      else if (e === 37) A = !0;
      else if (!Zt(e)) break;
      e = this.nextChar();
    }
    switch (0 | e) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new Tt(yt.NUMBER, this.getNumber());
      case 123:
        return this.nextChar(), Tt.LBRACE;
      case 125:
        return this.nextChar(), Tt.RBRACE;
    }
    const i = this.strBuf;
    for (i.length = 0, i[0] = String.fromCharCode(e); (e = this.nextChar()) >= 0 && (e >= 65 && e <= 90 || e >= 97 && e <= 122); ) i.push(String.fromCharCode(e));
    const a = i.join("");
    switch (a.toLowerCase()) {
      case "if":
        return Tt.IF;
      case "ifelse":
        return Tt.IFELSE;
      default:
        return Tt.getOperator(a);
    }
  }
  getNumber() {
    let A = this.currentChar;
    const e = this.strBuf;
    for (e.length = 0, e[0] = String.fromCharCode(A); (A = this.nextChar()) >= 0 && (A >= 48 && A <= 57 || A === 45 || A === 46); ) e.push(String.fromCharCode(A));
    const i = parseFloat(e.join(""));
    if (isNaN(i)) throw new X(`Invalid floating point number: ${i}`);
    return i;
  }
}
class Ka {
  constructor(A) {
    this._onlyRefs = (A == null ? void 0 : A.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new xt();
  }
  getByName(A) {
    this._onlyRefs && xA("Should not call `getByName` method.");
    const e = this._nameRefMap.get(A);
    return e ? this.getByRef(e) : this._imageMap.get(A) || null;
  }
  getByRef(A) {
    return this._imageCache.get(A) || null;
  }
  set(A, e, i) {
    xA("Abstract method `set` called.");
  }
}
class Kc extends Ka {
  set(A, e = null, i) {
    if (typeof A != "string") throw new Error('LocalImageCache.set - expected "name" argument.');
    if (e) {
      if (this._imageCache.has(e)) return;
      this._nameRefMap.set(A, e), this._imageCache.put(e, i);
    } else this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class AC extends Ka {
  set(A = null, e = null, i) {
    if (typeof A != "string" && !e) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (e) {
      if (this._imageCache.has(e)) return;
      A !== null && this._nameRefMap.set(A, e), this._imageCache.put(e, i);
    } else this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class bE extends Ka {
  constructor(A) {
    super({ onlyRefs: !0 });
  }
  set(A = null, e, i) {
    if (!e) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
class qc extends Ka {
  set(A, e = null, i) {
    if (typeof A != "string") throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (e) {
      if (this._imageCache.has(e)) return;
      this._nameRefMap.set(A, e), this._imageCache.put(e, i);
    } else this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class kE extends Ka {
  constructor(A) {
    super({ onlyRefs: !0 });
  }
  set(A = null, e, i) {
    if (!e) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
class FE extends Ka {
  constructor(A) {
    super({ onlyRefs: !0 });
  }
  set(A = null, e, i) {
    if (!e) throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(e) || this._imageCache.put(e, i);
  }
}
var ka, Oi, tC, uo;
const xe = class xe {
  constructor() {
    MA(this, Oi);
    MA(this, ka, new Bt());
    this._refCache = new xt(), this._imageCache = new xt();
  }
  shouldCache(A, e) {
    let i = this._refCache.get(A);
    return i || (i = /* @__PURE__ */ new Set(), this._refCache.put(A, i)), i.add(e), !(i.size < xe.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(A) && NA(this, Oi, uo));
  }
  addDecodeFailed(A) {
    NA(this, ka).put(A);
  }
  hasDecodeFailed(A) {
    return NA(this, ka).has(A);
  }
  addByteSize(A, e) {
    const i = this._imageCache.get(A);
    i && (i.byteSize || (i.byteSize = e));
  }
  getData(A, e) {
    const i = this._refCache.get(A);
    if (!i || i.size < xe.NUM_PAGES_THRESHOLD) return null;
    const a = this._imageCache.get(A);
    return a ? (i.add(e), a) : null;
  }
  setData(A, e) {
    if (!this._refCache.has(A)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    this._imageCache.has(A) || (NA(this, Oi, uo) ? G("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(A, e));
  }
  clear(A = !1) {
    A || (NA(this, ka).clear(), this._refCache.clear()), this._imageCache.clear();
  }
};
ka = new WeakMap(), Oi = new WeakSet(), tC = function() {
  let A = 0;
  for (const e of this._imageCache) A += e.byteSize;
  return A;
}, uo = function() {
  return !(this._imageCache.size < xe.MIN_IMAGES_TO_CACHE) && !(NA(this, Oi, tC) < xe.MAX_BYTE_SIZE);
}, Ft(xe, "NUM_PAGES_THRESHOLD", 2), Ft(xe, "MIN_IMAGES_TO_CACHE", 10), Ft(xe, "MAX_BYTE_SIZE", 5e7);
let Eo = xe;
class eC {
  constructor({ xref: A, isEvalSupported: e = !0 }) {
    this.xref = A, this.isEvalSupported = e !== !1;
  }
  create(A) {
    const e = this.getCached(A);
    if (e) return e;
    const i = Tc.parse({ xref: this.xref, isEvalSupported: this.isEvalSupported, fn: A instanceof rA ? this.xref.fetch(A) : A });
    return this._cache(A, i), i;
  }
  createFromArray(A) {
    const e = this.getCached(A);
    if (e) return e;
    const i = Tc.parseArray({ xref: this.xref, isEvalSupported: this.isEvalSupported, fnObj: A instanceof rA ? this.xref.fetch(A) : A });
    return this._cache(A, i), i;
  }
  getCached(A) {
    var i;
    let e;
    if (A instanceof rA ? e = A : A instanceof U ? e = A.objId : A instanceof FA && (e = (i = A.dict) == null ? void 0 : i.objId), e) {
      const a = this._localFunctionCache.getByRef(e);
      if (a) return a;
    }
    return null;
  }
  _cache(A, e) {
    var a;
    if (!e) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    let i;
    A instanceof rA ? i = A : A instanceof U ? i = A.objId : A instanceof FA && (i = (a = A.dict) == null ? void 0 : a.objId), i && this._localFunctionCache.set(null, i, e);
  }
  get _localFunctionCache() {
    return sA(this, "_localFunctionCache", new bE());
  }
}
function jt(t) {
  return Array.isArray(t) ? Gt(t, null) ? t : t.map((A) => +A) : null;
}
class Tc {
  static getSampleArray(A, e, i, a) {
    let s, r, n = 1;
    for (s = 0, r = A.length; s < r; s++) n *= A[s];
    n *= e;
    const g = new Array(n);
    let o = 0, I = 0;
    const C = 1 / (2 ** i - 1), h = a.getBytes((n * i + 7) / 8);
    let c = 0;
    for (s = 0; s < n; s++) {
      for (; o < i; )
        I <<= 8, I |= h[c++], o += 8;
      o -= i, g[s] = (I >> o) * C, I &= (1 << o) - 1;
    }
    return g;
  }
  static parse({ xref: A, isEvalSupported: e, fn: i }) {
    const a = i.dict || i;
    switch (a.get("FunctionType")) {
      case 0:
        return this.constructSampled({ xref: A, isEvalSupported: e, fn: i, dict: a });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({ xref: A, isEvalSupported: e, dict: a });
      case 3:
        return this.constructStiched({ xref: A, isEvalSupported: e, dict: a });
      case 4:
        return this.constructPostScript({ xref: A, isEvalSupported: e, fn: i, dict: a });
    }
    throw new X("Unknown type of function");
  }
  static parseArray({ xref: A, isEvalSupported: e, fnObj: i }) {
    if (!Array.isArray(i)) return this.parse({ xref: A, isEvalSupported: e, fn: i });
    const a = [];
    for (const s of i) a.push(this.parse({ xref: A, isEvalSupported: e, fn: A.fetchIfRef(s) }));
    return function(s, r, n, g) {
      for (let o = 0, I = a.length; o < I; o++) a[o](s, r, n, g + o);
    };
  }
  static constructSampled({ xref: A, isEvalSupported: e, fn: i, dict: a }) {
    function s(E) {
      const u = E.length, f = [];
      let d = 0;
      for (let p = 0; p < u; p += 2) f[d++] = [E[p], E[p + 1]];
      return f;
    }
    function r(E, u, f, d, p) {
      return d + (p - d) / (f - u) * (E - u);
    }
    let n = jt(a.getArray("Domain")), g = jt(a.getArray("Range"));
    if (!n || !g) throw new X("No domain or range");
    const o = n.length / 2, I = g.length / 2;
    n = s(n), g = s(g);
    const C = jt(a.getArray("Size")), h = a.get("BitsPerSample"), c = a.get("Order") || 1;
    c !== 1 && RA("No support for cubic spline interpolation: " + c);
    let B = jt(a.getArray("Encode"));
    if (B) B = s(B);
    else {
      B = [];
      for (let E = 0; E < o; ++E) B.push([0, C[E] - 1]);
    }
    let l = jt(a.getArray("Decode"));
    l = l ? s(l) : g;
    const Q = this.getSampleArray(C, I, h, i);
    return function(u, f, d, p) {
      const m = 1 << o, y = new Float64Array(m), b = new Uint32Array(m);
      let D, R;
      for (R = 0; R < m; R++) y[R] = 1;
      let k = I, Y = 1;
      for (D = 0; D < o; ++D) {
        const V = n[D][0], eA = n[D][1];
        let AA = r(Math.min(Math.max(u[f + D], V), eA), V, eA, B[D][0], B[D][1]);
        const O = C[D];
        AA = Math.min(Math.max(AA, 0), O - 1);
        const L = AA < O - 1 ? Math.floor(AA) : AA - 1, v = L + 1 - AA, W = AA - L, K = L * k, q = K + k;
        for (R = 0; R < m; R++) R & Y ? (y[R] *= W, b[R] += q) : (y[R] *= v, b[R] += K);
        k *= O, Y <<= 1;
      }
      for (R = 0; R < I; ++R) {
        let V = 0;
        for (D = 0; D < m; D++) V += Q[b[D] + R] * y[D];
        V = r(V, 0, 1, l[R][0], l[R][1]), d[p + R] = Math.min(Math.max(V, g[R][0]), g[R][1]);
      }
    };
  }
  static constructInterpolated({ xref: A, isEvalSupported: e, dict: i }) {
    const a = jt(i.getArray("C0")) || [0], s = jt(i.getArray("C1")) || [1], r = i.get("N"), n = [];
    for (let o = 0, I = a.length; o < I; ++o) n.push(s[o] - a[o]);
    const g = n.length;
    return function(I, C, h, c) {
      const B = r === 1 ? I[C] : I[C] ** r;
      for (let l = 0; l < g; ++l) h[c + l] = a[l] + B * n[l];
    };
  }
  static constructStiched({ xref: A, isEvalSupported: e, dict: i }) {
    const a = jt(i.getArray("Domain"));
    if (!a) throw new X("No domain");
    if (a.length / 2 !== 1) throw new X("Bad domain for stiched function");
    const s = [];
    for (const o of i.get("Functions")) s.push(this.parse({ xref: A, isEvalSupported: e, fn: A.fetchIfRef(o) }));
    const r = jt(i.getArray("Bounds")), n = jt(i.getArray("Encode")), g = new Float32Array(1);
    return function(I, C, h, c) {
      const B = function(m, y, b) {
        return m > b ? m = b : m < y && (m = y), m;
      }(I[C], a[0], a[1]), l = r.length;
      let Q;
      for (Q = 0; Q < l && !(B < r[Q]); ++Q) ;
      let E = a[0];
      Q > 0 && (E = r[Q - 1]);
      let u = a[1];
      Q < r.length && (u = r[Q]);
      const f = n[2 * Q], d = n[2 * Q + 1];
      g[0] = E === u ? f : f + (B - E) * (d - f) / (u - E), s[Q](g, 0, h, c);
    };
  }
  static constructPostScript({ xref: A, isEvalSupported: e, fn: i, dict: a }) {
    const s = jt(a.getArray("Domain")), r = jt(a.getArray("Range"));
    if (!s) throw new X("No domain.");
    if (!r) throw new X("No range.");
    const n = new DE(i), g = new wE(n).parse();
    if (e && Jt.isEvalSupported) {
      const l = new LE().compile(g, s, r);
      if (l) return new Function("src", "srcOffset", "dest", "destOffset", l);
    }
    RA("Unable to compile PS function");
    const o = r.length >> 1, I = s.length >> 1, C = new SE(g), h = /* @__PURE__ */ Object.create(null);
    let c = 8192;
    const B = new Float32Array(I);
    return function(Q, E, u, f) {
      let d, p, m = "";
      const y = B;
      for (d = 0; d < I; d++)
        p = Q[E + d], y[d] = p, m += p + "_";
      const b = h[m];
      if (b !== void 0) {
        u.set(b, f);
        return;
      }
      const D = new Float32Array(o), R = C.execute(y), k = R.length - o;
      for (d = 0; d < o; d++) {
        p = R[k + d];
        let Y = r[2 * d];
        p < Y ? p = Y : (Y = r[2 * d + 1], p > Y && (p = Y)), D[d] = p;
      }
      c > 0 && (c--, h[m] = D), u.set(D, f);
    };
  }
}
function kg(t) {
  let A;
  if (t instanceof U) A = t;
  else {
    if (!(t instanceof FA)) return !1;
    A = t.dict;
  }
  return A.has("FunctionType");
}
const ds = class ds {
  constructor(A) {
    this.stack = A ? Array.from(A) : [];
  }
  push(A) {
    if (this.stack.length >= ds.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    this.stack.push(A);
  }
  pop() {
    if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(A) {
    if (this.stack.length + A >= ds.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
    const e = this.stack;
    for (let i = e.length - A, a = A - 1; a >= 0; a--, i++) e.push(e[i]);
  }
  index(A) {
    this.push(this.stack[this.stack.length - A - 1]);
  }
  roll(A, e) {
    const i = this.stack, a = i.length - A, s = i.length - 1, r = a + (e - Math.floor(e / A) * A);
    for (let n = a, g = s; n < g; n++, g--) {
      const o = i[n];
      i[n] = i[g], i[g] = o;
    }
    for (let n = a, g = r - 1; n < g; n++, g--) {
      const o = i[n];
      i[n] = i[g], i[g] = o;
    }
    for (let n = r, g = s; n < g; n++, g--) {
      const o = i[n];
      i[n] = i[g], i[g] = o;
    }
  }
};
Ft(ds, "MAX_STACK_SIZE", 100);
let fo = ds;
class SE {
  constructor(A) {
    this.operators = A;
  }
  execute(A) {
    const e = new fo(A);
    let i = 0;
    const a = this.operators, s = a.length;
    let r, n, g;
    for (; i < s; )
      if (r = a[i++], typeof r != "number") switch (r) {
        case "jz":
          g = e.pop(), n = e.pop(), n || (i = g);
          break;
        case "j":
          n = e.pop(), i = n;
          break;
        case "abs":
          n = e.pop(), e.push(Math.abs(n));
          break;
        case "add":
          g = e.pop(), n = e.pop(), e.push(n + g);
          break;
        case "and":
          g = e.pop(), n = e.pop(), typeof n == "boolean" && typeof g == "boolean" ? e.push(n && g) : e.push(n & g);
          break;
        case "atan":
          g = e.pop(), n = e.pop(), n = Math.atan2(n, g) / Math.PI * 180, n < 0 && (n += 360), e.push(n);
          break;
        case "bitshift":
          g = e.pop(), n = e.pop(), n > 0 ? e.push(n << g) : e.push(n >> g);
          break;
        case "ceiling":
          n = e.pop(), e.push(Math.ceil(n));
          break;
        case "copy":
          n = e.pop(), e.copy(n);
          break;
        case "cos":
          n = e.pop(), e.push(Math.cos(n % 360 / 180 * Math.PI));
          break;
        case "cvi":
          n = 0 | e.pop(), e.push(n);
          break;
        case "cvr":
          break;
        case "div":
          g = e.pop(), n = e.pop(), e.push(n / g);
          break;
        case "dup":
          e.copy(1);
          break;
        case "eq":
          g = e.pop(), n = e.pop(), e.push(n === g);
          break;
        case "exch":
          e.roll(2, 1);
          break;
        case "exp":
          g = e.pop(), n = e.pop(), e.push(n ** g);
          break;
        case "false":
          e.push(!1);
          break;
        case "floor":
          n = e.pop(), e.push(Math.floor(n));
          break;
        case "ge":
          g = e.pop(), n = e.pop(), e.push(n >= g);
          break;
        case "gt":
          g = e.pop(), n = e.pop(), e.push(n > g);
          break;
        case "idiv":
          g = e.pop(), n = e.pop(), e.push(n / g | 0);
          break;
        case "index":
          n = e.pop(), e.index(n);
          break;
        case "le":
          g = e.pop(), n = e.pop(), e.push(n <= g);
          break;
        case "ln":
          n = e.pop(), e.push(Math.log(n));
          break;
        case "log":
          n = e.pop(), e.push(Math.log10(n));
          break;
        case "lt":
          g = e.pop(), n = e.pop(), e.push(n < g);
          break;
        case "mod":
          g = e.pop(), n = e.pop(), e.push(n % g);
          break;
        case "mul":
          g = e.pop(), n = e.pop(), e.push(n * g);
          break;
        case "ne":
          g = e.pop(), n = e.pop(), e.push(n !== g);
          break;
        case "neg":
          n = e.pop(), e.push(-n);
          break;
        case "not":
          n = e.pop(), typeof n == "boolean" ? e.push(!n) : e.push(~n);
          break;
        case "or":
          g = e.pop(), n = e.pop(), typeof n == "boolean" && typeof g == "boolean" ? e.push(n || g) : e.push(n | g);
          break;
        case "pop":
          e.pop();
          break;
        case "roll":
          g = e.pop(), n = e.pop(), e.roll(n, g);
          break;
        case "round":
          n = e.pop(), e.push(Math.round(n));
          break;
        case "sin":
          n = e.pop(), e.push(Math.sin(n % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          n = e.pop(), e.push(Math.sqrt(n));
          break;
        case "sub":
          g = e.pop(), n = e.pop(), e.push(n - g);
          break;
        case "true":
          e.push(!0);
          break;
        case "truncate":
          n = e.pop(), n = n < 0 ? Math.ceil(n) : Math.floor(n), e.push(n);
          break;
        case "xor":
          g = e.pop(), n = e.pop(), typeof n == "boolean" && typeof g == "boolean" ? e.push(n !== g) : e.push(n ^ g);
          break;
        default:
          throw new X(`Unknown operator ${r}`);
      }
      else e.push(r);
    return e.stack;
  }
}
class qa {
  constructor(A) {
    this.type = A;
  }
  visit(A) {
    xA("abstract method");
  }
}
class RE extends qa {
  constructor(A, e, i) {
    super("args"), this.index = A, this.min = e, this.max = i;
  }
  visit(A) {
    A.visitArgument(this);
  }
}
class Yi extends qa {
  constructor(A) {
    super("literal"), this.number = A, this.min = A, this.max = A;
  }
  visit(A) {
    A.visitLiteral(this);
  }
}
class oI extends qa {
  constructor(A, e, i, a, s) {
    super("binary"), this.op = A, this.arg1 = e, this.arg2 = i, this.min = a, this.max = s;
  }
  visit(A) {
    A.visitBinaryOperation(this);
  }
}
class GE extends qa {
  constructor(A, e) {
    super("max"), this.arg = A, this.min = A.min, this.max = e;
  }
  visit(A) {
    A.visitMin(this);
  }
}
class Pc extends qa {
  constructor(A, e, i) {
    super("var"), this.index = A, this.min = e, this.max = i;
  }
  visit(A) {
    A.visitVariable(this);
  }
}
class Wc extends qa {
  constructor(A, e) {
    super("definition"), this.variable = A, this.arg = e;
  }
  visit(A) {
    A.visitVariableDefinition(this);
  }
}
class Zc {
  constructor() {
    this.parts = [];
  }
  visitArgument(A) {
    this.parts.push("Math.max(", A.min, ", Math.min(", A.max, ", src[srcOffset + ", A.index, "]))");
  }
  visitVariable(A) {
    this.parts.push("v", A.index);
  }
  visitLiteral(A) {
    this.parts.push(A.number);
  }
  visitBinaryOperation(A) {
    this.parts.push("("), A.arg1.visit(this), this.parts.push(" ", A.op, " "), A.arg2.visit(this), this.parts.push(")");
  }
  visitVariableDefinition(A) {
    this.parts.push("var "), A.variable.visit(this), this.parts.push(" = "), A.arg.visit(this), this.parts.push(";");
  }
  visitMin(A) {
    this.parts.push("Math.min("), A.arg.visit(this), this.parts.push(", ", A.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function NE(t, A) {
  return A.type === "literal" && A.number === 0 ? t : t.type === "literal" && t.number === 0 ? A : A.type === "literal" && t.type === "literal" ? new Yi(t.number + A.number) : new oI("+", t, A, t.min + A.min, t.max + A.max);
}
function xE(t, A) {
  if (A.type === "literal") {
    if (A.number === 0) return new Yi(0);
    if (A.number === 1) return t;
    if (t.type === "literal") return new Yi(t.number * A.number);
  }
  if (t.type === "literal") {
    if (t.number === 0) return new Yi(0);
    if (t.number === 1) return A;
  }
  const e = Math.min(t.min * A.min, t.min * A.max, t.max * A.min, t.max * A.max), i = Math.max(t.min * A.min, t.min * A.max, t.max * A.min, t.max * A.max);
  return new oI("*", t, A, e, i);
}
function UE(t, A) {
  if (A.type === "literal") {
    if (A.number === 0) return t;
    if (t.type === "literal") return new Yi(t.number - A.number);
  }
  return A.type === "binary" && A.op === "-" && t.type === "literal" && t.number === 1 && A.arg1.type === "literal" && A.arg1.number === 1 ? A.arg2 : new oI("-", t, A, t.min - A.max, t.max - A.min);
}
function ME(t, A) {
  return t.min >= A ? new Yi(A) : t.max <= A ? t : new GE(t, A);
}
class LE {
  compile(A, e, i) {
    const a = [], s = [], r = e.length >> 1, n = i.length >> 1;
    let g, o, I, C, h, c, B, l, Q = 0;
    for (let u = 0; u < r; u++) a.push(new RE(u, e[2 * u], e[2 * u + 1]));
    for (let u = 0, f = A.length; u < f; u++)
      if (l = A[u], typeof l != "number") switch (l) {
        case "add":
          if (a.length < 2) return null;
          C = a.pop(), I = a.pop(), a.push(NE(I, C));
          break;
        case "cvr":
          if (a.length < 1) return null;
          break;
        case "mul":
          if (a.length < 2) return null;
          C = a.pop(), I = a.pop(), a.push(xE(I, C));
          break;
        case "sub":
          if (a.length < 2) return null;
          C = a.pop(), I = a.pop(), a.push(UE(I, C));
          break;
        case "exch":
          if (a.length < 2) return null;
          h = a.pop(), c = a.pop(), a.push(h, c);
          break;
        case "pop":
          if (a.length < 1) return null;
          a.pop();
          break;
        case "index":
          if (a.length < 1 || (I = a.pop(), I.type !== "literal") || (g = I.number, g < 0 || !Number.isInteger(g) || a.length < g)) return null;
          if (h = a[a.length - g - 1], h.type === "literal" || h.type === "var") {
            a.push(h);
            break;
          }
          B = new Pc(Q++, h.min, h.max), a[a.length - g - 1] = B, a.push(B), s.push(new Wc(B, h));
          break;
        case "dup":
          if (a.length < 1) return null;
          if (typeof A[u + 1] == "number" && A[u + 2] === "gt" && A[u + 3] === u + 7 && A[u + 4] === "jz" && A[u + 5] === "pop" && A[u + 6] === A[u + 1]) {
            I = a.pop(), a.push(ME(I, A[u + 1])), u += 6;
            break;
          }
          if (h = a.at(-1), h.type === "literal" || h.type === "var") {
            a.push(h);
            break;
          }
          B = new Pc(Q++, h.min, h.max), a[a.length - 1] = B, a.push(B), s.push(new Wc(B, h));
          break;
        case "roll":
          if (a.length < 2 || (C = a.pop(), I = a.pop(), C.type !== "literal" || I.type !== "literal") || (o = C.number, g = I.number, g <= 0 || !Number.isInteger(g) || !Number.isInteger(o) || a.length < g)) return null;
          if (o = (o % g + g) % g, o === 0) break;
          a.push(...a.splice(a.length - g, g - o));
          break;
        default:
          return null;
      }
      else a.push(new Yi(l));
    if (a.length !== n) return null;
    const E = [];
    for (const u of s) {
      const f = new Zc();
      u.visit(f), E.push(f.toString());
    }
    for (let u = 0, f = a.length; u < f; u++) {
      const d = a[u], p = new Zc();
      d.visit(p);
      const m = i[2 * u], y = i[2 * u + 1], b = [p.toString()];
      m > d.min && (b.unshift("Math.max(", m, ", "), b.push(")")), y < d.max && (b.unshift("Math.min(", y, ", "), b.push(")")), b.unshift("dest[destOffset + ", u, "] = "), b.push(";"), E.push(b.join(""));
    }
    return E.join(`
`);
  }
}
const JE = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], HE = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function Oc(t) {
  return (1 & t) != 0;
}
function YE(t) {
  return (1 & t) == 0;
}
function vE(t, A, e) {
  let i, a;
  for (i = A, a = t.length; i < a; ++i) if (t[i] !== e) return i;
  return i;
}
function KE(t, A, e, i) {
  for (let a = A; a < e; ++a) t[a] = i;
}
function Xc(t, A, e) {
  for (let i = A, a = e - 1; i < a; ++i, --a) {
    const s = t[i];
    t[i] = t[a], t[a] = s;
  }
}
function Fg(t, A, e = !1) {
  let i = "ltr";
  return e ? i = "ttb" : A || (i = "rtl"), { str: t, dir: i };
}
const Ve = [], HA = [];
function iC(t, A = -1, e = !1) {
  let i = !0;
  const a = t.length;
  if (a === 0 || e) return Fg(t, i, e);
  Ve.length = a, HA.length = a;
  let s, r, n = 0;
  for (s = 0; s < a; ++s) {
    Ve[s] = t.charAt(s);
    const E = t.charCodeAt(s);
    let u = "L";
    E <= 255 ? u = JE[E] : 1424 <= E && E <= 1524 ? u = "R" : 1536 <= E && E <= 1791 ? (u = HE[255 & E], u || G("Bidi: invalid Unicode character " + E.toString(16))) : (1792 <= E && E <= 2220 || 64336 <= E && E <= 65023 || 65136 <= E && E <= 65279) && (u = "AL"), u !== "R" && u !== "AL" && u !== "AN" || n++, HA[s] = u;
  }
  if (n === 0)
    return i = !0, Fg(t, i);
  A === -1 && (n / a < 0.3 && a > 4 ? (i = !0, A = 0) : (i = !1, A = 1));
  const g = [];
  for (s = 0; s < a; ++s) g[s] = A;
  const o = Oc(A) ? "R" : "L", I = o, C = I;
  let h, c = I;
  for (s = 0; s < a; ++s) HA[s] === "NSM" ? HA[s] = c : c = HA[s];
  for (c = I, s = 0; s < a; ++s)
    h = HA[s], h === "EN" ? HA[s] = c === "AL" ? "AN" : "EN" : h !== "R" && h !== "L" && h !== "AL" || (c = h);
  for (s = 0; s < a; ++s)
    h = HA[s], h === "AL" && (HA[s] = "R");
  for (s = 1; s < a - 1; ++s)
    HA[s] === "ES" && HA[s - 1] === "EN" && HA[s + 1] === "EN" && (HA[s] = "EN"), HA[s] !== "CS" || HA[s - 1] !== "EN" && HA[s - 1] !== "AN" || HA[s + 1] !== HA[s - 1] || (HA[s] = HA[s - 1]);
  for (s = 0; s < a; ++s) if (HA[s] === "EN") {
    for (let E = s - 1; E >= 0 && HA[E] === "ET"; --E) HA[E] = "EN";
    for (let E = s + 1; E < a && HA[E] === "ET"; ++E) HA[E] = "EN";
  }
  for (s = 0; s < a; ++s)
    h = HA[s], h !== "WS" && h !== "ES" && h !== "ET" && h !== "CS" || (HA[s] = "ON");
  for (c = I, s = 0; s < a; ++s)
    h = HA[s], h === "EN" ? HA[s] = c === "L" ? "L" : "EN" : h !== "R" && h !== "L" || (c = h);
  for (s = 0; s < a; ++s) if (HA[s] === "ON") {
    const E = vE(HA, s + 1, "ON");
    let u = I;
    s > 0 && (u = HA[s - 1]);
    let f = C;
    E + 1 < a && (f = HA[E + 1]), u !== "L" && (u = "R"), f !== "L" && (f = "R"), u === f && KE(HA, s, E, u), s = E - 1;
  }
  for (s = 0; s < a; ++s) HA[s] === "ON" && (HA[s] = o);
  for (s = 0; s < a; ++s)
    h = HA[s], YE(g[s]) ? h === "R" ? g[s] += 1 : h !== "AN" && h !== "EN" || (g[s] += 2) : h !== "L" && h !== "AN" && h !== "EN" || (g[s] += 1);
  let B, l = -1, Q = 99;
  for (s = 0, r = g.length; s < r; ++s)
    B = g[s], l < B && (l = B), Q > B && Oc(B) && (Q = B);
  for (B = l; B >= Q; --B) {
    let E = -1;
    for (s = 0, r = g.length; s < r; ++s) g[s] < B ? E >= 0 && (Xc(Ve, E, s), E = -1) : E < 0 && (E = s);
    E >= 0 && Xc(Ve, E, g.length);
  }
  for (s = 0, r = Ve.length; s < r; ++s) {
    const E = Ve[s];
    E !== "<" && E !== ">" || (Ve[s] = "");
  }
  return Fg(Ve.join(""), i);
}
const Si = { style: "normal", weight: "normal" }, Gi = { style: "normal", weight: "bold" }, Ni = { style: "italic", weight: "normal" }, xi = { style: "italic", weight: "bold" }, Cs = /* @__PURE__ */ new Map([["Times-Roman", { local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"], style: Si, ultimate: "serif" }], ["Times-Bold", { alias: "Times-Roman", style: Gi, ultimate: "serif" }], ["Times-Italic", { alias: "Times-Roman", style: Ni, ultimate: "serif" }], ["Times-BoldItalic", { alias: "Times-Roman", style: xi, ultimate: "serif" }], ["Helvetica", { local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"], path: "LiberationSans-Regular.ttf", style: Si, ultimate: "sans-serif" }], ["Helvetica-Bold", { alias: "Helvetica", path: "LiberationSans-Bold.ttf", style: Gi, ultimate: "sans-serif" }], ["Helvetica-Oblique", { alias: "Helvetica", path: "LiberationSans-Italic.ttf", style: Ni, ultimate: "sans-serif" }], ["Helvetica-BoldOblique", { alias: "Helvetica", path: "LiberationSans-BoldItalic.ttf", style: xi, ultimate: "sans-serif" }], ["Courier", { local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"], style: Si, ultimate: "monospace" }], ["Courier-Bold", { alias: "Courier", style: Gi, ultimate: "monospace" }], ["Courier-Oblique", { alias: "Courier", style: Ni, ultimate: "monospace" }], ["Courier-BoldOblique", { alias: "Courier", style: xi, ultimate: "monospace" }], ["ArialBlack", { local: ["Arial Black"], style: { style: "normal", weight: "900" }, fallback: "Helvetica-Bold" }], ["ArialBlack-Bold", { alias: "ArialBlack" }], ["ArialBlack-Italic", { alias: "ArialBlack", style: { style: "italic", weight: "900" }, fallback: "Helvetica-BoldOblique" }], ["ArialBlack-BoldItalic", { alias: "ArialBlack-Italic" }], ["ArialNarrow", { local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"], style: Si, fallback: "Helvetica" }], ["ArialNarrow-Bold", { alias: "ArialNarrow", style: Gi, fallback: "Helvetica-Bold" }], ["ArialNarrow-Italic", { alias: "ArialNarrow", style: Ni, fallback: "Helvetica-Oblique" }], ["ArialNarrow-BoldItalic", { alias: "ArialNarrow", style: xi, fallback: "Helvetica-BoldOblique" }], ["Calibri", { local: ["Calibri", "Carlito"], style: Si, fallback: "Helvetica" }], ["Calibri-Bold", { alias: "Calibri", style: Gi, fallback: "Helvetica-Bold" }], ["Calibri-Italic", { alias: "Calibri", style: Ni, fallback: "Helvetica-Oblique" }], ["Calibri-BoldItalic", { alias: "Calibri", style: xi, fallback: "Helvetica-BoldOblique" }], ["Wingdings", { local: ["Wingdings", "URW Dingbats"], style: Si }], ["Wingdings-Regular", { alias: "Wingdings" }], ["Wingdings-Bold", { alias: "Wingdings" }]]), qE = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function Vc(t) {
  const A = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return t.split(/[- ,+]+/g).filter((e) => !A.has(e.toLowerCase())).join(" ");
}
function po({ alias: t, local: A, path: e, fallback: i, style: a, ultimate: s }, r, n, g = !0, o = !0, I = "") {
  const C = { style: null, ultimate: null };
  if (A) {
    const h = I ? ` ${I}` : "";
    for (const c of A) r.push(`local(${c}${h})`);
  }
  if (t) {
    const h = Cs.get(t), c = I || function(l) {
      switch (l) {
        case Gi:
          return "Bold";
        case Ni:
          return "Italic";
        case xi:
          return "Bold Italic";
        default:
          if ((l == null ? void 0 : l.weight) === "bold") return "Bold";
          if ((l == null ? void 0 : l.style) === "italic") return "Italic";
      }
      return "";
    }(a);
    Object.assign(C, po(h, r, n, g && !i, o && !e, c));
  }
  if (a && (C.style = a), s && (C.ultimate = s), g && i) {
    const h = Cs.get(i), { ultimate: c } = po(h, r, n, g, o && !e, I);
    C.ultimate || (C.ultimate = c);
  }
  return o && e && n && r.push(`url(${n}${e})`), C;
}
function jc(t, A, e, i, a, s) {
  if (i.startsWith("InvalidPDFjsFont_")) return null;
  s !== "TrueType" && s !== "Type1" || !/^[A-Z]{6}\+/.test(i) || (i = i.slice(7));
  const r = i = sn(i);
  let n = t.get(r);
  if (n) return n;
  let g = Cs.get(i);
  if (!g) {
    for (const [Q, E] of qE) if (i.startsWith(Q)) {
      i = `${E}${i.substring(Q.length)}`, g = Cs.get(i);
      break;
    }
  }
  let o = !1;
  g || (g = Cs.get(a), o = !0);
  const I = `${A.getDocId()}_s${A.createFontId()}`;
  if (!g) {
    if (!_g(i))
      return G(`Cannot substitute the font because of its name: ${i}`), t.set(r, null), null;
    const Q = /bold/gi.test(i), E = /oblique|italic/gi.test(i), u = Q && E && xi || Q && Gi || E && Ni || Si;
    return n = { css: `"${Vc(i)}",${I}`, guessFallback: !0, loadedName: I, baseFontName: i, src: `local(${i})`, style: u }, t.set(r, n), n;
  }
  const C = [];
  o && _g(i) && C.push(`local(${i})`);
  const { style: h, ultimate: c } = po(g, C, e), B = c === null, l = B ? "" : `,${c}`;
  return n = { css: `"${Vc(i)}",${I}${l}`, guessFallback: B, loadedName: I, baseFontName: i, src: C.join(","), style: h }, t.set(r, n), n;
}
var $t, Xs, Hr, aC;
const ai = class ai {
  constructor(A, e) {
    MA(this, Hr);
    this._imgData = A, this._isMask = e;
  }
  static get canUseImageDecoder() {
    return sA(this, "canUseImageDecoder", NA(this, Xs) ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
  }
  static needsToBeResized(A, e) {
    if (A <= NA(this, $t) && e <= NA(this, $t)) return !1;
    const { MAX_DIM: i } = this;
    if (A > i || e > i) return !0;
    const a = A * e;
    return this._hasMaxArea ? a > this.MAX_AREA : a < NA(this, $t) ** 2 ? !1 : this._areGoodDims(A, e) ? (Vt(this, $t, Math.max(NA(this, $t), Math.floor(Math.sqrt(A * e)))), !1) : (Vt(this, $t, this._guessMax(NA(this, $t), i, 128, 0)), a > (this.MAX_AREA = NA(this, $t) ** 2));
  }
  static get MAX_DIM() {
    return sA(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
  }
  static get MAX_AREA() {
    return this._hasMaxArea = !0, sA(this, "MAX_AREA", this._guessMax(NA(this, $t), this.MAX_DIM, 128, 0) ** 2);
  }
  static set MAX_AREA(A) {
    A >= 0 && (this._hasMaxArea = !0, sA(this, "MAX_AREA", A));
  }
  static setOptions({ canvasMaxAreaInBytes: A = -1, isImageDecoderSupported: e = !1 }) {
    this._hasMaxArea || (this.MAX_AREA = A >> 2), Vt(this, Xs, e);
  }
  static _areGoodDims(A, e) {
    try {
      const i = new OffscreenCanvas(A, e), a = i.getContext("2d");
      a.fillRect(0, 0, 1, 1);
      const s = a.getImageData(0, 0, 1, 1).data[3];
      return i.width = i.height = 1, s !== 0;
    } catch {
      return !1;
    }
  }
  static _guessMax(A, e, i, a) {
    for (; A + i + 1 < e; ) {
      const s = Math.floor((A + e) / 2), r = a || s;
      this._areGoodDims(s, r) ? A = s : e = s;
    }
    return A;
  }
  static async createImage(A, e = !1) {
    return new ai(A, e)._createImage();
  }
  async _createImage() {
    const { _imgData: A } = this, { width: e, height: i } = A;
    if (e * i * 4 > Vg) {
      const u = CA(this, Hr, aC).call(this);
      if (u) return u;
    }
    const a = this._encodeBMP();
    let s, r;
    await ai.canUseImageDecoder ? (s = new ImageDecoder({ data: a, type: "image/bmp", preferAnimation: !1, transfer: [a.buffer] }), r = s.decode().catch((u) => (G(`BMP image decoding failed: ${u}`), createImageBitmap(new Blob([this._encodeBMP().buffer], { type: "image/bmp" })))).finally(() => {
      s.close();
    })) : r = createImageBitmap(new Blob([a.buffer], { type: "image/bmp" }));
    const { MAX_AREA: n, MAX_DIM: g } = ai, o = Math.max(e / g, i / g, Math.sqrt(e * i / n)), I = Math.max(o, 2), C = Math.round(10 * (o + 1.25)) / 10 / I, h = Math.floor(Math.log2(C)), c = new Array(h + 2).fill(2);
    c[0] = I, c.splice(-1, 1, C / (1 << h));
    let B = e, l = i;
    const Q = await r;
    let E = Q.image || Q;
    for (const u of c) {
      const f = B, d = l;
      B = Math.floor(B / u) - 1, l = Math.floor(l / u) - 1;
      const p = new OffscreenCanvas(B, l);
      p.getContext("2d").drawImage(E, 0, 0, f, d, 0, 0, B, l), E.close(), E = p.transferToImageBitmap();
    }
    return A.data = null, A.bitmap = E, A.width = B, A.height = l, A;
  }
  _encodeBMP() {
    const { width: A, height: e, kind: i } = this._imgData;
    let a, s = this._imgData.data, r = new Uint8Array(0), n = r, g = 0;
    switch (i) {
      case er: {
        a = 1, r = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const l = A + 7 >> 3, Q = l + 3 & -4;
        if (l !== Q) {
          const E = new Uint8Array(Q * e);
          let u = 0;
          for (let f = 0, d = e * l; f < d; f += l, u += Q) E.set(s.subarray(f, f + l), u);
          s = E;
        }
        break;
      }
      case os:
        if (a = 24, 3 & A) {
          const l = 3 * A, Q = l + 3 & -4, E = Q - l, u = new Uint8Array(Q * e);
          let f = 0;
          for (let d = 0, p = e * l; d < p; d += l) {
            const m = s.subarray(d, d + l);
            for (let y = 0; y < l; y += 3)
              u[f++] = m[y + 2], u[f++] = m[y + 1], u[f++] = m[y];
            f += E;
          }
          s = u;
        } else for (let l = 0, Q = s.length; l < Q; l += 3) {
          const E = s[l];
          s[l] = s[l + 2], s[l + 2] = E;
        }
        break;
      case Ue:
        a = 32, g = 3, n = new Uint8Array(68);
        const B = new DataView(n.buffer);
        Jt.isLittleEndian ? (B.setUint32(0, 255, !0), B.setUint32(4, 65280, !0), B.setUint32(8, 16711680, !0), B.setUint32(12, 4278190080, !0)) : (B.setUint32(0, 4278190080, !0), B.setUint32(4, 16711680, !0), B.setUint32(8, 65280, !0), B.setUint32(12, 255, !0));
        break;
      default:
        throw new Error("invalid format");
    }
    let o = 0;
    const I = 40 + n.length, C = 14 + I + r.length + s.length, h = new Uint8Array(C), c = new DataView(h.buffer);
    return c.setUint16(o, 19778, !0), o += 2, c.setUint32(o, C, !0), o += 4, c.setUint32(o, 0, !0), o += 4, c.setUint32(o, 14 + I + r.length, !0), o += 4, c.setUint32(o, I, !0), o += 4, c.setInt32(o, A, !0), o += 4, c.setInt32(o, -e, !0), o += 4, c.setUint16(o, 1, !0), o += 2, c.setUint16(o, a, !0), o += 2, c.setUint32(o, g, !0), o += 4, c.setUint32(o, 0, !0), o += 4, c.setInt32(o, 0, !0), o += 4, c.setInt32(o, 0, !0), o += 4, c.setUint32(o, r.length / 4, !0), o += 4, c.setUint32(o, 0, !0), o += 4, h.set(n, o), o += n.length, h.set(r, o), o += r.length, h.set(s, o), h;
  }
};
$t = new WeakMap(), Xs = new WeakMap(), Hr = new WeakSet(), aC = function() {
  const { _imgData: A } = this, { data: e, width: i, height: a, kind: s } = A, r = i * a * 4, n = Math.ceil(Math.log2(r / Vg)), g = i >> n, o = a >> n;
  let I, C = a;
  try {
    I = new Uint8Array(r);
  } catch {
    let f = Math.floor(Math.log2(r + 1));
    for (; ; ) try {
      I = new Uint8Array(2 ** f - 1);
      break;
    } catch {
      f -= 1;
    }
    C = Math.floor((2 ** f - 1) / (4 * i));
    const d = i * C * 4;
    d < I.length && (I = new Uint8Array(d));
  }
  const h = new Uint32Array(I.buffer), c = new Uint32Array(g * o);
  let B = 0, l = 0;
  const Q = Math.ceil(a / C), E = a % C == 0 ? a : a % C;
  for (let f = 0; f < Q; f++) {
    const d = f < Q - 1 ? C : E;
    ({ srcPos: B } = N1({ kind: s, src: e, dest: h, width: i, height: d, inverseDecode: this._isMask, srcPos: B }));
    for (let p = 0, m = d >> n; p < m; p++) {
      const y = h.subarray((p << n) * i);
      for (let b = 0; b < g; b++) c[l++] = y[b << n];
    }
  }
  if (ai.needsToBeResized(g, o))
    return A.data = c, A.width = g, A.height = o, A.kind = Ue, null;
  const u = new OffscreenCanvas(g, o);
  return u.getContext("2d", { willReadFrequently: !0 }).putImageData(new ImageData(new Uint8ClampedArray(c.buffer), g, o), 0, 0), A.data = null, A.bitmap = u.transferToImageBitmap(), A.width = g, A.height = o, A;
}, MA(ai, $t, 2048), MA(ai, Xs, Jt.isImageDecoderSupported);
let pe = ai;
const zc = 3285377520, zt = 4294901760, je = 65535;
class TE {
  constructor(A) {
    this.h1 = A ? 4294967295 & A : zc, this.h2 = A ? 4294967295 & A : zc;
  }
  update(A) {
    let e, i;
    if (typeof A == "string") {
      e = new Uint8Array(2 * A.length), i = 0;
      for (let l = 0, Q = A.length; l < Q; l++) {
        const E = A.charCodeAt(l);
        E <= 255 ? e[i++] = E : (e[i++] = E >>> 8, e[i++] = 255 & E);
      }
    } else {
      if (!ArrayBuffer.isView(A)) throw new Error("Invalid data format, must be a string or TypedArray.");
      e = A.slice(), i = e.byteLength;
    }
    const a = i >> 2, s = i - 4 * a, r = new Uint32Array(e.buffer, 0, a);
    let n = 0, g = 0, o = this.h1, I = this.h2;
    const C = 3432918353, h = 461845907, c = 11601, B = 13715;
    for (let l = 0; l < a; l++) 1 & l ? (n = r[l], n = n * C & zt | n * c & je, n = n << 15 | n >>> 17, n = n * h & zt | n * B & je, o ^= n, o = o << 13 | o >>> 19, o = 5 * o + 3864292196) : (g = r[l], g = g * C & zt | g * c & je, g = g << 15 | g >>> 17, g = g * h & zt | g * B & je, I ^= g, I = I << 13 | I >>> 19, I = 5 * I + 3864292196);
    switch (n = 0, s) {
      case 3:
        n ^= e[4 * a + 2] << 16;
      case 2:
        n ^= e[4 * a + 1] << 8;
      case 1:
        n ^= e[4 * a], n = n * C & zt | n * c & je, n = n << 15 | n >>> 17, n = n * h & zt | n * B & je, 1 & a ? o ^= n : I ^= n;
    }
    this.h1 = o, this.h2 = I;
  }
  hexdigest() {
    let A = this.h1, e = this.h2;
    return A ^= e >>> 1, A = 3981806797 * A & zt | 36045 * A & je, e = 4283543511 * e & zt | (2950163797 * (e << 16 | A >>> 16) & zt) >>> 16, A ^= e >>> 1, A = 444984403 * A & zt | 60499 * A & je, e = 3301882366 * e & zt | (3120437893 * (e << 16 | A >>> 16) & zt) >>> 16, A ^= e >>> 1, (A >>> 0).toString(16).padStart(8, "0") + (e >>> 0).toString(16).padStart(8, "0");
  }
}
function Vr(t, A, e, i, a) {
  let s = t;
  for (let r = 0, n = A.length - 1; r < n; r++) {
    const g = A[r];
    s = s[g] || (s[g] = []);
  }
  s[A.at(-1)] = { checkFn: e, iterateFn: i, processFn: a };
}
const Ua = [];
Vr(Ua, [Se, Qi, or, Wt], null, function(A, e) {
  const i = A.fnArray, a = (e - (A.iCurr - 3)) % 4;
  switch (a) {
    case 0:
      return i[e] === Se;
    case 1:
      return i[e] === Qi;
    case 2:
      return i[e] === or;
    case 3:
      return i[e] === Wt;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`);
}, function(A, e) {
  const i = A.fnArray, a = A.argsArray, s = A.iCurr, r = s - 3, n = s - 2, g = s - 1, o = Math.min(Math.floor((e - r) / 4), 200);
  if (o < 10) return e - (e - r) % 4;
  let I = 0;
  const C = [];
  let h = 0, c = 1, B = 1;
  for (let d = 0; d < o; d++) {
    const p = a[n + (d << 2)], m = a[g + (d << 2)][0];
    c + m.width > 1e3 && (I = Math.max(I, c), B += h + 2, c = 0, h = 0), C.push({ transform: p, x: c, y: B, w: m.width, h: m.height }), c += m.width + 2, h = Math.max(h, m.height);
  }
  const l = Math.max(I, c) + 1, Q = B + h + 1, E = new Uint8Array(l * Q * 4), u = l << 2;
  for (let d = 0; d < o; d++) {
    const p = a[g + (d << 2)][0].data, m = C[d].w << 2;
    let y = 0, b = C[d].x + C[d].y * l << 2;
    E.set(p.subarray(0, m), b - u);
    for (let D = 0, R = C[d].h; D < R; D++)
      E.set(p.subarray(y, y + m), b), y += m, b += u;
    for (E.set(p.subarray(y - m, y), b); b >= 0; )
      p[b - 4] = p[b], p[b - 3] = p[b + 1], p[b - 2] = p[b + 2], p[b - 1] = p[b + 3], p[b + m] = p[b + m - 4], p[b + m + 1] = p[b + m - 3], p[b + m + 2] = p[b + m - 2], p[b + m + 3] = p[b + m - 1], b -= u;
  }
  const f = { width: l, height: Q };
  if (A.isOffscreenCanvasSupported) {
    const d = new OffscreenCanvas(l, Q);
    d.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(E.buffer), l, Q), 0, 0), f.bitmap = d.transferToImageBitmap(), f.data = null;
  } else
    f.kind = Ue, f.data = E;
  return i.splice(r, 4 * o, o1), a.splice(r, 4 * o, [f, C]), r + 1;
});
Vr(Ua, [Se, Qi, oi, Wt], null, function(A, e) {
  const i = A.fnArray, a = (e - (A.iCurr - 3)) % 4;
  switch (a) {
    case 0:
      return i[e] === Se;
    case 1:
      return i[e] === Qi;
    case 2:
      return i[e] === oi;
    case 3:
      return i[e] === Wt;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`);
}, function(A, e) {
  const i = A.fnArray, a = A.argsArray, s = A.iCurr, r = s - 3, n = s - 2, g = s - 1;
  let o = Math.floor((e - r) / 4);
  if (o < 10) return e - (e - r) % 4;
  let I, C, h = !1;
  const c = a[g][0], B = a[n][0], l = a[n][1], Q = a[n][2], E = a[n][3];
  if (l === Q) {
    h = !0, I = n + 4;
    let u = g + 4;
    for (let f = 1; f < o; f++, I += 4, u += 4)
      if (C = a[I], a[u][0] !== c || C[0] !== B || C[1] !== l || C[2] !== Q || C[3] !== E) {
        f < 10 ? h = !1 : o = f;
        break;
      }
  }
  if (h) {
    o = Math.min(o, 1e3);
    const u = new Float32Array(2 * o);
    I = n;
    for (let f = 0; f < o; f++, I += 4)
      C = a[I], u[f << 1] = C[4], u[1 + (f << 1)] = C[5];
    i.splice(r, 4 * o, xB), a.splice(r, 4 * o, [c, B, l, Q, E, u]);
  } else {
    o = Math.min(o, 100);
    const u = [];
    for (let f = 0; f < o; f++) {
      C = a[n + (f << 2)];
      const d = a[g + (f << 2)][0];
      u.push({ data: d.data, width: d.width, height: d.height, interpolate: d.interpolate, count: d.count, transform: C });
    }
    i.splice(r, 4 * o, GB), a.splice(r, 4 * o, [u]);
  }
  return r + 1;
});
Vr(Ua, [Se, Qi, Ri, Wt], function(t) {
  const A = t.argsArray, e = t.iCurr - 2;
  return A[e][1] === 0 && A[e][2] === 0;
}, function(A, e) {
  const i = A.fnArray, a = A.argsArray, s = (e - (A.iCurr - 3)) % 4;
  switch (s) {
    case 0:
      return i[e] === Se;
    case 1:
      if (i[e] !== Qi) return !1;
      const r = A.iCurr - 2, n = a[r][0], g = a[r][3];
      return a[e][0] === n && a[e][1] === 0 && a[e][2] === 0 && a[e][3] === g;
    case 2:
      if (i[e] !== Ri) return !1;
      const o = a[A.iCurr - 1][0];
      return a[e][0] === o;
    case 3:
      return i[e] === Wt;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${s}`);
}, function(t, A) {
  const e = t.fnArray, i = t.argsArray, a = t.iCurr, s = a - 3, r = a - 2, n = i[a - 1][0], g = i[r][0], o = i[r][3], I = Math.min(Math.floor((A - s) / 4), 1e3);
  if (I < 3) return A - (A - s) % 4;
  const C = new Float32Array(2 * I);
  let h = r;
  for (let B = 0; B < I; B++, h += 4) {
    const l = i[h];
    C[B << 1] = l[4], C[1 + (B << 1)] = l[5];
  }
  const c = [n, g, o, C];
  return e.splice(s, 4 * I, NB), i.splice(s, 4 * I, c), s + 1;
});
Vr(Ua, [ps, li, ys, Je, ms], null, function(A, e) {
  const i = A.fnArray, a = A.argsArray, s = (e - (A.iCurr - 4)) % 5;
  switch (s) {
    case 0:
      return i[e] === ps;
    case 1:
      return i[e] === li;
    case 2:
      return i[e] === ys;
    case 3:
      if (i[e] !== Je) return !1;
      const r = A.iCurr - 3, n = a[r][0], g = a[r][1];
      return a[e][0] === n && a[e][1] === g;
    case 4:
      return i[e] === ms;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${s}`);
}, function(t, A) {
  const e = t.fnArray, i = t.argsArray, a = t.iCurr, s = a - 4, r = a - 3, n = a - 2, g = a - 1, o = a, I = i[r][0], C = i[r][1];
  let h = Math.min(Math.floor((A - s) / 5), 1e3);
  if (h < 3) return A - (A - s) % 5;
  let c = s;
  s >= 4 && e[s - 4] === e[r] && e[s - 3] === e[n] && e[s - 2] === e[g] && e[s - 1] === e[o] && i[s - 4][0] === I && i[s - 4][1] === C && (h++, c -= 5);
  let B = c + 4;
  for (let l = 1; l < h; l++)
    e.splice(B, 3), i.splice(B, 3), B += 2;
  return B + 1;
});
class sC {
  constructor(A) {
    this.queue = A;
  }
  _optimize() {
  }
  push(A, e) {
    this.queue.fnArray.push(A), this.queue.argsArray.push(e), this._optimize();
  }
  flush() {
  }
  reset() {
  }
}
class PE extends sC {
  constructor(A) {
    super(A), this.state = null, this.context = { iCurr: 0, fnArray: A.fnArray, argsArray: A.argsArray, isOffscreenCanvasSupported: !1 }, this.match = null, this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(A) {
    this.context.isOffscreenCanvasSupported = A;
  }
  _optimize() {
    const A = this.queue.fnArray;
    let e = this.lastProcessed, i = A.length, a = this.state, s = this.match;
    if (!a && !s && e + 1 === i && !Ua[A[e]]) {
      this.lastProcessed = i;
      return;
    }
    const r = this.context;
    for (; e < i; ) {
      if (s) {
        if ((0, s.iterateFn)(r, e)) {
          e++;
          continue;
        }
        if (e = (0, s.processFn)(r, e + 1), i = A.length, s = null, a = null, e >= i) break;
      }
      a = (a || Ua)[A[e]], a && !Array.isArray(a) ? (r.iCurr = e, e++, (!a.checkFn || (0, a.checkFn)(r)) && (s = a), a = null) : e++;
    }
    this.state = a, this.match = s, this.lastProcessed = e;
  }
  flush() {
    for (; this.match; ) {
      const A = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, A), this.match = null, this.state = null, this._optimize();
    }
  }
  reset() {
    this.state = null, this.match = null, this.lastProcessed = 0;
  }
}
const si = class si {
  constructor(A = 0, e) {
    this._streamSink = e, this.fnArray = [], this.argsArray = [], this.optimizer = !e || A & wh ? new sC(this) : new PE(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = e ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(A) {
    this.optimizer.isOffscreenCanvasSupported = A;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(A, e) {
    this.optimizer.push(A, e), this.weight++, this._streamSink && (this.weight >= si.CHUNK_SIZE || this.weight >= si.CHUNK_SIZE_ABOUT && (A === Wt || A === ms)) && this.flush();
  }
  addImageOps(A, e, i) {
    i !== void 0 && this.addOp(ye, ["OC", i]), this.addOp(A, e), i !== void 0 && this.addOp(Ra, []);
  }
  addDependency(A) {
    this.dependencies.has(A) || (this.dependencies.add(A), this.addOp(gB, [A]));
  }
  addDependencies(A) {
    for (const e of A) this.addDependency(e);
  }
  addOpList(A) {
    if (A instanceof si) {
      for (const e of A.dependencies) this.dependencies.add(e);
      for (let e = 0, i = A.length; e < i; e++) this.addOp(A.fnArray[e], A.argsArray[e]);
    } else G('addOpList - ignoring invalid "opList" parameter.');
  }
  getIR() {
    return { fnArray: this.fnArray, argsArray: this.argsArray, length: this.length };
  }
  get _transfers() {
    var s;
    const A = [], { fnArray: e, argsArray: i, length: a } = this;
    for (let r = 0; r < a; r++) switch (e[r]) {
      case or:
      case o1:
      case oi:
        const n = i[r][0];
        !n.cached && ((s = n.data) == null ? void 0 : s.buffer) instanceof ArrayBuffer && A.push(n.data.buffer);
    }
    return A;
  }
  flush(A = !1, e = null) {
    this.optimizer.flush();
    const i = this.length;
    this._totalLength += i, this._streamSink.enqueue({ fnArray: this.fnArray, argsArray: this.argsArray, lastChunk: A, separateAnnots: e, length: i }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
  }
};
Ft(si, "CHUNK_SIZE", 1e3), Ft(si, "CHUNK_SIZE_ABOUT", si.CHUNK_SIZE - 5);
let Lt = si;
function WE(t, A, e, i) {
  return (t = A + t * e) < 0 ? t = 0 : t > i && (t = i), t;
}
function _c(t, A, e, i, a, s) {
  const r = a * s;
  let n;
  n = A <= 8 ? new Uint8Array(r) : A <= 16 ? new Uint16Array(r) : new Uint32Array(r);
  const g = e / a, o = i / s;
  let I, C, h, c, B = 0;
  const l = new Uint16Array(a), Q = e;
  for (I = 0; I < a; I++) l[I] = Math.floor(I * g);
  for (I = 0; I < s; I++)
    for (h = Math.floor(I * o) * Q, C = 0; C < a; C++)
      c = h + l[C], n[B++] = t[c];
  return n;
}
var Vs, mo;
const Qa = class Qa {
  constructor({ xref: A, res: e, image: i, isInline: a = !1, smask: s = null, mask: r = null, isMask: n = !1, pdfFunctionFactory: g, localColorSpaceCache: o }) {
    MA(this, Vs);
    var Q, E;
    this.image = i;
    const I = i.dict, C = I.get("F", "Filter");
    let h;
    if (C instanceof T) h = C.name;
    else if (Array.isArray(C)) {
      const u = A.fetchIfRef(C[0]);
      u instanceof T && (h = u.name);
    }
    switch (h) {
      case "JPXDecode":
        ({ width: i.width, height: i.height, componentsCount: i.numComps, bitsPerComponent: i.bitsPerComponent } = Or.parseImageProperties(i.stream)), i.stream.reset(), this.jpxDecoderOptions = { numComponents: 0, isIndexedColormap: !1, smaskInData: I.has("SMaskInData") };
        break;
      case "JBIG2Decode":
        i.bitsPerComponent = 1, i.numComps = 1;
    }
    let c = I.get("W", "Width"), B = I.get("H", "Height");
    if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== c || i.height !== B) && (G("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), c = i.width, B = i.height), c < 1 || B < 1) throw new X(`Invalid image width: ${c} or height: ${B}`);
    this.width = c, this.height = B, this.interpolate = I.get("I", "Interpolate"), this.imageMask = I.get("IM", "ImageMask") || !1, this.matte = I.get("Matte") || !1;
    let l = i.bitsPerComponent;
    if (!l && (l = I.get("BPC", "BitsPerComponent"), !l)) {
      if (!this.imageMask) throw new X(`Bits per component missing in image: ${this.imageMask}`);
      l = 1;
    }
    if (this.bpc = l, !this.imageMask) {
      let u = I.getRaw("CS") || I.getRaw("ColorSpace");
      const f = !!u;
      if (f) (Q = this.jpxDecoderOptions) != null && Q.smaskInData && (u = T.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions) u = T.get("DeviceRGBA");
      else switch (i.numComps) {
        case 1:
          u = T.get("DeviceGray");
          break;
        case 3:
          u = T.get("DeviceRGB");
          break;
        case 4:
          u = T.get("DeviceCMYK");
          break;
        default:
          throw new Error(`Images with ${i.numComps} color components not supported.`);
      }
      this.colorSpace = kA.parse({ cs: u, xref: A, resources: a ? e : null, pdfFunctionFactory: g, localColorSpaceCache: o }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = f ? this.numComp : 0, this.jpxDecoderOptions.isIndexedColormap = this.colorSpace.name === "Indexed");
    }
    if (this.decode = I.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, l) || n && !kA.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = !0;
      const u = (1 << l) - 1;
      this.decodeCoefficients = [], this.decodeAddends = [];
      const f = ((E = this.colorSpace) == null ? void 0 : E.name) === "Indexed";
      for (let d = 0, p = 0; d < this.decode.length; d += 2, ++p) {
        const m = this.decode[d], y = this.decode[d + 1];
        this.decodeCoefficients[p] = f ? (y - m) / u : y - m, this.decodeAddends[p] = f ? m : u * m;
      }
    }
    s ? this.smask = new Qa({ xref: A, res: e, image: s, isInline: a, pdfFunctionFactory: g, localColorSpaceCache: o }) : r && (r instanceof FA ? r.dict.get("IM", "ImageMask") ? this.mask = new Qa({ xref: A, res: e, image: r, isInline: a, isMask: !0, pdfFunctionFactory: g, localColorSpaceCache: o }) : G("Ignoring /Mask in image without /ImageMask.") : this.mask = r);
  }
  static async buildImage({ xref: A, res: e, image: i, isInline: a = !1, pdfFunctionFactory: s, localColorSpaceCache: r }) {
    const n = i;
    let g = null, o = null;
    const I = i.dict.get("SMask"), C = i.dict.get("Mask");
    return I ? I instanceof FA ? g = I : G("Unsupported /SMask format.") : C && (C instanceof FA || Array.isArray(C) ? o = C : G("Unsupported /Mask format.")), new Qa({ xref: A, res: e, image: n, isInline: a, smask: g, mask: o, pdfFunctionFactory: s, localColorSpaceCache: r });
  }
  static createRawMask({ imgArray: A, width: e, height: i, imageIsFromDecodeStream: a, inverseDecode: s, interpolate: r }) {
    const n = (e + 7 >> 3) * i, g = A.byteLength;
    let o, I;
    if (!a || s && n !== g ? s ? (o = new Uint8Array(n), o.set(A), o.fill(255, g)) : o = new Uint8Array(A) : o = A, s) for (I = 0; I < g; I++) o[I] ^= 255;
    return { data: o, width: e, height: i, interpolate: r };
  }
  static async createMask({ imgArray: A, width: e, height: i, imageIsFromDecodeStream: a, inverseDecode: s, interpolate: r, isOffscreenCanvasSupported: n = !1 }) {
    const g = e === 1 && i === 1 && s === (A.length === 0 || !!(128 & A[0]));
    if (g) return { isSingleOpaquePixel: g };
    if (n) {
      if (pe.needsToBeResized(e, i)) {
        const h = new Uint8ClampedArray(e * i * 4);
        return no({ src: A, dest: h, width: e, height: i, nonBlackColor: 0, inverseDecode: s }), pe.createImage({ kind: Ue, data: h, width: e, height: i, interpolate: r });
      }
      const o = new OffscreenCanvas(e, i), I = o.getContext("2d"), C = I.createImageData(e, i);
      return no({ src: A, dest: C.data, width: e, height: i, nonBlackColor: 0, inverseDecode: s }), I.putImageData(C, 0, 0), { data: null, width: e, height: i, interpolate: r, bitmap: o.transferToImageBitmap() };
    }
    return this.createRawMask({ imgArray: A, width: e, height: i, inverseDecode: s, imageIsFromDecodeStream: a, interpolate: r });
  }
  get drawWidth() {
    var A, e;
    return Math.max(this.width, ((A = this.smask) == null ? void 0 : A.width) || 0, ((e = this.mask) == null ? void 0 : e.width) || 0);
  }
  get drawHeight() {
    var A, e;
    return Math.max(this.height, ((A = this.smask) == null ? void 0 : A.height) || 0, ((e = this.mask) == null ? void 0 : e.height) || 0);
  }
  decodeBuffer(A) {
    const e = this.bpc, i = this.numComps, a = this.decodeAddends, s = this.decodeCoefficients, r = (1 << e) - 1;
    let n, g;
    if (e === 1) {
      for (n = 0, g = A.length; n < g; n++) A[n] = +!A[n];
      return;
    }
    let o = 0;
    for (n = 0, g = this.width * this.height; n < g; n++) for (let I = 0; I < i; I++)
      A[o] = WE(A[o], a[I], s[I], r), o++;
  }
  getComponents(A) {
    const e = this.bpc;
    if (e === 8) return A;
    const i = this.width, a = this.height, s = this.numComps, r = i * a * s;
    let n, g = 0;
    n = e <= 8 ? new Uint8Array(r) : e <= 16 ? new Uint16Array(r) : new Uint32Array(r);
    const o = i * s, I = (1 << e) - 1;
    let C, h, c = 0;
    if (e === 1) {
      let B, l, Q;
      for (let E = 0; E < a; E++) {
        for (l = c + (-8 & o), Q = c + o; c < l; )
          h = A[g++], n[c] = h >> 7 & 1, n[c + 1] = h >> 6 & 1, n[c + 2] = h >> 5 & 1, n[c + 3] = h >> 4 & 1, n[c + 4] = h >> 3 & 1, n[c + 5] = h >> 2 & 1, n[c + 6] = h >> 1 & 1, n[c + 7] = 1 & h, c += 8;
        if (c < Q)
          for (h = A[g++], B = 128; c < Q; )
            n[c++] = +!!(h & B), B >>= 1;
      }
    } else {
      let B = 0;
      for (h = 0, c = 0, C = r; c < C; ++c) {
        for (c % o == 0 && (h = 0, B = 0); B < e; )
          h = h << 8 | A[g++], B += 8;
        const l = B - e;
        let Q = h >> l;
        Q < 0 ? Q = 0 : Q > I && (Q = I), n[c] = Q, h &= (1 << l) - 1, B = l;
      }
    }
    return n;
  }
  async fillOpacity(A, e, i, a, s) {
    const r = this.smask, n = this.mask;
    let g, o, I, C, h, c;
    if (r)
      o = r.width, I = r.height, g = new Uint8ClampedArray(o * I), await r.fillGrayBuffer(g), o === e && I === i || (g = _c(g, r.bpc, o, I, e, i));
    else if (n) if (n instanceof Qa) {
      for (o = n.width, I = n.height, g = new Uint8ClampedArray(o * I), n.numComps = 1, await n.fillGrayBuffer(g), C = 0, h = o * I; C < h; ++C) g[C] = 255 - g[C];
      o === e && I === i || (g = _c(g, n.bpc, o, I, e, i));
    } else {
      if (!Array.isArray(n)) throw new X("Unknown mask format.");
      {
        g = new Uint8ClampedArray(e * i);
        const B = this.numComps;
        for (C = 0, h = e * i; C < h; ++C) {
          let l = 0;
          const Q = C * B;
          for (c = 0; c < B; ++c) {
            const E = s[Q + c], u = 2 * c;
            if (E < n[u] || E > n[u + 1]) {
              l = 255;
              break;
            }
          }
          g[C] = l;
        }
      }
    }
    if (g) for (C = 0, c = 3, h = e * a; C < h; ++C, c += 4) A[c] = g[C];
    else for (C = 0, c = 3, h = e * a; C < h; ++C, c += 4) A[c] = 255;
  }
  undoPreblend(A, e, i) {
    var I;
    const a = (I = this.smask) == null ? void 0 : I.matte;
    if (!a) return;
    const s = this.colorSpace.getRgb(a, 0), r = s[0], n = s[1], g = s[2], o = e * i * 4;
    for (let C = 0; C < o; C += 4) {
      const h = A[C + 3];
      if (h === 0) {
        A[C] = 255, A[C + 1] = 255, A[C + 2] = 255;
        continue;
      }
      const c = 255 / h;
      A[C] = (A[C] - r) * c + r, A[C + 1] = (A[C + 1] - n) * c + n, A[C + 2] = (A[C + 2] - g) * c + g;
    }
  }
  async createImageData(A = !1, e = !1) {
    const i = this.drawWidth, a = this.drawHeight, s = { width: i, height: a, interpolate: this.interpolate, kind: 0, data: null }, r = this.numComps, n = this.width, g = this.height, o = this.bpc, I = n * r * o + 7 >> 3, C = e && pe.needsToBeResized(i, a);
    if (!this.smask && !this.mask && this.colorSpace.name === "DeviceRGBA") {
      s.kind = Ue;
      const p = s.data = await this.getImageBytes(g * n * 4, {});
      return e ? C ? pe.createImage(s, !1) : this.createBitmap(Ue, i, a, p) : s;
    }
    if (!A) {
      let p;
      if (this.colorSpace.name === "DeviceGray" && o === 1 ? p = er : this.colorSpace.name !== "DeviceRGB" || o !== 8 || this.needsDecode || (p = os), p && !this.smask && !this.mask && i === n && a === g) {
        const m = await CA(this, Vs, mo).call(this, n, g);
        if (m) return m;
        const y = await this.getImageBytes(g * I, {});
        if (e) return C ? pe.createImage({ data: y, kind: p, width: i, height: a, interpolate: this.interpolate }, this.needsDecode) : this.createBitmap(p, n, g, y);
        if (s.kind = p, s.data = y, this.needsDecode) {
          Rt(p === er, "PDFImage.createImageData: The image must be grayscale.");
          const b = s.data;
          for (let D = 0, R = b.length; D < R; D++) b[D] ^= 255;
        }
        return s;
      }
      if (this.image instanceof Na && !this.smask && !this.mask && !this.needsDecode) {
        let m = g * I;
        if (e && !C) {
          let y = !1;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              m *= 4, y = !0;
              break;
            case "DeviceRGB":
              m = m / 3 * 4, y = !0;
              break;
            case "DeviceCMYK":
              y = !0;
          }
          if (y) {
            const b = await CA(this, Vs, mo).call(this, i, a);
            if (b) return b;
            const D = await this.getImageBytes(m, { drawWidth: i, drawHeight: a, forceRGBA: !0 });
            return this.createBitmap(Ue, i, a, D);
          }
        } else switch (this.colorSpace.name) {
          case "DeviceGray":
            m *= 3;
          case "DeviceRGB":
          case "DeviceCMYK":
            return s.kind = os, s.data = await this.getImageBytes(m, { drawWidth: i, drawHeight: a, forceRGB: !0 }), C ? pe.createImage(s) : s;
        }
      }
    }
    const h = await this.getImageBytes(g * I, { internal: !0 }), c = 0 | h.length / I * a / g, B = this.getComponents(h);
    let l, Q, E, u, f, d;
    return e && !C && (E = new OffscreenCanvas(i, a), u = E.getContext("2d"), f = u.createImageData(i, a), d = f.data), s.kind = Ue, A || this.smask || this.mask ? (e && !C || (d = new Uint8ClampedArray(i * a * 4)), l = 1, Q = !0, await this.fillOpacity(d, i, a, c, B)) : (!e || C ? (s.kind = os, d = new Uint8ClampedArray(i * a * 3), l = 0) : (new Uint32Array(d.buffer).fill(Jt.isLittleEndian ? 4278190080 : 255), l = 1), Q = !1), this.needsDecode && this.decodeBuffer(B), this.colorSpace.fillRgb(d, n, g, i, a, c, o, B, l), Q && this.undoPreblend(d, i, c), e && !C ? (u.putImageData(f, 0, 0), { data: null, width: i, height: a, bitmap: E.transferToImageBitmap(), interpolate: this.interpolate }) : (s.data = d, C ? pe.createImage(s) : s);
  }
  async fillGrayBuffer(A) {
    const e = this.numComps;
    if (e !== 1) throw new X(`Reading gray scale from a color image: ${e}`);
    const i = this.width, a = this.height, s = this.bpc, r = i * e * s + 7 >> 3, n = await this.getImageBytes(a * r, { internal: !0 }), g = this.getComponents(n);
    let o, I;
    if (s === 1) {
      if (I = i * a, this.needsDecode) for (o = 0; o < I; ++o) A[o] = g[o] - 1 & 255;
      else for (o = 0; o < I; ++o) A[o] = 255 & -g[o];
      return;
    }
    this.needsDecode && this.decodeBuffer(g), I = i * a;
    const C = 255 / ((1 << s) - 1);
    for (o = 0; o < I; ++o) A[o] = C * g[o];
  }
  createBitmap(A, e, i, a) {
    const s = new OffscreenCanvas(e, i), r = s.getContext("2d");
    let n;
    return A === Ue ? n = new ImageData(a, e, i) : (n = r.createImageData(e, i), N1({ kind: A, src: a, dest: new Uint32Array(n.data.buffer), width: e, height: i, inverseDecode: this.needsDecode })), r.putImageData(n, 0, 0), { data: null, width: e, height: i, bitmap: s.transferToImageBitmap(), interpolate: this.interpolate };
  }
  async getImageBytes(A, { drawWidth: e, drawHeight: i, forceRGBA: a = !1, forceRGB: s = !1, internal: r = !1 }) {
    this.image.reset(), this.image.drawWidth = e || this.width, this.image.drawHeight = i || this.height, this.image.forceRGBA = !!a, this.image.forceRGB = !!s;
    const n = await this.image.getImageData(A, this.jpxDecoderOptions);
    return r || this.image instanceof Dt ? n : (Rt(n instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(n));
  }
};
Vs = new WeakSet(), mo = async function(A, e) {
  const i = await this.image.getTransferableImage();
  return i ? { data: null, width: A, height: e, bitmap: i, interpolate: this.interpolate } : null;
};
let Ca = Qa;
const nC = Object.freeze({ maxImageSize: -1, disableFontFace: !1, ignoreErrors: !1, isEvalSupported: !0, isOffscreenCanvasSupported: !1, isImageDecoderSupported: !1, canvasMaxAreaInBytes: -1, fontExtraProperties: !1, useSystemFonts: !0, cMapUrl: null, standardFontDataUrl: null }), ZE = 1, OE = 2, $c = Promise.resolve();
function rC(t, A = !1) {
  if (Array.isArray(t)) {
    for (const e of t) {
      const i = rC(e, !0);
      if (i) return i;
    }
    return G(`Unsupported blend mode Array: ${t}`), "source-over";
  }
  if (!(t instanceof T)) return A ? null : "source-over";
  switch (t.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return A ? null : (G(`Unsupported blend mode: ${t.name}`), "source-over");
}
function Sg(t, A) {
  var e;
  A.objId && t.addDependency(A.objId), t.addImageOps(A.fn, A.args, A.optionalContent), A.fn === oi && ((e = A.args[0]) == null ? void 0 : e.count) > 0 && A.args[0].count++;
}
const Ea = class Ea {
  constructor() {
    this.reset();
  }
  check() {
    return ++this.checked < Ea.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
  }
  reset() {
    this.endTime = Date.now() + Ea.TIME_SLOT_DURATION_MS, this.checked = 0;
  }
};
Ft(Ea, "TIME_SLOT_DURATION_MS", 20), Ft(Ea, "CHECK_TIME_EVERY", 100);
let fr = Ea;
var js, yo;
const Yr = class Yr {
  constructor({ xref: A, handler: e, pageIndex: i, idFactory: a, fontCache: s, builtInCMapCache: r, standardFontDataCache: n, globalImageCache: g, systemFontCache: o, options: I = null }) {
    MA(this, js);
    this.xref = A, this.handler = e, this.pageIndex = i, this.idFactory = a, this.fontCache = s, this.builtInCMapCache = r, this.standardFontDataCache = n, this.globalImageCache = g, this.systemFontCache = o, this.options = I || nC, this.type3FontRefs = null, this._regionalImageCache = new FE(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), pe.setOptions(this.options), Na.setOptions(this.options);
  }
  get _pdfFunctionFactory() {
    return sA(this, "_pdfFunctionFactory", new eC({ xref: this.xref, isEvalSupported: this.options.isEvalSupported }));
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(A = null) {
    const e = Object.create(this);
    return e.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, A), e;
  }
  hasBlendModes(A, e) {
    if (!(A instanceof U) || A.objId && e.has(A.objId)) return !1;
    const i = new Bt(e);
    A.objId && i.put(A.objId);
    const a = [A], s = this.xref;
    for (; a.length; ) {
      const r = a.shift(), n = r.get("ExtGState");
      if (n instanceof U) for (let o of n.getRawValues()) {
        if (o instanceof rA) {
          if (i.has(o)) continue;
          try {
            o = s.fetch(o);
          } catch (C) {
            i.put(o), RA(`hasBlendModes - ignoring ExtGState: "${C}".`);
            continue;
          }
        }
        if (!(o instanceof U)) continue;
        o.objId && i.put(o.objId);
        const I = o.get("BM");
        if (I instanceof T) {
          if (I.name !== "Normal") return !0;
        } else if (I !== void 0 && Array.isArray(I)) {
          for (const C of I) if (C instanceof T && C.name !== "Normal") return !0;
        }
      }
      const g = r.get("XObject");
      if (g instanceof U) for (let o of g.getRawValues()) {
        if (o instanceof rA) {
          if (i.has(o)) continue;
          try {
            o = s.fetch(o);
          } catch (C) {
            i.put(o), RA(`hasBlendModes - ignoring XObject: "${C}".`);
            continue;
          }
        }
        if (!(o instanceof FA)) continue;
        o.dict.objId && i.put(o.dict.objId);
        const I = o.dict.get("Resources");
        I instanceof U && (!I.objId || !i.has(I.objId)) && (a.push(I), I.objId && i.put(I.objId));
      }
    }
    for (const r of i) e.put(r);
    return !1;
  }
  async fetchBuiltInCMap(A) {
    const e = this.builtInCMapCache.get(A);
    if (e) return e;
    let i;
    return this.options.cMapUrl !== null ? i = { cMapData: await CA(this, js, yo).call(this, `${this.options.cMapUrl}${A}.bcmap`), isCompressed: !0 } : i = await this.handler.sendWithPromise("FetchBuiltInCMap", { name: A }), this.builtInCMapCache.set(A, i), i;
  }
  async fetchStandardFontData(A) {
    const e = this.standardFontDataCache.get(A);
    if (e) return new At(e);
    if (this.options.useSystemFonts && A !== "Symbol" && A !== "ZapfDingbats") return null;
    const i = CQ()[A];
    let a;
    try {
      a = this.options.standardFontDataUrl !== null ? await CA(this, js, yo).call(this, `${this.options.standardFontDataUrl}${i}`) : await this.handler.sendWithPromise("FetchStandardFontData", { filename: i });
    } catch (s) {
      return G(s), null;
    }
    return this.standardFontDataCache.set(A, a), new At(a);
  }
  async buildFormXObject(A, e, i, a, s, r, n) {
    const g = e.dict, o = ci(g.getArray("Matrix"), null), I = be(g.getArray("BBox"), null);
    let C, h;
    g.has("OC") && (C = await this.parseMarkedContentProps(g.get("OC"), A)), C !== void 0 && a.addOp(ye, ["OC", C]);
    const c = g.get("Group");
    if (c) {
      h = { matrix: o, bbox: I, smask: i, isolated: !1, knockout: !1 };
      let l = null;
      if (it(c.get("S"), "Transparency") && (h.isolated = c.get("I") || !1, h.knockout = c.get("K") || !1, c.has("CS"))) {
        const Q = c.getRaw("CS");
        l = kA.getCached(Q, this.xref, n) || await this.parseColorSpace({ cs: Q, resources: A, localColorSpaceCache: n });
      }
      i != null && i.backdrop && (l || (l = kA.singletons.rgb), i.backdrop = l.getRgb(i.backdrop, 0)), a.addOp(SB, [h]);
    }
    const B = c ? [o, null] : [o, I];
    a.addOp(kB, B), await this.getOperatorList({ stream: e, task: s, resources: g.get("Resources") || A, operatorList: a, initialState: r }), a.addOp(FB, []), c && a.addOp(RB, [h]), C !== void 0 && a.addOp(Ra, []);
  }
  _sendImgData(A, e, i = !1) {
    const a = e ? [e.bitmap || e.data.buffer] : null;
    return this.parsingType3Font || i ? this.handler.send("commonobj", [A, "Image", e], a) : this.handler.send("obj", [A, this.pageIndex, "Image", e], a);
  }
  async buildPaintImageXObject({ resources: A, image: e, isInline: i = !1, operatorList: a, cacheKey: s, localImageCache: r, localColorSpaceCache: n }) {
    const g = e.dict, o = g.objId, I = g.get("W", "Width"), C = g.get("H", "Height");
    if (!I || typeof I != "number" || !C || typeof C != "number") {
      G("Image dimensions are missing, or not numbers.");
      return;
    }
    const h = this.options.maxImageSize;
    if (h !== -1 && I * C > h) {
      const u = "Image exceeded maximum allowed size and was removed.";
      if (this.options.ignoreErrors) {
        G(u);
        return;
      }
      throw new Error(u);
    }
    let c;
    g.has("OC") && (c = await this.parseMarkedContentProps(g.get("OC"), A));
    let B, l;
    if (g.get("IM", "ImageMask")) {
      const u = g.get("I", "Interpolate"), f = I + 7 >> 3, d = e.getBytes(f * C), p = g.getArray("D", "Decode");
      if (this.parsingType3Font) {
        if (B = Ca.createRawMask({ imgArray: d, width: I, height: C, imageIsFromDecodeStream: e instanceof Dt, inverseDecode: (p == null ? void 0 : p[0]) > 0, interpolate: u }), B.cached = !!s, l = [B], a.addImageOps(oi, l, c), s) {
          const y = { fn: oi, args: l, optionalContent: c };
          r.set(s, o, y), o && this._regionalImageCache.set(null, o, y);
        }
        return;
      }
      if (B = await Ca.createMask({ imgArray: d, width: I, height: C, imageIsFromDecodeStream: e instanceof Dt, inverseDecode: (p == null ? void 0 : p[0]) > 0, interpolate: u, isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported }), B.isSingleOpaquePixel) {
        if (a.addImageOps(VI, [], c), s) {
          const y = { fn: VI, args: [], optionalContent: c };
          r.set(s, o, y), o && this._regionalImageCache.set(null, o, y);
        }
        return;
      }
      const m = `mask_${this.idFactory.createObjId()}`;
      if (a.addDependency(m), B.dataLen = B.bitmap ? B.width * B.height * 4 : B.data.length, this._sendImgData(m, B), l = [{ data: m, width: B.width, height: B.height, interpolate: B.interpolate, count: 1 }], a.addImageOps(oi, l, c), s) {
        const y = { objId: m, fn: oi, args: l, optionalContent: c };
        r.set(s, o, y), o && this._regionalImageCache.set(null, o, y);
      }
      return;
    }
    if (i && I + C < 200 && !g.has("SMask") && !g.has("Mask")) {
      try {
        B = await new Ca({ xref: this.xref, res: A, image: e, isInline: i, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n }).createImageData(!0, !1), a.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, a.addImageOps(or, [B], c);
      } catch (u) {
        const f = `Unable to decode inline image: "${u}".`;
        if (!this.options.ignoreErrors) throw new Error(f);
        G(f);
      }
      return;
    }
    let Q = `img_${this.idFactory.createObjId()}`, E = !1;
    if (this.parsingType3Font ? Q = `${this.idFactory.getDocId()}_type3_${Q}` : s && o && (E = this.globalImageCache.shouldCache(o, this.pageIndex), E && (Rt(!i, "Cannot cache an inline image globally."), Q = `${this.idFactory.getDocId()}_${Q}`)), a.addDependency(Q), l = [Q, I, C], a.addImageOps(Ri, l, c), E) {
      if (this.globalImageCache.hasDecodeFailed(o)) {
        this.globalImageCache.setData(o, { objId: Q, fn: Ri, args: l, optionalContent: c, byteSize: 0 }), this._sendImgData(Q, null, E);
        return;
      }
      if (I * C > 25e4 || g.has("SMask") || g.has("Mask")) {
        const u = await this.handler.sendWithPromise("commonobj", [Q, "CopyLocalImage", { imageRef: o }]);
        if (u) {
          this.globalImageCache.setData(o, { objId: Q, fn: Ri, args: l, optionalContent: c, byteSize: 0 }), this.globalImageCache.addByteSize(o, u);
          return;
        }
      }
    }
    if (Ca.buildImage({ xref: this.xref, res: A, image: e, isInline: i, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: n }).then(async (u) => (B = await u.createImageData(!1, this.options.isOffscreenCanvasSupported), B.dataLen = B.bitmap ? B.width * B.height * 4 : B.data.length, B.ref = o, E && this.globalImageCache.addByteSize(o, B.dataLen), this._sendImgData(Q, B, E))).catch((u) => (G(`Unable to decode image "${Q}": "${u}".`), o && this.globalImageCache.addDecodeFailed(o), this._sendImgData(Q, null, E))), s) {
      const u = { objId: Q, fn: Ri, args: l, optionalContent: c };
      r.set(s, o, u), o && (this._regionalImageCache.set(null, o, u), E && this.globalImageCache.setData(o, { objId: Q, fn: Ri, args: l, optionalContent: c, byteSize: 0 }));
    }
  }
  handleSMask(A, e, i, a, s, r) {
    const n = A.get("G"), g = { subtype: A.get("S").name, backdrop: A.get("BC") }, o = A.get("TR");
    if (kg(o)) {
      const I = this._pdfFunctionFactory.create(o), C = new Uint8Array(256), h = new Float32Array(1);
      for (let c = 0; c < 256; c++)
        h[0] = c / 255, I(h, 0, h, 0), C[c] = 255 * h[0] | 0;
      g.transferMap = C;
    }
    return this.buildFormXObject(e, n, g, i, a, s.state.clone(), r);
  }
  handleTransferFunction(A) {
    let e;
    if (Array.isArray(A)) e = A;
    else {
      if (!kg(A)) return null;
      e = [A];
    }
    const i = [];
    let a = 0, s = 0;
    for (const r of e) {
      const n = this.xref.fetchIfRef(r);
      if (a++, it(n, "Identity")) {
        i.push(null);
        continue;
      }
      if (!kg(n)) return null;
      const g = this._pdfFunctionFactory.create(n), o = new Uint8Array(256), I = new Float32Array(1);
      for (let C = 0; C < 256; C++)
        I[0] = C / 255, g(I, 0, I, 0), o[C] = 255 * I[0] | 0;
      i.push(o), s++;
    }
    return a !== 1 && a !== 4 || s === 0 ? null : i;
  }
  handleTilingType(A, e, i, a, s, r, n, g) {
    const o = new Lt(), I = U.merge({ xref: this.xref, dictArray: [s.get("Resources"), i] });
    return this.getOperatorList({ stream: a, task: n, resources: I, operatorList: o }).then(function() {
      const C = o.getIR(), h = vc(C, s, e);
      r.addDependencies(o.dependencies), r.addOp(A, h), s.objId && g.set(null, s.objId, { operatorListIR: C, dict: s });
    }).catch((C) => {
      if (!(C instanceof pt)) {
        if (!this.options.ignoreErrors) throw C;
        G(`handleTilingType - ignoring pattern: "${C}".`);
      }
    });
  }
  async handleSetFont(A, e, i, a, s, r, n = null, g = null) {
    const o = (e == null ? void 0 : e[0]) instanceof T ? e[0].name : null;
    let I = await this.loadFont(o, i, A, n, g);
    if (I.font.isType3Font) try {
      await I.loadType3Data(this, A, s), a.addDependencies(I.type3Dependencies);
    } catch (C) {
      I = new Dn({ loadedName: "g_font_error", font: new bg(`Type3 font load error: ${C}`), dict: I.font, evaluatorOptions: this.options });
    }
    return r.font = I.font, I.send(this.handler), I.loadedName;
  }
  handleText(A, e) {
    const i = e.font, a = i.charsToGlyphs(A);
    return i.data && (e.textRenderingMode & bh || e.fillColorSpace.name === "Pattern" || i.disableFontFace || this.options.disableFontFace) && Yr.buildFontPaths(i, a, this.handler, this.options), a;
  }
  ensureStateFont(A) {
    if (A.font) return;
    const e = new X("Missing setFont (Tf) operator before text rendering operator.");
    if (!this.options.ignoreErrors) throw e;
    G(`ensureStateFont: "${e}".`);
  }
  async setGState({ resources: A, gState: e, operatorList: i, cacheKey: a, task: s, stateManager: r, localGStateCache: n, localColorSpaceCache: g }) {
    const o = e.objId;
    let I = !0;
    const C = [];
    let h = Promise.resolve();
    for (const c of e.getKeys()) {
      const B = e.get(c);
      switch (c) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          C.push([c, B]);
          break;
        case "Font":
          I = !1, h = h.then(() => this.handleSetFont(A, null, B[0], i, s, r.state).then(function(Q) {
            i.addDependency(Q), C.push([c, [Q, B[1]]]);
          }));
          break;
        case "BM":
          C.push([c, rC(B)]);
          break;
        case "SMask":
          if (it(B, "None")) {
            C.push([c, !1]);
            break;
          }
          B instanceof U ? (I = !1, h = h.then(() => this.handleSMask(B, A, i, s, r, g)), C.push([c, !0])) : G("Unsupported SMask type");
          break;
        case "TR":
          const l = this.handleTransferFunction(B);
          C.push([c, l]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          RA("graphic state operator " + c);
          break;
        default:
          RA("Unknown graphic state operator " + c);
      }
    }
    await h, C.length > 0 && i.addOp(ca, [C]), I && n.set(a, o, C);
  }
  loadFont(A, e, i, a = null, s = null) {
    var l;
    const r = async () => new Dn({ loadedName: "g_font_error", font: new bg(`Font "${A}" is not available.`), dict: e, evaluatorOptions: this.options });
    let n;
    if (e) e instanceof rA && (n = e);
    else {
      const Q = i.get("Font");
      Q && (n = Q.getRaw(A));
    }
    if (n) {
      if ((l = this.type3FontRefs) != null && l.has(n)) return r();
      if (this.fontCache.has(n)) return this.fontCache.get(n);
      try {
        e = this.xref.fetchIfRef(n);
      } catch (Q) {
        G(`loadFont - lookup failed: "${Q}".`);
      }
    }
    if (!(e instanceof U)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font)
        return G(`Font "${A}" is not available.`), r();
      G(`Font "${A}" is not available -- attempting to fallback to a default font.`), e = a || Yr.fallbackFontDict;
    }
    if (e.cacheKey && this.fontCache.has(e.cacheKey)) return this.fontCache.get(e.cacheKey);
    const { promise: g, resolve: o } = Promise.withResolvers();
    let I;
    try {
      I = this.preEvaluateFont(e), I.cssFontInfo = s;
    } catch (Q) {
      return G(`loadFont - preEvaluateFont failed: "${Q}".`), r();
    }
    const { descriptor: C, hash: h } = I, c = n instanceof rA;
    let B;
    if (h && C instanceof U) {
      const Q = C.fontAliases || (C.fontAliases = /* @__PURE__ */ Object.create(null));
      if (Q[h]) {
        const E = Q[h].aliasRef;
        if (c && E && this.fontCache.has(E))
          return this.fontCache.putAlias(n, E), this.fontCache.get(n);
      } else Q[h] = { fontID: this.idFactory.createFontId() };
      c && (Q[h].aliasRef = n), B = Q[h].fontID;
    } else B = this.idFactory.createFontId();
    return Rt(B == null ? void 0 : B.startsWith("f"), 'The "fontID" must be (correctly) defined.'), c ? this.fontCache.put(n, g) : (e.cacheKey = `cacheKey_${B}`, this.fontCache.put(e.cacheKey, g)), e.loadedName = `${this.idFactory.getDocId()}_${B}`, this.translateFont(I).then((Q) => {
      o(new Dn({ loadedName: e.loadedName, font: Q, dict: e, evaluatorOptions: this.options }));
    }).catch((Q) => {
      G(`loadFont - translateFont failed: "${Q}".`), o(new Dn({ loadedName: e.loadedName, font: new bg(Q instanceof Error ? Q.message : Q), dict: e, evaluatorOptions: this.options }));
    }), g;
  }
  buildPath(A, e, i, a = !1) {
    const s = A.length - 1;
    if (i || (i = []), s < 0 || A.fnArray[s] !== jI) {
      a && (G(`Encountered path operator "${e}" inside of a text object.`), A.addOp(Se, null));
      let r;
      switch (e) {
        case Mn:
          const n = i[0] + i[2], g = i[1] + i[3];
          r = [Math.min(i[0], n), Math.min(i[1], g), Math.max(i[0], n), Math.max(i[1], g)];
          break;
        case Is:
        case Un:
          r = [i[0], i[1], i[0], i[1]];
          break;
        default:
          r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      }
      A.addOp(jI, [[e], i, r]), a && A.addOp(Wt, null);
    } else {
      const r = A.argsArray[s];
      r[0].push(e), r[1].push(...i);
      const n = r[2];
      switch (e) {
        case Mn:
          const g = i[0] + i[2], o = i[1] + i[3];
          n[0] = Math.min(n[0], i[0], g), n[1] = Math.min(n[1], i[1], o), n[2] = Math.max(n[2], i[0], g), n[3] = Math.max(n[3], i[1], o);
          break;
        case Is:
        case Un:
          n[0] = Math.min(n[0], i[0]), n[1] = Math.min(n[1], i[1]), n[2] = Math.max(n[2], i[0]), n[3] = Math.max(n[3], i[1]);
      }
    }
  }
  parseColorSpace({ cs: A, resources: e, localColorSpaceCache: i }) {
    return kA.parseAsync({ cs: A, xref: this.xref, resources: e, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: i }).catch((a) => {
      if (a instanceof pt) return null;
      if (this.options.ignoreErrors)
        return G(`parseColorSpace - ignoring ColorSpace: "${a}".`), null;
      throw a;
    });
  }
  parseShading({ shading: A, resources: e, localColorSpaceCache: i, localShadingPatternCache: a }) {
    let s, r = a.get(A);
    if (r) return r;
    try {
      s = KQ.parseShading(A, this.xref, e, this._pdfFunctionFactory, i).getIR();
    } catch (n) {
      if (n instanceof pt) return null;
      if (this.options.ignoreErrors)
        return G(`parseShading - ignoring shading: "${n}".`), a.set(A, null), null;
      throw n;
    }
    return r = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (r = `${this.idFactory.getDocId()}_type3_${r}`), a.set(A, r), this.parsingType3Font ? this.handler.send("commonobj", [r, "Pattern", s]) : this.handler.send("obj", [r, this.pageIndex, "Pattern", s]), r;
  }
  handleColorN(A, e, i, a, s, r, n, g, o, I) {
    const C = i.pop();
    if (C instanceof T) {
      const h = s.getRaw(C.name), c = h instanceof rA && o.getByRef(h);
      if (c) try {
        const l = a.base ? a.base.getRgb(i, 0) : null, Q = vc(c.operatorListIR, c.dict, l);
        A.addOp(e, Q);
        return;
      } catch {
      }
      const B = this.xref.fetchIfRef(h);
      if (B) {
        const l = B instanceof FA ? B.dict : B, Q = l.get("PatternType");
        if (Q === ZE) {
          const E = a.base ? a.base.getRgb(i, 0) : null;
          return this.handleTilingType(e, E, r, B, l, A, n, o);
        }
        if (Q === OE) {
          const E = l.get("Shading"), u = this.parseShading({ shading: E, resources: r, localColorSpaceCache: g, localShadingPatternCache: I });
          if (u) {
            const f = ci(l.getArray("Matrix"), null);
            A.addOp(e, ["Shading", u, f]);
          }
          return;
        }
        throw new X(`Unknown PatternType: ${Q}`);
      }
    }
    throw new X(`Unknown PatternName: ${C}`);
  }
  _parseVisibilityExpression(A, e, i) {
    if (++e > 10) {
      G("Visibility expression is too deeply nested");
      return;
    }
    const a = A.length, s = this.xref.fetchIfRef(A[0]);
    if (!(a < 2) && s instanceof T) {
      switch (s.name) {
        case "And":
        case "Or":
        case "Not":
          i.push(s.name);
          break;
        default:
          G(`Invalid operator ${s.name} in visibility expression`);
          return;
      }
      for (let r = 1; r < a; r++) {
        const n = A[r], g = this.xref.fetchIfRef(n);
        if (Array.isArray(g)) {
          const o = [];
          i.push(o), this._parseVisibilityExpression(g, e, o);
        } else n instanceof rA && i.push(n.toString());
      }
    } else G("Invalid visibility expression");
  }
  async parseMarkedContentProps(A, e) {
    var s;
    let i;
    if (A instanceof T)
      i = e.get("Properties").get(A.name);
    else {
      if (!(A instanceof U)) throw new X("Optional content properties malformed.");
      i = A;
    }
    const a = (s = i.get("Type")) == null ? void 0 : s.name;
    if (a === "OCG") return { type: a, id: i.objId };
    if (a === "OCMD") {
      const r = i.get("VE");
      if (Array.isArray(r)) {
        const g = [];
        if (this._parseVisibilityExpression(r, 0, g), g.length > 0) return { type: "OCMD", expression: g };
      }
      const n = i.get("OCGs");
      if (Array.isArray(n) || n instanceof U) {
        const g = [];
        if (Array.isArray(n)) for (const o of n) g.push(o.toString());
        else g.push(n.objId);
        return { type: a, ids: g, policy: i.get("P") instanceof T ? i.get("P").name : null, expression: null };
      }
      if (n instanceof rA) return { type: a, id: n.toString() };
    }
    return null;
  }
  getOperatorList({ stream: A, task: e, resources: i, operatorList: a, initialState: s = null, fallbackFontDict: r = null }) {
    if (i || (i = U.empty), s || (s = new gC()), !a) throw new Error('getOperatorList: missing "operatorList" parameter');
    const n = this, g = this.xref;
    let o = !1;
    const I = new Kc(), C = new AC(), h = new qc(), c = new kE(), B = /* @__PURE__ */ new Map(), l = i.get("XObject") || U.empty, Q = i.get("Pattern") || U.empty, E = new jn(s), u = new Ma(A, g, E), f = new fr();
    function d(p) {
      for (let m = 0, y = u.savedStatesDepth; m < y; m++) a.addOp(Wt, []);
    }
    return new Promise(function p(m, y) {
      const b = function(O) {
        Promise.all([O, a.ready]).then(function() {
          try {
            p(m, y);
          } catch (L) {
            y(L);
          }
        }, y);
      };
      e.ensureNotTerminated(), f.reset();
      const D = {};
      let R, k, Y, V, eA, AA;
      for (; !(R = f.check()) && (D.args = null, !!u.read(D)); ) {
        let O = D.args, L = D.fn;
        switch (0 | L) {
          case Zg:
            if (AA = O[0] instanceof T, eA = O[0].name, AA) {
              const w = I.getByName(eA);
              if (w) {
                Sg(a, w), O = null;
                continue;
              }
            }
            b(new Promise(function(w, x) {
              if (!AA) throw new X("XObject must be referred to by name.");
              let J = l.getRaw(eA);
              if (J instanceof rA) {
                const H = I.getByRef(J) || n._regionalImageCache.getByRef(J);
                if (H) {
                  Sg(a, H), w();
                  return;
                }
                const z = n.globalImageCache.getData(J, n.pageIndex);
                if (z) {
                  a.addDependency(z.objId), a.addImageOps(z.fn, z.args, z.optionalContent), w();
                  return;
                }
                J = g.fetch(J);
              }
              if (!(J instanceof FA)) throw new X("XObject should be a stream");
              const M = J.dict.get("Subtype");
              if (!(M instanceof T)) throw new X("XObject should have a Name subtype");
              if (M.name !== "Form") if (M.name !== "Image") {
                if (M.name !== "PS") throw new X(`Unhandled XObject subtype ${M.name}`);
                RA("Ignored XObject subtype PS"), w();
              } else n.buildPaintImageXObject({ resources: i, image: J, operatorList: a, cacheKey: eA, localImageCache: I, localColorSpaceCache: C }).then(w, x);
              else
                E.save(), n.buildFormXObject(i, J, null, a, e, E.state.clone(), C).then(function() {
                  E.restore(), w();
                }, x);
            }).catch(function(w) {
              if (!(w instanceof pt)) {
                if (!n.options.ignoreErrors) throw w;
                G(`getOperatorList - ignoring XObject: "${w}".`);
              }
            }));
            return;
          case li:
            const v = O[1];
            b(n.handleSetFont(i, O, null, a, e, E.state, r).then(function(w) {
              a.addDependency(w), a.addOp(li, [w, v]);
            }));
            return;
          case ps:
            o = !0;
            break;
          case ms:
            o = !1;
            break;
          case t1:
            const W = O[0].cacheKey;
            if (W) {
              const w = I.getByName(W);
              if (w) {
                Sg(a, w), O = null;
                continue;
              }
            }
            b(n.buildPaintImageXObject({ resources: i, image: O[0], isInline: !0, operatorList: a, cacheKey: W, localImageCache: I, localColorSpaceCache: C }));
            return;
          case Je:
            if (!E.state.font) {
              n.ensureStateFont(E.state);
              continue;
            }
            O[0] = n.handleText(O[0], E.state);
            break;
          case ir:
            if (!E.state.font) {
              n.ensureStateFont(E.state);
              continue;
            }
            const K = [], q = E.state;
            for (const w of O[0]) typeof w == "string" ? K.push(...n.handleText(w, q)) : typeof w == "number" && K.push(w);
            O[0] = K, L = Je;
            break;
          case ar:
            if (!E.state.font) {
              n.ensureStateFont(E.state);
              continue;
            }
            a.addOp(Ln), O[0] = n.handleText(O[0], E.state), L = Je;
            break;
          case sr:
            if (!E.state.font) {
              n.ensureStateFont(E.state);
              continue;
            }
            a.addOp(Ln), a.addOp(Pg, [O.shift()]), a.addOp(Tg, [O.shift()]), O[0] = n.handleText(O[0], E.state), L = Je;
            break;
          case z0:
            E.state.textRenderingMode = O[0];
            break;
          case qr: {
            const w = kA.getCached(O[0], g, C);
            if (w) {
              E.state.fillColorSpace = w;
              continue;
            }
            b(n.parseColorSpace({ cs: O[0], resources: i, localColorSpaceCache: C }).then(function(x) {
              E.state.fillColorSpace = x || kA.singletons.gray;
            }));
            return;
          }
          case Wo: {
            const w = kA.getCached(O[0], g, C);
            if (w) {
              E.state.strokeColorSpace = w;
              continue;
            }
            b(n.parseColorSpace({ cs: O[0], resources: i, localColorSpaceCache: C }).then(function(x) {
              E.state.strokeColorSpace = x || kA.singletons.gray;
            }));
            return;
          }
          case Tr:
            V = E.state.fillColorSpace, O = V.getRgb(O, 0), L = me;
            break;
          case Zo:
            V = E.state.strokeColorSpace, O = V.getRgb(O, 0), L = Ai;
            break;
          case tn:
            E.state.fillColorSpace = kA.singletons.gray, O = kA.singletons.gray.getRgb(O, 0), L = me;
            break;
          case Oo:
            E.state.strokeColorSpace = kA.singletons.gray, O = kA.singletons.gray.getRgb(O, 0), L = Ai;
            break;
          case en:
            E.state.fillColorSpace = kA.singletons.cmyk, O = kA.singletons.cmyk.getRgb(O, 0), L = me;
            break;
          case Xo:
            E.state.strokeColorSpace = kA.singletons.cmyk, O = kA.singletons.cmyk.getRgb(O, 0), L = Ai;
            break;
          case me:
            E.state.fillColorSpace = kA.singletons.rgb, O = kA.singletons.rgb.getRgb(O, 0);
            break;
          case Ai:
            E.state.strokeColorSpace = kA.singletons.rgb, O = kA.singletons.rgb.getRgb(O, 0);
            break;
          case rr:
            if (V = E.state.patternFillColorSpace, !V) {
              if (Gt(O, null)) {
                O = kA.singletons.gray.getRgb(O, 0), L = me;
                break;
              }
              O = [], L = MB;
              break;
            }
            if (V.name === "Pattern") {
              b(n.handleColorN(a, rr, O, V, Q, i, e, C, c, B));
              return;
            }
            O = V.getRgb(O, 0), L = me;
            break;
          case nr:
            if (V = E.state.patternStrokeColorSpace, !V) {
              if (Gt(O, null)) {
                O = kA.singletons.gray.getRgb(O, 0), L = Ai;
                break;
              }
              O = [], L = UB;
              break;
            }
            if (V.name === "Pattern") {
              b(n.handleColorN(a, nr, O, V, Q, i, e, C, c, B));
              return;
            }
            O = V.getRgb(O, 0), L = Ai;
            break;
          case gr:
            let N;
            try {
              const w = i.get("Shading");
              if (!w) throw new X("No shading resource found");
              if (N = w.get(O[0].name), !N) throw new X("No shading object found");
            } catch (w) {
              if (w instanceof pt) continue;
              if (n.options.ignoreErrors) {
                G(`getOperatorList - ignoring Shading: "${w}".`);
                continue;
              }
              throw w;
            }
            const F = n.parseShading({ shading: N, resources: i, localColorSpaceCache: C, localShadingPatternCache: B });
            if (!F) continue;
            O = [F], L = gr;
            break;
          case ca:
            if (AA = O[0] instanceof T, eA = O[0].name, AA) {
              const w = h.getByName(eA);
              if (w) {
                w.length > 0 && a.addOp(ca, [w]), O = null;
                continue;
              }
            }
            b(new Promise(function(w, x) {
              if (!AA) throw new X("GState must be referred to by name.");
              const J = i.get("ExtGState");
              if (!(J instanceof U)) throw new X("ExtGState should be a dictionary.");
              const M = J.get(eA);
              if (!(M instanceof U)) throw new X("GState should be a dictionary.");
              n.setGState({ resources: i, gState: M, operatorList: a, cacheKey: eA, task: e, stateManager: E, localGStateCache: h, localColorSpaceCache: C }).then(w, x);
            }).catch(function(w) {
              if (!(w instanceof pt)) {
                if (!n.options.ignoreErrors) throw w;
                G(`getOperatorList - ignoring ExtGState: "${w}".`);
              }
            }));
            return;
          case Is:
          case Un:
          case W0:
          case Z0:
          case O0:
          case X0:
          case Mn:
            n.buildPath(a, L, O, o);
            continue;
          case e1:
          case i1:
          case s1:
          case n1:
            continue;
          case ye:
            if (!(O[0] instanceof T)) {
              G(`Expected name for beginMarkedContentProps arg0=${O[0]}`), a.addOp(ye, ["OC", null]);
              continue;
            }
            if (O[0].name === "OC") {
              b(n.parseMarkedContentProps(O[1], i).then((w) => {
                a.addOp(ye, ["OC", w]);
              }).catch((w) => {
                if (!(w instanceof pt)) {
                  if (!n.options.ignoreErrors) throw w;
                  G(`getOperatorList - ignoring beginMarkedContentProps: "${w}".`), a.addOp(ye, ["OC", null]);
                }
              }));
              return;
            }
            O = [O[0].name, O[1] instanceof U ? O[1].get("MCID") : null];
            break;
          default:
            if (O !== null) {
              for (k = 0, Y = O.length; k < Y && !(O[k] instanceof U); k++) ;
              if (k < Y) {
                G("getOperatorList - ignoring operator: " + L);
                continue;
              }
            }
        }
        a.addOp(L, O);
      }
      R ? b($c) : (d(), m());
    }).catch((p) => {
      if (!(p instanceof pt)) {
        if (!this.options.ignoreErrors) throw p;
        G(`getOperatorList - ignoring errors during "${e.name}" task: "${p}".`), d();
      }
    });
  }
  getTextContent({ stream: A, task: e, resources: i, stateManager: a = null, includeMarkedContent: s = !1, sink: r, seenStyles: n = /* @__PURE__ */ new Set(), viewBox: g, lang: o = null, markedContentData: I = null, disableNormalization: C = !1, keepWhiteSpace: h = !1 }) {
    i || (i = U.empty), a || (a = new jn(new XE())), s && (I || (I = { level: 0 }));
    const c = { items: [], styles: /* @__PURE__ */ Object.create(null), lang: o }, B = { initialized: !1, str: [], totalWidth: 0, totalHeight: 0, width: 0, height: 0, vertical: !1, prevTransform: null, textAdvanceScale: 0, spaceInFlowMin: 0, spaceInFlowMax: 0, trackingSpaceMin: 1 / 0, negativeSpaceMax: -1 / 0, notASpace: -1 / 0, transform: null, fontName: null, hasEOL: !1 }, l = [" ", " "];
    let Q = 0;
    function E(J) {
      const M = (Q + 1) % 2, H = l[Q] !== " " && l[M] === " ";
      return l[Q] = J, Q = M, !h && H;
    }
    function u() {
      return !h && l[Q] !== " " && l[(Q + 1) % 2] === " ";
    }
    function f() {
      l[0] = l[1] = " ", Q = 0;
    }
    const d = this, p = this.xref, m = [];
    let y = null;
    const b = new Kc(), D = new qc(), R = new Ma(A, p, a);
    let k;
    function Y({ width: J = 0, height: M = 0, transform: H = B.prevTransform, fontName: z = B.fontName }) {
      c.items.push({ str: " ", dir: "ltr", width: J, height: M, transform: H, fontName: z, hasEOL: !1 });
    }
    function V() {
      const J = k.font, M = [k.fontSize * k.textHScale, 0, 0, k.fontSize, 0, k.textRise];
      if (J.isType3Font && (k.fontSize <= 1 || J.isCharBBox) && !Pi(k.fontMatrix, Ji)) {
        const H = J.bbox[3] - J.bbox[1];
        H > 0 && (M[3] *= H * k.fontMatrix[3]);
      }
      return nt.transform(k.ctm, nt.transform(k.textMatrix, M));
    }
    function eA() {
      if (B.initialized) return B;
      const { font: J, loadedName: M } = k;
      if (!n.has(M) && (n.add(M), c.styles[M] = { fontFamily: J.fallbackName, ascent: J.ascent, descent: J.descent, vertical: J.vertical }, d.options.fontExtraProperties && J.systemFontInfo)) {
        const hA = c.styles[M];
        hA.fontSubstitution = J.systemFontInfo.css, hA.fontSubstitutionLoadedName = J.systemFontInfo.loadedName;
      }
      B.fontName = M;
      const H = B.transform = V();
      J.vertical ? (B.width = B.totalWidth = Math.hypot(H[0], H[1]), B.height = B.totalHeight = 0, B.vertical = !0) : (B.width = B.totalWidth = 0, B.height = B.totalHeight = Math.hypot(H[2], H[3]), B.vertical = !1);
      const z = Math.hypot(k.textLineMatrix[0], k.textLineMatrix[1]), aA = Math.hypot(k.ctm[0], k.ctm[1]);
      B.textAdvanceScale = aA * z;
      const { fontSize: tA } = k;
      return B.trackingSpaceMin = 0.102 * tA, B.notASpace = 0.03 * tA, B.negativeSpaceMax = -0.2 * tA, B.spaceInFlowMin = 0.102 * tA, B.spaceInFlowMax = 0.6 * tA, B.hasEOL = !1, B.initialized = !0, B;
    }
    function AA() {
      if (!B.initialized) return;
      const J = Math.hypot(k.textLineMatrix[0], k.textLineMatrix[1]), M = Math.hypot(k.ctm[0], k.ctm[1]) * J;
      M !== B.textAdvanceScale && (B.vertical ? (B.totalHeight += B.height * B.textAdvanceScale, B.height = 0) : (B.totalWidth += B.width * B.textAdvanceScale, B.width = 0), B.textAdvanceScale = M);
    }
    function O(J) {
      let M = J.str.join("");
      C || (M = function(aA) {
        return Ig || (Ig = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, zI = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), aA.replaceAll(Ig, (tA, hA, BA) => hA ? hA.normalize("NFKC") : zI.get(BA));
      }(M));
      const H = iC(M, -1, J.vertical);
      return { str: H.str, dir: H.dir, width: Math.abs(J.totalWidth), height: Math.abs(J.totalHeight), transform: J.transform, fontName: J.fontName, hasEOL: J.hasEOL };
    }
    async function L(J, M) {
      const H = await d.loadFont(J, M, i);
      if (H.font.isType3Font) try {
        await H.loadType3Data(d, i, e);
      } catch {
      }
      k.loadedName = H.loadedName, k.font = H.font, k.fontMatrix = H.font.fontMatrix || Ji;
    }
    function v(J, M, H) {
      const z = Math.hypot(H[0], H[1]);
      return [(H[0] * J + H[1] * M) / z, (H[2] * J + H[3] * M) / z];
    }
    function W(J) {
      var EA;
      const M = V();
      let H = M[4], z = M[5];
      if ((EA = k.font) != null && EA.vertical) {
        if (H < g[0] || H > g[2] || z + J < g[1] || z > g[3]) return !1;
      } else if (H + J < g[0] || H > g[2] || z < g[1] || z > g[3]) return !1;
      if (!k.font || !B.prevTransform) return !0;
      let aA = B.prevTransform[4], tA = B.prevTransform[5];
      if (aA === H && tA === z) return !0;
      let hA = -1;
      switch (M[0] && M[1] === 0 && M[2] === 0 ? hA = M[0] > 0 ? 0 : 180 : M[1] && M[0] === 0 && M[3] === 0 && (hA = M[1] > 0 ? 90 : 270), hA) {
        case 0:
          break;
        case 90:
          [H, z] = [z, H], [aA, tA] = [tA, aA];
          break;
        case 180:
          [H, z, aA, tA] = [-H, -z, -aA, -tA];
          break;
        case 270:
          [H, z] = [-z, -H], [aA, tA] = [-tA, -aA];
          break;
        default:
          [H, z] = v(H, z, M), [aA, tA] = v(aA, tA, B.prevTransform);
      }
      if (k.font.vertical) {
        const IA = (tA - z) / B.textAdvanceScale, cA = H - aA, bA = Math.sign(B.height);
        return IA < bA * B.negativeSpaceMax ? Math.abs(cA) > 0.5 * B.width ? (q(), !0) : (f(), F(), !0) : Math.abs(cA) > B.width ? (q(), !0) : (IA <= bA * B.notASpace && f(), IA <= bA * B.trackingSpaceMin ? u() ? (f(), F(), Y({ height: Math.abs(IA) })) : B.height += IA : N(IA, B.prevTransform, bA) || (B.str.length === 0 ? (f(), Y({ height: Math.abs(IA) })) : B.height += IA), Math.abs(cA) > 0.25 * B.width && F(), !0);
      }
      const BA = (H - aA) / B.textAdvanceScale, gA = z - tA, wA = Math.sign(B.width);
      return BA < wA * B.negativeSpaceMax ? Math.abs(gA) > 0.5 * B.height ? (q(), !0) : (f(), F(), !0) : Math.abs(gA) > B.height ? (q(), !0) : (BA <= wA * B.notASpace && f(), BA <= wA * B.trackingSpaceMin ? u() ? (f(), F(), Y({ width: Math.abs(BA) })) : B.width += BA : N(BA, B.prevTransform, wA) || (B.str.length === 0 ? (f(), Y({ width: Math.abs(BA) })) : B.width += BA), Math.abs(gA) > 0.25 * B.height && F(), !0);
    }
    function K({ chars: J, extraSpacing: M }) {
      const H = k.font;
      if (!J) {
        const tA = k.charSpacing + M;
        tA && (H.vertical ? k.translateTextMatrix(0, -tA) : k.translateTextMatrix(tA * k.textHScale, 0)), h && W(0);
        return;
      }
      const z = H.charsToGlyphs(J), aA = k.fontMatrix[0] * k.fontSize;
      for (let tA = 0, hA = z.length; tA < hA; tA++) {
        const BA = z[tA], { category: gA } = BA;
        if (gA.isInvisibleFormatMark) continue;
        let wA = k.charSpacing + (tA + 1 === hA ? M : 0), EA = BA.width;
        H.vertical && (EA = BA.vmetric ? BA.vmetric[0] : -EA);
        let IA = EA * aA;
        if (!h && gA.isWhitespace) {
          H.vertical ? (wA += -IA + k.wordSpacing, k.translateTextMatrix(0, -wA)) : (wA += IA + k.wordSpacing, k.translateTextMatrix(wA * k.textHScale, 0)), E(" ");
          continue;
        }
        if (!gA.isZeroWidthDiacritic && !W(IA)) {
          H.vertical ? k.translateTextMatrix(0, IA) : k.translateTextMatrix(IA * k.textHScale, 0);
          continue;
        }
        const cA = eA();
        gA.isZeroWidthDiacritic && (IA = 0), H.vertical ? (k.translateTextMatrix(0, IA), IA = Math.abs(IA), cA.height += IA) : (IA *= k.textHScale, k.translateTextMatrix(IA, 0), cA.width += IA), IA && (cA.prevTransform = V());
        const bA = BA.unicode;
        E(bA) && cA.str.push(" "), cA.str.push(bA), wA && (H.vertical ? k.translateTextMatrix(0, -wA) : k.translateTextMatrix(wA * k.textHScale, 0));
      }
    }
    function q() {
      f(), B.initialized ? (B.hasEOL = !0, F()) : c.items.push({ str: "", dir: "ltr", width: 0, height: 0, transform: V(), fontName: k.loadedName, hasEOL: !0 });
    }
    function N(J, M, H) {
      if (H * B.spaceInFlowMin <= J && J <= H * B.spaceInFlowMax)
        return B.initialized && (f(), B.str.push(" ")), !1;
      const z = B.fontName;
      let aA = 0;
      return B.vertical && (aA = J, J = 0), F(), f(), Y({ width: Math.abs(J), height: Math.abs(aA), transform: M || V(), fontName: z }), !0;
    }
    function F() {
      B.initialized && B.str && (B.vertical ? B.totalHeight += B.height * B.textAdvanceScale : B.totalWidth += B.width * B.textAdvanceScale, c.items.push(O(B)), B.initialized = !1, B.str.length = 0);
    }
    function w(J = !1) {
      const M = c.items.length;
      M !== 0 && !(J && M < 10) && (r.enqueue(c, M), c.items = [], c.styles = /* @__PURE__ */ Object.create(null));
    }
    const x = new fr();
    return new Promise(function J(M, H) {
      const z = function(wA) {
        w(!0), Promise.all([wA, r.ready]).then(function() {
          try {
            J(M, H);
          } catch (EA) {
            H(EA);
          }
        }, H);
      };
      e.ensureNotTerminated(), x.reset();
      const aA = {};
      let tA, hA, BA, gA = [];
      for (; !(tA = x.check()) && (gA.length = 0, aA.args = gA, !!R.read(aA)); ) {
        const wA = k;
        k = a.state;
        const EA = aA.fn;
        switch (gA = aA.args, 0 | EA) {
          case li:
            const IA = gA[0].name, cA = gA[1];
            if (k.font && IA === k.fontName && cA === k.fontSize) break;
            F(), k.fontName = IA, k.fontSize = cA, z(L(IA, null));
            return;
          case _0:
            k.textRise = gA[0];
            break;
          case V0:
            k.textHScale = gA[0] / 100;
            break;
          case j0:
            k.leading = gA[0];
            break;
          case $0:
            k.translateTextLineMatrix(gA[0], gA[1]), k.textMatrix = k.textLineMatrix.slice();
            break;
          case A1:
            k.leading = -gA[1], k.translateTextLineMatrix(gA[0], gA[1]), k.textMatrix = k.textLineMatrix.slice();
            break;
          case Ln:
            k.carriageReturn();
            break;
          case ys:
            k.setTextMatrix(gA[0], gA[1], gA[2], gA[3], gA[4], gA[5]), k.setTextLineMatrix(gA[0], gA[1], gA[2], gA[3], gA[4], gA[5]), AA();
            break;
          case Tg:
            k.charSpacing = gA[0];
            break;
          case Pg:
            k.wordSpacing = gA[0];
            break;
          case ps:
            k.textMatrix = Be.slice(), k.textLineMatrix = Be.slice();
            break;
          case ir:
            if (!a.state.font) {
              d.ensureStateFont(a.state);
              continue;
            }
            const bA = (k.font.vertical ? 1 : -1) * k.fontSize / 1e3, DA = gA[0];
            for (let QA = 0, dA = DA.length; QA < dA; QA++) {
              const mA = DA[QA];
              if (typeof mA == "string") m.push(mA);
              else if (typeof mA == "number" && mA !== 0) {
                const KA = m.join("");
                m.length = 0, K({ chars: KA, extraSpacing: mA * bA });
              }
            }
            if (m.length > 0) {
              const QA = m.join("");
              m.length = 0, K({ chars: QA, extraSpacing: 0 });
            }
            break;
          case Je:
            if (!a.state.font) {
              d.ensureStateFont(a.state);
              continue;
            }
            K({ chars: gA[0], extraSpacing: 0 });
            break;
          case ar:
            if (!a.state.font) {
              d.ensureStateFont(a.state);
              continue;
            }
            k.carriageReturn(), K({ chars: gA[0], extraSpacing: 0 });
            break;
          case sr:
            if (!a.state.font) {
              d.ensureStateFont(a.state);
              continue;
            }
            k.wordSpacing = gA[0], k.charSpacing = gA[1], k.carriageReturn(), K({ chars: gA[2], extraSpacing: 0 });
            break;
          case Zg:
            if (F(), y ?? (y = i.get("XObject") || U.empty), BA = gA[0] instanceof T, hA = gA[0].name, BA && b.getByName(hA)) break;
            z(new Promise(function(QA, dA) {
              if (!BA) throw new X("XObject must be referred to by name.");
              let mA = y.getRaw(hA);
              if (mA instanceof rA) {
                if (b.getByRef(mA)) {
                  QA();
                  return;
                }
                if (d.globalImageCache.getData(mA, d.pageIndex)) {
                  QA();
                  return;
                }
                mA = p.fetch(mA);
              }
              if (!(mA instanceof FA)) throw new X("XObject should be a stream");
              const KA = mA.dict.get("Subtype");
              if (!(KA instanceof T)) throw new X("XObject should have a Name subtype");
              if (KA.name !== "Form") {
                b.set(hA, mA.dict.objId, !0), QA();
                return;
              }
              const kt = a.state.clone(), RI = new jn(kt), GI = ci(mA.dict.getArray("Matrix"), null);
              GI && RI.transform(GI), w();
              const NI = { enqueueInvoked: !1, enqueue(Eh, uh) {
                this.enqueueInvoked = !0, r.enqueue(Eh, uh);
              }, get desiredSize() {
                return r.desiredSize;
              }, get ready() {
                return r.ready;
              } };
              d.getTextContent({ stream: mA, task: e, resources: mA.dict.get("Resources") || i, stateManager: RI, includeMarkedContent: s, sink: NI, seenStyles: n, viewBox: g, lang: o, markedContentData: I, disableNormalization: C, keepWhiteSpace: h }).then(function() {
                NI.enqueueInvoked || b.set(hA, mA.dict.objId, !0), QA();
              }, dA);
            }).catch(function(QA) {
              if (!(QA instanceof pt)) {
                if (!d.options.ignoreErrors) throw QA;
                G(`getTextContent - ignoring XObject: "${QA}".`);
              }
            }));
            return;
          case ca:
            if (BA = gA[0] instanceof T, hA = gA[0].name, BA && D.getByName(hA)) break;
            z(new Promise(function(QA, dA) {
              if (!BA) throw new X("GState must be referred to by name.");
              const mA = i.get("ExtGState");
              if (!(mA instanceof U)) throw new X("ExtGState should be a dictionary.");
              const KA = mA.get(hA);
              if (!(KA instanceof U)) throw new X("GState should be a dictionary.");
              const kt = KA.get("Font");
              kt ? (F(), k.fontName = null, k.fontSize = kt[1], L(null, kt[0]).then(QA, dA)) : (D.set(hA, KA.objId, !0), QA());
            }).catch(function(QA) {
              if (!(QA instanceof pt)) {
                if (!d.options.ignoreErrors) throw QA;
                G(`getTextContent - ignoring ExtGState: "${QA}".`);
              }
            }));
            return;
          case a1:
            F(), s && (I.level++, c.items.push({ type: "beginMarkedContent", tag: gA[0] instanceof T ? gA[0].name : null }));
            break;
          case ye:
            if (F(), s) {
              I.level++;
              let QA = null;
              gA[1] instanceof U && (QA = gA[1].get("MCID")), c.items.push({ type: "beginMarkedContentProps", id: Number.isInteger(QA) ? `${d.idFactory.getPageObjId()}_mc${QA}` : null, tag: gA[0] instanceof T ? gA[0].name : null });
            }
            break;
          case Ra:
            if (F(), s) {
              if (I.level === 0) break;
              I.level--, c.items.push({ type: "endMarkedContent" });
            }
            break;
          case Wt:
            !wA || wA.font === k.font && wA.fontSize === k.fontSize && wA.fontName === k.fontName || F();
        }
        if (c.items.length >= r.desiredSize) {
          tA = !0;
          break;
        }
      }
      tA ? z($c) : (F(), w(), M());
    }).catch((J) => {
      if (!(J instanceof pt)) {
        if (!this.options.ignoreErrors) throw J;
        G(`getTextContent - ignoring errors during "${e.name}" task: "${J}".`), F(), w();
      }
    });
  }
  async extractDataStructures(A, e) {
    const i = this.xref;
    let a;
    const s = this.readToUnicode(e.toUnicode);
    if (e.composite) {
      const h = A.get("CIDSystemInfo");
      h instanceof U && (e.cidSystemInfo = { registry: LA(h.get("Registry")), ordering: LA(h.get("Ordering")), supplement: h.get("Supplement") });
      try {
        const c = A.get("CIDToGIDMap");
        c instanceof FA && (a = c.getBytes());
      } catch (c) {
        if (!this.options.ignoreErrors) throw c;
        G(`extractDataStructures - ignoring CIDToGIDMap data: "${c}".`);
      }
    }
    const r = [];
    let n, g = null;
    if (A.has("Encoding")) {
      if (n = A.get("Encoding"), n instanceof U) {
        if (g = n.get("BaseEncoding"), g = g instanceof T ? g.name : null, n.has("Differences")) {
          const h = n.get("Differences");
          let c = 0;
          for (const B of h) {
            const l = i.fetchIfRef(B);
            if (typeof l == "number") c = l;
            else {
              if (!(l instanceof T)) throw new X(`Invalid entry in 'Differences' array: ${l}`);
              r[c++] = l.name;
            }
          }
        }
      } else if (n instanceof T) g = n.name;
      else {
        const h = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors) throw new X(h);
        G(h);
      }
      g !== "MacRomanEncoding" && g !== "MacExpertEncoding" && g !== "WinAnsiEncoding" && (g = null);
    }
    const o = !e.file || e.isInternalFont, I = Co()[e.name];
    if (g && o && I && (g = null), g) e.defaultEncoding = bs(g);
    else {
      const h = !!(e.flags & ur), c = !!(e.flags & uc);
      n = ve, e.type !== "TrueType" || c || (n = Ds), (h || I) && (n = $o, o && (/Symbol/i.test(e.name) ? n = AI : /Dingbats/i.test(e.name) ? n = tI : /Wingdings/i.test(e.name) && (n = Ds))), e.defaultEncoding = n;
    }
    e.differences = r, e.baseEncodingName = g, e.hasEncoding = !!g || r.length > 0, e.dict = A, e.toUnicode = await s;
    const C = await this.buildToUnicode(e);
    return e.toUnicode = C, a && (e.cidToGidMap = this.readCidToGidMap(a, C)), e;
  }
  _simpleFontToUnicode(A, e = !1) {
    Rt(!A.composite, "Must be a simple font.");
    const i = [], a = A.defaultEncoding.slice(), s = A.baseEncodingName, r = A.differences;
    for (const g in r) {
      const o = r[g];
      o !== ".notdef" && (a[g] = o);
    }
    const n = fe();
    for (const g in a) {
      let o = a[g];
      if (o === "") continue;
      let I = n[o];
      if (I !== void 0) {
        i[g] = String.fromCharCode(I);
        continue;
      }
      let C = 0;
      switch (o[0]) {
        case "G":
          o.length === 3 && (C = parseInt(o.substring(1), 16));
          break;
        case "g":
          o.length === 5 && (C = parseInt(o.substring(1), 16));
          break;
        case "C":
        case "c":
          if (o.length >= 3 && o.length <= 4) {
            const h = o.substring(1);
            if (e) {
              C = parseInt(h, 16);
              break;
            }
            if (C = +h, Number.isNaN(C) && Number.isInteger(parseInt(h, 16))) return this._simpleFontToUnicode(A, !0);
          }
          break;
        case "u":
          I = xa(o, n), I !== -1 && (C = I);
          break;
        default:
          switch (o) {
            case "f_h":
            case "f_t":
            case "T_h":
              i[g] = o.replaceAll("_", "");
              continue;
          }
      }
      if (C > 0 && C <= 1114111 && Number.isInteger(C)) {
        if (s && C === +g) {
          const h = bs(s);
          if (h && (o = h[g])) {
            i[g] = String.fromCharCode(n[o]);
            continue;
          }
        }
        i[g] = String.fromCodePoint(C);
      }
    }
    return i;
  }
  async buildToUnicode(A) {
    var e, i;
    if (A.hasIncludedToUnicodeMap = ((e = A.toUnicode) == null ? void 0 : e.length) > 0, A.hasIncludedToUnicodeMap)
      return !A.composite && A.hasEncoding && (A.fallbackToUnicode = this._simpleFontToUnicode(A)), A.toUnicode;
    if (!A.composite) return new ns(this._simpleFontToUnicode(A));
    if (A.composite && (A.cMap.builtInCMap && !(A.cMap instanceof ma) || ((i = A.cidSystemInfo) == null ? void 0 : i.registry) === "Adobe" && (A.cidSystemInfo.ordering === "GB1" || A.cidSystemInfo.ordering === "CNS1" || A.cidSystemInfo.ordering === "Japan1" || A.cidSystemInfo.ordering === "Korea1"))) {
      const { registry: a, ordering: s } = A.cidSystemInfo, r = T.get(`${a}-${s}-UCS2`), n = await mn.create({ encoding: r, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null }), g = [], o = [];
      return A.cMap.forEach(function(I, C) {
        if (C > 65535) throw new X("Max size of CID is 65,535");
        const h = n.lookup(C);
        if (h) {
          o.length = 0;
          for (let c = 0, B = h.length; c < B; c += 2) o.push((h.charCodeAt(c) << 8) + h.charCodeAt(c + 1));
          g[I] = String.fromCharCode(...o);
        }
      }), new ns(g);
    }
    return new Ae(A.firstChar, A.lastChar);
  }
  async readToUnicode(A) {
    if (!A) return null;
    if (A instanceof T) {
      const e = await mn.create({ encoding: A, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      return e instanceof ma ? new Ae(0, 65535) : new ns(e.getMap());
    }
    if (A instanceof FA) try {
      const e = await mn.create({ encoding: A, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      if (e instanceof ma) return new Ae(0, 65535);
      const i = new Array(e.length);
      return e.forEach(function(a, s) {
        if (typeof s == "number") {
          i[a] = String.fromCodePoint(s);
          return;
        }
        s.length % 2 != 0 && (s = "\0" + s);
        const r = [];
        for (let n = 0; n < s.length; n += 2) {
          const g = s.charCodeAt(n) << 8 | s.charCodeAt(n + 1);
          if ((63488 & g) != 55296) {
            r.push(g);
            continue;
          }
          n += 2;
          const o = s.charCodeAt(n) << 8 | s.charCodeAt(n + 1);
          r.push(((1023 & g) << 10) + (1023 & o) + 65536);
        }
        i[a] = String.fromCodePoint(...r);
      }), new ns(i);
    } catch (e) {
      if (e instanceof pt) return null;
      if (this.options.ignoreErrors)
        return G(`readToUnicode - ignoring ToUnicode data: "${e}".`), null;
      throw e;
    }
    return null;
  }
  readCidToGidMap(A, e) {
    const i = [];
    for (let a = 0, s = A.length; a < s; a++) {
      const r = A[a++] << 8 | A[a], n = a >> 1;
      (r !== 0 || e.has(n)) && (i[n] = r);
    }
    return i;
  }
  extractWidths(A, e, i) {
    const a = this.xref;
    let s = [], r = 0;
    const n = [];
    let g;
    if (i.composite) {
      const C = A.get("DW");
      r = typeof C == "number" ? Math.ceil(C) : 1e3;
      const h = A.get("W");
      if (Array.isArray(h)) for (let c = 0, B = h.length; c < B; c++) {
        let l = a.fetchIfRef(h[c++]);
        if (!Number.isInteger(l)) break;
        const Q = a.fetchIfRef(h[c]);
        if (Array.isArray(Q)) for (const E of Q) {
          const u = a.fetchIfRef(E);
          typeof u == "number" && (s[l] = u), l++;
        }
        else {
          if (!Number.isInteger(Q)) break;
          {
            const E = a.fetchIfRef(h[++c]);
            if (typeof E != "number") continue;
            for (let u = l; u <= Q; u++) s[u] = E;
          }
        }
      }
      if (i.vertical) {
        const c = A.getArray("DW2");
        let B = Gt(c, 2) ? c : [880, -1e3];
        if (g = [B[1], 0.5 * r, B[0]], B = A.get("W2"), Array.isArray(B)) for (let l = 0, Q = B.length; l < Q; l++) {
          let E = a.fetchIfRef(B[l++]);
          if (!Number.isInteger(E)) break;
          const u = a.fetchIfRef(B[l]);
          if (Array.isArray(u)) for (let f = 0, d = u.length; f < d; f++) {
            const p = [a.fetchIfRef(u[f++]), a.fetchIfRef(u[f++]), a.fetchIfRef(u[f])];
            Gt(p, null) && (n[E] = p), E++;
          }
          else {
            if (!Number.isInteger(u)) break;
            {
              const f = [a.fetchIfRef(B[++l]), a.fetchIfRef(B[++l]), a.fetchIfRef(B[++l])];
              if (!Gt(f, null)) continue;
              for (let d = E; d <= u; d++) n[d] = f;
            }
          }
        }
      }
    } else {
      const C = A.get("Widths");
      if (Array.isArray(C)) {
        let h = i.firstChar;
        for (const B of C) {
          const l = a.fetchIfRef(B);
          typeof l == "number" && (s[h] = l), h++;
        }
        const c = e.get("MissingWidth");
        r = typeof c == "number" ? c : 0;
      } else {
        const h = A.get("BaseFont");
        if (h instanceof T) {
          const c = this.getBaseFontMetrics(h.name);
          s = this.buildCharCodeToWidth(c.widths, i), r = c.defaultWidth;
        }
      }
    }
    let o = !0, I = r;
    for (const C in s) {
      const h = s[C];
      if (h) if (I) {
        if (I !== h) {
          o = !1;
          break;
        }
      } else I = h;
    }
    o ? i.flags |= On : i.flags &= ~On, i.defaultWidth = r, i.widths = s, i.defaultVMetrics = g, i.vmetrics = n;
  }
  isSerifFont(A) {
    const e = A.split("-", 1)[0];
    return e in aI() || /serif/gi.test(e);
  }
  getBaseFontMetrics(A) {
    let e = 0, i = /* @__PURE__ */ Object.create(null), a = !1, s = Xr()[A] || A;
    const r = pQ();
    s in r || (s = this.isSerifFont(A) ? "Times-Roman" : "Helvetica");
    const n = r[s];
    return typeof n == "number" ? (e = n, a = !0) : i = n(), { defaultWidth: e, monospace: a, widths: i };
  }
  buildCharCodeToWidth(A, e) {
    const i = /* @__PURE__ */ Object.create(null), a = e.differences, s = e.defaultEncoding;
    for (let r = 0; r < 256; r++) r in a && A[a[r]] ? i[r] = A[a[r]] : r in s && A[s[r]] && (i[r] = A[s[r]]);
    return i;
  }
  preEvaluateFont(A) {
    const e = A;
    let i = A.get("Subtype");
    if (!(i instanceof T)) throw new X("invalid font Subtype");
    let a, s = !1;
    if (i.name === "Type0") {
      const I = A.get("DescendantFonts");
      if (!I) throw new X("Descendant fonts are not specified");
      if (!((A = Array.isArray(I) ? this.xref.fetchIfRef(I[0]) : I) instanceof U)) throw new X("Descendant font is not a dictionary.");
      if (i = A.get("Subtype"), !(i instanceof T)) throw new X("invalid font Subtype");
      s = !0;
    }
    let r = A.get("FirstChar");
    Number.isInteger(r) || (r = 0);
    let n = A.get("LastChar");
    Number.isInteger(n) || (n = s ? 65535 : 255);
    const g = A.get("FontDescriptor"), o = A.get("ToUnicode") || e.get("ToUnicode");
    if (g) {
      a = new TE();
      const I = e.getRaw("Encoding");
      if (I instanceof T) a.update(I.name);
      else if (I instanceof rA) a.update(I.toString());
      else if (I instanceof U) {
        for (const h of I.getRawValues()) if (h instanceof T) a.update(h.name);
        else if (h instanceof rA) a.update(h.toString());
        else if (Array.isArray(h)) {
          const c = h.length, B = new Array(c);
          for (let l = 0; l < c; l++) {
            const Q = h[l];
            Q instanceof T ? B[l] = Q.name : (typeof Q == "number" || Q instanceof rA) && (B[l] = Q.toString());
          }
          a.update(B.join());
        }
      }
      if (a.update(`${r}-${n}`), o instanceof FA) {
        const h = o.str || o, c = h.buffer ? new Uint8Array(h.buffer.buffer, 0, h.bufferLength) : new Uint8Array(h.bytes.buffer, h.start, h.end - h.start);
        a.update(c);
      } else o instanceof T && a.update(o.name);
      const C = A.get("Widths") || e.get("Widths");
      if (Array.isArray(C)) {
        const h = [];
        for (const c of C) (typeof c == "number" || c instanceof rA) && h.push(c.toString());
        a.update(h.join());
      }
      if (s) {
        a.update("compositeFont");
        const h = A.get("W") || e.get("W");
        if (Array.isArray(h)) {
          const B = [];
          for (const l of h) if (typeof l == "number" || l instanceof rA) B.push(l.toString());
          else if (Array.isArray(l)) {
            const Q = [];
            for (const E of l) (typeof E == "number" || E instanceof rA) && Q.push(E.toString());
            B.push(`[${Q.join()}]`);
          }
          a.update(B.join());
        }
        const c = A.getRaw("CIDToGIDMap") || e.getRaw("CIDToGIDMap");
        c instanceof T ? a.update(c.name) : c instanceof rA ? a.update(c.toString()) : c instanceof FA && a.update(c.peekBytes());
      }
    }
    return { descriptor: g, dict: A, baseDict: e, composite: s, type: i.name, firstChar: r, lastChar: n, toUnicode: o, hash: a ? a.hexdigest() : "" };
  }
  async translateFont({ descriptor: A, dict: e, baseDict: i, composite: a, type: s, firstChar: r, lastChar: n, toUnicode: g, cssFontInfo: o }) {
    const I = s === "Type3";
    if (!A) {
      if (!I) {
        let L = e.get("BaseFont");
        if (!(L instanceof T)) throw new X("Base font is not specified");
        L = L.name.replaceAll(/[,_]/g, "-");
        const v = this.getBaseFontMetrics(L), W = L.split("-", 1)[0], K = (this.isSerifFont(W) ? q1 : 0) | (v.monospace ? On : 0) | (Co()[W] ? ur : uc), q = { type: s, name: L, loadedName: i.loadedName, systemFontInfo: null, widths: v.widths, defaultWidth: v.defaultWidth, isSimulatedFlags: !0, flags: K, firstChar: r, lastChar: n, toUnicode: g, xHeight: 0, capHeight: 0, italicAngle: 0, isType3Font: I }, N = e.get("Widths"), F = pc(L);
        let w = null;
        F && (w = await this.fetchStandardFontData(F), q.isInternalFont = !!w), !q.isInternalFont && this.options.useSystemFonts && (q.systemFontInfo = jc(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, L, F, s));
        const x = await this.extractDataStructures(e, q);
        if (Array.isArray(N)) {
          const J = [];
          let M = r;
          for (const H of N) {
            const z = this.xref.fetchIfRef(H);
            typeof z == "number" && (J[M] = z), M++;
          }
          x.widths = J;
        } else x.widths = this.buildCharCodeToWidth(v.widths, x);
        return new Hc(L, w, x);
      }
      {
        const L = be(e.getArray("FontBBox"), [0, 0, 0, 0]);
        (A = new U(null)).set("FontName", T.get(s)), A.set("FontBBox", L);
      }
    }
    let C = A.get("FontName"), h = e.get("BaseFont");
    typeof C == "string" && (C = T.get(C)), typeof h == "string" && (h = T.get(h));
    const c = C == null ? void 0 : C.name, B = h == null ? void 0 : h.name;
    if (!I && c !== B && (RA(`The FontDescriptor's FontName is "${c}" but should be the same as the Font's BaseFont "${B}".`), c && B && (B.startsWith(c) || !mc(c) && mc(B)) && (C = null)), C || (C = h), !(C instanceof T)) throw new X("invalid font name");
    let l, Q, E, u, f;
    try {
      if (l = A.get("FontFile", "FontFile2", "FontFile3"), l) {
        if (!(l instanceof FA)) throw new X("FontFile should be a stream");
        if (l.isEmpty) throw new X("FontFile is empty");
      }
    } catch (L) {
      if (!this.options.ignoreErrors) throw L;
      G(`translateFont - fetching "${C.name}" font file: "${L}".`), l = null;
    }
    let d = !1, p = null, m = null;
    if (l) {
      if (l.dict) {
        const L = l.dict.get("Subtype");
        L instanceof T && (Q = L.name), E = l.dict.get("Length1"), u = l.dict.get("Length2"), f = l.dict.get("Length3");
      }
    } else if (o) {
      const L = gI(C.name);
      L && (o.fontFamily = `${o.fontFamily}-PdfJS-XFA`, o.metrics = L.metrics || null, p = L.factors || null, l = await this.fetchStandardFontData(L.name), d = !!l, i = e = $1(C.name), a = !0);
    } else if (!I) {
      const L = pc(C.name);
      L && (l = await this.fetchStandardFontData(L), d = !!l), !d && this.options.useSystemFonts && (m = jc(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, C.name, L, s));
    }
    const y = ci(e.getArray("FontMatrix"), Ji), b = be(A.getArray("FontBBox") || e.getArray("FontBBox"), void 0);
    let D = A.get("Ascent");
    typeof D != "number" && (D = void 0);
    let R = A.get("Descent");
    typeof R != "number" && (R = void 0);
    let k = A.get("XHeight");
    typeof k != "number" && (k = 0);
    let Y = A.get("CapHeight");
    typeof Y != "number" && (Y = 0);
    let V = A.get("Flags");
    Number.isInteger(V) || (V = 0);
    let eA = A.get("ItalicAngle");
    typeof eA != "number" && (eA = 0);
    const AA = { type: s, name: C.name, subtype: Q, file: l, length1: E, length2: u, length3: f, isInternalFont: d, loadedName: i.loadedName, composite: a, fixedPitch: !1, fontMatrix: y, firstChar: r, lastChar: n, toUnicode: g, bbox: b, ascent: D, descent: R, xHeight: k, capHeight: Y, flags: V, italicAngle: eA, isType3Font: I, cssFontInfo: o, scaleFactors: p, systemFontInfo: m };
    if (a) {
      const L = i.get("Encoding");
      L instanceof T && (AA.cidEncoding = L.name);
      const v = await mn.create({ encoding: L, fetchBuiltInCMap: this._fetchBuiltInCMapBound, useCMap: null });
      AA.cMap = v, AA.vertical = AA.cMap.vertical;
    }
    const O = await this.extractDataStructures(e, AA);
    return this.extractWidths(e, A, O), new Hc(C.name, l, O);
  }
  static buildFontPaths(A, e, i, a) {
    function s(r) {
      const n = `${A.loadedName}_path_${r}`;
      try {
        if (A.renderer.hasBuiltPath(r)) return;
        i.send("commonobj", [n, "FontPath", A.renderer.getPathJs(r)]);
      } catch (g) {
        if (a.ignoreErrors) {
          G(`buildFontPaths - ignoring ${n} glyph: "${g}".`);
          return;
        }
        throw g;
      }
    }
    for (const r of e) {
      s(r.fontChar);
      const n = r.accent;
      n != null && n.fontChar && s(n.fontChar);
    }
  }
  static get fallbackFontDict() {
    const A = new U();
    return A.set("BaseFont", T.get("Helvetica")), A.set("Type", T.get("FallbackType")), A.set("Subtype", T.get("FallbackType")), A.set("Encoding", T.get("WinAnsiEncoding")), sA(this, "fallbackFontDict", A);
  }
};
js = new WeakSet(), yo = async function(A) {
  const e = await fetch(A);
  if (!e.ok) throw new Error(`Failed to fetch file "${A}" with "${e.statusText}".`);
  return new Uint8Array(await e.arrayBuffer());
};
let He = Yr;
class Dn {
  constructor({ loadedName: A, font: e, dict: i, evaluatorOptions: a }) {
    this.loadedName = A, this.font = e, this.dict = i, this._evaluatorOptions = a || nC, this.type3Loaded = null, this.type3Dependencies = e.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
  }
  send(A) {
    this.sent || (this.sent = !0, A.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
  }
  fallback(A) {
    this.font.data && (this.font.disableFontFace = !0, He.buildFontPaths(this.font, this.font.glyphCacheValues, A, this._evaluatorOptions));
  }
  loadType3Data(A, e, i) {
    if (this.type3Loaded) return this.type3Loaded;
    if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
    const a = A.clone({ ignoreErrors: !1 }), s = new Bt(A.type3FontRefs);
    this.dict.objId && !s.has(this.dict.objId) && s.put(this.dict.objId), a.type3FontRefs = s;
    const r = this.font, n = this.type3Dependencies;
    let g = Promise.resolve();
    const o = this.dict.get("CharProcs"), I = this.dict.get("Resources") || e, C = /* @__PURE__ */ Object.create(null), h = nt.normalizeRect(r.bbox || [0, 0, 0, 0]), c = h[2] - h[0], B = h[3] - h[1], l = Math.hypot(c, B);
    for (const Q of o.getKeys()) g = g.then(() => {
      const E = o.get(Q), u = new Lt();
      return a.getOperatorList({ stream: E, task: i, resources: I, operatorList: u }).then(() => {
        u.fnArray[0] === Wg && this._removeType3ColorOperators(u, l), C[Q] = u.getIR();
        for (const f of u.dependencies) n.add(f);
      }).catch(function(f) {
        G(`Type3 font resource "${Q}" is not available.`);
        const d = new Lt();
        C[Q] = d.getIR();
      });
    });
    return this.type3Loaded = g.then(() => {
      r.charProcOperatorList = C, this._bbox && (r.isCharBBox = !0, r.bbox = this._bbox);
    }), this.type3Loaded;
  }
  _removeType3ColorOperators(A, e = NaN) {
    const i = nt.normalizeRect(A.argsArray[0].slice(2)), a = i[2] - i[0], s = i[3] - i[1], r = Math.hypot(a, s);
    a === 0 || s === 0 ? (A.fnArray.splice(0, 1), A.argsArray.splice(0, 1)) : (e === 0 || Math.round(r / e) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], i[0]), this._bbox[1] = Math.min(this._bbox[1], i[1]), this._bbox[2] = Math.max(this._bbox[2], i[2]), this._bbox[3] = Math.max(this._bbox[3], i[3]));
    let n = 0, g = A.length;
    for (; n < g; ) {
      switch (A.fnArray[n]) {
        case Wg:
          break;
        case Wo:
        case qr:
        case Zo:
        case nr:
        case Tr:
        case rr:
        case Oo:
        case tn:
        case Ai:
        case me:
        case Xo:
        case en:
        case gr:
        case P0:
          A.fnArray.splice(n, 1), A.argsArray.splice(n, 1), g--;
          continue;
        case ca:
          const [o] = A.argsArray[n];
          let I = 0, C = o.length;
          for (; I < C; ) {
            const [h] = o[I];
            switch (h) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                o.splice(I, 1), C--;
                continue;
            }
            I++;
          }
      }
      n++;
    }
  }
}
class jn {
  constructor(A = new gC()) {
    this.state = A, this.stateStack = [];
  }
  save() {
    const A = this.state;
    this.stateStack.push(this.state), this.state = A.clone();
  }
  restore() {
    const A = this.stateStack.pop();
    A && (this.state = A);
  }
  transform(A) {
    this.state.ctm = nt.transform(this.state.ctm, A);
  }
}
class XE {
  constructor() {
    this.ctm = new Float32Array(Be), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = Ji, this.textMatrix = Be.slice(), this.textLineMatrix = Be.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
  }
  setTextMatrix(A, e, i, a, s, r) {
    const n = this.textMatrix;
    n[0] = A, n[1] = e, n[2] = i, n[3] = a, n[4] = s, n[5] = r;
  }
  setTextLineMatrix(A, e, i, a, s, r) {
    const n = this.textLineMatrix;
    n[0] = A, n[1] = e, n[2] = i, n[3] = a, n[4] = s, n[5] = r;
  }
  translateTextMatrix(A, e) {
    const i = this.textMatrix;
    i[4] = i[0] * A + i[2] * e + i[4], i[5] = i[1] * A + i[3] * e + i[5];
  }
  translateTextLineMatrix(A, e) {
    const i = this.textLineMatrix;
    i[4] = i[0] * A + i[2] * e + i[4], i[5] = i[1] * A + i[3] * e + i[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const A = Object.create(this);
    return A.textMatrix = this.textMatrix.slice(), A.textLineMatrix = this.textLineMatrix.slice(), A.fontMatrix = this.fontMatrix.slice(), A;
  }
}
class gC {
  constructor() {
    this.ctm = new Float32Array(Be), this.font = null, this.textRenderingMode = Dh, this._fillColorSpace = kA.singletons.gray, this._strokeColorSpace = kA.singletons.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null;
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(A) {
    this._fillColorSpace = this.patternFillColorSpace = A;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(A) {
    this._strokeColorSpace = this.patternStrokeColorSpace = A;
  }
  clone() {
    return Object.create(this);
  }
}
const ua = class ua {
  static get opMap() {
    return sA(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), { w: { id: oB, numArgs: 1, variableArgs: !1 }, J: { id: IB, numArgs: 1, variableArgs: !1 }, j: { id: cB, numArgs: 1, variableArgs: !1 }, M: { id: CB, numArgs: 1, variableArgs: !1 }, d: { id: hB, numArgs: 2, variableArgs: !1 }, ri: { id: P0, numArgs: 1, variableArgs: !1 }, i: { id: BB, numArgs: 1, variableArgs: !1 }, gs: { id: ca, numArgs: 1, variableArgs: !1 }, q: { id: Se, numArgs: 0, variableArgs: !1 }, Q: { id: Wt, numArgs: 0, variableArgs: !1 }, cm: { id: Qi, numArgs: 6, variableArgs: !1 }, m: { id: Is, numArgs: 2, variableArgs: !1 }, l: { id: Un, numArgs: 2, variableArgs: !1 }, c: { id: W0, numArgs: 6, variableArgs: !1 }, v: { id: Z0, numArgs: 4, variableArgs: !1 }, y: { id: O0, numArgs: 4, variableArgs: !1 }, h: { id: X0, numArgs: 0, variableArgs: !1 }, re: { id: Mn, numArgs: 4, variableArgs: !1 }, S: { id: lB, numArgs: 0, variableArgs: !1 }, s: { id: QB, numArgs: 0, variableArgs: !1 }, f: { id: OI, numArgs: 0, variableArgs: !1 }, F: { id: OI, numArgs: 0, variableArgs: !1 }, "f*": { id: EB, numArgs: 0, variableArgs: !1 }, B: { id: uB, numArgs: 0, variableArgs: !1 }, "B*": { id: dB, numArgs: 0, variableArgs: !1 }, b: { id: fB, numArgs: 0, variableArgs: !1 }, "b*": { id: pB, numArgs: 0, variableArgs: !1 }, n: { id: XI, numArgs: 0, variableArgs: !1 }, W: { id: mB, numArgs: 0, variableArgs: !1 }, "W*": { id: yB, numArgs: 0, variableArgs: !1 }, BT: { id: ps, numArgs: 0, variableArgs: !1 }, ET: { id: ms, numArgs: 0, variableArgs: !1 }, Tc: { id: Tg, numArgs: 1, variableArgs: !1 }, Tw: { id: Pg, numArgs: 1, variableArgs: !1 }, Tz: { id: V0, numArgs: 1, variableArgs: !1 }, TL: { id: j0, numArgs: 1, variableArgs: !1 }, Tf: { id: li, numArgs: 2, variableArgs: !1 }, Tr: { id: z0, numArgs: 1, variableArgs: !1 }, Ts: { id: _0, numArgs: 1, variableArgs: !1 }, Td: { id: $0, numArgs: 2, variableArgs: !1 }, TD: { id: A1, numArgs: 2, variableArgs: !1 }, Tm: { id: ys, numArgs: 6, variableArgs: !1 }, "T*": { id: Ln, numArgs: 0, variableArgs: !1 }, Tj: { id: Je, numArgs: 1, variableArgs: !1 }, TJ: { id: ir, numArgs: 1, variableArgs: !1 }, "'": { id: ar, numArgs: 1, variableArgs: !1 }, '"': { id: sr, numArgs: 3, variableArgs: !1 }, d0: { id: wB, numArgs: 2, variableArgs: !1 }, d1: { id: Wg, numArgs: 6, variableArgs: !1 }, CS: { id: Wo, numArgs: 1, variableArgs: !1 }, cs: { id: qr, numArgs: 1, variableArgs: !1 }, SC: { id: Zo, numArgs: 4, variableArgs: !0 }, SCN: { id: nr, numArgs: 33, variableArgs: !0 }, sc: { id: Tr, numArgs: 4, variableArgs: !0 }, scn: { id: rr, numArgs: 33, variableArgs: !0 }, G: { id: Oo, numArgs: 1, variableArgs: !1 }, g: { id: tn, numArgs: 1, variableArgs: !1 }, RG: { id: Ai, numArgs: 3, variableArgs: !1 }, rg: { id: me, numArgs: 3, variableArgs: !1 }, K: { id: Xo, numArgs: 4, variableArgs: !1 }, k: { id: en, numArgs: 4, variableArgs: !1 }, sh: { id: gr, numArgs: 1, variableArgs: !1 }, BI: { id: DB, numArgs: 0, variableArgs: !1 }, ID: { id: bB, numArgs: 0, variableArgs: !1 }, EI: { id: t1, numArgs: 1, variableArgs: !1 }, Do: { id: Zg, numArgs: 1, variableArgs: !1 }, MP: { id: e1, numArgs: 1, variableArgs: !1 }, DP: { id: i1, numArgs: 2, variableArgs: !1 }, BMC: { id: a1, numArgs: 1, variableArgs: !1 }, BDC: { id: ye, numArgs: 2, variableArgs: !1 }, EMC: { id: Ra, numArgs: 0, variableArgs: !1 }, BX: { id: s1, numArgs: 0, variableArgs: !1 }, EX: { id: n1, numArgs: 0, variableArgs: !1 }, BM: null, BD: null, true: null, fa: null, fal: null, fals: null, false: null, nu: null, nul: null, null: null }));
  }
  constructor(A, e, i = new jn()) {
    this.parser = new ti({ lexer: new Ce(A, ua.opMap), xref: e }), this.stateManager = i, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(A) {
    let e = A.args;
    for (; ; ) {
      const i = this.parser.getObj();
      if (i instanceof ot) {
        const a = i.cmd, s = ua.opMap[a];
        if (!s) {
          G(`Unknown command "${a}".`);
          continue;
        }
        const r = s.id, n = s.numArgs;
        let g = e !== null ? e.length : 0;
        if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = r >= Is && r <= XI, s.variableArgs) g > n && RA(`Command ${a}: expected [0, ${n}] args, but received ${g} args.`);
        else {
          if (g !== n) {
            const o = this.nonProcessedArgs;
            for (; g > n; )
              o.push(e.shift()), g--;
            for (; g < n && o.length !== 0; )
              e === null && (e = []), e.unshift(o.pop()), g++;
          }
          if (g < n) {
            const o = `command ${a}: expected ${n} args, but received ${g} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > ua.MAX_INVALID_PATH_OPS) throw new X(`Invalid ${o}`);
            G(`Skipping ${o}`), e !== null && (e.length = 0);
            continue;
          }
        }
        return this.preprocessCommand(r, e), A.fn = r, A.args = e, !0;
      }
      if (i === lt) return !1;
      if (i !== null && (e === null && (e = []), e.push(i), e.length > 33))
        throw new X("Too many arguments");
    }
  }
  preprocessCommand(A, e) {
    switch (0 | A) {
      case Se:
        this.stateManager.save();
        break;
      case Wt:
        this.stateManager.restore();
        break;
      case Qi:
        this.stateManager.transform(e);
    }
  }
};
Ft(ua, "MAX_INVALID_PATH_OPS", 10);
let Ma = ua;
class VE extends Ma {
  constructor(A) {
    super(new Ht(A));
  }
  parse() {
    const A = { fn: 0, args: [] }, e = { fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3) };
    try {
      for (; A.args.length = 0, !!this.read(A); ) {
        if (this.savedStatesDepth !== 0) continue;
        const { fn: i, args: a } = A;
        switch (0 | i) {
          case li:
            const [s, r] = a;
            s instanceof T && (e.fontName = s.name), typeof r == "number" && r > 0 && (e.fontSize = r);
            break;
          case me:
            kA.singletons.rgb.getRgbItem(a, 0, e.fontColor, 0);
            break;
          case tn:
            kA.singletons.gray.getRgbItem(a, 0, e.fontColor, 0);
            break;
          case en:
            kA.singletons.cmyk.getRgbItem(a, 0, e.fontColor, 0);
        }
      }
    } catch (i) {
      G(`parseDefaultAppearance - ignoring errors: "${i}".`);
    }
    return e;
  }
}
function II(t) {
  return new VE(t).parse();
}
class jE extends Ma {
  constructor(A, e, i) {
    var a;
    super(A), this.stream = A, this.evaluatorOptions = e, this.xref = i, this.resources = (a = A.dict) == null ? void 0 : a.get("Resources");
  }
  parse() {
    const A = { fn: 0, args: [] };
    let e = { scaleFactor: 1, fontSize: 0, fontName: "", fontColor: new Uint8ClampedArray(3), fillColorSpace: kA.singletons.gray }, i = !1;
    const a = [];
    try {
      for (; A.args.length = 0, !(i || !this.read(A)); ) {
        const { fn: s, args: r } = A;
        switch (0 | s) {
          case Se:
            a.push({ scaleFactor: e.scaleFactor, fontSize: e.fontSize, fontName: e.fontName, fontColor: e.fontColor.slice(), fillColorSpace: e.fillColorSpace });
            break;
          case Wt:
            e = a.pop() || e;
            break;
          case ys:
            e.scaleFactor *= Math.hypot(r[0], r[1]);
            break;
          case li:
            const [n, g] = r;
            n instanceof T && (e.fontName = n.name), typeof g == "number" && g > 0 && (e.fontSize = g * e.scaleFactor);
            break;
          case qr:
            e.fillColorSpace = kA.parse({ cs: r[0], xref: this.xref, resources: this.resources, pdfFunctionFactory: this._pdfFunctionFactory, localColorSpaceCache: this._localColorSpaceCache });
            break;
          case Tr:
            e.fillColorSpace.getRgbItem(r, 0, e.fontColor, 0);
            break;
          case me:
            kA.singletons.rgb.getRgbItem(r, 0, e.fontColor, 0);
            break;
          case tn:
            kA.singletons.gray.getRgbItem(r, 0, e.fontColor, 0);
            break;
          case en:
            kA.singletons.cmyk.getRgbItem(r, 0, e.fontColor, 0);
            break;
          case Je:
          case ir:
          case ar:
          case sr:
            i = !0;
        }
      }
    } catch (s) {
      G(`parseAppearanceStream - ignoring errors: "${s}".`);
    }
    return this.stream.reset(), delete e.scaleFactor, delete e.fillColorSpace, e;
  }
  get _localColorSpaceCache() {
    return sA(this, "_localColorSpaceCache", new AC());
  }
  get _pdfFunctionFactory() {
    return sA(this, "_pdfFunctionFactory", new eC({ xref: this.xref, isEvalSupported: this.evaluatorOptions.isEvalSupported }));
  }
}
function Ke(t, A) {
  return t[0] === t[1] && t[1] === t[2] ? `${vA(t[0] / 255)} ${A ? "g" : "G"}` : Array.from(t, (e) => vA(e / 255)).join(" ") + " " + (A ? "rg" : "RG");
}
class we {
  constructor(A, e) {
    this.xref = A, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = e;
    const i = new OffscreenCanvas(1, 1);
    this.ctxMeasure = i.getContext("2d", { willReadFrequently: !0 }), we._fontNameId || (we._fontNameId = 1), this.fontName = T.get(`InvalidPDFjsFont_${e}_${we._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!we._fontDescriptorRef) {
      const A = new U(this.xref);
      A.set("Type", T.get("FontDescriptor")), A.set("FontName", this.fontName), A.set("FontFamily", "MyriadPro Regular"), A.set("FontBBox", [0, 0, 0, 0]), A.set("FontStretch", T.get("Normal")), A.set("FontWeight", 400), A.set("ItalicAngle", 0), we._fontDescriptorRef = this.xref.getNewPersistentRef(A);
    }
    return we._fontDescriptorRef;
  }
  get descendantFontRef() {
    const A = new U(this.xref);
    A.set("BaseFont", this.fontName), A.set("Type", T.get("Font")), A.set("Subtype", T.get("CIDFontType0")), A.set("CIDToGIDMap", T.get("Identity")), A.set("FirstChar", this.firstChar), A.set("LastChar", this.lastChar), A.set("FontDescriptor", this.fontDescriptorRef), A.set("DW", 1e3);
    const e = [], i = [...this.widths.entries()].sort();
    let a = null, s = null;
    for (const [n, g] of i) a ? n === a + s.length ? s.push(g) : (e.push(a, s), a = n, s = [g]) : (a = n, s = [g]);
    a && e.push(a, s), A.set("W", e);
    const r = new U(this.xref);
    return r.set("Ordering", "Identity"), r.set("Registry", "Adobe"), r.set("Supplement", 0), A.set("CIDSystemInfo", r), this.xref.getNewPersistentRef(A);
  }
  get baseFontRef() {
    const A = new U(this.xref);
    return A.set("BaseFont", this.fontName), A.set("Type", T.get("Font")), A.set("Subtype", T.get("Type0")), A.set("Encoding", T.get("Identity-H")), A.set("DescendantFonts", [this.descendantFontRef]), A.set("ToUnicode", T.get("Identity-H")), this.xref.getNewPersistentRef(A);
  }
  get resources() {
    const A = new U(this.xref), e = new U(this.xref);
    return e.set(this.fontName.name, this.baseFontRef), A.set("Font", e), A;
  }
  _createContext() {
    return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
  }
  createFontResources(A) {
    const e = this._createContext();
    for (const i of A.split(/\r\n?|\n/)) for (const a of i.split("")) {
      const s = a.charCodeAt(0);
      if (this.widths.has(s)) continue;
      const r = e.measureText(a), n = Math.ceil(r.width);
      this.widths.set(s, n), this.firstChar = Math.min(s, this.firstChar), this.lastChar = Math.max(s, this.lastChar);
    }
    return this.resources;
  }
  static getFirstPositionInfo(A, e, i) {
    const [a, s, r, n] = A;
    let g = r - a, o = n - s;
    e % 180 != 0 && ([g, o] = [o, g]);
    const I = Hi * i;
    return { coords: [0, o + UI * i - I], bbox: [0, 0, g, o], matrix: e !== 0 ? Qr(e, o, I) : void 0 };
  }
  createAppearance(A, e, i, a, s, r) {
    const n = this._createContext(), g = [];
    let o = -1 / 0;
    for (const Y of A.split(/\r\n?|\n/)) {
      g.push(Y);
      const V = n.measureText(Y).width;
      o = Math.max(o, V);
      for (const eA of XB(Y)) {
        const AA = String.fromCodePoint(eA);
        let O = this.widths.get(eA);
        if (O === void 0) {
          const L = n.measureText(AA);
          O = Math.ceil(L.width), this.widths.set(eA, O), this.firstChar = Math.min(eA, this.firstChar), this.lastChar = Math.max(eA, this.lastChar);
        }
      }
    }
    o *= a / 1e3;
    const [I, C, h, c] = e;
    let B = h - I, l = c - C;
    i % 180 != 0 && ([B, l] = [l, B]);
    let Q = 1;
    o > B && (Q = B / o);
    let E = 1;
    const u = Hi * a, f = UI * a, d = u * g.length;
    d > l && (E = l / d);
    const p = a * Math.min(Q, E), m = ["q", `0 0 ${vA(B)} ${vA(l)} re W n`, "BT", `1 0 0 1 0 ${vA(l + f)} Tm 0 Tc ${Ke(s, !0)}`, `/${this.fontName.name} ${vA(p)} Tf`], { resources: y } = this;
    if ((r = typeof r == "number" && r >= 0 && r <= 1 ? r : 1) !== 1) {
      m.push("/R0 gs");
      const Y = new U(this.xref), V = new U(this.xref);
      V.set("ca", r), V.set("CA", r), V.set("Type", T.get("ExtGState")), Y.set("R0", V), y.set("ExtGState", Y);
    }
    const b = vA(u);
    for (const Y of g) m.push(`0 -${b} Td <${jB(Y)}> Tj`);
    m.push("ET", "Q");
    const D = m.join(`
`), R = new U(this.xref);
    if (R.set("Subtype", T.get("Form")), R.set("Type", T.get("XObject")), R.set("BBox", [0, 0, B, l]), R.set("Length", D.length), R.set("Resources", y), i) {
      const Y = Qr(i, B, l);
      R.set("Matrix", Y);
    }
    const k = new Ht(D);
    return k.dict = R, k;
  }
}
class oC {
  constructor(A, e, i) {
    this.root = A, this.xref = e, this._type = i;
  }
  getAll() {
    const A = /* @__PURE__ */ new Map();
    if (!this.root) return A;
    const e = this.xref, i = new Bt();
    i.put(this.root);
    const a = [this.root];
    for (; a.length > 0; ) {
      const s = e.fetchIfRef(a.shift());
      if (!(s instanceof U)) continue;
      if (s.has("Kids")) {
        const n = s.get("Kids");
        if (!Array.isArray(n)) continue;
        for (const g of n) {
          if (i.has(g)) throw new X(`Duplicate entry in "${this._type}" tree.`);
          a.push(g), i.put(g);
        }
        continue;
      }
      const r = s.get(this._type);
      if (Array.isArray(r)) for (let n = 0, g = r.length; n < g; n += 2) A.set(e.fetchIfRef(r[n]), e.fetchIfRef(r[n + 1]));
    }
    return A;
  }
  getRaw(A) {
    if (!this.root) return null;
    const e = this.xref;
    let i = e.fetchIfRef(this.root), a = 0;
    for (; i.has("Kids"); ) {
      if (++a > 10)
        return G(`Search depth limit reached for "${this._type}" tree.`), null;
      const r = i.get("Kids");
      if (!Array.isArray(r)) return null;
      let n = 0, g = r.length - 1;
      for (; n <= g; ) {
        const o = n + g >> 1, I = e.fetchIfRef(r[o]), C = I.get("Limits");
        if (A < e.fetchIfRef(C[0])) g = o - 1;
        else {
          if (!(A > e.fetchIfRef(C[1]))) {
            i = I;
            break;
          }
          n = o + 1;
        }
      }
      if (n > g) return null;
    }
    const s = i.get(this._type);
    if (Array.isArray(s)) {
      let r = 0, n = s.length - 2;
      for (; r <= n; ) {
        const g = r + n >> 1, o = g + (1 & g), I = e.fetchIfRef(s[o]);
        if (A < I) n = o - 2;
        else {
          if (!(A > I)) return s[o + 1];
          r = o + 2;
        }
      }
    }
    return null;
  }
  get(A) {
    return this.xref.fetchIfRef(this.getRaw(A));
  }
}
class Aa extends oC {
  constructor(A, e) {
    super(A, e, "Names");
  }
}
class pr extends oC {
  constructor(A, e) {
    super(A, e, "Nums");
  }
}
function cI() {
  (function() {
    Vn = /* @__PURE__ */ Object.create(null);
  })(), function() {
    Hn = /* @__PURE__ */ Object.create(null), Yn = /* @__PURE__ */ Object.create(null), ea = /* @__PURE__ */ Object.create(null);
  }(), function() {
    co.clear();
  }(), Or.cleanup();
}
function A0(t) {
  return t instanceof U ? t.has("UF") ? t.get("UF") : t.has("F") ? t.get("F") : t.has("Unix") ? t.get("Unix") : t.has("Mac") ? t.get("Mac") : t.has("DOS") ? t.get("DOS") : null : null;
}
var zs;
class wo {
  constructor(A, e, i = !1) {
    MA(this, zs, !1);
    A instanceof U && (this.xref = e, this.root = A, A.has("FS") && (this.fs = A.get("FS")), A.has("RF") && G("Related file specifications are not supported"), i || (A.has("EF") ? Vt(this, zs, !0) : G("Non-embedded file specifications are not supported")));
  }
  get filename() {
    let A = "";
    const e = A0(this.root);
    return e && typeof e == "string" && (A = LA(e).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), sA(this, "filename", A || "unnamed");
  }
  get content() {
    var e;
    if (!NA(this, zs)) return null;
    this._contentRef || (this._contentRef = A0((e = this.root) == null ? void 0 : e.get("EF")));
    let A = null;
    if (this._contentRef) {
      const i = this.xref.fetchIfRef(this._contentRef);
      i instanceof FA ? A = i.getBytes() : G("Embedded file specification points to non-existing/invalid content");
    } else G("Embedded file specification does not have any content");
    return A;
  }
  get description() {
    var i;
    let A = "";
    const e = (i = this.root) == null ? void 0 : i.get("Desc");
    return e && typeof e == "string" && (A = LA(e)), sA(this, "description", A);
  }
  get serializable() {
    return { rawFilename: this.filename, filename: (A = this.filename, A.substring(A.lastIndexOf("/") + 1)), content: this.content, description: this.description };
    var A;
  }
}
zs = new WeakMap();
const hs = 0, zE = -2, _E = -3, t0 = -4, $E = -5, e0 = -6, i0 = -9;
function ga(t, A) {
  const e = t[A];
  return e === " " || e === `
` || e === "\r" || e === "	";
}
class IC {
  _resolveEntities(A) {
    return A.replaceAll(/&([^;]+);/g, (e, i) => {
      if (i.substring(0, 2) === "#x") return String.fromCodePoint(parseInt(i.substring(2), 16));
      if (i.substring(0, 1) === "#") return String.fromCodePoint(parseInt(i.substring(1), 10));
      switch (i) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(i);
    });
  }
  _parseContent(A, e) {
    const i = [];
    let a = e;
    function s() {
      for (; a < A.length && ga(A, a); ) ++a;
    }
    for (; a < A.length && !ga(A, a) && A[a] !== ">" && A[a] !== "/"; ) ++a;
    const r = A.substring(e, a);
    for (s(); a < A.length && A[a] !== ">" && A[a] !== "/" && A[a] !== "?"; ) {
      s();
      let n = "", g = "";
      for (; a < A.length && !ga(A, a) && A[a] !== "="; )
        n += A[a], ++a;
      if (s(), A[a] !== "=") return null;
      ++a, s();
      const o = A[a];
      if (o !== '"' && o !== "'") return null;
      const I = A.indexOf(o, ++a);
      if (I < 0) return null;
      g = A.substring(a, I), i.push({ name: n, value: this._resolveEntities(g) }), a = I + 1, s();
    }
    return { name: r, attributes: i, parsed: a - e };
  }
  _parseProcessingInstruction(A, e) {
    let i = e;
    for (; i < A.length && !ga(A, i) && A[i] !== ">" && A[i] !== "?" && A[i] !== "/"; ) ++i;
    const a = A.substring(e, i);
    (function() {
      for (; i < A.length && ga(A, i); ) ++i;
    })();
    const s = i;
    for (; i < A.length && (A[i] !== "?" || A[i + 1] !== ">"); ) ++i;
    return { name: a, value: A.substring(s, i), parsed: i - e };
  }
  parseXml(A) {
    let e = 0;
    for (; e < A.length; ) {
      let i = e;
      if (A[e] === "<") {
        ++i;
        let a;
        switch (A[i]) {
          case "/":
            if (++i, a = A.indexOf(">", i), a < 0) {
              this.onError(i0);
              return;
            }
            this.onEndElement(A.substring(i, a)), i = a + 1;
            break;
          case "?":
            ++i;
            const s = this._parseProcessingInstruction(A, i);
            if (A.substring(i + s.parsed, i + s.parsed + 2) !== "?>") {
              this.onError(_E);
              return;
            }
            this.onPi(s.name, s.value), i += s.parsed + 2;
            break;
          case "!":
            if (A.substring(i + 1, i + 3) === "--") {
              if (a = A.indexOf("-->", i + 3), a < 0) {
                this.onError($E);
                return;
              }
              this.onComment(A.substring(i + 3, a)), i = a + 3;
            } else if (A.substring(i + 1, i + 8) === "[CDATA[") {
              if (a = A.indexOf("]]>", i + 8), a < 0) {
                this.onError(zE);
                return;
              }
              this.onCdata(A.substring(i + 8, a)), i = a + 3;
            } else {
              if (A.substring(i + 1, i + 8) !== "DOCTYPE") {
                this.onError(e0);
                return;
              }
              {
                const g = A.indexOf("[", i + 8);
                let o = !1;
                if (a = A.indexOf(">", i + 8), a < 0) {
                  this.onError(t0);
                  return;
                }
                if (g > 0 && a > g) {
                  if (a = A.indexOf("]>", i + 8), a < 0) {
                    this.onError(t0);
                    return;
                  }
                  o = !0;
                }
                const I = A.substring(i + 8, a + (o ? 1 : 0));
                this.onDoctype(I), i = a + (o ? 2 : 1);
              }
            }
            break;
          default:
            const r = this._parseContent(A, i);
            if (r === null) {
              this.onError(e0);
              return;
            }
            let n = !1;
            if (A.substring(i + r.parsed, i + r.parsed + 2) === "/>") n = !0;
            else if (A.substring(i + r.parsed, i + r.parsed + 1) !== ">") {
              this.onError(i0);
              return;
            }
            this.onBeginElement(r.name, r.attributes, n), i += r.parsed + (n ? 2 : 1);
        }
      } else {
        for (; i < A.length && A[i] !== "<"; ) i++;
        const a = A.substring(e, i);
        this.onText(this._resolveEntities(a));
      }
      e = i;
    }
  }
  onResolveEntity(A) {
    return `&${A};`;
  }
  onPi(A, e) {
  }
  onComment(A) {
  }
  onCdata(A) {
  }
  onDoctype(A) {
  }
  onText(A) {
  }
  onBeginElement(A, e, i) {
  }
  onEndElement(A) {
  }
  onError(A) {
  }
}
class Bs {
  constructor(A, e) {
    this.nodeName = A, this.nodeValue = e, Object.defineProperty(this, "parentNode", { value: null, writable: !0 });
  }
  get firstChild() {
    var A;
    return (A = this.childNodes) == null ? void 0 : A[0];
  }
  get nextSibling() {
    const A = this.parentNode.childNodes;
    if (!A) return;
    const e = A.indexOf(this);
    return e !== -1 ? A[e + 1] : void 0;
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map(function(A) {
      return A.textContent;
    }).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    var A;
    return ((A = this.childNodes) == null ? void 0 : A.length) > 0;
  }
  searchNode(A, e) {
    var r;
    if (e >= A.length) return this;
    const i = A[e];
    if (i.name.startsWith("#") && e < A.length - 1) return this.searchNode(A, e + 1);
    const a = [];
    let s = this;
    for (; ; ) {
      if (i.name === s.nodeName) {
        if (i.pos !== 0) {
          if (a.length === 0) return null;
          {
            const [n] = a.pop();
            let g = 0;
            for (const o of n.childNodes) if (i.name === o.nodeName) {
              if (g === i.pos) return o.searchNode(A, e + 1);
              g++;
            }
            return s.searchNode(A, e + 1);
          }
        }
        {
          const n = s.searchNode(A, e + 1);
          if (n !== null) return n;
        }
      }
      if (((r = s.childNodes) == null ? void 0 : r.length) > 0)
        a.push([s, 0]), s = s.childNodes[0];
      else {
        if (a.length === 0) return null;
        for (; a.length !== 0; ) {
          const [n, g] = a.pop(), o = g + 1;
          if (o < n.childNodes.length) {
            a.push([n, o]), s = n.childNodes[o];
            break;
          }
        }
        if (a.length === 0) return null;
      }
    }
  }
  dump(A) {
    if (this.nodeName !== "#text") {
      if (A.push(`<${this.nodeName}`), this.attributes) for (const e of this.attributes) A.push(` ${e.name}="${pa(e.value)}"`);
      if (this.hasChildNodes()) {
        A.push(">");
        for (const e of this.childNodes) e.dump(A);
        A.push(`</${this.nodeName}>`);
      } else this.nodeValue ? A.push(`>${pa(this.nodeValue)}</${this.nodeName}>`) : A.push("/>");
    } else A.push(pa(this.nodeValue));
  }
}
class jr extends IC {
  constructor({ hasAttributes: A = !1, lowerCaseName: e = !1 }) {
    super(), this._currentFragment = null, this._stack = null, this._errorCode = hs, this._hasAttributes = A, this._lowerCaseName = e;
  }
  parseFromString(A) {
    if (this._currentFragment = [], this._stack = [], this._errorCode = hs, this.parseXml(A), this._errorCode !== hs) return;
    const [e] = this._currentFragment;
    return e ? { documentElement: e } : void 0;
  }
  onText(A) {
    if (function(a) {
      for (let s = 0, r = a.length; s < r; s++) if (!ga(a, s)) return !1;
      return !0;
    }(A)) return;
    const e = new Bs("#text", A);
    this._currentFragment.push(e);
  }
  onCdata(A) {
    const e = new Bs("#text", A);
    this._currentFragment.push(e);
  }
  onBeginElement(A, e, i) {
    this._lowerCaseName && (A = A.toLowerCase());
    const a = new Bs(A);
    a.childNodes = [], this._hasAttributes && (a.attributes = e), this._currentFragment.push(a), i || (this._stack.push(this._currentFragment), this._currentFragment = a.childNodes);
  }
  onEndElement(A) {
    this._currentFragment = this._stack.pop() || [];
    const e = this._currentFragment.at(-1);
    if (!e) return null;
    for (const i of e.childNodes) i.parentNode = e;
    return e;
  }
  onError(A) {
    this._errorCode = A;
  }
}
class A2 {
  constructor(A) {
    A = this._repair(A);
    const e = new jr({ lowerCaseName: !0 }).parseFromString(A);
    this._metadataMap = /* @__PURE__ */ new Map(), this._data = A, e && this._parse(e);
  }
  _repair(A) {
    return A.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e, i) {
      const a = i.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(r, n, g, o) {
        return String.fromCharCode(64 * n + 8 * g + 1 * o);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(r, n) {
        switch (n) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${n} isn't defined.`);
      }), s = [">"];
      for (let r = 0, n = a.length; r < n; r += 2) {
        const g = 256 * a.charCodeAt(r) + a.charCodeAt(r + 1);
        g >= 32 && g < 127 && g !== 60 && g !== 62 && g !== 38 ? s.push(String.fromCharCode(g)) : s.push("&#x" + (65536 + g).toString(16).substring(1) + ";");
      }
      return s.join("");
    });
  }
  _getSequence(A) {
    const e = A.nodeName;
    return e !== "rdf:bag" && e !== "rdf:seq" && e !== "rdf:alt" ? null : A.childNodes.filter((i) => i.nodeName === "rdf:li");
  }
  _parseArray(A) {
    if (!A.hasChildNodes()) return;
    const [e] = A.childNodes, i = this._getSequence(e) || [];
    this._metadataMap.set(A.nodeName, i.map((a) => a.textContent.trim()));
  }
  _parse(A) {
    let e = A.documentElement;
    if (e.nodeName !== "rdf:rdf")
      for (e = e.firstChild; e && e.nodeName !== "rdf:rdf"; ) e = e.nextSibling;
    if (e && e.nodeName === "rdf:rdf" && e.hasChildNodes()) {
      for (const i of e.childNodes) if (i.nodeName === "rdf:description") for (const a of i.childNodes) {
        const s = a.nodeName;
        switch (s) {
          case "#text":
            continue;
          case "dc:creator":
          case "dc:subject":
            this._parseArray(a);
            continue;
        }
        this._metadataMap.set(s, a.textContent.trim());
      }
    }
  }
  get serializable() {
    return { parsedData: this._metadataMap, rawData: this._data };
  }
}
const cC = 1, CC = 2, Do = 3, hC = 4, bo = 5;
var vr, BC, re, ko, Fo, lC, QC;
const Ui = class Ui {
  constructor(A, e) {
    MA(this, vr);
    this.dict = A, this.ref = e instanceof rA ? e : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  addAnnotationIdToPage(A, e) {
    CA(this, vr, BC).call(this, A, e, hC);
  }
  readRoleMap() {
    const A = this.dict.get("RoleMap");
    if (A instanceof U) for (const [e, i] of A) i instanceof T && this.roleMap.set(e, i.name);
  }
  static async canCreateStructureTree({ catalogRef: A, pdfManager: e, newAnnotationsByPage: i }) {
    var r;
    if (!(A instanceof rA))
      return G("Cannot save the struct tree: no catalog reference."), !1;
    let a = 0, s = !0;
    for (const [n, g] of i) {
      const { ref: o } = await e.getPage(n);
      if (!(o instanceof rA)) {
        G(`Cannot save the struct tree: page ${n} has no ref.`), s = !0;
        break;
      }
      for (const I of g) (r = I.accessibilityData) != null && r.type && (I.parentTreeId = a++, s = !1);
    }
    if (s) {
      for (const n of i.values()) for (const g of n) delete g.parentTreeId;
      return !1;
    }
    return !0;
  }
  static async createStructureTree({ newAnnotationsByPage: A, xref: e, catalogRef: i, pdfManager: a, changes: s }) {
    const r = a.catalog.cloneDict(), n = new xt();
    n.put(i, r);
    const g = e.getNewTemporaryRef();
    r.set("StructTreeRoot", g);
    const o = new U(e);
    o.set("Type", T.get("StructTreeRoot"));
    const I = e.getNewTemporaryRef();
    o.set("ParentTree", I);
    const C = [];
    o.set("K", C), n.put(g, o);
    const h = new U(e), c = [];
    h.set("Nums", c);
    const B = await CA(this, re, ko).call(this, { newAnnotationsByPage: A, structTreeRootRef: g, structTreeRoot: null, kids: C, nums: c, xref: e, pdfManager: a, changes: s, cache: n });
    o.set("ParentTreeNextKey", B), n.put(I, h);
    for (const [l, Q] of n.items()) s.put(l, { data: Q });
  }
  async canUpdateStructTree({ pdfManager: A, xref: e, newAnnotationsByPage: i }) {
    var o, I;
    if (!this.ref)
      return G("Cannot update the struct tree: no root reference."), !1;
    let a = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(a) || a < 0)
      return G("Cannot update the struct tree: invalid next key."), !1;
    const s = this.dict.get("ParentTree");
    if (!(s instanceof U))
      return G("Cannot update the struct tree: ParentTree isn't a dict."), !1;
    const r = s.get("Nums");
    if (!Array.isArray(r))
      return G("Cannot update the struct tree: nums isn't an array."), !1;
    const n = new pr(s, e);
    for (const C of i.keys()) {
      const { pageDict: h } = await A.getPage(C);
      if (!h.has("StructParents")) continue;
      const c = h.get("StructParents");
      if (!Number.isInteger(c) || !Array.isArray(n.get(c)))
        return G(`Cannot save the struct tree: page ${C} has a wrong id.`), !1;
    }
    let g = !0;
    for (const [C, h] of i) {
      const { pageDict: c } = await A.getPage(C);
      CA(o = Ui, re, lC).call(o, { elements: h, xref: this.dict.xref, pageDict: c, numberTree: n });
      for (const B of h) (I = B.accessibilityData) != null && I.type && (B.accessibilityData.structParent >= 0 || (B.parentTreeId = a++), g = !1);
    }
    if (g) {
      for (const C of i.values()) for (const h of C)
        delete h.parentTreeId, delete h.structTreeParent;
      return !1;
    }
    return !0;
  }
  async updateStructureTree({ newAnnotationsByPage: A, pdfManager: e, changes: i }) {
    var c;
    const a = this.dict.xref, s = this.dict.clone(), r = this.ref, n = new xt();
    n.put(r, s);
    let g, o = s.getRaw("ParentTree");
    o instanceof rA ? g = a.fetch(o) : (g = o, o = a.getNewTemporaryRef(), s.set("ParentTree", o)), g = g.clone(), n.put(o, g);
    let I = g.getRaw("Nums"), C = null;
    I instanceof rA && (C = I, I = a.fetch(C)), I = I.slice(), C || g.set("Nums", I);
    const h = await CA(c = Ui, re, ko).call(c, { newAnnotationsByPage: A, structTreeRootRef: r, structTreeRoot: this, kids: null, nums: I, xref: a, pdfManager: e, changes: i, cache: n });
    if (h !== -1) {
      s.set("ParentTreeNextKey", h), C && n.put(C, I);
      for (const [B, l] of n.items()) i.put(B, { data: l });
    }
  }
};
vr = new WeakSet(), BC = function(A, e, i) {
  if (!(A instanceof rA) || e < 0) return;
  this.structParentIds || (this.structParentIds = new xt());
  let a = this.structParentIds.get(A);
  a || (a = [], this.structParentIds.put(A, a)), a.push([e, i]);
}, re = new WeakSet(), ko = async function({ newAnnotationsByPage: A, structTreeRootRef: e, structTreeRoot: i, kids: a, nums: s, xref: r, pdfManager: n, changes: g, cache: o }) {
  var c, B;
  const I = T.get("OBJR");
  let C, h = -1;
  for (const [l, Q] of A) {
    const E = await n.getPage(l), { ref: u } = E, f = u instanceof rA;
    for (const { accessibilityData: d, ref: p, parentTreeId: m, structTreeParent: y } of Q) {
      if (!(d != null && d.type)) continue;
      const { structParent: b } = d;
      if (i && Number.isInteger(b) && b >= 0) {
        let Y = (C || (C = /* @__PURE__ */ new Map())).get(l);
        Y === void 0 && (Y = new EC(i, E.pageDict).collectObjects(u), C.set(l, Y));
        const V = Y == null ? void 0 : Y.get(b);
        if (V) {
          const eA = r.fetch(V).clone();
          CA(c = Ui, re, Fo).call(c, eA, d), g.put(V, { data: eA });
          continue;
        }
      }
      h = Math.max(h, m);
      const D = r.getNewTemporaryRef(), R = new U(r);
      CA(B = Ui, re, Fo).call(B, R, d), await CA(this, re, QC).call(this, { structTreeParent: y, tagDict: R, newTagRef: D, structTreeRootRef: e, fallbackKids: a, xref: r, cache: o });
      const k = new U(r);
      R.set("K", k), k.set("Type", I), f && k.set("Pg", u), k.set("Obj", p), o.put(D, R), s.push(m, D);
    }
  }
  return h + 1;
}, Fo = function(A, { type: e, title: i, lang: a, alt: s, expanded: r, actualText: n }) {
  A.set("S", T.get(e)), i && A.set("T", ie(i)), a && A.set("Lang", ie(a)), s && A.set("Alt", ie(s)), r && A.set("E", ie(r)), n && A.set("ActualText", ie(n));
}, lC = function({ elements: A, xref: e, pageDict: i, numberTree: a }) {
  const s = /* @__PURE__ */ new Map();
  for (const o of A) if (o.structTreeParentId) {
    const I = parseInt(o.structTreeParentId.split("_mc")[1], 10);
    let C = s.get(I);
    C || (C = [], s.set(I, C)), C.push(o);
  }
  const r = i.get("StructParents");
  if (!Number.isInteger(r)) return;
  const n = a.get(r), g = (o, I, C) => {
    const h = s.get(o);
    if (h) {
      const c = I.getRaw("P"), B = e.fetchIfRef(c);
      if (c instanceof rA && B instanceof U) {
        const l = { ref: C, dict: I };
        for (const Q of h) Q.structTreeParent = l;
      }
      return !0;
    }
    return !1;
  };
  for (const o of n) {
    if (!(o instanceof rA)) continue;
    const I = e.fetch(o), C = I.get("K");
    if (Number.isInteger(C)) g(C, I, o);
    else if (Array.isArray(C)) for (let h of C) {
      if (h = e.fetchIfRef(h), Number.isInteger(h) && g(h, I, o)) break;
      if (!(h instanceof U)) continue;
      if (!it(h.get("Type"), "MCR")) break;
      const c = h.get("MCID");
      if (Number.isInteger(c) && g(c, I, o)) break;
    }
  }
}, QC = async function({ structTreeParent: A, tagDict: e, newTagRef: i, structTreeRootRef: a, fallbackKids: s, xref: r, cache: n }) {
  let g, o = null;
  A ? ({ ref: o } = A, g = A.dict.getRaw("P") || a) : g = a, e.set("P", g);
  const I = r.fetchIfRef(g);
  if (!I) {
    s.push(i);
    return;
  }
  let C = n.get(g);
  C || (C = I.clone(), n.put(g, C));
  const h = C.getRaw("K");
  let c = h instanceof rA ? n.get(h) : null;
  if (!c) {
    c = r.fetchIfRef(h), c = Array.isArray(c) ? c.slice() : [h];
    const l = r.getNewTemporaryRef();
    C.set("K", l), n.put(l, c);
  }
  const B = c.indexOf(o);
  c.splice(B >= 0 ? B + 1 : c.length, 0, i);
}, MA(Ui, re);
let Ns = Ui;
class t2 {
  constructor(A, e) {
    this.tree = A, this.dict = e, this.kids = [], this.parseKids();
  }
  get role() {
    const A = this.dict.get("S"), e = A instanceof T ? A.name : "", { root: i } = this.tree;
    return i.roleMap.has(e) ? i.roleMap.get(e) : e;
  }
  parseKids() {
    let A = null;
    const e = this.dict.getRaw("Pg");
    e instanceof rA && (A = e.toString());
    const i = this.dict.get("K");
    if (Array.isArray(i)) for (const a of i) {
      const s = this.parseKid(A, a);
      s && this.kids.push(s);
    }
    else {
      const a = this.parseKid(A, i);
      a && this.kids.push(a);
    }
  }
  parseKid(A, e) {
    if (Number.isInteger(e)) return this.tree.pageDict.objId !== A ? null : new bn({ type: cC, mcid: e, pageObjId: A });
    let i = null;
    if (e instanceof rA ? i = this.dict.xref.fetch(e) : e instanceof U && (i = e), !i) return null;
    const a = i.getRaw("Pg");
    a instanceof rA && (A = a.toString());
    const s = i.get("Type") instanceof T ? i.get("Type").name : null;
    if (s === "MCR") {
      if (this.tree.pageDict.objId !== A) return null;
      const r = i.getRaw("Stm");
      return new bn({ type: CC, refObjId: r instanceof rA ? r.toString() : null, pageObjId: A, mcid: i.get("MCID") });
    }
    if (s === "OBJR") {
      if (this.tree.pageDict.objId !== A) return null;
      const r = i.getRaw("Obj");
      return new bn({ type: Do, refObjId: r instanceof rA ? r.toString() : null, pageObjId: A });
    }
    return new bn({ type: bo, dict: i });
  }
}
class bn {
  constructor({ type: A, dict: e = null, mcid: i = null, pageObjId: a = null, refObjId: s = null }) {
    this.type = A, this.dict = e, this.mcid = i, this.pageObjId = a, this.refObjId = s, this.parentNode = null;
  }
}
class EC {
  constructor(A, e) {
    this.root = A, this.rootDict = A ? A.dict : null, this.pageDict = e, this.nodes = [];
  }
  collectObjects(A) {
    var r;
    if (!(this.root && this.rootDict && A instanceof rA)) return null;
    const e = this.rootDict.get("ParentTree");
    if (!e) return null;
    const i = (r = this.root.structParentIds) == null ? void 0 : r.get(A);
    if (!i) return null;
    const a = /* @__PURE__ */ new Map(), s = new pr(e, this.rootDict.xref);
    for (const [n] of i) {
      const g = s.getRaw(n);
      g instanceof rA && a.set(n, g);
    }
    return a;
  }
  parse(A) {
    var n, g;
    if (!(this.root && this.rootDict && A instanceof rA)) return;
    const e = this.rootDict.get("ParentTree");
    if (!e) return;
    const i = this.pageDict.get("StructParents"), a = (n = this.root.structParentIds) == null ? void 0 : n.get(A);
    if (!Number.isInteger(i) && !a) return;
    const s = /* @__PURE__ */ new Map(), r = new pr(e, this.rootDict.xref);
    if (Number.isInteger(i)) {
      const o = r.get(i);
      if (Array.isArray(o)) for (const I of o) I instanceof rA && this.addNode(this.rootDict.xref.fetch(I), s);
    }
    if (a) for (const [o, I] of a) {
      const C = r.get(o);
      if (C) {
        const h = this.addNode(this.rootDict.xref.fetchIfRef(C), s);
        ((g = h == null ? void 0 : h.kids) == null ? void 0 : g.length) === 1 && h.kids[0].type === Do && (h.kids[0].type = I);
      }
    }
  }
  addNode(A, e, i = 0) {
    if (i > 40)
      return G("StructTree MAX_DEPTH reached."), null;
    if (!(A instanceof U)) return null;
    if (e.has(A)) return e.get(A);
    const a = new t2(this, A);
    e.set(A, a);
    const s = A.get("P");
    if (!s || it(s.get("Type"), "StructTreeRoot"))
      return this.addTopLevelNode(A, a) || e.delete(A), a;
    const r = this.addNode(s, e, i + 1);
    if (!r) return a;
    let n = !1;
    for (const g of r.kids) g.type === bo && g.dict === A && (g.parentNode = a, n = !0);
    return n || e.delete(A), a;
  }
  addTopLevelNode(A, e) {
    const i = this.rootDict.get("K");
    if (!i) return !1;
    if (i instanceof U)
      return i.objId !== A.objId ? !1 : (this.nodes[0] = e, !0);
    if (!Array.isArray(i)) return !0;
    let a = !1;
    for (let s = 0; s < i.length; s++) {
      const r = i[s];
      (r == null ? void 0 : r.toString()) === A.objId && (this.nodes[s] = e, a = !0);
    }
    return a;
  }
  get serializable() {
    function A(i, a, s = 0) {
      if (s > 40) {
        G("StructTree too deep to be fully serialized.");
        return;
      }
      const r = /* @__PURE__ */ Object.create(null);
      r.role = i.role, r.children = [], a.children.push(r);
      let n = i.dict.get("Alt");
      typeof n != "string" && (n = i.dict.get("ActualText")), typeof n == "string" && (r.alt = LA(n));
      const g = i.dict.get("A");
      if (g instanceof U) {
        const I = be(g.getArray("BBox"), null);
        if (I) r.bbox = I;
        else {
          const C = g.get("Width"), h = g.get("Height");
          typeof C == "number" && C > 0 && typeof h == "number" && h > 0 && (r.bbox = [0, 0, C, h]);
        }
      }
      const o = i.dict.get("Lang");
      typeof o == "string" && (r.lang = LA(o));
      for (const I of i.kids) {
        const C = I.type === bo ? I.parentNode : null;
        C ? A(C, r, s + 1) : I.type === cC || I.type === CC ? r.children.push({ type: "content", id: `p${I.pageObjId}_mc${I.mcid}` }) : I.type === Do ? r.children.push({ type: "object", id: I.refObjId }) : I.type === hC && r.children.push({ type: "annotation", id: `pdfjs_internal_id_${I.refObjId}` });
      }
    }
    const e = /* @__PURE__ */ Object.create(null);
    e.children = [], e.role = "Root";
    for (const i of this.nodes) i && A(i, e);
    return e;
  }
}
function CI(t) {
  if (!Array.isArray(t) || t.length < 2) return !1;
  const [A, e, ...i] = t;
  if (!(A instanceof rA || Number.isInteger(A)) || !(e instanceof T)) return !1;
  const a = i.length;
  let s = !0;
  switch (e.name) {
    case "XYZ":
      if (a < 2 || a > 3) return !1;
      break;
    case "Fit":
    case "FitB":
      return a === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (a > 1) return !1;
      break;
    case "FitR":
      if (a !== 4) return !1;
      s = !1;
      break;
    default:
      return !1;
  }
  for (const r of i) if (!(typeof r == "number" || s && r === null)) return !1;
  return !0;
}
function kn(t) {
  return t instanceof U && (t = t.get("D")), CI(t) ? t : null;
}
function a0(t) {
  let A = t.get("D");
  if (A) {
    if (A instanceof T && (A = A.name), typeof A == "string") return LA(A);
    if (CI(A)) return JSON.stringify(A);
  }
  return null;
}
var va, uC, dC;
const Kr = class Kr {
  constructor(A, e) {
    MA(this, va);
    if (this.pdfManager = A, this.xref = e, this._catDict = e.getCatalogObj(), !(this._catDict instanceof U)) throw new X("Catalog object is not a dictionary.");
    this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new xt(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new Eo(), this.pageKidsCountCache = new xt(), this.pageIndexCache = new xt(), this.pageDictCache = new xt(), this.nonBlendModesSet = new Bt(), this.systemFontCache = /* @__PURE__ */ new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const A = this._catDict.get("Version");
    if (A instanceof T) {
      if (u1.test(A.name)) return sA(this, "version", A.name);
      G(`Invalid PDF catalog version: ${A.name}`);
    }
    return sA(this, "version", null);
  }
  get lang() {
    const A = this._catDict.get("Lang");
    return sA(this, "lang", A && typeof A == "string" ? LA(A) : null);
  }
  get needsRendering() {
    const A = this._catDict.get("NeedsRendering");
    return sA(this, "needsRendering", typeof A == "boolean" && A);
  }
  get collection() {
    let A = null;
    try {
      const e = this._catDict.get("Collection");
      e instanceof U && e.size > 0 && (A = e);
    } catch (e) {
      if (e instanceof OA) throw e;
      RA("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return sA(this, "collection", A);
  }
  get acroForm() {
    let A = null;
    try {
      const e = this._catDict.get("AcroForm");
      e instanceof U && e.size > 0 && (A = e);
    } catch (e) {
      if (e instanceof OA) throw e;
      RA("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return sA(this, "acroForm", A);
  }
  get acroFormRef() {
    const A = this._catDict.getRaw("AcroForm");
    return sA(this, "acroFormRef", A instanceof rA ? A : null);
  }
  get metadata() {
    var i;
    const A = this._catDict.getRaw("Metadata");
    if (!(A instanceof rA)) return sA(this, "metadata", null);
    let e = null;
    try {
      const a = this.xref.fetch(A, !((i = this.xref.encrypt) != null && i.encryptMetadata));
      if (a instanceof FA && a.dict instanceof U) {
        const s = a.dict.get("Type"), r = a.dict.get("Subtype");
        if (it(s, "Metadata") && it(r, "XML")) {
          const n = ws(a.getString());
          n && (e = new A2(n).serializable);
        }
      }
    } catch (a) {
      if (a instanceof OA) throw a;
      RA(`Skipping invalid Metadata: "${a}".`);
    }
    return sA(this, "metadata", e);
  }
  get markInfo() {
    let A = null;
    try {
      A = this._readMarkInfo();
    } catch (e) {
      if (e instanceof OA) throw e;
      G("Unable to read mark info.");
    }
    return sA(this, "markInfo", A);
  }
  _readMarkInfo() {
    const A = this._catDict.get("MarkInfo");
    if (!(A instanceof U)) return null;
    const e = { Marked: !1, UserProperties: !1, Suspects: !1 };
    for (const i in e) {
      const a = A.get(i);
      typeof a == "boolean" && (e[i] = a);
    }
    return e;
  }
  get structTreeRoot() {
    let A = null;
    try {
      A = this._readStructTreeRoot();
    } catch (e) {
      if (e instanceof OA) throw e;
      G("Unable read to structTreeRoot info.");
    }
    return sA(this, "structTreeRoot", A);
  }
  _readStructTreeRoot() {
    const A = this._catDict.getRaw("StructTreeRoot"), e = this.xref.fetchIfRef(A);
    if (!(e instanceof U)) return null;
    const i = new Ns(e, A);
    return i.init(), i;
  }
  get toplevelPagesDict() {
    const A = this._catDict.get("Pages");
    if (!(A instanceof U)) throw new X("Invalid top-level pages dictionary.");
    return sA(this, "toplevelPagesDict", A);
  }
  get documentOutline() {
    let A = null;
    try {
      A = this._readDocumentOutline();
    } catch (e) {
      if (e instanceof OA) throw e;
      G("Unable to read document outline.");
    }
    return sA(this, "documentOutline", A);
  }
  _readDocumentOutline() {
    let A = this._catDict.get("Outlines");
    if (!(A instanceof U) || (A = A.getRaw("First"), !(A instanceof rA))) return null;
    const e = { items: [] }, i = [{ obj: A, parent: e }], a = new Bt();
    a.put(A);
    const s = this.xref, r = new Uint8ClampedArray(3);
    for (; i.length > 0; ) {
      const n = i.shift(), g = s.fetchIfRef(n.obj);
      if (g === null) continue;
      g.has("Title") || G("Invalid outline item encountered.");
      const o = { url: null, dest: null, action: null };
      Kr.parseDestDictionary({ destDict: g, resultObj: o, docBaseUrl: this.baseUrl, docAttachments: this.attachments });
      const I = g.get("Title"), C = g.get("F") || 0, h = g.getArray("C"), c = g.get("Count");
      let B = r;
      !Gt(h, 3) || h[0] === 0 && h[1] === 0 && h[2] === 0 || (B = kA.singletons.rgb.getRgb(h, 0));
      const l = { action: o.action, attachment: o.attachment, dest: o.dest, url: o.url, unsafeUrl: o.unsafeUrl, newWindow: o.newWindow, setOCGState: o.setOCGState, title: typeof I == "string" ? LA(I) : "", color: B, count: Number.isInteger(c) ? c : void 0, bold: !!(2 & C), italic: !!(1 & C), items: [] };
      n.parent.items.push(l), A = g.getRaw("First"), A instanceof rA && !a.has(A) && (i.push({ obj: A, parent: l }), a.put(A)), A = g.getRaw("Next"), A instanceof rA && !a.has(A) && (i.push({ obj: A, parent: n.parent }), a.put(A));
    }
    return e.items.length > 0 ? e.items : null;
  }
  get permissions() {
    let A = null;
    try {
      A = this._readPermissions();
    } catch (e) {
      if (e instanceof OA) throw e;
      G("Unable to read permissions.");
    }
    return sA(this, "permissions", A);
  }
  _readPermissions() {
    const A = this.xref.trailer.get("Encrypt");
    if (!(A instanceof U)) return null;
    let e = A.get("P");
    if (typeof e != "number") return null;
    e += 2 ** 32;
    const i = [];
    for (const a in TI) {
      const s = TI[a];
      e & s && i.push(s);
    }
    return i;
  }
  get optionalContentConfig() {
    let A = null;
    try {
      const e = this._catDict.get("OCProperties");
      if (!e) return sA(this, "optionalContentConfig", null);
      const i = e.get("D");
      if (!i) return sA(this, "optionalContentConfig", null);
      const a = e.get("OCGs");
      if (!Array.isArray(a)) return sA(this, "optionalContentConfig", null);
      const s = new xt();
      for (const r of a) r instanceof rA && !s.has(r) && s.put(r, CA(this, va, uC).call(this, r));
      A = CA(this, va, dC).call(this, i, s);
    } catch (e) {
      if (e instanceof OA) throw e;
      G(`Unable to read optional content config: ${e}`);
    }
    return sA(this, "optionalContentConfig", A);
  }
  setActualNumPages(A = null) {
    this._actualNumPages = A;
  }
  get hasActualNumPages() {
    return this._actualNumPages !== null;
  }
  get _pagesCount() {
    const A = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(A)) throw new X("Page count in top-level pages dictionary is not an integer.");
    return sA(this, "_pagesCount", A);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const A = this._readDests(), e = /* @__PURE__ */ Object.create(null);
    if (A instanceof Aa) for (const [i, a] of A.getAll()) {
      const s = kn(a);
      s && (e[LA(i)] = s);
    }
    else if (A instanceof U) for (const [i, a] of A) {
      const s = kn(a);
      s && (e[i] = s);
    }
    return sA(this, "destinations", e);
  }
  getDestination(A) {
    const e = this._readDests();
    if (e instanceof Aa) {
      const i = kn(e.get(A));
      if (i) return i;
      const a = this.destinations[A];
      if (a)
        return G(`Found "${A}" at an incorrect position in the NameTree.`), a;
    } else if (e instanceof U) {
      const i = kn(e.get(A));
      if (i) return i;
    }
    return null;
  }
  _readDests() {
    const A = this._catDict.get("Names");
    return A != null && A.has("Dests") ? new Aa(A.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
  }
  get pageLabels() {
    let A = null;
    try {
      A = this._readPageLabels();
    } catch (e) {
      if (e instanceof OA) throw e;
      G("Unable to read page labels.");
    }
    return sA(this, "pageLabels", A);
  }
  _readPageLabels() {
    const A = this._catDict.getRaw("PageLabels");
    if (!A) return null;
    const e = new Array(this.numPages);
    let i = null, a = "";
    const s = new pr(A, this.xref).getAll();
    let r = "", n = 1;
    for (let g = 0, o = this.numPages; g < o; g++) {
      const I = s.get(g);
      if (I !== void 0) {
        if (!(I instanceof U)) throw new X("PageLabel is not a dictionary.");
        if (I.has("Type") && !it(I.get("Type"), "PageLabel")) throw new X("Invalid type in PageLabel dictionary.");
        if (I.has("S")) {
          const C = I.get("S");
          if (!(C instanceof T)) throw new X("Invalid style in PageLabel dictionary.");
          i = C.name;
        } else i = null;
        if (I.has("P")) {
          const C = I.get("P");
          if (typeof C != "string") throw new X("Invalid prefix in PageLabel dictionary.");
          a = LA(C);
        } else a = "";
        if (I.has("St")) {
          const C = I.get("St");
          if (!(Number.isInteger(C) && C >= 1)) throw new X("Invalid start in PageLabel dictionary.");
          n = C;
        } else n = 1;
      }
      switch (i) {
        case "D":
          r = n;
          break;
        case "R":
        case "r":
          r = ZB(n, i === "r");
          break;
        case "A":
        case "a":
          const C = 26, h = i === "a" ? 97 : 65, c = n - 1;
          r = String.fromCharCode(h + c % C).repeat(Math.floor(c / C) + 1);
          break;
        default:
          if (i) throw new X(`Invalid style "${i}" in PageLabel dictionary.`);
          r = "";
      }
      e[g] = a + r, n++;
    }
    return e;
  }
  get pageLayout() {
    const A = this._catDict.get("PageLayout");
    let e = "";
    if (A instanceof T) switch (A.name) {
      case "SinglePage":
      case "OneColumn":
      case "TwoColumnLeft":
      case "TwoColumnRight":
      case "TwoPageLeft":
      case "TwoPageRight":
        e = A.name;
    }
    return sA(this, "pageLayout", e);
  }
  get pageMode() {
    const A = this._catDict.get("PageMode");
    let e = "UseNone";
    if (A instanceof T) switch (A.name) {
      case "UseNone":
      case "UseOutlines":
      case "UseThumbs":
      case "FullScreen":
      case "UseOC":
      case "UseAttachments":
        e = A.name;
    }
    return sA(this, "pageMode", e);
  }
  get viewerPreferences() {
    const A = this._catDict.get("ViewerPreferences");
    if (!(A instanceof U)) return sA(this, "viewerPreferences", null);
    let e = null;
    for (const i of A.getKeys()) {
      const a = A.get(i);
      let s;
      switch (i) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          typeof a == "boolean" && (s = a);
          break;
        case "NonFullScreenPageMode":
          if (a instanceof T) switch (a.name) {
            case "UseNone":
            case "UseOutlines":
            case "UseThumbs":
            case "UseOC":
              s = a.name;
              break;
            default:
              s = "UseNone";
          }
          break;
        case "Direction":
          if (a instanceof T) switch (a.name) {
            case "L2R":
            case "R2L":
              s = a.name;
              break;
            default:
              s = "L2R";
          }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (a instanceof T) switch (a.name) {
            case "MediaBox":
            case "CropBox":
            case "BleedBox":
            case "TrimBox":
            case "ArtBox":
              s = a.name;
              break;
            default:
              s = "CropBox";
          }
          break;
        case "PrintScaling":
          if (a instanceof T) switch (a.name) {
            case "None":
            case "AppDefault":
              s = a.name;
              break;
            default:
              s = "AppDefault";
          }
          break;
        case "Duplex":
          if (a instanceof T) switch (a.name) {
            case "Simplex":
            case "DuplexFlipShortEdge":
            case "DuplexFlipLongEdge":
              s = a.name;
              break;
            default:
              s = "None";
          }
          break;
        case "PrintPageRange":
          Array.isArray(a) && a.length % 2 == 0 && a.every((r, n, g) => Number.isInteger(r) && r > 0 && (n === 0 || r >= g[n - 1]) && r <= this.numPages) && (s = a);
          break;
        case "NumCopies":
          Number.isInteger(a) && a > 0 && (s = a);
          break;
        default:
          G(`Ignoring non-standard key in ViewerPreferences: ${i}.`);
          continue;
      }
      s !== void 0 ? (e || (e = /* @__PURE__ */ Object.create(null)), e[i] = s) : G(`Bad value, for key "${i}", in ViewerPreferences: ${a}.`);
    }
    return sA(this, "viewerPreferences", e);
  }
  get openAction() {
    const A = this._catDict.get("OpenAction"), e = /* @__PURE__ */ Object.create(null);
    if (A instanceof U) {
      const i = new U(this.xref);
      i.set("A", A);
      const a = { url: null, dest: null, action: null };
      Kr.parseDestDictionary({ destDict: i, resultObj: a }), Array.isArray(a.dest) ? e.dest = a.dest : a.action && (e.action = a.action);
    } else Array.isArray(A) && (e.dest = A);
    return sA(this, "openAction", C1(e) > 0 ? e : null);
  }
  get attachments() {
    const A = this._catDict.get("Names");
    let e = null;
    if (A instanceof U && A.has("EmbeddedFiles")) {
      const i = new Aa(A.getRaw("EmbeddedFiles"), this.xref);
      for (const [a, s] of i.getAll()) {
        const r = new wo(s, this.xref);
        e || (e = /* @__PURE__ */ Object.create(null)), e[LA(a)] = r.serializable;
      }
    }
    return sA(this, "attachments", e);
  }
  get xfaImages() {
    const A = this._catDict.get("Names");
    let e = null;
    if (A instanceof U && A.has("XFAImages")) {
      const i = new Aa(A.getRaw("XFAImages"), this.xref);
      for (const [a, s] of i.getAll())
        e || (e = new U(this.xref)), e.set(LA(a), s);
    }
    return sA(this, "xfaImages", e);
  }
  _collectJavaScript() {
    const A = this._catDict.get("Names");
    let e = null;
    function i(s, r) {
      if (!(r instanceof U) || !it(r.get("S"), "JavaScript")) return;
      let n = r.get("JS");
      if (n instanceof FA) n = n.getString();
      else if (typeof n != "string") return;
      n = LA(n).replaceAll("\0", ""), n && (e || (e = /* @__PURE__ */ new Map())).set(s, n);
    }
    if (A instanceof U && A.has("JavaScript")) {
      const s = new Aa(A.getRaw("JavaScript"), this.xref);
      for (const [r, n] of s.getAll()) i(LA(r), n);
    }
    const a = this._catDict.get("OpenAction");
    return a && i("OpenAction", a), e;
  }
  get jsActions() {
    const A = this._collectJavaScript();
    let e = Wr(this.xref, this._catDict, nB);
    if (A) {
      e || (e = /* @__PURE__ */ Object.create(null));
      for (const [i, a] of A) i in e ? e[i].push(a) : e[i] = [a];
    }
    return sA(this, "jsActions", e);
  }
  async fontFallback(A, e) {
    const i = await Promise.all(this.fontCache);
    for (const a of i) if (a.loadedName === A) {
      a.fallback(e);
      return;
    }
  }
  async cleanup(A = !1) {
    cI(), this.globalImageCache.clear(A), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
    const e = await Promise.all(this.fontCache);
    for (const { dict: i } of e) delete i.cacheKey;
    this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
  }
  async getPageDict(A) {
    const e = [this.toplevelPagesDict], i = new Bt(), a = this._catDict.getRaw("Pages");
    a instanceof rA && i.put(a);
    const s = this.xref, r = this.pageKidsCountCache, n = this.pageIndexCache, g = this.pageDictCache;
    let o = 0;
    for (; e.length; ) {
      const I = e.pop();
      if (I instanceof rA) {
        const B = r.get(I);
        if (B >= 0 && o + B <= A) {
          o += B;
          continue;
        }
        if (i.has(I)) throw new X("Pages tree contains circular reference.");
        i.put(I);
        const l = await (g.get(I) || s.fetchAsync(I));
        if (l instanceof U) {
          let Q = l.getRaw("Type");
          if (Q instanceof rA && (Q = await s.fetchAsync(Q)), it(Q, "Page") || !l.has("Kids")) {
            if (r.has(I) || r.put(I, 1), n.has(I) || n.put(I, o), o === A) return [l, I];
            o++;
            continue;
          }
        }
        e.push(l);
        continue;
      }
      if (!(I instanceof U)) throw new X("Page dictionary kid reference points to wrong type of object.");
      const { objId: C } = I;
      let h = I.getRaw("Count");
      if (h instanceof rA && (h = await s.fetchAsync(h)), Number.isInteger(h) && h >= 0 && (C && !r.has(C) && r.put(C, h), o + h <= A)) {
        o += h;
        continue;
      }
      let c = I.getRaw("Kids");
      if (c instanceof rA && (c = await s.fetchAsync(c)), !Array.isArray(c)) {
        let B = I.getRaw("Type");
        if (B instanceof rA && (B = await s.fetchAsync(B)), it(B, "Page") || !I.has("Kids")) {
          if (o === A) return [I, null];
          o++;
          continue;
        }
        throw new X("Page dictionary kids object is not an array.");
      }
      for (let B = c.length - 1; B >= 0; B--) {
        const l = c[B];
        e.push(l), I === this.toplevelPagesDict && l instanceof rA && !g.has(l) && g.put(l, s.fetchAsync(l));
      }
    }
    throw new Error(`Page index ${A} not found.`);
  }
  async getAllPageDicts(A = !1) {
    const { ignoreErrors: e } = this.pdfManager.evaluatorOptions, i = [{ currentNode: this.toplevelPagesDict, posInKids: 0 }], a = new Bt(), s = this._catDict.getRaw("Pages");
    s instanceof rA && a.put(s);
    const r = /* @__PURE__ */ new Map(), n = this.xref, g = this.pageIndexCache;
    let o = 0;
    function I(h, c) {
      c && !g.has(c) && g.put(c, o), r.set(o++, [h, c]);
    }
    function C(h) {
      if (h instanceof Ii && !A) throw h;
      A && e && o === 0 && (G(`getAllPageDicts - Skipping invalid first page: "${h}".`), h = U.empty), r.set(o++, [h, null]);
    }
    for (; i.length > 0; ) {
      const h = i.at(-1), { currentNode: c, posInKids: B } = h;
      let l = c.getRaw("Kids");
      if (l instanceof rA) try {
        l = await n.fetchAsync(l);
      } catch (f) {
        C(f);
        break;
      }
      if (!Array.isArray(l)) {
        C(new X("Page dictionary kids object is not an array."));
        break;
      }
      if (B >= l.length) {
        i.pop();
        continue;
      }
      const Q = l[B];
      let E;
      if (Q instanceof rA) {
        if (a.has(Q)) {
          C(new X("Pages tree contains circular reference."));
          break;
        }
        a.put(Q);
        try {
          E = await n.fetchAsync(Q);
        } catch (f) {
          C(f);
          break;
        }
      } else E = Q;
      if (!(E instanceof U)) {
        C(new X("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let u = E.getRaw("Type");
      if (u instanceof rA) try {
        u = await n.fetchAsync(u);
      } catch (f) {
        C(f);
        break;
      }
      it(u, "Page") || !E.has("Kids") ? I(E, Q instanceof rA ? Q : null) : i.push({ currentNode: E, posInKids: 0 }), h.posInKids++;
    }
    return r;
  }
  getPageIndex(A) {
    const e = this.pageIndexCache.get(A);
    if (e !== void 0) return Promise.resolve(e);
    const i = this.xref;
    let a = 0;
    const s = (r) => function(g) {
      let o, I = 0;
      return i.fetchAsync(g).then(function(C) {
        if (Br(g, A) && !E1(C, "Page") && !(C instanceof U && !C.has("Type") && C.has("Contents"))) throw new X("The reference does not point to a /Page dictionary.");
        if (!C) return null;
        if (!(C instanceof U)) throw new X("Node must be a dictionary.");
        return o = C.getRaw("Parent"), C.getAsync("Parent");
      }).then(function(C) {
        if (!C) return null;
        if (!(C instanceof U)) throw new X("Parent must be a dictionary.");
        return C.getAsync("Kids");
      }).then(function(C) {
        if (!C) return null;
        const h = [];
        let c = !1;
        for (const B of C) {
          if (!(B instanceof rA)) throw new X("Kid must be a reference.");
          if (Br(B, g)) {
            c = !0;
            break;
          }
          h.push(i.fetchAsync(B).then(function(l) {
            if (!(l instanceof U)) throw new X("Kid node must be a dictionary.");
            l.has("Count") ? I += l.get("Count") : I++;
          }));
        }
        if (!c) throw new X("Kid reference not found in parent's kids.");
        return Promise.all(h).then(function() {
          return [I, o];
        });
      });
    }(r).then((n) => {
      if (!n)
        return this.pageIndexCache.put(A, a), a;
      const [g, o] = n;
      return a += g, s(o);
    });
    return s(A);
  }
  get baseUrl() {
    const A = this._catDict.get("URI");
    if (A instanceof U) {
      const e = A.get("Base");
      if (typeof e == "string") {
        const i = Ir(e, null, { tryConvertEncoding: !0 });
        if (i) return sA(this, "baseUrl", i.href);
      }
    }
    return sA(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({ destDict: A, resultObj: e, docBaseUrl: i = null, docAttachments: a = null }) {
    if (!(A instanceof U)) {
      G("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let s, r, n = A.get("A");
    if (n instanceof U || (A.has("Dest") ? n = A.get("Dest") : (n = A.get("AA"), n instanceof U && (n.has("D") ? n = n.get("D") : n.has("U") && (n = n.get("U"))))), n instanceof U) {
      const g = n.get("S");
      if (!(g instanceof T)) {
        G("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const o = g.name;
      switch (o) {
        case "ResetForm":
          const I = n.get("Flags"), C = (1 & (typeof I == "number" ? I : 0)) == 0, h = [], c = [];
          for (const R of n.get("Fields") || []) R instanceof rA ? c.push(R.toString()) : typeof R == "string" && h.push(LA(R));
          e.resetForm = { fields: h, refs: c, include: C };
          break;
        case "URI":
          s = n.get("URI"), s instanceof T && (s = "/" + s.name);
          break;
        case "GoTo":
          r = n.get("D");
          break;
        case "Launch":
        case "GoToR":
          const B = n.get("F");
          if (B instanceof U) {
            const R = new wo(B, null, !0), { rawFilename: k } = R.serializable;
            s = k;
          } else typeof B == "string" && (s = B);
          const l = a0(n);
          l && typeof s == "string" && (s = s.split("#", 1)[0] + "#" + l);
          const Q = n.get("NewWindow");
          typeof Q == "boolean" && (e.newWindow = Q);
          break;
        case "GoToE":
          const E = n.get("T");
          let u;
          if (a && E instanceof U) {
            const R = E.get("R"), k = E.get("N");
            it(R, "C") && typeof k == "string" && (u = a[LA(k)]);
          }
          if (u) {
            e.attachment = u;
            const R = a0(n);
            R && (e.attachmentDest = R);
          } else G('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const f = n.get("N");
          f instanceof T && (e.action = f.name);
          break;
        case "SetOCGState":
          const d = n.get("State"), p = n.get("PreserveRB");
          if (!Array.isArray(d) || d.length === 0) break;
          const m = [];
          for (const R of d) if (R instanceof T) switch (R.name) {
            case "ON":
            case "OFF":
            case "Toggle":
              m.push(R.name);
          }
          else R instanceof rA && m.push(R.toString());
          if (m.length !== d.length) break;
          e.setOCGState = { state: m, preserveRB: typeof p != "boolean" || p };
          break;
        case "JavaScript":
          const y = n.get("JS");
          let b;
          y instanceof FA ? b = y.getString() : typeof y == "string" && (b = y);
          const D = b && p1(LA(b));
          if (D) {
            s = D.url, e.newWindow = D.newWindow;
            break;
          }
        default:
          if (o === "JavaScript" || o === "SubmitForm") break;
          G(`parseDestDictionary - unsupported action: "${o}".`);
      }
    } else A.has("Dest") && (r = A.get("Dest"));
    if (typeof s == "string") {
      const g = Ir(s, i, { addDefaultProtocol: !0, tryConvertEncoding: !0 });
      g && (e.url = g.href), e.unsafeUrl = s;
    }
    r && (r instanceof T && (r = r.name), typeof r == "string" ? e.dest = LA(r) : CI(r) && (e.dest = r));
  }
};
va = new WeakSet(), uC = function(A) {
  const e = this.xref.fetch(A), i = { id: A.toString(), name: null, intent: null, usage: { print: null, view: null }, rbGroups: [] }, a = e.get("Name");
  typeof a == "string" && (i.name = LA(a));
  let s = e.getArray("Intent");
  Array.isArray(s) || (s = [s]), s.every((I) => I instanceof T) && (i.intent = s.map((I) => I.name));
  const r = e.get("Usage");
  if (!(r instanceof U)) return i;
  const n = i.usage, g = r.get("Print");
  if (g instanceof U) {
    const I = g.get("PrintState");
    if (I instanceof T) switch (I.name) {
      case "ON":
      case "OFF":
        n.print = { printState: I.name };
    }
  }
  const o = r.get("View");
  if (o instanceof U) {
    const I = o.get("ViewState");
    if (I instanceof T) switch (I.name) {
      case "ON":
      case "OFF":
        n.view = { viewState: I.name };
    }
  }
  return i;
}, dC = function(A, e) {
  function i(o) {
    const I = [];
    if (Array.isArray(o)) for (const C of o) C instanceof rA && e.has(C) && I.push(C.toString());
    return I;
  }
  function a(o, I = 0) {
    if (!Array.isArray(o)) return null;
    const C = [];
    for (const c of o) {
      if (c instanceof rA && e.has(c)) {
        n.put(c), C.push(c.toString());
        continue;
      }
      const B = s(c, I);
      B && C.push(B);
    }
    if (I > 0) return C;
    const h = [];
    for (const [c] of e.items()) n.has(c) || h.push(c.toString());
    return h.length && C.push({ name: null, order: h }), C;
  }
  function s(o, I) {
    if (++I > g)
      return G("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
    const C = r.fetchIfRef(o);
    if (!Array.isArray(C)) return null;
    const h = r.fetchIfRef(C[0]);
    if (typeof h != "string") return null;
    const c = a(C.slice(1), I);
    return c && c.length ? { name: LA(h), order: c } : null;
  }
  const r = this.xref, n = new Bt(), g = 10;
  return function(I) {
    if (Array.isArray(I)) for (const C of I) {
      const h = r.fetchIfRef(C);
      if (!Array.isArray(h) || !h.length) continue;
      const c = /* @__PURE__ */ new Set();
      for (const B of h) B instanceof rA && e.has(B) && !c.has(B.toString()) && (c.add(B.toString()), e.get(B).rbGroups.push(c));
    }
  }(A.get("RBGroups")), { name: typeof A.get("Name") == "string" ? LA(A.get("Name")) : null, creator: typeof A.get("Creator") == "string" ? LA(A.get("Creator")) : null, baseState: A.get("BaseState") instanceof T ? A.get("BaseState").name : null, on: i(A.get("ON")), off: i(A.get("OFF")), order: a(A.get("Order")), groups: [...e] };
};
let xs = Kr;
function e2(t, A) {
  if (t instanceof U) t = t.getRawValues();
  else if (t instanceof FA) t = t.dict.getRawValues();
  else if (!Array.isArray(t)) return;
  for (const i of t) ((e = i) instanceof rA || e instanceof U || e instanceof FA || Array.isArray(e)) && A.push(i);
  var e;
}
class mr {
  constructor(A, e, i) {
    this.dict = A, this.keys = e, this.xref = i, this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded) return;
    const { keys: A, dict: e } = this;
    this.refSet = new Bt();
    const i = [];
    for (const a of A) {
      const s = e.getRaw(a);
      s !== void 0 && i.push(s);
    }
    return this._walk(i);
  }
  async _walk(A) {
    const e = [], i = [];
    for (; A.length; ) {
      let a = A.pop();
      if (a instanceof rA) {
        if (this.refSet.has(a)) continue;
        try {
          this.refSet.put(a), a = this.xref.fetch(a);
        } catch (s) {
          if (!(s instanceof OA)) {
            G(`ObjectLoader._walk - requesting all data: "${s}".`), this.refSet = null;
            const { manager: r } = this.xref.stream;
            return r.requestAllChunks();
          }
          e.push(a), i.push({ begin: s.begin, end: s.end });
        }
      }
      if (a instanceof FA) {
        const s = a.getBaseStreams();
        if (s) {
          let r = !1;
          for (const n of s) n.isDataLoaded || (r = !0, i.push({ begin: n.start, end: n.end }));
          r && e.push(a);
        }
      }
      e2(a, A);
    }
    if (i.length) {
      await this.xref.stream.manager.requestRanges(i);
      for (const a of e) a instanceof rA && this.refSet.remove(a);
      return this._walk(e);
    }
    this.refSet = null;
  }
}
const zr = Symbol(), vi = Symbol(), $A = Symbol(), ui = Symbol(), ne = Symbol(), ha = Symbol(), zn = Symbol(), he = Symbol(), De = Symbol(), j = Symbol("content"), ae = Symbol("data"), La = Symbol(), P = Symbol("extra"), ZA = Symbol(), nn = Symbol(), So = Symbol(), fC = Symbol(), Ki = Symbol(), _r = Symbol(), Us = Symbol(), ls = Symbol(), hI = Symbol(), dt = Symbol(), Qs = Symbol(), Qt = Symbol(), Ja = Symbol(), Le = Symbol(), rt = Symbol(), yA = Symbol(), at = Symbol(), WA = Symbol(), Ms = Symbol(), oa = Symbol(), Ro = Symbol(), _n = Symbol(), BI = Symbol(), Xi = Symbol(), Ba = Symbol(), ni = Symbol(), Es = Symbol(), qe = Symbol(), Ze = Symbol(), Ls = Symbol(), Js = Symbol(), i2 = Symbol(), st = Symbol("namespaceId"), JA = Symbol("nodeName"), hi = Symbol(), ke = Symbol(), Go = Symbol(), Te = Symbol(), Re = Symbol(), Ut = Symbol(), Ta = Symbol(), Bi = Symbol(), pC = Symbol("root"), rs = Symbol(), Ye = Symbol(), No = Symbol(), mC = Symbol(), Yt = Symbol(), ce = Symbol(), It = Symbol(), yC = Symbol(), uA = Symbol(), us = Symbol(), UA = Symbol(), TA = Symbol("uid"), Qe = Symbol(), gt = { config: { id: 0, check: (t) => t.startsWith("http://www.xfa.org/schema/xci/") }, connectionSet: { id: 1, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-connection-set/") }, datasets: { id: 2, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-data/") }, form: { id: 3, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-form/") }, localeSet: { id: 4, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-locale-set/") }, pdf: { id: 5, check: (t) => t === "http://ns.adobe.com/xdp/pdf/" }, signature: { id: 6, check: (t) => t === "http://www.w3.org/2000/09/xmldsig#" }, sourceSet: { id: 7, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-source-set/") }, stylesheet: { id: 8, check: (t) => t === "http://www.w3.org/1999/XSL/Transform" }, template: { id: 9, check: (t) => t.startsWith("http://www.xfa.org/schema/xfa-template/") }, xdc: { id: 10, check: (t) => t.startsWith("http://www.xfa.org/schema/xdc/") }, xdp: { id: 11, check: (t) => t === "http://ns.adobe.com/xdp/" }, xfdf: { id: 12, check: (t) => t === "http://ns.adobe.com/xfdf/" }, xhtml: { id: 13, check: (t) => t === "http://www.w3.org/1999/xhtml" }, xmpmeta: { id: 14, check: (t) => t === "http://ns.adobe.com/xmpmeta/" } }, a2 = { pt: (t) => t, cm: (t) => t / 2.54 * 72, mm: (t) => t / 25.4 * 72, in: (t) => 72 * t, px: (t) => t }, s2 = /([+-]?\d+\.?\d*)(.*)/;
function $r(t) {
  return t.startsWith("'") || t.startsWith('"') ? t.slice(1, -1) : t;
}
function pA({ data: t, defaultValue: A, validate: e }) {
  if (!t) return A;
  t = t.trim();
  const i = parseInt(t, 10);
  return !isNaN(i) && e(i) ? i : A;
}
function yr({ data: t, defaultValue: A, validate: e }) {
  if (!t) return A;
  t = t.trim();
  const i = parseFloat(t);
  return !isNaN(i) && e(i) ? i : A;
}
function Ag({ data: t, defaultValue: A, validate: e }) {
  return t && e(t = t.trim()) ? t : A;
}
function _(t, A) {
  return Ag({ data: t, defaultValue: A[0], validate: (e) => A.includes(e) });
}
function oA(t, A = "0") {
  if (A || (A = "0"), !t) return oA(A);
  const e = t.trim().match(s2);
  if (!e) return oA(A);
  const [, i, a] = e, s = parseFloat(i);
  if (isNaN(s)) return oA(A);
  if (s === 0) return 0;
  const r = a2[a];
  return r ? r(s) : s;
}
function s0(t) {
  if (!t) return { num: 1, den: 1 };
  const A = t.trim().split(/\s*:\s*/).map((a) => parseFloat(a)).filter((a) => !isNaN(a));
  if (A.length === 1 && A.push(1), A.length === 0) return { num: 1, den: 1 };
  const [e, i] = A;
  return { num: e, den: i };
}
function Ee(t) {
  return t ? t.trim().split(/\s+/).map((A) => ({ excluded: A[0] === "-", viewname: A.substring(1) })) : [];
}
class lA {
  static get FAILURE() {
    return sA(this, "FAILURE", new lA(!1, null, null, null));
  }
  static get EMPTY() {
    return sA(this, "EMPTY", new lA(!0, null, null, null));
  }
  constructor(A, e, i, a) {
    this.success = A, this.html = e, this.bbox = i, this.breakNode = a;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(A) {
    return new lA(!1, null, null, A);
  }
  static success(A, e = null) {
    return new lA(!0, A, e, null);
  }
}
class n2 {
  constructor(A) {
    this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(A);
  }
  add(A, e = null) {
    for (const a of A) this.addPdfFont(a);
    for (const a of this.fonts.values()) a.regular || (a.regular = a.italic || a.bold || a.bolditalic);
    if (!e || e.size === 0) return;
    const i = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const a of e) this.fonts.set(a, i);
  }
  addPdfFont(A) {
    var n, g, o;
    const e = A.cssFontInfo, i = e.fontFamily;
    let a = this.fonts.get(i);
    a || (a = /* @__PURE__ */ Object.create(null), this.fonts.set(i, a), this.defaultFont || (this.defaultFont = a));
    let s = "";
    const r = parseFloat(e.fontWeight);
    parseFloat(e.italicAngle) !== 0 ? s = r >= 700 ? "bolditalic" : "italic" : r >= 700 && (s = "bold"), s || ((A.name.includes("Bold") || (n = A.psName) != null && n.includes("Bold")) && (s = "bold"), (A.name.includes("Italic") || A.name.endsWith("It") || (g = A.psName) != null && g.includes("Italic") || (o = A.psName) != null && o.endsWith("It")) && (s += "italic")), s || (s = "regular"), a[s] = A;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(A, e = !0) {
    var n, g;
    let i = this.fonts.get(A) || this.cache.get(A);
    if (i) return i;
    const a = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let s = A.replaceAll(a, "");
    if (i = this.fonts.get(s), i)
      return this.cache.set(A, i), i;
    s = s.toLowerCase();
    const r = [];
    for (const [o, I] of this.fonts.entries()) o.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(I);
    if (r.length === 0) for (const [, o] of this.fonts.entries()) (n = o.regular.name) != null && n.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(o);
    if (r.length === 0) {
      s = s.replaceAll(/psmt|mt/gi, "");
      for (const [o, I] of this.fonts.entries()) o.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(I);
    }
    if (r.length === 0) for (const o of this.fonts.values()) (g = o.regular.name) != null && g.replaceAll(a, "").toLowerCase().startsWith(s) && r.push(o);
    return r.length >= 1 ? (r.length !== 1 && e && G(`XFA - Too many choices to guess the correct font: ${A}`), this.cache.set(A, r[0]), r[0]) : (e && !this.warned.has(A) && (this.warned.add(A), G(`XFA - Cannot find the font: ${A}`)), null);
  }
}
function lI(t, A) {
  return t.posture === "italic" ? t.weight === "bold" ? A.bolditalic : A.italic : t.weight === "bold" ? A.bold : A.regular;
}
class n0 {
  constructor(A, e, i, a) {
    if (this.lineHeight = i, this.paraMargin = e || { top: 0, bottom: 0, left: 0, right: 0 }, !A) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(a);
      return;
    }
    this.xfaFont = { typeface: A.typeface, posture: A.posture, weight: A.weight, size: A.size, letterSpacing: A.letterSpacing };
    const s = a.find(A.typeface);
    s ? (this.pdfFont = lI(A, s), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a))) : [this.pdfFont, this.xfaFont] = this.defaultFont(a);
  }
  defaultFont(A) {
    const e = A.find("Helvetica", !1) || A.find("Myriad Pro", !1) || A.find("Arial", !1) || A.getDefault();
    if (e != null && e.regular) {
      const i = e.regular;
      return [i, { typeface: i.cssFontInfo.fontFamily, posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
    }
    return [null, { typeface: "Courier", posture: "normal", weight: "normal", size: 10, letterSpacing: 0 }];
  }
}
class r2 {
  constructor(A, e, i, a) {
    this.fontFinder = a, this.stack = [new n0(A, e, i, a)];
  }
  pushData(A, e, i) {
    const a = this.stack.at(-1);
    for (const r of ["typeface", "posture", "weight", "size", "letterSpacing"]) A[r] || (A[r] = a.xfaFont[r]);
    for (const r of ["top", "bottom", "left", "right"]) isNaN(e[r]) && (e[r] = a.paraMargin[r]);
    const s = new n0(A, e, i || a.lineHeight, this.fontFinder);
    s.pdfFont || (s.pdfFont = a.pdfFont), this.stack.push(s);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class g2 {
  constructor(A, e, i, a) {
    this.glyphs = [], this.fontSelector = new r2(A, e, i, a), this.extraHeight = 0;
  }
  pushData(A, e, i) {
    this.fontSelector.pushData(A, e, i);
  }
  popFont(A) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const A = this.fontSelector.topFont();
    this.extraHeight += A.paraMargin.top + A.paraMargin.bottom;
  }
  addString(A) {
    if (!A) return;
    const e = this.fontSelector.topFont(), i = e.xfaFont.size;
    if (e.pdfFont) {
      const a = e.xfaFont.letterSpacing, s = e.pdfFont, r = s.lineHeight || 1.2, n = e.lineHeight || Math.max(1.2, r) * i, g = r - (s.lineGap === void 0 ? 0.2 : s.lineGap), o = Math.max(1, g) * i, I = i / 1e3, C = s.defaultWidth || s.charsToGlyphs(" ")[0].width;
      for (const h of A.split(/[\u2029\n]/)) {
        const c = s.encodeString(h).join(""), B = s.charsToGlyphs(c);
        for (const l of B) {
          const Q = l.width || C;
          this.glyphs.push([Q * I + a, n, o, l.unicode, !1]);
        }
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
    } else {
      for (const a of A.split(/[\u2029\n]/)) {
        for (const s of a.split("")) this.glyphs.push([i, 1.2 * i, i, s, !1]);
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
    }
  }
  compute(A) {
    let e = -1, i = 0, a = 0, s = 0, r = 0, n = 0, g = !1, o = !0;
    for (let I = 0, C = this.glyphs.length; I < C; I++) {
      const [h, c, B, l, Q] = this.glyphs[I], E = l === " ", u = o ? B : c;
      Q ? (a = Math.max(a, r), r = 0, s += n, n = u, e = -1, i = 0, o = !1) : E ? r + h > A ? (a = Math.max(a, r), r = 0, s += n, n = u, e = -1, i = 0, g = !0, o = !1) : (n = Math.max(u, n), i = r, r += h, e = I) : r + h > A ? (s += n, n = u, e !== -1 ? (I = e, a = Math.max(a, i), r = 0, e = -1, i = 0) : (a = Math.max(a, r), r = h), g = !0, o = !1) : (r += h, n = Math.max(u, n));
    }
    return a = Math.max(a, r), s += n + this.extraHeight, { width: 1.02 * a, height: s, isBroken: g };
  }
}
const r0 = /^[^.[]+/, o2 = /^[^\]]+/, Pt = { dot: 0, dotDot: 1, dotHash: 2, dotBracket: 3, dotParen: 4 }, wC = /* @__PURE__ */ new Map([["$data", (t, A) => t.datasets ? t.datasets.data : t], ["$record", (t, A) => (t.datasets ? t.datasets.data : t)[Qt]()[0]], ["$template", (t, A) => t.template], ["$connectionSet", (t, A) => t.connectionSet], ["$form", (t, A) => t.form], ["$layout", (t, A) => t.layout], ["$host", (t, A) => t.host], ["$dataWindow", (t, A) => t.dataWindow], ["$event", (t, A) => t.event], ["!", (t, A) => t.datasets], ["$xfa", (t, A) => t], ["xfa", (t, A) => t], ["$", (t, A) => A]]), g0 = /* @__PURE__ */ new WeakMap();
function DC(t, A, e = !0) {
  let i = t.match(r0);
  if (!i) return null;
  let [a] = i;
  const s = [{ name: a, cacheName: "." + a, index: 0, js: null, formCalc: null, operator: Pt.dot }];
  let r = a.length;
  for (; r < t.length; ) {
    const g = r;
    if (t.charAt(r++) === "[") {
      if (i = t.slice(r).match(o2), !i)
        return G("XFA - Invalid index in SOM expression"), null;
      s.at(-1).index = (n = (n = i[0]).trim()) === "*" ? 1 / 0 : parseInt(n, 10) || 0, r += i[0].length + 1;
      continue;
    }
    let o;
    switch (t.charAt(r)) {
      case ".":
        if (!A) return null;
        r++, o = Pt.dotDot;
        break;
      case "#":
        r++, o = Pt.dotHash;
        break;
      case "[":
        if (e)
          return G("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        o = Pt.dotBracket;
        break;
      case "(":
        if (e)
          return G("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        o = Pt.dotParen;
        break;
      default:
        o = Pt.dot;
    }
    if (i = t.slice(r).match(r0), !i) break;
    [a] = i, r += a.length, s.push({ name: a, cacheName: t.slice(g, r), operator: o, index: 0, js: null, formCalc: null });
  }
  var n;
  return s;
}
function ei(t, A, e, i = !0, a = !0) {
  const s = DC(e, i);
  if (!s) return null;
  const r = wC.get(s[0].name);
  let n, g = 0;
  r ? (n = !0, t = [r(t, A)], g = 1) : (n = A === null, t = [A || t]);
  for (let o = s.length; g < o; g++) {
    const { name: I, cacheName: C, operator: h, index: c } = s[g], B = [];
    for (const l of t) {
      if (!l.isXFAObject) continue;
      let Q, E;
      if (a && (E = g0.get(l), E || (E = /* @__PURE__ */ new Map(), g0.set(l, E)), Q = E.get(C)), !Q) {
        switch (h) {
          case Pt.dot:
            Q = l[Us](I, !1);
            break;
          case Pt.dotDot:
            Q = l[Us](I, !0);
            break;
          case Pt.dotHash:
            Q = l[_r](I), Q = Q.isXFAObjectArray ? Q.children : [Q];
        }
        a && E.set(C, Q);
      }
      Q.length > 0 && B.push(Q);
    }
    if (B.length !== 0 || n || g !== 0) t = isFinite(c) ? B.filter((l) => c < l.length).map((l) => l[c]) : B.flat();
    else {
      if (!(A = A[yA]())) return null;
      g = -1, t = [A];
    }
  }
  return t.length === 0 ? null : t;
}
function I2(t, A, e) {
  const i = DC(e);
  if (!i || i.some((r) => r.operator === Pt.dotDot)) return null;
  const a = wC.get(i[0].name);
  let s = 0;
  a ? (t = a(t, A), s = 1) : t = A || t;
  for (let r = i.length; s < r; s++) {
    const { name: n, operator: g, index: o } = i[s];
    if (!isFinite(o))
      return i[s].index = 0, t.createNodes(i.slice(s));
    let I;
    switch (g) {
      case Pt.dot:
        I = t[Us](n, !1);
        break;
      case Pt.dotDot:
        I = t[Us](n, !0);
        break;
      case Pt.dotHash:
        I = t[_r](n), I = I.isXFAObjectArray ? I.children : [I];
    }
    if (I.length === 0) return t.createNodes(i.slice(s));
    if (!(o < I.length))
      return i[s].index = o - I.length, t.createNodes(i.slice(s));
    {
      const C = I[o];
      if (!C.isXFAObject)
        return G("XFA - Cannot create a node."), null;
      t = C;
    }
  }
  return null;
}
const Fn = Symbol(), Di = Symbol(), ta = Symbol(), SA = Symbol("_children"), Rg = Symbol(), ze = Symbol(), Gg = Symbol(), o0 = Symbol(), Ng = Symbol(), I0 = Symbol(), xg = Symbol(), gs = Symbol(), Sn = Symbol(), te = Symbol("parent"), ts = Symbol(), es = Symbol(), Ug = Symbol();
let xo = 0;
const bC = gt.datasets.id;
class Z {
  constructor(A, e, i = !1) {
    this[st] = A, this[JA] = e, this[xg] = i, this[te] = null, this[SA] = [], this[TA] = `${e}${xo++}`, this[WA] = null;
  }
  get isXFAObject() {
    return !0;
  }
  get isXFAObjectArray() {
    return !1;
  }
  createNodes(A) {
    let e = this, i = null;
    for (const { name: a, index: s } of A) {
      for (let r = 0, n = isFinite(s) ? s : 0; r <= n; r++) {
        const g = e[st] === bC ? -1 : e[st];
        i = new Fe(g, a), e[$A](i);
      }
      e = i;
    }
    return i;
  }
  [ke](A) {
    if (!this[xg] || !this[Go](A)) return !1;
    const e = A[JA], i = this[e];
    if (!(i instanceof S))
      return i !== null && this[Bi](i), this[e] = A, this[$A](A), !0;
    if (i.push(A))
      return this[$A](A), !0;
    let a = "";
    return this.id ? a = ` (id: ${this.id})` : this.name && (a = ` (name: ${this.name} ${this.h.value})`), G(`XFA - node "${this[JA]}"${a} has already enough "${e}"!`), !1;
  }
  [Go](A) {
    return this.hasOwnProperty(A[JA]) && A[st] === this[st];
  }
  [Es]() {
    return !1;
  }
  [zr]() {
    return !1;
  }
  [BI]() {
    return !1;
  }
  [Xi]() {
    return !1;
  }
  [Ut]() {
    this.para && this[at]()[P].paraStack.pop();
  }
  [Ta]() {
    this[at]()[P].paraStack.push(this.para);
  }
  [No](A) {
    this.id && this[st] === gt.template.id && A.set(this.id, this);
  }
  [at]() {
    return this[WA].template;
  }
  [qe]() {
    return !1;
  }
  [Ze]() {
    return !1;
  }
  [$A](A) {
    A[te] = this, this[SA].push(A), !A[WA] && this[WA] && (A[WA] = this[WA]);
  }
  [Bi](A) {
    const e = this[SA].indexOf(A);
    this[SA].splice(e, 1);
  }
  [Ms]() {
    return this.hasOwnProperty("value");
  }
  [Yt](A) {
  }
  [Te](A) {
  }
  [ZA]() {
  }
  [ne](A) {
    delete this[xg], this[zn] && (A.clean(this[zn]), delete this[zn]);
  }
  [Ro](A) {
    return this[SA].indexOf(A);
  }
  [_n](A, e) {
    e[te] = this, this[SA].splice(A, 0, e), !e[WA] && this[WA] && (e[WA] = this[WA]);
  }
  [Ls]() {
    return !this.name;
  }
  [i2]() {
    return "";
  }
  [It]() {
    return this[SA].length === 0 ? this[j] : this[SA].map((A) => A[It]()).join("");
  }
  get [ta]() {
    const A = Object.getPrototypeOf(this);
    if (!A._attributes) {
      const e = A._attributes = /* @__PURE__ */ new Set();
      for (const i of Object.getOwnPropertyNames(this)) {
        if (this[i] === null || this[i] instanceof Z || this[i] instanceof S) break;
        e.add(i);
      }
    }
    return sA(this, ta, A._attributes);
  }
  [ni](A) {
    let e = this;
    for (; e; ) {
      if (e === A) return !0;
      e = e[yA]();
    }
    return !1;
  }
  [yA]() {
    return this[te];
  }
  [rt]() {
    return this[yA]();
  }
  [Qt](A = null) {
    return A ? this[A] : this[SA];
  }
  [La]() {
    const A = /* @__PURE__ */ Object.create(null);
    this[j] && (A.$content = this[j]);
    for (const e of Object.getOwnPropertyNames(this)) {
      const i = this[e];
      i !== null && (i instanceof Z ? A[e] = i[La]() : i instanceof S ? i.isEmpty() || (A[e] = i.dump()) : A[e] = i);
    }
    return A;
  }
  [UA]() {
    return null;
  }
  [uA]() {
    return lA.EMPTY;
  }
  *[Ja]() {
    for (const A of this[Qt]()) yield A;
  }
  *[o0](A, e) {
    for (const i of this[Ja]()) if (!A || e === A.has(i[JA])) {
      const a = this[Ki](), s = i[uA](a);
      s.success || (this[P].failingNode = i), yield s;
    }
  }
  [nn]() {
    return null;
  }
  [vi](A, e) {
    this[P].children.push(A);
  }
  [Ki]() {
  }
  [ui]({ filter: A = null, include: e = !0 }) {
    if (this[P].generator) {
      const i = this[Ki](), a = this[P].failingNode[uA](i);
      if (!a.success) return a;
      a.html && this[vi](a.html, a.bbox), delete this[P].failingNode;
    } else this[P].generator = this[o0](A, e);
    for (; ; ) {
      const i = this[P].generator.next();
      if (i.done) break;
      const a = i.value;
      if (!a.success) return a;
      a.html && this[vi](a.html, a.bbox);
    }
    return this[P].generator = null, lA.EMPTY;
  }
  [mC](A) {
    this[es] = new Set(Object.keys(A));
  }
  [I0](A) {
    const e = this[ta], i = this[es];
    return [...A].filter((a) => e.has(a) && !i.has(a));
  }
  [rs](A, e = /* @__PURE__ */ new Set()) {
    for (const i of this[SA]) i[ts](A, e);
  }
  [ts](A, e) {
    const i = this[Ng](A, e);
    i ? this[Fn](i, A, e) : this[rs](A, e);
  }
  [Ng](A, e) {
    const { use: i, usehref: a } = this;
    if (!i && !a) return null;
    let s = null, r = null, n = null, g = i;
    if (a ? (g = a, a.startsWith("#som(") && a.endsWith(")") ? r = a.slice(5, -1) : a.startsWith(".#som(") && a.endsWith(")") ? r = a.slice(6, -1) : a.startsWith("#") ? n = a.slice(1) : a.startsWith(".#") && (n = a.slice(2))) : i.startsWith("#") ? n = i.slice(1) : r = i, this.use = this.usehref = "", n ? s = A.get(n) : (s = ei(A.get(pC), this, r, !0, !1), s && (s = s[0])), !s)
      return G(`XFA - Invalid prototype reference: ${g}.`), null;
    if (s[JA] !== this[JA])
      return G(`XFA - Incompatible prototype: ${s[JA]} !== ${this[JA]}.`), null;
    if (e.has(s))
      return G("XFA - Cycle detected in prototypes use."), null;
    e.add(s);
    const o = s[Ng](A, e);
    return o && s[Fn](o, A, e), s[rs](A, e), e.delete(s), s;
  }
  [Fn](A, e, i) {
    if (i.has(A)) {
      G("XFA - Cycle detected in prototypes use.");
      return;
    }
    !this[j] && A[j] && (this[j] = A[j]), new Set(i).add(A);
    for (const a of this[I0](A[es]))
      this[a] = A[a], this[es] && this[es].add(a);
    for (const a of Object.getOwnPropertyNames(this)) {
      if (this[ta].has(a)) continue;
      const s = this[a], r = A[a];
      if (s instanceof S) {
        for (const n of s[SA]) n[ts](e, i);
        for (let n = s[SA].length, g = r[SA].length; n < g; n++) {
          const o = A[SA][n][he]();
          if (!s.push(o)) break;
          o[te] = this, this[SA].push(o), o[ts](e, i);
        }
      } else if (s === null) {
        if (r !== null) {
          const n = r[he]();
          n[te] = this, this[a] = n, this[SA].push(n), n[ts](e, i);
        }
      } else
        s[rs](e, i), r && s[Fn](r, e, i);
    }
  }
  static [Rg](A) {
    return Array.isArray(A) ? A.map((e) => Z[Rg](e)) : typeof A == "object" && A !== null ? Object.assign({}, A) : A;
  }
  [he]() {
    const A = Object.create(Object.getPrototypeOf(this));
    for (const e of Object.getOwnPropertySymbols(this)) try {
      A[e] = this[e];
    } catch {
      sA(A, e, this[e]);
    }
    A[TA] = `${A[JA]}${xo++}`, A[SA] = [];
    for (const e of Object.getOwnPropertyNames(this)) {
      if (this[ta].has(e)) {
        A[e] = Z[Rg](this[e]);
        continue;
      }
      const i = this[e];
      A[e] = i instanceof S ? new S(i[gs]) : null;
    }
    for (const e of this[SA]) {
      const i = e[JA], a = e[he]();
      A[SA].push(a), a[te] = A, A[i] === null ? A[i] = a : A[i][SA].push(a);
    }
    return A;
  }
  [Qt](A = null) {
    return A ? this[SA].filter((e) => e[JA] === A) : this[SA];
  }
  [_r](A) {
    return this[A];
  }
  [Us](A, e, i = !0) {
    return Array.from(this[ls](A, e, i));
  }
  *[ls](A, e, i = !0) {
    if (A !== "parent") {
      for (const a of this[SA])
        a[JA] === A && (yield a), a.name === A && (yield a), (e || a[Ls]()) && (yield* a[ls](A, e, !1));
      i && this[ta].has(A) && (yield new QI(this, A, this[A]));
    } else yield this[te];
  }
}
class S {
  constructor(A = 1 / 0) {
    this[gs] = A, this[SA] = [];
  }
  get isXFAObject() {
    return !1;
  }
  get isXFAObjectArray() {
    return !0;
  }
  push(A) {
    return this[SA].length <= this[gs] ? (this[SA].push(A), !0) : (G(`XFA - node "${A[JA]}" accepts no more than ${this[gs]} children`), !1);
  }
  isEmpty() {
    return this[SA].length === 0;
  }
  dump() {
    return this[SA].length === 1 ? this[SA][0][La]() : this[SA].map((A) => A[La]());
  }
  [he]() {
    const A = new S(this[gs]);
    return A[SA] = this[SA].map((e) => e[he]()), A;
  }
  get children() {
    return this[SA];
  }
  clear() {
    this[SA].length = 0;
  }
}
class QI {
  constructor(A, e, i) {
    this[te] = A, this[JA] = e, this[j] = i, this[De] = !1, this[TA] = "attribute" + xo++;
  }
  [yA]() {
    return this[te];
  }
  [Ba]() {
    return !0;
  }
  [hI]() {
    return this[j].trim();
  }
  [Yt](A) {
    A = A.value || "", this[j] = A.toString();
  }
  [It]() {
    return this[j];
  }
  [ni](A) {
    return this[te] === A || this[te][ni](A);
  }
}
class Fe extends Z {
  constructor(A, e, i = {}) {
    if (super(A, e), this[j] = "", this[ze] = null, e !== "#text") {
      const a = /* @__PURE__ */ new Map();
      this[Di] = a;
      for (const [s, r] of Object.entries(i)) a.set(s, new QI(this, s, r));
      if (i.hasOwnProperty(hi)) {
        const s = i[hi].xfa.dataNode;
        s !== void 0 && (s === "dataGroup" ? this[ze] = !1 : s === "dataValue" && (this[ze] = !0));
      }
    }
    this[De] = !1;
  }
  [us](A) {
    const e = this[JA];
    if (e === "#text") {
      A.push(pa(this[j]));
      return;
    }
    const i = Xg(e), a = this[st] === bC ? "xfa:" : "";
    A.push(`<${a}${i}`);
    for (const [s, r] of this[Di].entries()) {
      const n = Xg(s);
      A.push(` ${n}="${pa(r[j])}"`);
    }
    if (this[ze] !== null && (this[ze] ? A.push(' xfa:dataNode="dataValue"') : A.push(' xfa:dataNode="dataGroup"')), this[j] || this[SA].length !== 0) {
      if (A.push(">"), this[j]) typeof this[j] == "string" ? A.push(pa(this[j])) : this[j][us](A);
      else for (const s of this[SA]) s[us](A);
      A.push(`</${a}${i}>`);
    } else A.push("/>");
  }
  [ke](A) {
    if (this[j]) {
      const e = new Fe(this[st], "#text");
      this[$A](e), e[j] = this[j], this[j] = "";
    }
    return this[$A](A), !0;
  }
  [Te](A) {
    this[j] += A;
  }
  [ZA]() {
    if (this[j] && this[SA].length > 0) {
      const A = new Fe(this[st], "#text");
      this[$A](A), A[j] = this[j], delete this[j];
    }
  }
  [uA]() {
    return this[JA] === "#text" ? lA.success({ name: "#text", value: this[j] }) : lA.EMPTY;
  }
  [Qt](A = null) {
    return A ? this[SA].filter((e) => e[JA] === A) : this[SA];
  }
  [fC]() {
    return this[Di];
  }
  [_r](A) {
    const e = this[Di].get(A);
    return e !== void 0 ? e : this[Qt](A);
  }
  *[ls](A, e) {
    const i = this[Di].get(A);
    i && (yield i);
    for (const a of this[SA])
      a[JA] === A && (yield a), e && (yield* a[ls](A, e));
  }
  *[So](A, e) {
    const i = this[Di].get(A);
    !i || e && i[De] || (yield i);
    for (const a of this[SA]) yield* a[So](A, e);
  }
  *[Qs](A, e, i) {
    for (const a of this[SA])
      a[JA] !== A || i && a[De] || (yield a), e && (yield* a[Qs](A, e, i));
  }
  [Ba]() {
    return this[ze] === null ? this[SA].length === 0 || this[SA][0][st] === gt.xhtml.id : this[ze];
  }
  [hI]() {
    return this[ze] === null ? this[SA].length === 0 ? this[j].trim() : this[SA][0][st] === gt.xhtml.id ? this[SA][0][It]().trim() : null : this[j].trim();
  }
  [Yt](A) {
    A = A.value || "", this[j] = A.toString();
  }
  [La](A = !1) {
    const e = /* @__PURE__ */ Object.create(null);
    A && (e.$ns = this[st]), this[j] && (e.$content = this[j]), e.$name = this[JA], e.children = [];
    for (const i of this[SA]) e.children.push(i[La](A));
    e.attributes = /* @__PURE__ */ Object.create(null);
    for (const [i, a] of this[Di]) e.attributes[i] = a[j];
    return e;
  }
}
class tt extends Z {
  constructor(A, e) {
    super(A, e), this[j] = "";
  }
  [Te](A) {
    this[j] += A;
  }
  [ZA]() {
  }
}
class PA extends tt {
  constructor(A, e, i) {
    super(A, e), this[Sn] = i;
  }
  [ZA]() {
    this[j] = Ag({ data: this[j], defaultValue: this[Sn][0], validate: (A) => this[Sn].includes(A) });
  }
  [ne](A) {
    super[ne](A), delete this[Sn];
  }
}
class GA extends tt {
  [ZA]() {
    this[j] = this[j].trim();
  }
}
class ue extends tt {
  constructor(A, e, i, a) {
    super(A, e), this[Gg] = i, this[Ug] = a;
  }
  [ZA]() {
    this[j] = pA({ data: this[j], defaultValue: this[Gg], validate: this[Ug] });
  }
  [ne](A) {
    super[ne](A), delete this[Gg], delete this[Ug];
  }
}
class ct extends ue {
  constructor(A, e) {
    super(A, e, 0, (i) => i === 1);
  }
}
class kC extends ue {
  constructor(A, e) {
    super(A, e, 1, (i) => i === 0);
  }
}
function fA(t) {
  return typeof t == "string" ? "0px" : Number.isInteger(t) ? `${t}px` : `${t.toFixed(2)}px`;
}
const c0 = { anchorType(t, A) {
  const e = t[rt]();
  if (e && (!e.layout || e.layout === "position"))
    switch ("transform" in A || (A.transform = ""), t.anchorType) {
      case "bottomCenter":
        A.transform += "translate(-50%, -100%)";
        break;
      case "bottomLeft":
        A.transform += "translate(0,-100%)";
        break;
      case "bottomRight":
        A.transform += "translate(-100%,-100%)";
        break;
      case "middleCenter":
        A.transform += "translate(-50%,-50%)";
        break;
      case "middleLeft":
        A.transform += "translate(0,-50%)";
        break;
      case "middleRight":
        A.transform += "translate(-100%,-50%)";
        break;
      case "topCenter":
        A.transform += "translate(-50%,0)";
        break;
      case "topRight":
        A.transform += "translate(-100%,0)";
    }
}, dimensions(t, A) {
  var s;
  const e = t[rt]();
  let i = t.w;
  const a = t.h;
  if ((s = e.layout) != null && s.includes("row")) {
    const r = e[P], n = t.colSpan;
    let g;
    n === -1 ? (g = r.columnWidths.slice(r.currentColumn).reduce((o, I) => o + I, 0), r.currentColumn = 0) : (g = r.columnWidths.slice(r.currentColumn, r.currentColumn + n).reduce((o, I) => o + I, 0), r.currentColumn = (r.currentColumn + t.colSpan) % r.columnWidths.length), isNaN(g) || (i = t.w = g);
  }
  A.width = i !== "" ? fA(i) : "auto", A.height = a !== "" ? fA(a) : "auto";
}, position(t, A) {
  const e = t[rt]();
  (!(e != null && e.layout) || e.layout === "position") && (A.position = "absolute", A.left = fA(t.x), A.top = fA(t.y));
}, rotate(t, A) {
  t.rotate && ("transform" in A || (A.transform = ""), A.transform += `rotate(-${t.rotate}deg)`, A.transformOrigin = "top left");
}, presence(t, A) {
  switch (t.presence) {
    case "invisible":
      A.visibility = "hidden";
      break;
    case "hidden":
    case "inactive":
      A.display = "none";
  }
}, hAlign(t, A) {
  if (t[JA] === "para") switch (t.hAlign) {
    case "justifyAll":
      A.textAlign = "justify-all";
      break;
    case "radix":
      A.textAlign = "left";
      break;
    default:
      A.textAlign = t.hAlign;
  }
  else switch (t.hAlign) {
    case "left":
      A.alignSelf = "start";
      break;
    case "center":
      A.alignSelf = "center";
      break;
    case "right":
      A.alignSelf = "end";
  }
}, margin(t, A) {
  t.margin && (A.margin = t.margin[UA]().margin);
} };
function FC(t, A) {
  t[rt]().layout === "position" && (t.minW > 0 && (A.minWidth = fA(t.minW)), t.maxW > 0 && (A.maxWidth = fA(t.maxW)), t.minH > 0 && (A.minHeight = fA(t.minH)), t.maxH > 0 && (A.maxHeight = fA(t.maxH)));
}
function C0(t, A, e, i, a, s) {
  const r = new g2(A, e, i, a);
  return typeof t == "string" ? r.addString(t) : t[Re](r), r.compute(s);
}
function EI(t, A) {
  let e = null, i = null, a = !1;
  if ((!t.w || !t.h) && t.value) {
    let s = 0, r = 0;
    t.margin && (s = t.margin.leftInset + t.margin.rightInset, r = t.margin.topInset + t.margin.bottomInset);
    let n = null, g = null;
    t.para && (g = /* @__PURE__ */ Object.create(null), n = t.para.lineHeight === "" ? null : t.para.lineHeight, g.top = t.para.spaceAbove === "" ? 0 : t.para.spaceAbove, g.bottom = t.para.spaceBelow === "" ? 0 : t.para.spaceBelow, g.left = t.para.marginLeft === "" ? 0 : t.para.marginLeft, g.right = t.para.marginRight === "" ? 0 : t.para.marginRight);
    let o = t.font;
    if (!o) {
      const h = t[at]();
      let c = t[yA]();
      for (; c && c !== h; ) {
        if (c.font) {
          o = c.font;
          break;
        }
        c = c[yA]();
      }
    }
    const I = (t.w || A.width) - s, C = t[WA].fontFinder;
    if (t.value.exData && t.value.exData[j] && t.value.exData.contentType === "text/html") {
      const h = C0(t.value.exData[j], o, g, n, C, I);
      i = h.width, e = h.height, a = h.isBroken;
    } else {
      const h = t.value[It]();
      if (h) {
        const c = C0(h, o, g, n, C, I);
        i = c.width, e = c.height, a = c.isBroken;
      }
    }
    i === null || t.w || (i += s), e === null || t.h || (e += r);
  }
  return { w: i, h: e, isBroken: a };
}
function SC(t, A, e) {
  let i;
  if (t.w !== "" && t.h !== "") i = [t.x, t.y, t.w, t.h];
  else {
    if (!e) return null;
    let a = t.w;
    if (a === "") {
      if (t.maxW === 0) {
        const r = t[rt]();
        a = r.layout === "position" && r.w !== "" ? 0 : t.minW;
      } else a = Math.min(t.maxW, e.width);
      A.attributes.style.width = fA(a);
    }
    let s = t.h;
    if (s === "") {
      if (t.maxH === 0) {
        const r = t[rt]();
        s = r.layout === "position" && r.h !== "" ? 0 : t.minH;
      } else s = Math.min(t.maxH, e.height);
      A.attributes.style.height = fA(s);
    }
    i = [t.x, t.y, a, s];
  }
  return i;
}
function tg(t) {
  var e;
  const A = t[rt]();
  if ((e = A.layout) != null && e.includes("row")) {
    const i = A[P], a = t.colSpan;
    let s;
    s = a === -1 ? i.columnWidths.slice(i.currentColumn).reduce((r, n) => r + n, 0) : i.columnWidths.slice(i.currentColumn, i.currentColumn + a).reduce((r, n) => r + n, 0), isNaN(s) || (t.w = s);
  }
  A.layout && A.layout !== "position" && (t.x = t.y = 0), t.layout === "table" && t.w === "" && Array.isArray(t.columnWidths) && (t.w = t.columnWidths.reduce((i, a) => i + a, 0));
}
function RC(t) {
  switch (t.layout) {
    case "position":
    default:
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
  }
}
function Nt(t, ...A) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const i of A) {
    const a = t[i];
    if (a !== null) {
      if (c0.hasOwnProperty(i)) c0[i](t, e);
      else if (a instanceof Z) {
        const s = a[UA]();
        s ? Object.assign(e, s) : G(`(DEBUG) - XFA - style for ${i} not implemented yet`);
      }
    }
  }
  return e;
}
function qi(t, A) {
  const { attributes: e } = A, { style: i } = e, a = { name: "div", attributes: { class: ["xfaWrapper"], style: /* @__PURE__ */ Object.create(null) }, children: [] };
  if (e.class.push("xfaWrapped"), t.border) {
    const { widths: s, insets: r } = t.border[P];
    let n, g, o = r[0], I = r[3];
    const C = r[0] + r[2], h = r[1] + r[3];
    switch (t.border.hand) {
      case "even":
        o -= s[0] / 2, I -= s[3] / 2, n = `calc(100% + ${(s[1] + s[3]) / 2 - h}px)`, g = `calc(100% + ${(s[0] + s[2]) / 2 - C}px)`;
        break;
      case "left":
        o -= s[0], I -= s[3], n = `calc(100% + ${s[1] + s[3] - h}px)`, g = `calc(100% + ${s[0] + s[2] - C}px)`;
        break;
      case "right":
        n = h ? `calc(100% - ${h}px)` : "100%", g = C ? `calc(100% - ${C}px)` : "100%";
    }
    const c = ["xfaBorder"];
    Pa(t.border) && c.push("xfaPrintOnly");
    const B = { name: "div", attributes: { class: c, style: { top: `${o}px`, left: `${I}px`, width: n, height: g } }, children: [] };
    for (const l of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"]) i[l] !== void 0 && (B.attributes.style[l] = i[l], delete i[l]);
    a.children.push(B, A);
  } else a.children.push(A);
  for (const s of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"]) i[s] !== void 0 && (a.attributes.style[s] = i[s], delete i[s]);
  return a.attributes.style.position = i.position === "absolute" ? "absolute" : "relative", delete i.position, i.alignSelf && (a.attributes.style.alignSelf = i.alignSelf, delete i.alignSelf), a;
}
function GC(t) {
  const A = oA(t.textIndent, "0px");
  if (A >= 0) return;
  const e = "padding" + ((t.textAlign === "right" ? "right" : "left") == "left" ? "Left" : "Right"), i = oA(t[e], "0px");
  t[e] = i - A + "px";
}
function uI(t, A) {
  switch (t.access) {
    case "nonInteractive":
      A.push("xfaNonInteractive");
      break;
    case "readOnly":
      A.push("xfaReadOnly");
      break;
    case "protected":
      A.push("xfaDisabled");
  }
}
function Pa(t) {
  return t.relevant.length > 0 && !t.relevant[0].excluded && t.relevant[0].viewname === "print";
}
function NC(t) {
  const A = t[at]()[P].paraStack;
  return A.length ? A.at(-1) : null;
}
function xC(t, A, e) {
  var i;
  if ((i = e.attributes.class) != null && i.includes("xfaRich")) {
    A && (t.h === "" && (A.height = "auto"), t.w === "" && (A.width = "auto"));
    const a = NC(t);
    if (a) {
      const s = e.attributes.style;
      switch (s.display = "flex", s.flexDirection = "column", a.vAlign) {
        case "top":
          s.justifyContent = "start";
          break;
        case "bottom":
          s.justifyContent = "end";
          break;
        case "middle":
          s.justifyContent = "center";
      }
      const r = a[UA]();
      for (const [n, g] of Object.entries(r)) n in s || (s[n] = g);
    }
  }
}
function UC(t, A, e, i) {
  if (!e) {
    delete i.fontFamily;
    return;
  }
  const a = $r(t.typeface);
  i.fontFamily = `"${a}"`;
  const s = e.find(a);
  if (s) {
    const { fontFamily: r } = s.regular.cssFontInfo;
    r !== a && (i.fontFamily = `"${r}"`);
    const n = NC(A);
    if (n && n.lineHeight !== "" || i.lineHeight) return;
    const g = lI(t, s);
    g && (i.lineHeight = Math.max(1.2, g.lineHeight));
  }
}
function MC(t) {
  const A = Ir(t, null, { addDefaultProtocol: !0, tryConvertEncoding: !0 });
  return A ? A.href : null;
}
function LC(t, A) {
  return { name: "div", attributes: { class: [t.layout === "lr-tb" ? "xfaLr" : "xfaRl"] }, children: A };
}
function JC(t) {
  if (!t[P]) return null;
  const A = { name: "div", attributes: t[P].attributes, children: t[P].children };
  if (t[P].failingNode) {
    const e = t[P].failingNode[nn]();
    e && (t.layout.endsWith("-tb") ? A.children.push(LC(t, [e])) : A.children.push(e));
  }
  return A.children.length === 0 ? null : A;
}
function HC(t, A, e) {
  const i = t[P], a = i.availableSpace, [s, r, n, g] = e;
  switch (t.layout) {
    case "position":
      i.width = Math.max(i.width, s + n), i.height = Math.max(i.height, r + g), i.children.push(A);
      break;
    case "lr-tb":
    case "rl-tb":
      (!i.line || i.attempt === 1) && (i.line = LC(t, []), i.children.push(i.line), i.numberInLine = 0), i.numberInLine += 1, i.line.children.push(A), i.attempt === 0 ? (i.currentWidth += n, i.height = Math.max(i.height, i.prevHeight + g)) : (i.currentWidth = n, i.prevHeight = i.height, i.height += g, i.attempt = 0), i.width = Math.max(i.width, i.currentWidth);
      break;
    case "rl-row":
    case "row": {
      i.children.push(A), i.width += n, i.height = Math.max(i.height, g);
      const o = fA(i.height);
      for (const I of i.children) I.attributes.style.height = o;
      break;
    }
    case "table":
    case "tb":
      i.width = Math.min(a.width, Math.max(i.width, n)), i.height += g, i.children.push(A);
  }
}
function YC(t) {
  const A = t[P].availableSpace, e = t.margin ? t.margin.topInset + t.margin.bottomInset : 0, i = t.margin ? t.margin.leftInset + t.margin.rightInset : 0;
  switch (t.layout) {
    case "lr-tb":
    case "rl-tb":
      return t[P].attempt === 0 ? { width: A.width - i - t[P].currentWidth, height: A.height - e - t[P].prevHeight } : { width: A.width - i, height: A.height - e - t[P].height };
    case "rl-row":
    case "row":
      return { width: t[P].columnWidths.slice(t[P].currentColumn).reduce((a, s) => a + s), height: A.height - i };
    case "table":
    case "tb":
      return { width: A.width - i, height: A.height - e - t[P].height };
    default:
      return A;
  }
}
function eg(t, A) {
  var n;
  if (t[at]()[P].firstUnsplittable === null || t.w === 0 || t.h === 0) return !0;
  const e = t[rt](), i = ((n = e[P]) == null ? void 0 : n.attempt) || 0, [, a, s, r] = function(o) {
    let I, C, h = o.w === "" ? NaN : o.w, c = o.h === "" ? NaN : o.h, [B, l] = [0, 0];
    switch (o.anchorType || "") {
      case "bottomCenter":
        [B, l] = [h / 2, c];
        break;
      case "bottomLeft":
        [B, l] = [0, c];
        break;
      case "bottomRight":
        [B, l] = [h, c];
        break;
      case "middleCenter":
        [B, l] = [h / 2, c / 2];
        break;
      case "middleLeft":
        [B, l] = [0, c / 2];
        break;
      case "middleRight":
        [B, l] = [h, c / 2];
        break;
      case "topCenter":
        [B, l] = [h / 2, 0];
        break;
      case "topRight":
        [B, l] = [h, 0];
    }
    switch (o.rotate || 0) {
      case 0:
        [I, C] = [-B, -l];
        break;
      case 90:
        [I, C] = [-l, B], [h, c] = [c, -h];
        break;
      case 180:
        [I, C] = [B, l], [h, c] = [-h, -c];
        break;
      case 270:
        [I, C] = [l, -B], [h, c] = [-c, h];
    }
    return [o.x + I + Math.min(0, h), o.y + C + Math.min(0, c), Math.abs(h), Math.abs(c)];
  }(t);
  switch (e.layout) {
    case "lr-tb":
    case "rl-tb":
      return i === 0 ? t[at]()[P].noLayoutFailure ? t.w !== "" ? Math.round(s - A.width) <= 2 : A.width > 2 : !(t.h !== "" && Math.round(r - A.height) > 2) && (t.w !== "" ? Math.round(s - A.width) <= 2 || e[P].numberInLine === 0 && A.height > 2 : A.width > 2) : !!t[at]()[P].noLayoutFailure || !(t.h !== "" && Math.round(r - A.height) > 2) && (t.w === "" || Math.round(s - A.width) <= 2 || !e[Ze]()) && A.height > 2;
    case "table":
    case "tb":
      return !!t[at]()[P].noLayoutFailure || (t.h === "" || t[qe]() ? (t.w === "" || Math.round(s - A.width) <= 2 || !e[Ze]()) && A.height > 2 : Math.round(r - A.height) <= 2);
    case "position":
      return t[at]()[P].noLayoutFailure || t.h === "" || Math.round(r + a - A.height) <= 2 ? !0 : r + a > t[at]()[P].currentContentArea.h;
    case "rl-row":
    case "row":
      return !!t[at]()[P].noLayoutFailure || t.h === "" || Math.round(r - A.height) <= 2;
    default:
      return !0;
  }
}
const iA = gt.template.id, Ti = "http://www.w3.org/2000/svg", c2 = /^H(\d+)$/, C2 = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), h2 = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function h0(t) {
  if (!t || !t.border) return { w: 0, h: 0 };
  const A = t.border[dt]();
  return A ? { w: A.widths[0] + A.widths[2] + A.insets[0] + A.insets[2], h: A.widths[1] + A.widths[3] + A.insets[1] + A.insets[3] } : { w: 0, h: 0 };
}
function dI(t) {
  return t.margin && (t.margin.topInset || t.margin.rightInset || t.margin.bottomInset || t.margin.leftInset);
}
function fI(t, A) {
  if (!t.value) {
    const e = new kI({});
    t[$A](e), t.value = e;
  }
  t.value[Yt](A);
}
function* pI(t) {
  for (const A of t[Qt]()) A instanceof wI ? yield* A[Ja]() : yield A;
}
function rn(t) {
  var A;
  return ((A = t.validate) == null ? void 0 : A.nullTest) === "error";
}
function ig(t) {
  for (; t; ) {
    if (!t.traversal) {
      t[ce] = t[yA]()[ce];
      return;
    }
    if (t[ce]) return;
    let A = null;
    for (const a of t.traversal[Qt]()) if (a.operation === "next") {
      A = a;
      break;
    }
    if (!A || !A.ref) {
      t[ce] = t[yA]()[ce];
      return;
    }
    const e = t[at]();
    t[ce] = ++e[ce];
    const i = e[Ye](A.ref, t);
    if (!i) return;
    t = i[0];
  }
}
function ag(t, A) {
  var i;
  const e = t.assist;
  if (e) {
    const a = e[uA]();
    a && (A.title = a);
    const s = e.role.match(c2);
    if (s) {
      const r = "heading", n = s[1];
      A.role = r, A["aria-level"] = n;
    }
  }
  if (t.layout === "table") A.role = "table";
  else if (t.layout === "row") A.role = "row";
  else {
    const a = t[yA]();
    a.layout === "row" && (A.role = ((i = a.assist) == null ? void 0 : i.role) === "TH" ? "columnheader" : "cell");
  }
}
function Zi(t) {
  if (!t.assist) return null;
  const A = t.assist;
  return A.speak && A.speak[j] !== "" ? A.speak[j] : A.toolTip ? A.toolTip[j] : null;
}
function di(t) {
  return lA.success({ name: "div", attributes: { class: ["xfaRich"], style: /* @__PURE__ */ Object.create(null) }, children: [{ name: "span", attributes: { style: /* @__PURE__ */ Object.create(null) }, value: t }] });
}
function sg(t) {
  const A = t[at]();
  A[P].firstUnsplittable === null && (A[P].firstUnsplittable = t, A[P].noLayoutFailure = !0);
}
function ng(t) {
  const A = t[at]();
  A[P].firstUnsplittable === t && (A[P].noLayoutFailure = !1);
}
function B0(t) {
  if (t[P] || (t[P] = /* @__PURE__ */ Object.create(null), t.targetType === "auto")) return !1;
  const A = t[at]();
  let e = null;
  if (t.target) {
    if (e = A[Ye](t.target, t[yA]()), !e) return !1;
    e = e[0];
  }
  const { currentPageArea: i, currentContentArea: a } = A[P];
  if (t.targetType === "pageArea")
    return e instanceof Ha || (e = null), t.startNew ? (t[P].target = e || i, !0) : e && e !== i ? (t[P].target = e, !0) : !1;
  e instanceof mI || (e = null);
  const s = e && e[yA]();
  let r, n = s;
  if (t.startNew) if (e) {
    const g = s.contentArea.children, o = g.indexOf(a), I = g.indexOf(e);
    o !== -1 && o < I && (n = null), r = I - 1;
  } else r = i.contentArea.children.indexOf(a);
  else {
    if (!e || e === a) return !1;
    r = s.contentArea.children.indexOf(e) - 1, n = s === i ? null : s;
  }
  return t[P].target = n, t[P].index = r, !0;
}
function l0(t, A, e) {
  const i = t[at](), a = i[P].noLayoutFailure, s = A[rt];
  A[rt] = () => t, i[P].noLayoutFailure = !0;
  const r = A[uA](e);
  t[vi](r.html, r.bbox), i[P].noLayoutFailure = a, A[rt] = s;
}
class B2 extends GA {
  constructor(A) {
    super(iA, "appearanceFilter"), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class vC extends Z {
  constructor(A) {
    super(iA, "arc", !0), this.circular = pA({ data: A.circular, defaultValue: 0, validate: (e) => e === 1 }), this.hand = _(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.startAngle = yr({ data: A.startAngle, defaultValue: 0, validate: (e) => !0 }), this.sweepAngle = yr({ data: A.sweepAngle, defaultValue: 360, validate: (e) => !0 }), this.use = A.use || "", this.usehref = A.usehref || "", this.edge = null, this.fill = null;
  }
  [uA]() {
    var n;
    const A = this.edge || new gn({}), e = A[UA](), i = /* @__PURE__ */ Object.create(null);
    ((n = this.fill) == null ? void 0 : n.presence) === "visible" ? Object.assign(i, this.fill[UA]()) : i.fill = "transparent", i.strokeWidth = fA(A.presence === "visible" ? A.thickness : 0), i.stroke = e.color;
    let a;
    const s = { xmlns: Ti, style: { width: "100%", height: "100%", overflow: "visible" } };
    if (this.sweepAngle === 360) a = { name: "ellipse", attributes: { xmlns: Ti, cx: "50%", cy: "50%", rx: "50%", ry: "50%", style: i } };
    else {
      const g = this.startAngle * Math.PI / 180, o = this.sweepAngle * Math.PI / 180, I = this.sweepAngle > 180 ? 1 : 0, [C, h, c, B] = [50 * (1 + Math.cos(g)), 50 * (1 - Math.sin(g)), 50 * (1 + Math.cos(g + o)), 50 * (1 - Math.sin(g + o))];
      a = { name: "path", attributes: { xmlns: Ti, d: `M ${C} ${h} A 50 50 0 ${I} 0 ${c} ${B}`, vectorEffect: "non-scaling-stroke", style: i } }, Object.assign(s, { viewBox: "0 0 100 100", preserveAspectRatio: "none" });
    }
    const r = { name: "svg", children: [a], attributes: s };
    return dI(this[yA]()[yA]()) ? lA.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [r] }) : (r.attributes.style.position = "absolute", lA.success(r));
  }
}
class l2 extends Z {
  constructor(A) {
    super(iA, "area", !0), this.colSpan = pA({ data: A.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.id = A.id || "", this.name = A.name || "", this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.desc = null, this.extras = null, this.area = new S(), this.draw = new S(), this.exObject = new S(), this.exclGroup = new S(), this.field = new S(), this.subform = new S(), this.subformSet = new S();
  }
  *[Ja]() {
    yield* pI(this);
  }
  [Ls]() {
    return !0;
  }
  [Xi]() {
    return !0;
  }
  [vi](A, e) {
    const [i, a, s, r] = e;
    this[P].width = Math.max(this[P].width, i + s), this[P].height = Math.max(this[P].height, a + r), this[P].children.push(A);
  }
  [Ki]() {
    return this[P].availableSpace;
  }
  [uA](A) {
    const e = Nt(this, "position"), i = { style: e, id: this[TA], class: ["xfaArea"] };
    Pa(this) && i.class.push("xfaPrintOnly"), this.name && (i.xfaName = this.name);
    const a = [];
    this[P] = { children: a, width: 0, height: 0, availableSpace: A };
    const s = this[ui]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]), include: !0 });
    if (!s.success)
      return s.isBreak() ? s : (delete this[P], lA.FAILURE);
    e.width = fA(this[P].width), e.height = fA(this[P].height);
    const r = { name: "div", attributes: i, children: a }, n = [this.x, this.y, this[P].width, this[P].height];
    return delete this[P], lA.success(r, n);
  }
}
class Q2 extends Z {
  constructor(A) {
    super(iA, "assist", !0), this.id = A.id || "", this.role = A.role || "", this.use = A.use || "", this.usehref = A.usehref || "", this.speak = null, this.toolTip = null;
  }
  [uA]() {
    var A;
    return ((A = this.toolTip) == null ? void 0 : A[j]) || null;
  }
}
class E2 extends Z {
  constructor(A) {
    super(iA, "barcode", !0), this.charEncoding = Ag({ data: A.charEncoding ? A.charEncoding.toLowerCase() : "", defaultValue: "", validate: (e) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/) }), this.checksum = _(A.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = pA({ data: A.dataColumnCount, defaultValue: -1, validate: (e) => e >= 0 }), this.dataLength = pA({ data: A.dataLength, defaultValue: -1, validate: (e) => e >= 0 }), this.dataPrep = _(A.dataPrep, ["none", "flateCompress"]), this.dataRowCount = pA({ data: A.dataRowCount, defaultValue: -1, validate: (e) => e >= 0 }), this.endChar = A.endChar || "", this.errorCorrectionLevel = pA({ data: A.errorCorrectionLevel, defaultValue: -1, validate: (e) => e >= 0 && e <= 8 }), this.id = A.id || "", this.moduleHeight = oA(A.moduleHeight, "5mm"), this.moduleWidth = oA(A.moduleWidth, "0.25mm"), this.printCheckDigit = pA({ data: A.printCheckDigit, defaultValue: 0, validate: (e) => e === 1 }), this.rowColumnRatio = s0(A.rowColumnRatio), this.startChar = A.startChar || "", this.textLocation = _(A.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = pA({ data: A.truncate, defaultValue: 0, validate: (e) => e === 1 }), this.type = _(A.type ? A.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = _(A.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = A.use || "", this.usehref = A.usehref || "", this.wideNarrowRatio = s0(A.wideNarrowRatio), this.encrypt = null, this.extras = null;
  }
}
class u2 extends Z {
  constructor(A) {
    super(iA, "bind", !0), this.match = _(A.match, ["once", "dataRef", "global", "none"]), this.ref = A.ref || "", this.picture = null;
  }
}
class Uo extends Z {
  constructor(A) {
    super(iA, "bindItems"), this.connection = A.connection || "", this.labelRef = A.labelRef || "", this.ref = A.ref || "", this.valueRef = A.valueRef || "";
  }
}
class d2 extends Z {
  constructor(A) {
    super(iA, "bookend"), this.id = A.id || "", this.leader = A.leader || "", this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class f2 extends ct {
  constructor(A) {
    super(iA, "boolean"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [uA](A) {
    return di(this[j] === 1 ? "1" : "0");
  }
}
class KC extends Z {
  constructor(A) {
    super(iA, "border", !0), this.break = _(A.break, ["close", "open"]), this.hand = _(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.corner = new S(4), this.edge = new S(4), this.extras = null, this.fill = null, this.margin = null;
  }
  [dt]() {
    if (!this[P]) {
      const A = this.edge.children.slice();
      if (A.length < 4) {
        const a = A.at(-1) || new gn({});
        for (let s = A.length; s < 4; s++) A.push(a);
      }
      const e = A.map((a) => a.thickness), i = [0, 0, 0, 0];
      this.margin && (i[0] = this.margin.topInset, i[1] = this.margin.rightInset, i[2] = this.margin.bottomInset, i[3] = this.margin.leftInset), this[P] = { widths: e, insets: i, edges: A };
    }
    return this[P];
  }
  [UA]() {
    var a;
    const { edges: A } = this[dt](), e = A.map((s) => {
      const r = s[UA]();
      return r.color || (r.color = "#000000"), r;
    }), i = /* @__PURE__ */ Object.create(null);
    if (this.margin && Object.assign(i, this.margin[UA]()), ((a = this.fill) == null ? void 0 : a.presence) === "visible" && Object.assign(i, this.fill[UA]()), this.corner.children.some((s) => s.radius !== 0)) {
      const s = this.corner.children.map((r) => r[UA]());
      if (s.length === 2 || s.length === 3) {
        const r = s.at(-1);
        for (let n = s.length; n < 4; n++) s.push(r);
      }
      i.borderRadius = s.map((r) => r.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        i.borderStyle = "";
        break;
      case "inactive":
        i.borderStyle = "none";
        break;
      default:
        i.borderStyle = e.map((s) => s.style).join(" ");
    }
    return i.borderWidth = e.map((s) => s.width).join(" "), i.borderColor = e.map((s) => s.color).join(" "), i;
  }
}
class p2 extends Z {
  constructor(A) {
    super(iA, "break", !0), this.after = _(A.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = A.afterTarget || "", this.before = _(A.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = A.beforeTarget || "", this.bookendLeader = A.bookendLeader || "", this.bookendTrailer = A.bookendTrailer || "", this.id = A.id || "", this.overflowLeader = A.overflowLeader || "", this.overflowTarget = A.overflowTarget || "", this.overflowTrailer = A.overflowTrailer || "", this.startNew = pA({ data: A.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class qC extends Z {
  constructor(A) {
    super(iA, "breakAfter", !0), this.id = A.id || "", this.leader = A.leader || "", this.startNew = pA({ data: A.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.target = A.target || "", this.targetType = _(A.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "", this.script = null;
  }
}
class TC extends Z {
  constructor(A) {
    super(iA, "breakBefore", !0), this.id = A.id || "", this.leader = A.leader || "", this.startNew = pA({ data: A.startNew, defaultValue: 0, validate: (e) => e === 1 }), this.target = A.target || "", this.targetType = _(A.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "", this.script = null;
  }
  [uA](A) {
    return this[P] = {}, lA.FAILURE;
  }
}
class m2 extends Z {
  constructor(A) {
    super(iA, "button", !0), this.highlight = _(A.highlight, ["inverted", "none", "outline", "push"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [uA](A) {
    const e = this[yA]()[yA](), i = { name: "button", attributes: { id: this[TA], class: ["xfaButton"], style: {} }, children: [] };
    for (const a of e.event.children) {
      if (a.activity !== "click" || !a.script) continue;
      const s = p1(a.script[j]);
      if (!s) continue;
      const r = MC(s.url);
      r && i.children.push({ name: "a", attributes: { id: "link" + this[TA], href: r, newWindow: s.newWindow, class: ["xfaLink"], style: {} }, children: [] });
    }
    return lA.success(i);
  }
}
class y2 extends Z {
  constructor(A) {
    super(iA, "calculate", !0), this.id = A.id || "", this.override = _(A.override, ["disabled", "error", "ignore", "warning"]), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.message = null, this.script = null;
  }
}
class w2 extends Z {
  constructor(A) {
    super(iA, "caption", !0), this.id = A.id || "", this.placement = _(A.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(oA(A.reserve)), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
  }
  [Yt](A) {
    fI(this, A);
  }
  [dt](A) {
    if (!this[P]) {
      let { width: e, height: i } = A;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          e = this.reserve <= 0 ? e : this.reserve;
          break;
        case "top":
        case "bottom":
          i = this.reserve <= 0 ? i : this.reserve;
      }
      this[P] = EI(this, { width: e, height: i });
    }
    return this[P];
  }
  [uA](A) {
    if (!this.value) return lA.EMPTY;
    this[Ta]();
    const e = this.value[uA](A).html;
    if (!e)
      return this[Ut](), lA.EMPTY;
    const i = this.reserve;
    if (this.reserve <= 0) {
      const { w: r, h: n } = this[dt](A);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = r;
          break;
        case "top":
        case "bottom":
          this.reserve = n;
      }
    }
    const a = [];
    typeof e == "string" ? a.push({ name: "#text", value: e }) : a.push(e);
    const s = Nt(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (s.width = fA(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (s.height = fA(this.reserve));
    }
    return xC(this, null, e), this[Ut](), this.reserve = i, lA.success({ name: "div", attributes: { style: s, class: ["xfaCaption"] }, children: a });
  }
}
class D2 extends GA {
  constructor(A) {
    super(iA, "certificate"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class b2 extends Z {
  constructor(A) {
    super(iA, "certificates", !0), this.credentialServerPolicy = _(A.credentialServerPolicy, ["optional", "required"]), this.id = A.id || "", this.url = A.url || "", this.urlPolicy = A.urlPolicy || "", this.use = A.use || "", this.usehref = A.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
  }
}
class PC extends Z {
  constructor(A) {
    super(iA, "checkButton", !0), this.id = A.id || "", this.mark = _(A.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = _(A.shape, ["square", "round"]), this.size = oA(A.size, "10pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    var l, Q, E;
    const e = Nt("margin"), i = fA(this.size);
    e.width = e.height = i;
    let a, s, r;
    const n = this[yA]()[yA](), g = n.items.children.length && n.items.children[0][uA]().html || [], o = { on: (g[0] !== void 0 ? g[0] : "on").toString(), off: (g[1] !== void 0 ? g[1] : "off").toString() }, I = (((l = n.value) == null ? void 0 : l[It]()) || "off") === o.on || void 0, C = n[rt](), h = n[TA];
    let c;
    C instanceof XC ? (r = C[TA], a = "radio", s = "xfaRadio", c = ((Q = C[ae]) == null ? void 0 : Q[TA]) || C[TA]) : (a = "checkbox", s = "xfaCheckbox", c = ((E = n[ae]) == null ? void 0 : E[TA]) || n[TA]);
    const B = { name: "input", attributes: { class: [s], style: e, fieldId: h, dataId: c, type: a, checked: I, xfaOn: o.on, xfaOff: o.off, "aria-label": Zi(n), "aria-required": !1 } };
    return r && (B.attributes.name = r), rn(n) && (B.attributes["aria-required"] = !0, B.attributes.required = !0), lA.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [B] });
  }
}
class WC extends Z {
  constructor(A) {
    super(iA, "choiceList", !0), this.commitOn = _(A.commitOn, ["select", "exit"]), this.id = A.id || "", this.open = _(A.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = pA({ data: A.textEntry, defaultValue: 0, validate: (e) => e === 1 }), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    var n, g, o;
    const e = Nt(this, "border", "margin"), i = this[yA]()[yA](), a = { fontSize: `calc(${((n = i.font) == null ? void 0 : n.size) || 10}px * var(--scale-factor))` }, s = [];
    if (i.items.children.length > 0) {
      const I = i.items;
      let C = 0, h = 0;
      I.children.length === 2 && (C = I.children[0].save, h = 1 - C);
      const c = I.children[C][uA]().html, B = I.children[h][uA]().html;
      let l = !1;
      const Q = ((g = i.value) == null ? void 0 : g[It]()) || "";
      for (let E = 0, u = c.length; E < u; E++) {
        const f = { name: "option", attributes: { value: B[E] || c[E], style: a }, value: c[E] };
        B[E] === Q && (f.attributes.selected = l = !0), s.push(f);
      }
      l || s.splice(0, 0, { name: "option", attributes: { hidden: !0, selected: !0 }, value: " " });
    }
    const r = { class: ["xfaSelect"], fieldId: i[TA], dataId: ((o = i[ae]) == null ? void 0 : o[TA]) || i[TA], style: e, "aria-label": Zi(i), "aria-required": !1 };
    return rn(i) && (r["aria-required"] = !0, r.required = !0), this.open === "multiSelect" && (r.multiple = !0), lA.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [{ name: "select", children: s, attributes: r }] });
  }
}
class k2 extends Z {
  constructor(A) {
    super(iA, "color", !0), this.cSpace = _(A.cSpace, ["SRGB"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.value = A.value ? function(i, a = [0, 0, 0]) {
      let [s, r, n] = a;
      if (!i) return { r: s, g: r, b: n };
      const g = i.trim().split(/\s*,\s*/).map((o) => Math.min(Math.max(0, parseInt(o.trim(), 10)), 255)).map((o) => isNaN(o) ? 0 : o);
      return g.length < 3 ? { r: s, g: r, b: n } : ([s, r, n] = g, { r: s, g: r, b: n });
    }(A.value) : "", this.extras = null;
  }
  [Ms]() {
    return !1;
  }
  [UA]() {
    return this.value ? nt.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class F2 extends Z {
  constructor(A) {
    super(iA, "comb"), this.id = A.id || "", this.numberOfCells = pA({ data: A.numberOfCells, defaultValue: 0, validate: (e) => e >= 0 }), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class S2 extends Z {
  constructor(A) {
    super(iA, "connect", !0), this.connection = A.connection || "", this.id = A.id || "", this.ref = A.ref || "", this.usage = _(A.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = A.use || "", this.usehref = A.usehref || "", this.picture = null;
  }
}
class mI extends Z {
  constructor(A) {
    super(iA, "contentArea", !0), this.h = oA(A.h), this.id = A.id || "", this.name = A.name || "", this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.w = oA(A.w), this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.desc = null, this.extras = null;
  }
  [uA](A) {
    const e = { left: fA(this.x), top: fA(this.y), width: fA(this.w), height: fA(this.h) }, i = ["xfaContentarea"];
    return Pa(this) && i.push("xfaPrintOnly"), lA.success({ name: "div", children: [], attributes: { style: e, class: i, id: this[TA] } });
  }
}
class ZC extends Z {
  constructor(A) {
    super(iA, "corner", !0), this.id = A.id || "", this.inverted = pA({ data: A.inverted, defaultValue: 0, validate: (e) => e === 1 }), this.join = _(A.join, ["square", "round"]), this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = oA(A.radius), this.stroke = _(A.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = oA(A.thickness, "0.5pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA]() {
    const A = Nt(this, "visibility");
    return A.radius = fA(this.join === "square" ? 0 : this.radius), A;
  }
}
class R2 extends tt {
  constructor(A) {
    super(iA, "date"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = this[j].trim();
    this[j] = A ? new Date(A) : null;
  }
  [uA](A) {
    return di(this[j] ? this[j].toString() : "");
  }
}
class G2 extends tt {
  constructor(A) {
    super(iA, "dateTime"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = this[j].trim();
    this[j] = A ? new Date(A) : null;
  }
  [uA](A) {
    return di(this[j] ? this[j].toString() : "");
  }
}
class N2 extends Z {
  constructor(A) {
    super(iA, "dateTimeEdit", !0), this.hScrollPolicy = _(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.picker = _(A.picker, ["host", "none"]), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    var s;
    const e = Nt(this, "border", "font", "margin"), i = this[yA]()[yA](), a = { name: "input", attributes: { type: "text", fieldId: i[TA], dataId: ((s = i[ae]) == null ? void 0 : s[TA]) || i[TA], class: ["xfaTextfield"], style: e, "aria-label": Zi(i), "aria-required": !1 } };
    return rn(i) && (a.attributes["aria-required"] = !0, a.attributes.required = !0), lA.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a] });
  }
}
class x2 extends tt {
  constructor(A) {
    super(iA, "decimal"), this.fracDigits = pA({ data: A.fracDigits, defaultValue: 2, validate: (e) => !0 }), this.id = A.id || "", this.leadDigits = pA({ data: A.leadDigits, defaultValue: -1, validate: (e) => !0 }), this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = parseFloat(this[j].trim());
    this[j] = isNaN(A) ? null : A;
  }
  [uA](A) {
    return di(this[j] !== null ? this[j].toString() : "");
  }
}
class U2 extends Z {
  constructor(A) {
    super(iA, "defaultUi", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class M2 extends Z {
  constructor(A) {
    super(iA, "desc", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new S(), this.date = new S(), this.dateTime = new S(), this.decimal = new S(), this.exData = new S(), this.float = new S(), this.image = new S(), this.integer = new S(), this.text = new S(), this.time = new S();
  }
}
class L2 extends PA {
  constructor(A) {
    super(iA, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class J2 extends Z {
  constructor(A) {
    super(iA, "digestMethods", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.digestMethod = new S();
  }
}
class OC extends Z {
  constructor(A) {
    super(iA, "draw", !0), this.anchorType = _(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = pA({ data: A.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = A.h ? oA(A.h) : "", this.hAlign = _(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.locale = A.locale || "", this.maxH = oA(A.maxH, "0pt"), this.maxW = oA(A.maxW, "0pt"), this.minH = oA(A.minH, "0pt"), this.minW = oA(A.minW, "0pt"), this.name = A.name || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Ee(A.relevant), this.rotate = pA({ data: A.rotate, defaultValue: 0, validate: (e) => e % 90 == 0 }), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? oA(A.w) : "", this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new S();
  }
  [Yt](A) {
    fI(this, A);
  }
  [uA](A) {
    if (ig(this), this.presence === "hidden" || this.presence === "inactive") return lA.EMPTY;
    tg(this), this[Ta]();
    const e = this.w, i = this.h, { w: a, h: s, isBroken: r } = EI(this, A);
    if (a && this.w === "") {
      if (r && this[rt]()[Ze]())
        return this[Ut](), lA.FAILURE;
      this.w = a;
    }
    if (s && this.h === "" && (this.h = s), sg(this), !eg(this, A))
      return this.w = e, this.h = i, this[Ut](), lA.FAILURE;
    ng(this);
    const n = Nt(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    FC(this, n), n.margin && (n.padding = n.margin, delete n.margin);
    const g = ["xfaDraw"];
    this.font && g.push("xfaFont"), Pa(this) && g.push("xfaPrintOnly");
    const o = { style: n, id: this[TA], class: g };
    this.name && (o.xfaName = this.name);
    const I = { name: "div", attributes: o, children: [] };
    ag(this, o);
    const C = SC(this, I, A), h = this.value ? this.value[uA](A).html : null;
    return h === null ? (this.w = e, this.h = i, this[Ut](), lA.success(qi(this, I), C)) : (I.children.push(h), xC(this, n, h), this.w = e, this.h = i, this[Ut](), lA.success(qi(this, I), C));
  }
}
class gn extends Z {
  constructor(A) {
    super(iA, "edge", !0), this.cap = _(A.cap, ["square", "butt", "round"]), this.id = A.id || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = _(A.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = oA(A.thickness, "0.5pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA]() {
    const A = Nt(this, "visibility");
    if (Object.assign(A, { linecap: this.cap, width: fA(this.thickness), color: this.color ? this.color[UA]() : "#000000", style: "" }), this.presence !== "visible") A.style = "none";
    else switch (this.stroke) {
      case "solid":
        A.style = "solid";
        break;
      case "dashDot":
      case "dashDotDot":
      case "dashed":
        A.style = "dashed";
        break;
      case "dotted":
        A.style = "dotted";
        break;
      case "embossed":
        A.style = "ridge";
        break;
      case "etched":
        A.style = "groove";
        break;
      case "lowered":
        A.style = "inset";
        break;
      case "raised":
        A.style = "outset";
    }
    return A;
  }
}
class H2 extends PA {
  constructor(A) {
    super(iA, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Y2 extends Z {
  constructor(A) {
    super(iA, "encodings", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.encoding = new S();
  }
}
class v2 extends Z {
  constructor(A) {
    super(iA, "encrypt", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = null;
  }
}
class K2 extends Z {
  constructor(A) {
    super(iA, "encryptData", !0), this.id = A.id || "", this.operation = _(A.operation, ["encrypt", "decrypt"]), this.target = A.target || "", this.use = A.use || "", this.usehref = A.usehref || "", this.filter = null, this.manifest = null;
  }
}
class q2 extends Z {
  constructor(A) {
    super(iA, "encryption", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new S();
  }
}
class T2 extends PA {
  constructor(A) {
    super(iA, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class P2 extends Z {
  constructor(A) {
    super(iA, "encryptionMethods", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.encryptionMethod = new S();
  }
}
class W2 extends Z {
  constructor(A) {
    super(iA, "event", !0), this.activity = _(A.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = A.id || "", this.listen = _(A.listen, ["refOnly", "refAndDescendents"]), this.name = A.name || "", this.ref = A.ref || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
  }
}
class Z2 extends tt {
  constructor(A) {
    super(iA, "exData"), this.contentType = A.contentType || "", this.href = A.href || "", this.id = A.id || "", this.maxLength = pA({ data: A.maxLength, defaultValue: -1, validate: (e) => e >= -1 }), this.name = A.name || "", this.rid = A.rid || "", this.transferEncoding = _(A.transferEncoding, ["none", "base64", "package"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [BI]() {
    return this.contentType === "text/html";
  }
  [ke](A) {
    return this.contentType === "text/html" && A[st] === gt.xhtml.id ? (this[j] = A, !0) : this.contentType === "text/xml" ? (this[j] = A, !0) : !1;
  }
  [uA](A) {
    return this.contentType === "text/html" && this[j] ? this[j][uA](A) : lA.EMPTY;
  }
}
class O2 extends Z {
  constructor(A) {
    super(iA, "exObject", !0), this.archive = A.archive || "", this.classId = A.classId || "", this.codeBase = A.codeBase || "", this.codeType = A.codeType || "", this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.boolean = new S(), this.date = new S(), this.dateTime = new S(), this.decimal = new S(), this.exData = new S(), this.exObject = new S(), this.float = new S(), this.image = new S(), this.integer = new S(), this.text = new S(), this.time = new S();
  }
}
class XC extends Z {
  constructor(A) {
    super(iA, "exclGroup", !0), this.access = _(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = A.accessKey || "", this.anchorType = _(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = pA({ data: A.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = A.h ? oA(A.h) : "", this.hAlign = _(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.layout = _(A.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = oA(A.maxH, "0pt"), this.maxW = oA(A.maxW, "0pt"), this.minH = oA(A.minH, "0pt"), this.minW = oA(A.minW, "0pt"), this.name = A.name || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? oA(A.w) : "", this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new S(), this.event = new S(), this.field = new S(), this.setProperty = new S();
  }
  [Xi]() {
    return !0;
  }
  [Ms]() {
    return !0;
  }
  [Yt](A) {
    for (const e of this.field.children) {
      if (!e.value) {
        const i = new kI({});
        e[$A](i), e.value = i;
      }
      e.value[Yt](A);
    }
  }
  [Ze]() {
    return this.layout.endsWith("-tb") && this[P].attempt === 0 && this[P].numberInLine > 0 || this[yA]()[Ze]();
  }
  [qe]() {
    var e;
    const A = this[rt]();
    return A[qe]() ? this[P]._isSplittable !== void 0 ? this[P]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[P]._isSplittable = !1, !1) : (e = A.layout) != null && e.endsWith("-tb") && A[P].numberInLine !== 0 ? !1 : (this[P]._isSplittable = !0, !0) : !1;
  }
  [nn]() {
    return JC(this);
  }
  [vi](A, e) {
    HC(this, A, e);
  }
  [Ki]() {
    return YC(this);
  }
  [uA](A) {
    if (ig(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) return lA.EMPTY;
    tg(this);
    const e = [], i = { id: this[TA], class: [] };
    uI(this, i.class), this[P] || (this[P] = /* @__PURE__ */ Object.create(null)), Object.assign(this[P], { children: e, attributes: i, attempt: 0, line: null, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, A.width), height: Math.min(this.h || 1 / 0, A.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const a = this[qe]();
    if (a || sg(this), !eg(this, A)) return lA.FAILURE;
    const s = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const E = this[rt]().columnWidths;
      Array.isArray(E) && E.length > 0 && (this[P].columnWidths = E, this[P].currentColumn = 0);
    }
    const r = Nt(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), n = ["xfaExclgroup"], g = RC(this);
    g && n.push(g), Pa(this) && n.push("xfaPrintOnly"), i.style = r, i.class = n, this.name && (i.xfaName = this.name), this[Ta]();
    const o = this.layout === "lr-tb" || this.layout === "rl-tb", I = o ? 2 : 1;
    for (; this[P].attempt < I; this[P].attempt++) {
      o && this[P].attempt === 1 && (this[P].numberInLine = 0);
      const E = this[ui]({ filter: s, include: !0 });
      if (E.success) break;
      if (E.isBreak())
        return this[Ut](), E;
      if (o && this[P].attempt === 0 && this[P].numberInLine === 0 && !this[at]()[P].noLayoutFailure) {
        this[P].attempt = I;
        break;
      }
    }
    if (this[Ut](), a || ng(this), this[P].attempt === I)
      return a || delete this[P], lA.FAILURE;
    let C = 0, h = 0;
    this.margin && (C = this.margin.leftInset + this.margin.rightInset, h = this.margin.topInset + this.margin.bottomInset);
    const c = Math.max(this[P].width + C, this.w || 0), B = Math.max(this[P].height + h, this.h || 0), l = [this.x, this.y, c, B];
    this.w === "" && (r.width = fA(c)), this.h === "" && (r.height = fA(B));
    const Q = { name: "div", attributes: i, children: e };
    return ag(this, i), delete this[P], lA.success(qi(this, Q), l);
  }
}
class X2 extends Z {
  constructor(A) {
    super(iA, "execute"), this.connection = A.connection || "", this.executeType = _(A.executeType, ["import", "remerge"]), this.id = A.id || "", this.runAt = _(A.runAt, ["client", "both", "server"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class V2 extends Z {
  constructor(A) {
    super(iA, "extras", !0), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new S(), this.date = new S(), this.dateTime = new S(), this.decimal = new S(), this.exData = new S(), this.extras = new S(), this.float = new S(), this.image = new S(), this.integer = new S(), this.text = new S(), this.time = new S();
  }
}
class yI extends Z {
  constructor(A) {
    super(iA, "field", !0), this.access = _(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = A.accessKey || "", this.anchorType = _(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = pA({ data: A.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.h = A.h ? oA(A.h) : "", this.hAlign = _(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.locale = A.locale || "", this.maxH = oA(A.maxH, "0pt"), this.maxW = oA(A.maxW, "0pt"), this.minH = oA(A.minH, "0pt"), this.minW = oA(A.minW, "0pt"), this.name = A.name || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Ee(A.relevant), this.rotate = pA({ data: A.rotate, defaultValue: 0, validate: (e) => e % 90 == 0 }), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? oA(A.w) : "", this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new S(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new S(), this.connect = new S(), this.event = new S(), this.setProperty = new S();
  }
  [Xi]() {
    return !0;
  }
  [Yt](A) {
    fI(this, A);
  }
  [uA](A) {
    var E, u, f;
    if (ig(this), !this.ui) {
      this.ui = new bI({}), this.ui[WA] = this[WA], this[$A](this.ui);
      let d;
      switch (this.items.children.length) {
        case 0:
          d = new Ah({}), this.ui.textEdit = d;
          break;
        case 1:
          d = new PC({}), this.ui.checkButton = d;
          break;
        case 2:
          d = new WC({}), this.ui.choiceList = d;
      }
      this.ui[$A](d);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0) return lA.EMPTY;
    this.caption && delete this.caption[P], this[Ta]();
    const e = this.caption ? this.caption[uA](A).html : null, i = this.w, a = this.h;
    let s = 0, r = 0;
    this.margin && (s = this.margin.leftInset + this.margin.rightInset, r = this.margin.topInset + this.margin.bottomInset);
    let n = null;
    if (this.w === "" || this.h === "") {
      let d = null, p = null, m = 0, y = 0;
      if (this.ui.checkButton) m = y = this.ui.checkButton.size;
      else {
        const { w: b, h: D } = EI(this, A);
        b !== null ? (m = b, y = D) : y = function(k, Y = !1) {
          let V = null;
          if (k) {
            const L = $r(k.typeface), v = k[WA].fontFinder.find(L);
            V = lI(k, v);
          }
          if (!V) return { lineHeight: 12, lineGap: 2, lineNoGap: 10 };
          const eA = k.size || 10, AA = V.lineHeight ? Math.max(Y ? 0 : 1.2, V.lineHeight) : 1.2, O = V.lineGap === void 0 ? 0.2 : V.lineGap;
          return { lineHeight: AA * eA, lineGap: O * eA, lineNoGap: Math.max(1, AA - O) * eA };
        }(this.font, !0).lineNoGap;
      }
      if (n = h0(this.ui[dt]()), m += n.w, y += n.h, this.caption) {
        const { w: b, h: D, isBroken: R } = this.caption[dt](A);
        if (R && this[rt]()[Ze]())
          return this[Ut](), lA.FAILURE;
        switch (d = b, p = D, this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            d += m;
            break;
          case "top":
          case "bottom":
            p += y;
        }
      } else
        d = m, p = y;
      d && this.w === "" && (d += s, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < d ? d : this.minW)), p && this.h === "" && (p += r, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < p ? p : this.minH));
    }
    if (this[Ut](), tg(this), sg(this), !eg(this, A))
      return this.w = i, this.h = a, this[Ut](), lA.FAILURE;
    ng(this);
    const g = Nt(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    FC(this, g);
    const o = ["xfaField"];
    this.font && o.push("xfaFont"), Pa(this) && o.push("xfaPrintOnly");
    const I = { style: g, id: this[TA], class: o };
    g.margin && (g.padding = g.margin, delete g.margin), uI(this, o), this.name && (I.xfaName = this.name);
    const C = [], h = { name: "div", attributes: I, children: C };
    ag(this, I);
    const c = this.border ? this.border[UA]() : null, B = SC(this, h, A), l = this.ui[uA]().html;
    if (!l)
      return Object.assign(g, c), lA.success(qi(this, h), B);
    this[ce] && ((E = l.children) != null && E[0] ? l.children[0].attributes.tabindex = this[ce] : l.attributes.tabindex = this[ce]), l.attributes.style || (l.attributes.style = /* @__PURE__ */ Object.create(null));
    let Q = null;
    if (this.ui.button ? (l.children.length === 1 && ([Q] = l.children.splice(0, 1)), Object.assign(l.attributes.style, c)) : Object.assign(g, c), C.push(l), this.value) {
      if (this.ui.imageEdit) l.children.push(this.value[uA]().html);
      else if (!this.ui.button) {
        let d = "";
        if (this.value.exData) d = this.value.exData[It]();
        else if (this.value.text) d = this.value.text[dt]();
        else {
          const p = this.value[uA]().html;
          p !== null && (d = p.children[0].value);
        }
        this.ui.textEdit && ((u = this.value.text) != null && u.maxChars) && (l.children[0].attributes.maxLength = this.value.text.maxChars), d && (this.ui.numericEdit && (d = parseFloat(d), d = isNaN(d) ? "" : d.toString()), l.children[0].name === "textarea" ? l.children[0].attributes.textContent = d : l.children[0].attributes.value = d);
      }
    }
    if (!this.ui.imageEdit && ((f = l.children) != null && f[0]) && this.h) {
      n = n || h0(this.ui[dt]());
      let d = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        d = this.caption.reserve, d <= 0 && (d = this.caption[dt](A).h);
        const p = this.h - d - r - n.h;
        l.children[0].attributes.style.height = fA(p);
      } else l.children[0].attributes.style.height = "100%";
    }
    if (Q && l.children.push(Q), !e)
      return l.attributes.class && l.attributes.class.push("xfaLeft"), this.w = i, this.h = a, lA.success(qi(this, h), B);
    if (this.ui.button)
      return g.padding && delete g.padding, e.name === "div" && (e.name = "span"), l.children.push(e), lA.success(h, B);
    switch (this.ui.checkButton && (e.attributes.class[0] = "xfaCaptionForCheckButton"), l.attributes.class || (l.attributes.class = []), l.children.splice(0, 0, e), this.caption.placement) {
      case "left":
      case "inline":
        l.attributes.class.push("xfaLeft");
        break;
      case "right":
        l.attributes.class.push("xfaRight");
        break;
      case "top":
        l.attributes.class.push("xfaTop");
        break;
      case "bottom":
        l.attributes.class.push("xfaBottom");
    }
    return this.w = i, this.h = a, lA.success(qi(this, h), B);
  }
}
class j2 extends Z {
  constructor(A) {
    super(iA, "fill", !0), this.id = A.id || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
  }
  [UA]() {
    var r;
    const A = this[yA](), e = A[yA]()[yA](), i = /* @__PURE__ */ Object.create(null);
    let a = "color", s = a;
    A instanceof KC && (a = "background-color", s = "background", e instanceof bI && (i.backgroundColor = "white")), (A instanceof zC || A instanceof vC) && (a = s = "fill", i.fill = "white");
    for (const n of Object.getOwnPropertyNames(this)) {
      if (n === "extras" || n === "color") continue;
      const g = this[n];
      if (!(g instanceof Z)) continue;
      const o = g[UA](this.color);
      return o && (i[o.startsWith("#") ? a : s] = o), i;
    }
    if ((r = this.color) != null && r.value) {
      const n = this.color[UA]();
      i[n.startsWith("#") ? a : s] = n;
    }
    return i;
  }
}
class z2 extends Z {
  constructor(A) {
    super(iA, "filter", !0), this.addRevocationInfo = _(A.addRevocationInfo, ["", "required", "optional", "none"]), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.version = pA({ data: this.version, defaultValue: 5, validate: (e) => e >= 1 && e <= 5 }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
  }
}
class _2 extends tt {
  constructor(A) {
    super(iA, "float"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = parseFloat(this[j].trim());
    this[j] = isNaN(A) ? null : A;
  }
  [uA](A) {
    return di(this[j] !== null ? this[j].toString() : "");
  }
}
class $2 extends Z {
  constructor(A) {
    super(iA, "font", !0), this.baselineShift = oA(A.baselineShift), this.fontHorizontalScale = yr({ data: A.fontHorizontalScale, defaultValue: 100, validate: (e) => e >= 0 }), this.fontVerticalScale = yr({ data: A.fontVerticalScale, defaultValue: 100, validate: (e) => e >= 0 }), this.id = A.id || "", this.kerningMode = _(A.kerningMode, ["none", "pair"]), this.letterSpacing = oA(A.letterSpacing, "0"), this.lineThrough = pA({ data: A.lineThrough, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.lineThroughPeriod = _(A.lineThroughPeriod, ["all", "word"]), this.overline = pA({ data: A.overline, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.overlinePeriod = _(A.overlinePeriod, ["all", "word"]), this.posture = _(A.posture, ["normal", "italic"]), this.size = oA(A.size, "10pt"), this.typeface = A.typeface || "Courier", this.underline = pA({ data: A.underline, defaultValue: 0, validate: (e) => e === 1 || e === 2 }), this.underlinePeriod = _(A.underlinePeriod, ["all", "word"]), this.use = A.use || "", this.usehref = A.usehref || "", this.weight = _(A.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
  }
  [ne](A) {
    super[ne](A), this[WA].usedTypefaces.add(this.typeface);
  }
  [UA]() {
    const A = Nt(this, "fill"), e = A.color;
    return e && (e === "#000000" ? delete A.color : e.startsWith("#") || (A.background = e, A.backgroundClip = "text", A.color = "transparent")), this.baselineShift && (A.verticalAlign = fA(this.baselineShift)), A.fontKerning = this.kerningMode === "none" ? "none" : "normal", A.letterSpacing = fA(this.letterSpacing), this.lineThrough !== 0 && (A.textDecoration = "line-through", this.lineThrough === 2 && (A.textDecorationStyle = "double")), this.overline !== 0 && (A.textDecoration = "overline", this.overline === 2 && (A.textDecorationStyle = "double")), A.fontStyle = this.posture, A.fontSize = fA(0.99 * this.size), UC(this, this, this[WA].fontFinder, A), this.underline !== 0 && (A.textDecoration = "underline", this.underline === 2 && (A.textDecorationStyle = "double")), A.fontWeight = this.weight, A;
  }
}
class Au extends Z {
  constructor(A) {
    super(iA, "format", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.picture = null;
  }
}
class tu extends GA {
  constructor(A) {
    super(iA, "handler"), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class eu extends Z {
  constructor(A) {
    super(iA, "hyphenation"), this.excludeAllCaps = pA({ data: A.excludeAllCaps, defaultValue: 0, validate: (e) => e === 1 }), this.excludeInitialCap = pA({ data: A.excludeInitialCap, defaultValue: 0, validate: (e) => e === 1 }), this.hyphenate = pA({ data: A.hyphenate, defaultValue: 0, validate: (e) => e === 1 }), this.id = A.id || "", this.pushCharacterCount = pA({ data: A.pushCharacterCount, defaultValue: 3, validate: (e) => e >= 0 }), this.remainCharacterCount = pA({ data: A.remainCharacterCount, defaultValue: 3, validate: (e) => e >= 0 }), this.use = A.use || "", this.usehref = A.usehref || "", this.wordCharacterCount = pA({ data: A.wordCharacterCount, defaultValue: 7, validate: (e) => e >= 0 });
  }
}
class VC extends GA {
  constructor(A) {
    super(iA, "image"), this.aspect = _(A.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = A.contentType || "", this.href = A.href || "", this.id = A.id || "", this.name = A.name || "", this.transferEncoding = _(A.transferEncoding, ["base64", "none", "package"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [uA]() {
    if (this.contentType && !C2.has(this.contentType.toLowerCase())) return lA.EMPTY;
    let A = this[WA].images && this[WA].images.get(this.href);
    if (!A && (this.href || !this[j]) || (A || this.transferEncoding !== "base64" || (A = function(r) {
      return Uint8Array.fromBase64 ? Uint8Array.fromBase64(r) : ut(atob(r));
    }(this[j])), !A)) return lA.EMPTY;
    if (!this.contentType) {
      for (const [s, r] of h2) if (A.length > s.length && s.every((n, g) => n === A[g])) {
        this.contentType = r;
        break;
      }
      if (!this.contentType) return lA.EMPTY;
    }
    const e = new Blob([A], { type: this.contentType });
    let i;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        i = { height: "100%", objectFit: "fill" };
        break;
      case "none":
        i = { width: "100%", height: "100%", objectFit: "fill" };
        break;
      case "width":
        i = { width: "100%", objectFit: "fill" };
    }
    const a = this[yA]();
    return lA.success({ name: "img", attributes: { class: ["xfaImage"], style: i, src: URL.createObjectURL(e), alt: a ? Zi(a[yA]()) : null } });
  }
}
class iu extends Z {
  constructor(A) {
    super(iA, "imageEdit", !0), this.data = _(A.data, ["link", "embed"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    return this.data === "embed" ? lA.success({ name: "div", children: [], attributes: {} }) : lA.EMPTY;
  }
}
class au extends tt {
  constructor(A) {
    super(iA, "integer"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = parseInt(this[j].trim(), 10);
    this[j] = isNaN(A) ? null : A;
  }
  [uA](A) {
    return di(this[j] !== null ? this[j].toString() : "");
  }
}
class su extends Z {
  constructor(A) {
    super(iA, "issuers", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new S();
  }
}
class Mo extends Z {
  constructor(A) {
    super(iA, "items", !0), this.id = A.id || "", this.name = A.name || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = A.ref || "", this.save = pA({ data: A.save, defaultValue: 0, validate: (e) => e === 1 }), this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new S(), this.date = new S(), this.dateTime = new S(), this.decimal = new S(), this.exData = new S(), this.float = new S(), this.image = new S(), this.integer = new S(), this.text = new S(), this.time = new S();
  }
  [uA]() {
    const A = [];
    for (const e of this[Qt]()) A.push(e[It]());
    return lA.success(A);
  }
}
class nu extends Z {
  constructor(A) {
    super(iA, "keep", !0), this.id = A.id || "";
    const e = ["none", "contentArea", "pageArea"];
    this.intact = _(A.intact, e), this.next = _(A.next, e), this.previous = _(A.previous, e), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class ru extends Z {
  constructor(A) {
    super(iA, "keyUsage");
    const e = ["", "yes", "no"];
    this.crlSign = _(A.crlSign, e), this.dataEncipherment = _(A.dataEncipherment, e), this.decipherOnly = _(A.decipherOnly, e), this.digitalSignature = _(A.digitalSignature, e), this.encipherOnly = _(A.encipherOnly, e), this.id = A.id || "", this.keyAgreement = _(A.keyAgreement, e), this.keyCertSign = _(A.keyCertSign, e), this.keyEncipherment = _(A.keyEncipherment, e), this.nonRepudiation = _(A.nonRepudiation, e), this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class gu extends Z {
  constructor(A) {
    super(iA, "line", !0), this.hand = _(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.slope = _(A.slope, ["\\", "/"]), this.use = A.use || "", this.usehref = A.usehref || "", this.edge = null;
  }
  [uA]() {
    const A = this[yA]()[yA](), e = this.edge || new gn({}), i = e[UA](), a = /* @__PURE__ */ Object.create(null), s = e.presence === "visible" ? e.thickness : 0;
    a.strokeWidth = fA(s), a.stroke = i.color;
    let r, n, g, o, I = "100%", C = "100%";
    A.w <= s ? ([r, n, g, o] = ["50%", 0, "50%", "100%"], I = a.strokeWidth) : A.h <= s ? ([r, n, g, o] = [0, "50%", "100%", "50%"], C = a.strokeWidth) : this.slope === "\\" ? [r, n, g, o] = [0, 0, "100%", "100%"] : [r, n, g, o] = [0, "100%", "100%", 0];
    const h = { name: "svg", children: [{ name: "line", attributes: { xmlns: Ti, x1: r, y1: n, x2: g, y2: o, style: a } }], attributes: { xmlns: Ti, width: I, height: C, style: { overflow: "visible" } } };
    return dI(A) ? lA.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [h] }) : (h.attributes.style.position = "absolute", lA.success(h));
  }
}
class ou extends Z {
  constructor(A) {
    super(iA, "linear", !0), this.id = A.id || "", this.type = _(A.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA](A) {
    return A = A ? A[UA]() : "#FFFFFF", `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${A}, ${this.color ? this.color[UA]() : "#000000"})`;
  }
}
class Iu extends tt {
  constructor(A) {
    super(iA, "lockDocument"), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    this[j] = _(this[j], ["auto", "0", "1"]);
  }
}
class cu extends Z {
  constructor(A) {
    super(iA, "manifest", !0), this.action = _(A.action, ["include", "all", "exclude"]), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.ref = new S();
  }
}
class Cu extends Z {
  constructor(A) {
    super(iA, "margin", !0), this.bottomInset = oA(A.bottomInset, "0"), this.id = A.id || "", this.leftInset = oA(A.leftInset, "0"), this.rightInset = oA(A.rightInset, "0"), this.topInset = oA(A.topInset, "0"), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [UA]() {
    return { margin: fA(this.topInset) + " " + fA(this.rightInset) + " " + fA(this.bottomInset) + " " + fA(this.leftInset) };
  }
}
class hu extends Z {
  constructor(A) {
    super(iA, "mdp"), this.id = A.id || "", this.permissions = pA({ data: A.permissions, defaultValue: 2, validate: (e) => e === 1 || e === 3 }), this.signatureType = _(A.signatureType, ["filler", "author"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Bu extends Z {
  constructor(A) {
    super(iA, "medium"), this.id = A.id || "", this.imagingBBox = function(i) {
      if (!i) return { x: -1, y: -1, width: -1, height: -1 };
      const s = i.trim().split(/\s*,\s*/).map((I) => oA(I, "-1"));
      if (s.length < 4 || s[2] < 0 || s[3] < 0) return { x: -1, y: -1, width: -1, height: -1 };
      const [r, n, g, o] = s;
      return { x: r, y: n, width: g, height: o };
    }(A.imagingBBox), this.long = oA(A.long), this.orientation = _(A.orientation, ["portrait", "landscape"]), this.short = oA(A.short), this.stock = A.stock || "", this.trayIn = _(A.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = _(A.trayOut, ["auto", "delegate"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class lu extends Z {
  constructor(A) {
    super(iA, "message", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.text = new S();
  }
}
class Qu extends Z {
  constructor(A) {
    super(iA, "numericEdit", !0), this.hScrollPolicy = _(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    var s;
    const e = Nt(this, "border", "font", "margin"), i = this[yA]()[yA](), a = { name: "input", attributes: { type: "text", fieldId: i[TA], dataId: ((s = i[ae]) == null ? void 0 : s[TA]) || i[TA], class: ["xfaTextfield"], style: e, "aria-label": Zi(i), "aria-required": !1 } };
    return rn(i) && (a.attributes["aria-required"] = !0, a.attributes.required = !0), lA.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [a] });
  }
}
class Eu extends Z {
  constructor(A) {
    super(iA, "occur", !0), this.id = A.id || "", this.initial = A.initial !== "" ? pA({ data: A.initial, defaultValue: "", validate: (e) => !0 }) : "", this.max = A.max !== "" ? pA({ data: A.max, defaultValue: 1, validate: (e) => !0 }) : "", this.min = A.min !== "" ? pA({ data: A.min, defaultValue: 1, validate: (e) => !0 }) : "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [ne]() {
    const A = this[yA](), e = this.min;
    this.min === "" && (this.min = A instanceof Ha || A instanceof Hs ? 0 : 1), this.max === "" && (this.max = e === "" ? A instanceof Ha || A instanceof Hs ? -1 : 1 : this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = A instanceof DI ? 1 : this.min);
  }
}
class uu extends GA {
  constructor(A) {
    super(iA, "oid"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class du extends Z {
  constructor(A) {
    super(iA, "oids", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.oid = new S();
  }
}
class jC extends Z {
  constructor(A) {
    super(iA, "overflow"), this.id = A.id || "", this.leader = A.leader || "", this.target = A.target || "", this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [dt]() {
    if (!this[P]) {
      const A = this[yA](), e = this[at](), i = e[Ye](this.target, A), a = e[Ye](this.leader, A), s = e[Ye](this.trailer, A);
      this[P] = { target: (i == null ? void 0 : i[0]) || null, leader: (a == null ? void 0 : a[0]) || null, trailer: (s == null ? void 0 : s[0]) || null, addLeader: !1, addTrailer: !1 };
    }
    return this[P];
  }
}
class Ha extends Z {
  constructor(A) {
    super(iA, "pageArea", !0), this.blankOrNotBlank = _(A.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = A.id || "", this.initialNumber = pA({ data: A.initialNumber, defaultValue: 1, validate: (e) => !0 }), this.name = A.name || "", this.numbered = pA({ data: A.numbered, defaultValue: 1, validate: (e) => !0 }), this.oddOrEven = _(A.oddOrEven, ["any", "even", "odd"]), this.pagePosition = _(A.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new S(), this.contentArea = new S(), this.draw = new S(), this.exclGroup = new S(), this.field = new S(), this.subform = new S();
  }
  [Js]() {
    return this[P] ? !this.occur || this.occur.max === -1 || this[P].numberOfUse < this.occur.max : (this[P] = { numberOfUse: 0 }, !0);
  }
  [ha]() {
    delete this[P];
  }
  [Le]() {
    this[P] || (this[P] = { numberOfUse: 0 });
    const A = this[yA]();
    return A.relation === "orderedOccurrence" && this[Js]() ? (this[P].numberOfUse += 1, this) : A[Le]();
  }
  [Ki]() {
    return this[P].space || { width: 0, height: 0 };
  }
  [uA]() {
    this[P] || (this[P] = { numberOfUse: 1 });
    const A = [];
    this[P].children = A;
    const e = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      if (e.width = fA(this.medium.short), e.height = fA(this.medium.long), this[P].space = { width: this.medium.short, height: this.medium.long }, this.medium.orientation === "landscape") {
        const i = e.width;
        e.width = e.height, e.height = i, this[P].space = { width: this.medium.long, height: this.medium.short };
      }
    } else G("XFA - No medium specified in pageArea: please file a bug.");
    return this[ui]({ filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]), include: !0 }), this[ui]({ filter: /* @__PURE__ */ new Set(["contentArea"]), include: !0 }), lA.success({ name: "div", children: A, attributes: { class: ["xfaPage"], id: this[TA], style: e, xfaName: this.name } });
  }
}
class Hs extends Z {
  constructor(A) {
    super(iA, "pageSet", !0), this.duplexImposition = _(A.duplexImposition, ["longEdge", "shortEdge"]), this.id = A.id || "", this.name = A.name || "", this.relation = _(A.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.occur = null, this.pageArea = new S(), this.pageSet = new S();
  }
  [ha]() {
    for (const A of this.pageArea.children) A[ha]();
    for (const A of this.pageSet.children) A[ha]();
  }
  [Js]() {
    return !this.occur || this.occur.max === -1 || this[P].numberOfUse < this.occur.max;
  }
  [Le]() {
    if (this[P] || (this[P] = { numberOfUse: 1, pageIndex: -1, pageSetIndex: -1 }), this.relation === "orderedOccurrence") {
      if (this[P].pageIndex + 1 < this.pageArea.children.length)
        return this[P].pageIndex += 1, this.pageArea.children[this[P].pageIndex][Le]();
      if (this[P].pageSetIndex + 1 < this.pageSet.children.length)
        return this[P].pageSetIndex += 1, this.pageSet.children[this[P].pageSetIndex][Le]();
      if (this[Js]())
        return this[P].numberOfUse += 1, this[P].pageIndex = -1, this[P].pageSetIndex = -1, this[Le]();
      const s = this[yA]();
      return s instanceof Hs ? s[Le]() : (this[ha](), this[Le]());
    }
    const A = this[at]()[P].pageNumber, e = A % 2 == 0 ? "even" : "odd", i = A === 0 ? "first" : "rest";
    let a = this.pageArea.children.find((s) => s.oddOrEven === e && s.pagePosition === i);
    return a || (a = this.pageArea.children.find((s) => s.oddOrEven === "any" && s.pagePosition === i), a) ? a : (a = this.pageArea.children.find((s) => s.oddOrEven === "any" && s.pagePosition === "any"), a || this.pageArea.children[0]);
  }
}
class fu extends Z {
  constructor(A) {
    super(iA, "para", !0), this.hAlign = _(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.lineHeight = A.lineHeight ? oA(A.lineHeight, "0pt") : "", this.marginLeft = A.marginLeft ? oA(A.marginLeft, "0pt") : "", this.marginRight = A.marginRight ? oA(A.marginRight, "0pt") : "", this.orphans = pA({ data: A.orphans, defaultValue: 0, validate: (e) => e >= 0 }), this.preserve = A.preserve || "", this.radixOffset = A.radixOffset ? oA(A.radixOffset, "0pt") : "", this.spaceAbove = A.spaceAbove ? oA(A.spaceAbove, "0pt") : "", this.spaceBelow = A.spaceBelow ? oA(A.spaceBelow, "0pt") : "", this.tabDefault = A.tabDefault ? oA(this.tabDefault) : "", this.tabStops = (A.tabStops || "").trim().split(/\s+/).map((e, i) => i % 2 == 1 ? oA(e) : e), this.textIndent = A.textIndent ? oA(A.textIndent, "0pt") : "", this.use = A.use || "", this.usehref = A.usehref || "", this.vAlign = _(A.vAlign, ["top", "bottom", "middle"]), this.widows = pA({ data: A.widows, defaultValue: 0, validate: (e) => e >= 0 }), this.hyphenation = null;
  }
  [UA]() {
    const A = Nt(this, "hAlign");
    return this.marginLeft !== "" && (A.paddingLeft = fA(this.marginLeft)), this.marginRight !== "" && (A.paddingRight = fA(this.marginRight)), this.spaceAbove !== "" && (A.paddingTop = fA(this.spaceAbove)), this.spaceBelow !== "" && (A.paddingBottom = fA(this.spaceBelow)), this.textIndent !== "" && (A.textIndent = fA(this.textIndent), GC(A)), this.lineHeight > 0 && (A.lineHeight = fA(this.lineHeight)), this.tabDefault !== "" && (A.tabSize = fA(this.tabDefault)), this.tabStops.length, this.hyphenatation && Object.assign(A, this.hyphenatation[UA]()), A;
  }
}
class pu extends Z {
  constructor(A) {
    super(iA, "passwordEdit", !0), this.hScrollPolicy = _(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.passwordChar = A.passwordChar || "*", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
}
class mu extends Z {
  constructor(A) {
    super(iA, "pattern", !0), this.id = A.id || "", this.type = _(A.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA](A) {
    A = A ? A[UA]() : "#FFFFFF";
    const e = this.color ? this.color[UA]() : "#000000", i = "repeating-linear-gradient", a = `${A},${A} 5px,${e} 5px,${e} 10px`;
    switch (this.type) {
      case "crossHatch":
        return `${i}(to top,${a}) ${i}(to right,${a})`;
      case "crossDiagonal":
        return `${i}(45deg,${a}) ${i}(-45deg,${a})`;
      case "diagonalLeft":
        return `${i}(45deg,${a})`;
      case "diagonalRight":
        return `${i}(-45deg,${a})`;
      case "horizontal":
        return `${i}(to top,${a})`;
      case "vertical":
        return `${i}(to right,${a})`;
    }
    return "";
  }
}
class yu extends GA {
  constructor(A) {
    super(iA, "picture"), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class wu extends Z {
  constructor(A) {
    super(iA, "proto", !0), this.appearanceFilter = new S(), this.arc = new S(), this.area = new S(), this.assist = new S(), this.barcode = new S(), this.bindItems = new S(), this.bookend = new S(), this.boolean = new S(), this.border = new S(), this.break = new S(), this.breakAfter = new S(), this.breakBefore = new S(), this.button = new S(), this.calculate = new S(), this.caption = new S(), this.certificate = new S(), this.certificates = new S(), this.checkButton = new S(), this.choiceList = new S(), this.color = new S(), this.comb = new S(), this.connect = new S(), this.contentArea = new S(), this.corner = new S(), this.date = new S(), this.dateTime = new S(), this.dateTimeEdit = new S(), this.decimal = new S(), this.defaultUi = new S(), this.desc = new S(), this.digestMethod = new S(), this.digestMethods = new S(), this.draw = new S(), this.edge = new S(), this.encoding = new S(), this.encodings = new S(), this.encrypt = new S(), this.encryptData = new S(), this.encryption = new S(), this.encryptionMethod = new S(), this.encryptionMethods = new S(), this.event = new S(), this.exData = new S(), this.exObject = new S(), this.exclGroup = new S(), this.execute = new S(), this.extras = new S(), this.field = new S(), this.fill = new S(), this.filter = new S(), this.float = new S(), this.font = new S(), this.format = new S(), this.handler = new S(), this.hyphenation = new S(), this.image = new S(), this.imageEdit = new S(), this.integer = new S(), this.issuers = new S(), this.items = new S(), this.keep = new S(), this.keyUsage = new S(), this.line = new S(), this.linear = new S(), this.lockDocument = new S(), this.manifest = new S(), this.margin = new S(), this.mdp = new S(), this.medium = new S(), this.message = new S(), this.numericEdit = new S(), this.occur = new S(), this.oid = new S(), this.oids = new S(), this.overflow = new S(), this.pageArea = new S(), this.pageSet = new S(), this.para = new S(), this.passwordEdit = new S(), this.pattern = new S(), this.picture = new S(), this.radial = new S(), this.reason = new S(), this.reasons = new S(), this.rectangle = new S(), this.ref = new S(), this.script = new S(), this.setProperty = new S(), this.signData = new S(), this.signature = new S(), this.signing = new S(), this.solid = new S(), this.speak = new S(), this.stipple = new S(), this.subform = new S(), this.subformSet = new S(), this.subjectDN = new S(), this.subjectDNs = new S(), this.submit = new S(), this.text = new S(), this.textEdit = new S(), this.time = new S(), this.timeStamp = new S(), this.toolTip = new S(), this.traversal = new S(), this.traverse = new S(), this.ui = new S(), this.validate = new S(), this.value = new S(), this.variables = new S();
  }
}
class Du extends Z {
  constructor(A) {
    super(iA, "radial", !0), this.id = A.id || "", this.type = _(A.type, ["toEdge", "toCenter"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA](A) {
    A = A ? A[UA]() : "#FFFFFF";
    const e = this.color ? this.color[UA]() : "#000000";
    return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${A},${e}` : `${e},${A}`})`;
  }
}
class bu extends GA {
  constructor(A) {
    super(iA, "reason"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class ku extends Z {
  constructor(A) {
    super(iA, "reasons", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.reason = new S();
  }
}
class zC extends Z {
  constructor(A) {
    super(iA, "rectangle", !0), this.hand = _(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.corner = new S(4), this.edge = new S(4), this.fill = null;
  }
  [uA]() {
    var r;
    const A = this.edge.children.length ? this.edge.children[0] : new gn({}), e = A[UA](), i = /* @__PURE__ */ Object.create(null);
    ((r = this.fill) == null ? void 0 : r.presence) === "visible" ? Object.assign(i, this.fill[UA]()) : i.fill = "transparent", i.strokeWidth = fA(A.presence === "visible" ? A.thickness : 0), i.stroke = e.color;
    const a = (this.corner.children.length ? this.corner.children[0] : new ZC({}))[UA](), s = { name: "svg", children: [{ name: "rect", attributes: { xmlns: Ti, width: "100%", height: "100%", x: 0, y: 0, rx: a.radius, ry: a.radius, style: i } }], attributes: { xmlns: Ti, style: { overflow: "visible" }, width: "100%", height: "100%" } };
    return dI(this[yA]()[yA]()) ? lA.success({ name: "div", attributes: { style: { display: "inline", width: "100%", height: "100%" } }, children: [s] }) : (s.attributes.style.position = "absolute", lA.success(s));
  }
}
class Fu extends GA {
  constructor(A) {
    super(iA, "ref"), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Su extends GA {
  constructor(A) {
    super(iA, "script"), this.binding = A.binding || "", this.contentType = A.contentType || "", this.id = A.id || "", this.name = A.name || "", this.runAt = _(A.runAt, ["client", "both", "server"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Lo extends Z {
  constructor(A) {
    super(iA, "setProperty"), this.connection = A.connection || "", this.ref = A.ref || "", this.target = A.target || "";
  }
}
class Ru extends Z {
  constructor(A) {
    super(iA, "signData", !0), this.id = A.id || "", this.operation = _(A.operation, ["sign", "clear", "verify"]), this.ref = A.ref || "", this.target = A.target || "", this.use = A.use || "", this.usehref = A.usehref || "", this.filter = null, this.manifest = null;
  }
}
class Gu extends Z {
  constructor(A) {
    super(iA, "signature", !0), this.id = A.id || "", this.type = _(A.type, ["PDF1.3", "PDF1.6"]), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
  }
}
class Nu extends Z {
  constructor(A) {
    super(iA, "signing", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new S();
  }
}
class xu extends Z {
  constructor(A) {
    super(iA, "solid", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [UA](A) {
    return A ? A[UA]() : "#FFFFFF";
  }
}
class Uu extends GA {
  constructor(A) {
    super(iA, "speak"), this.disable = pA({ data: A.disable, defaultValue: 0, validate: (e) => e === 1 }), this.id = A.id || "", this.priority = _(A.priority, ["custom", "caption", "name", "toolTip"]), this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Mu extends Z {
  constructor(A) {
    super(iA, "stipple", !0), this.id = A.id || "", this.rate = pA({ data: A.rate, defaultValue: 50, validate: (e) => e >= 0 && e <= 100 }), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [UA](A) {
    const e = this.rate / 100;
    return nt.makeHexColor(Math.round(A.value.r * (1 - e) + this.value.r * e), Math.round(A.value.g * (1 - e) + this.value.g * e), Math.round(A.value.b * (1 - e) + this.value.b * e));
  }
}
class _C extends Z {
  constructor(A) {
    super(iA, "subform", !0), this.access = _(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = pA({ data: A.allowMacro, defaultValue: 0, validate: (e) => e === 1 }), this.anchorType = _(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = pA({ data: A.colSpan, defaultValue: 1, validate: (e) => e >= 1 || e === -1 }), this.columnWidths = (A.columnWidths || "").trim().split(/\s+/).map((e) => e === "-1" ? -1 : oA(e)), this.h = A.h ? oA(A.h) : "", this.hAlign = _(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.layout = _(A.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = A.locale || "", this.maxH = oA(A.maxH, "0pt"), this.maxW = oA(A.maxW, "0pt"), this.mergeMode = _(A.mergeMode, ["consumeData", "matchTemplate"]), this.minH = oA(A.minH, "0pt"), this.minW = oA(A.minW, "0pt"), this.name = A.name || "", this.presence = _(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Ee(A.relevant), this.restoreState = _(A.restoreState, ["manual", "auto"]), this.scope = _(A.scope, ["name", "none"]), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? oA(A.w) : "", this.x = oA(A.x, "0pt"), this.y = oA(A.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new S(), this.breakAfter = new S(), this.breakBefore = new S(), this.connect = new S(), this.draw = new S(), this.event = new S(), this.exObject = new S(), this.exclGroup = new S(), this.field = new S(), this.proto = new S(), this.setProperty = new S(), this.subform = new S(), this.subformSet = new S();
  }
  [rt]() {
    const A = this[yA]();
    return A instanceof wI ? A[rt]() : A;
  }
  [Xi]() {
    return !0;
  }
  [Ze]() {
    return this.layout.endsWith("-tb") && this[P].attempt === 0 && this[P].numberInLine > 0 || this[yA]()[Ze]();
  }
  *[Ja]() {
    yield* pI(this);
  }
  [nn]() {
    return JC(this);
  }
  [vi](A, e) {
    HC(this, A, e);
  }
  [Ki]() {
    return YC(this);
  }
  [qe]() {
    var e;
    const A = this[rt]();
    return A[qe]() ? this[P]._isSplittable !== void 0 ? this[P]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[P]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[P]._isSplittable = !1, !1) : (e = A.layout) != null && e.endsWith("-tb") && A[P].numberInLine !== 0 ? !1 : (this[P]._isSplittable = !0, !0) : !1;
  }
  [uA](A) {
    var d;
    if (ig(this), this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const p = new qC({ targetType: this.break.after, target: this.break.afterTarget, startNew: this.break.startNew.toString() });
        p[WA] = this[WA], this[$A](p), this.breakAfter.push(p);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const p = new TC({ targetType: this.break.before, target: this.break.beforeTarget, startNew: this.break.startNew.toString() });
        p[WA] = this[WA], this[$A](p), this.breakBefore.push(p);
      }
      if (this.break.overflowTarget !== "") {
        const p = new jC({ target: this.break.overflowTarget, leader: this.break.overflowLeader, trailer: this.break.overflowTrailer });
        p[WA] = this[WA], this[$A](p), this.overflow.push(p);
      }
      this[Bi](this.break), this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive") return lA.EMPTY;
    if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && G("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
      const p = this.breakBefore.children[0];
      if (B0(p)) return lA.breakNode(p);
    }
    if ((d = this[P]) != null && d.afterBreakAfter) return lA.EMPTY;
    tg(this);
    const e = [], i = { id: this[TA], class: [] };
    uI(this, i.class), this[P] || (this[P] = /* @__PURE__ */ Object.create(null)), Object.assign(this[P], { children: e, line: null, attributes: i, attempt: 0, numberInLine: 0, availableSpace: { width: Math.min(this.w || 1 / 0, A.width), height: Math.min(this.h || 1 / 0, A.height) }, width: 0, height: 0, prevHeight: 0, currentWidth: 0 });
    const a = this[at](), s = a[P].noLayoutFailure, r = this[qe]();
    if (r || sg(this), !eg(this, A)) return lA.FAILURE;
    const n = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const p = this[rt]().columnWidths;
      Array.isArray(p) && p.length > 0 && (this[P].columnWidths = p, this[P].currentColumn = 0);
    }
    const g = Nt(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), o = ["xfaSubform"], I = RC(this);
    if (I && o.push(I), i.style = g, i.class = o, this.name && (i.xfaName = this.name), this.overflow) {
      const p = this.overflow[dt]();
      p.addLeader && (p.addLeader = !1, l0(this, p.leader, A));
    }
    this[Ta]();
    const C = this.layout === "lr-tb" || this.layout === "rl-tb", h = C ? 2 : 1;
    for (; this[P].attempt < h; this[P].attempt++) {
      C && this[P].attempt === 1 && (this[P].numberInLine = 0);
      const p = this[ui]({ filter: n, include: !0 });
      if (p.success) break;
      if (p.isBreak())
        return this[Ut](), p;
      if (C && this[P].attempt === 0 && this[P].numberInLine === 0 && !a[P].noLayoutFailure) {
        this[P].attempt = h;
        break;
      }
    }
    if (this[Ut](), r || ng(this), a[P].noLayoutFailure = s, this[P].attempt === h)
      return this.overflow && (this[at]()[P].overflowNode = this.overflow), r || delete this[P], lA.FAILURE;
    if (this.overflow) {
      const p = this.overflow[dt]();
      p.addTrailer && (p.addTrailer = !1, l0(this, p.trailer, A));
    }
    let c = 0, B = 0;
    this.margin && (c = this.margin.leftInset + this.margin.rightInset, B = this.margin.topInset + this.margin.bottomInset);
    const l = Math.max(this[P].width + c, this.w || 0), Q = Math.max(this[P].height + B, this.h || 0), E = [this.x, this.y, l, Q];
    if (this.w === "" && (g.width = fA(l)), this.h === "" && (g.height = fA(Q)), (g.width === "0px" || g.height === "0px") && e.length === 0) return lA.EMPTY;
    const u = { name: "div", attributes: i, children: e };
    ag(this, i);
    const f = lA.success(qi(this, u), E);
    if (this.breakAfter.children.length >= 1) {
      const p = this.breakAfter.children[0];
      if (B0(p))
        return this[P].afterBreakAfter = f, lA.breakNode(p);
    }
    return delete this[P], f;
  }
}
class wI extends Z {
  constructor(A) {
    super(iA, "subformSet", !0), this.id = A.id || "", this.name = A.name || "", this.relation = _(A.relation, ["ordered", "choice", "unordered"]), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new S(), this.breakBefore = new S(), this.subform = new S(), this.subformSet = new S();
  }
  *[Ja]() {
    yield* pI(this);
  }
  [rt]() {
    let A = this[yA]();
    for (; !(A instanceof _C); ) A = A[yA]();
    return A;
  }
  [Xi]() {
    return !0;
  }
}
class Lu extends tt {
  constructor(A) {
    super(iA, "subjectDN"), this.delimiter = A.delimiter || ",", this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    this[j] = new Map(this[j].split(this.delimiter).map((A) => ((A = A.split("=", 2))[0] = A[0].trim(), A)));
  }
}
class Ju extends Z {
  constructor(A) {
    super(iA, "subjectDNs", !0), this.id = A.id || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.subjectDN = new S();
  }
}
class Hu extends Z {
  constructor(A) {
    super(iA, "submit", !0), this.embedPDF = pA({ data: A.embedPDF, defaultValue: 0, validate: (e) => e === 1 }), this.format = _(A.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = A.id || "", this.target = A.target || "", this.textEncoding = Ag({ data: A.textEncoding ? A.textEncoding.toLowerCase() : "", defaultValue: "", validate: (e) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(e) || e.match(/iso-8859-\d{2}/) }), this.use = A.use || "", this.usehref = A.usehref || "", this.xdpContent = A.xdpContent || "", this.encrypt = null, this.encryptData = new S(), this.signData = new S();
  }
}
class DI extends Z {
  constructor(A) {
    super(iA, "template", !0), this.baseProfile = _(A.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new S();
  }
  [ZA]() {
    this.subform.children.length === 0 && G("XFA - No subforms in template node."), this.subform.children.length >= 2 && G("XFA - Several subforms in template node: please file a bug."), this[ce] = 5e3;
  }
  [qe]() {
    return !0;
  }
  [Ye](A, e) {
    return A.startsWith("#") ? [this[oa].get(A.slice(1))] : ei(this, e, A, !0, !0);
  }
  *[yC]() {
    var B, l, Q;
    if (!this.subform.children.length) return lA.success({ name: "div", children: [] });
    this[P] = { overflowNode: null, firstUnsplittable: null, currentContentArea: null, currentPageArea: null, noLayoutFailure: !1, pageNumber: 1, pagePosition: "first", oddOrEven: "odd", blankOrNotBlank: "nonBlank", paraStack: [] };
    const A = this.subform.children[0];
    A.pageSet[ha]();
    const e = A.pageSet.pageArea.children, i = { name: "div", children: [] };
    let a = null, s = null, r = null;
    if (A.breakBefore.children.length >= 1 ? (s = A.breakBefore.children[0], r = s.target) : A.subform.children.length >= 1 && A.subform.children[0].breakBefore.children.length >= 1 ? (s = A.subform.children[0].breakBefore.children[0], r = s.target) : (B = A.break) != null && B.beforeTarget ? (s = A.break, r = s.beforeTarget) : A.subform.children.length >= 1 && ((l = A.subform.children[0].break) != null && l.beforeTarget) && (s = A.subform.children[0].break, r = s.beforeTarget), s) {
      const E = this[Ye](r, s[yA]());
      E instanceof Ha && (a = E, s[P] = {});
    }
    a || (a = e[0]), a[P] = { numberOfUse: 1 };
    const n = a[yA]();
    n[P] = { numberOfUse: 1, pageIndex: n.pageArea.children.indexOf(a), pageSetIndex: 0 };
    let g, o = null, I = null, C = !0, h = 0, c = 0;
    for (; ; ) {
      if (C) h = 0;
      else if (i.children.pop(), ++h == 3)
        return G("XFA - Something goes wrong: please file a bug."), i;
      g = null, this[P].currentPageArea = a;
      const E = a[uA]().html;
      i.children.push(E), o && (this[P].noLayoutFailure = !0, E.children.push(o[uA](a[P].space).html), o = null), I && (this[P].noLayoutFailure = !0, E.children.push(I[uA](a[P].space).html), I = null);
      const u = a.contentArea.children, f = E.children.filter((p) => p.attributes.class.includes("xfaContentarea"));
      C = !1, this[P].firstUnsplittable = null, this[P].noLayoutFailure = !1;
      const d = (p) => {
        var y;
        const m = A[nn]();
        m && (C || (C = ((y = m.children) == null ? void 0 : y.length) > 0), f[p].children.push(m));
      };
      for (let p = c, m = u.length; p < m; p++) {
        const y = this[P].currentContentArea = u[p], b = { width: y.w, height: y.h };
        c = 0, o && (f[p].children.push(o[uA](b).html), o = null), I && (f[p].children.push(I[uA](b).html), I = null);
        const D = A[uA](b);
        if (D.success)
          return D.html ? (C || (C = ((Q = D.html.children) == null ? void 0 : Q.length) > 0), f[p].children.push(D.html)) : !C && i.children.length > 1 && i.children.pop(), i;
        if (D.isBreak()) {
          const R = D.breakNode;
          if (d(p), R.targetType === "auto") continue;
          R.leader && (o = this[Ye](R.leader, R[yA]()), o = o ? o[0] : null), R.trailer && (I = this[Ye](R.trailer, R[yA]()), I = I ? I[0] : null), R.targetType === "pageArea" ? (g = R[P].target, p = 1 / 0) : R[P].target ? (g = R[P].target, c = R[P].index + 1, p = 1 / 0) : p = R[P].index;
        } else if (this[P].overflowNode) {
          const R = this[P].overflowNode;
          this[P].overflowNode = null;
          const k = R[dt](), Y = k.target;
          k.addLeader = k.leader !== null, k.addTrailer = k.trailer !== null, d(p);
          const V = p;
          if (p = 1 / 0, Y instanceof Ha) g = Y;
          else if (Y instanceof mI) {
            const eA = u.indexOf(Y);
            eA !== -1 ? eA > V ? p = eA - 1 : c = eA : (g = Y[yA](), c = g.contentArea.children.indexOf(Y));
          }
        } else d(p);
      }
      this[P].pageNumber += 1, g && (g[Js]() ? g[P].numberOfUse += 1 : g = null), a = g || a[Le](), yield null;
    }
  }
}
class $C extends tt {
  constructor(A) {
    super(iA, "text"), this.id = A.id || "", this.maxChars = pA({ data: A.maxChars, defaultValue: 0, validate: (e) => e >= 0 }), this.name = A.name || "", this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [zr]() {
    return !0;
  }
  [ke](A) {
    return A[st] === gt.xhtml.id ? (this[j] = A, !0) : (G(`XFA - Invalid content in Text: ${A[JA]}.`), !1);
  }
  [Te](A) {
    this[j] instanceof Z || super[Te](A);
  }
  [ZA]() {
    typeof this[j] == "string" && (this[j] = this[j].replaceAll(`\r
`, `
`));
  }
  [dt]() {
    return typeof this[j] == "string" ? this[j].split(/[\u2029\u2028\n]/).reduce((A, e) => (e && A.push(e), A), []).join(`
`) : this[j][It]();
  }
  [uA](A) {
    if (typeof this[j] == "string") {
      const e = di(this[j]).html;
      return this[j].includes("\u2029") ? (e.name = "div", e.children = [], this[j].split("\u2029").map((i) => i.split(/[\u2028\n]/).reduce((a, s) => (a.push({ name: "span", value: s }, { name: "br" }), a), [])).forEach((i) => {
        e.children.push({ name: "p", children: i });
      })) : /[\u2028\n]/.test(this[j]) && (e.name = "div", e.children = [], this[j].split(/[\u2028\n]/).forEach((i) => {
        e.children.push({ name: "span", value: i }, { name: "br" });
      })), lA.success(e);
    }
    return this[j][uA](A);
  }
}
class Ah extends Z {
  constructor(A) {
    super(iA, "textEdit", !0), this.allowRichText = pA({ data: A.allowRichText, defaultValue: 0, validate: (e) => e === 1 }), this.hScrollPolicy = _(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.multiLine = pA({ data: A.multiLine, defaultValue: "", validate: (e) => e === 0 || e === 1 }), this.use = A.use || "", this.usehref = A.usehref || "", this.vScrollPolicy = _(A.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [uA](A) {
    var s, r;
    const e = Nt(this, "border", "font", "margin");
    let i;
    const a = this[yA]()[yA]();
    return this.multiLine === "" && (this.multiLine = a instanceof OC ? 1 : 0), i = this.multiLine === 1 ? { name: "textarea", attributes: { dataId: ((s = a[ae]) == null ? void 0 : s[TA]) || a[TA], fieldId: a[TA], class: ["xfaTextfield"], style: e, "aria-label": Zi(a), "aria-required": !1 } } : { name: "input", attributes: { type: "text", dataId: ((r = a[ae]) == null ? void 0 : r[TA]) || a[TA], fieldId: a[TA], class: ["xfaTextfield"], style: e, "aria-label": Zi(a), "aria-required": !1 } }, rn(a) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), lA.success({ name: "label", attributes: { class: ["xfaLabel"] }, children: [i] });
  }
}
class Yu extends GA {
  constructor(A) {
    super(iA, "time"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ZA]() {
    const A = this[j].trim();
    this[j] = A ? new Date(A) : null;
  }
  [uA](A) {
    return di(this[j] ? this[j].toString() : "");
  }
}
class vu extends Z {
  constructor(A) {
    super(iA, "timeStamp"), this.id = A.id || "", this.server = A.server || "", this.type = _(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Ku extends GA {
  constructor(A) {
    super(iA, "toolTip"), this.id = A.id || "", this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class qu extends Z {
  constructor(A) {
    super(iA, "traversal", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.traverse = new S();
  }
}
class Tu extends Z {
  constructor(A) {
    super(iA, "traverse", !0), this.id = A.id || "", this.operation = _(A.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = A.ref || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.script = null;
  }
  get name() {
    return this.operation;
  }
  [Ls]() {
    return !1;
  }
}
class bI extends Z {
  constructor(A) {
    super(iA, "ui", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
  }
  [dt]() {
    if (this[P] === void 0) {
      for (const A of Object.getOwnPropertyNames(this)) {
        if (A === "extras" || A === "picture") continue;
        const e = this[A];
        if (e instanceof Z)
          return this[P] = e, e;
      }
      this[P] = null;
    }
    return this[P];
  }
  [uA](A) {
    const e = this[dt]();
    return e ? e[uA](A) : lA.EMPTY;
  }
}
class Pu extends Z {
  constructor(A) {
    super(iA, "validate", !0), this.formatTest = _(A.formatTest, ["warning", "disabled", "error"]), this.id = A.id || "", this.nullTest = _(A.nullTest, ["disabled", "error", "warning"]), this.scriptTest = _(A.scriptTest, ["error", "disabled", "warning"]), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
  }
}
class kI extends Z {
  constructor(A) {
    super(iA, "value", !0), this.id = A.id || "", this.override = pA({ data: A.override, defaultValue: 0, validate: (e) => e === 1 }), this.relevant = Ee(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
  }
  [Yt](A) {
    var a;
    const e = this[yA]();
    if (e instanceof yI && ((a = e.ui) != null && a.imageEdit)) {
      this.image || (this.image = new VC({}), this[$A](this.image)), this.image[j] = A[j];
      return;
    }
    const i = A[JA];
    if (this[i] === null) {
      for (const s of Object.getOwnPropertyNames(this)) {
        const r = this[s];
        r instanceof Z && (this[s] = null, this[Bi](r));
      }
      this[A[JA]] = A, this[$A](A);
    } else this[i][j] = A[j];
  }
  [It]() {
    if (this.exData) return typeof this.exData[j] == "string" ? this.exData[j].trim() : this.exData[j][It]().trim();
    for (const A of Object.getOwnPropertyNames(this)) {
      if (A === "image") continue;
      const e = this[A];
      if (e instanceof Z) return (e[j] || "").toString().trim();
    }
    return null;
  }
  [uA](A) {
    for (const e of Object.getOwnPropertyNames(this)) {
      const i = this[e];
      if (i instanceof Z) return i[uA](A);
    }
    return lA.EMPTY;
  }
}
class Wu extends Z {
  constructor(A) {
    super(iA, "variables", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new S(), this.date = new S(), this.dateTime = new S(), this.decimal = new S(), this.exData = new S(), this.float = new S(), this.image = new S(), this.integer = new S(), this.manifest = new S(), this.script = new S(), this.text = new S(), this.time = new S();
  }
  [Ls]() {
    return !0;
  }
}
class wr {
  static [Qe](A, e) {
    if (wr.hasOwnProperty(A)) {
      const i = wr[A](e);
      return i[mC](e), i;
    }
  }
  static appearanceFilter(A) {
    return new B2(A);
  }
  static arc(A) {
    return new vC(A);
  }
  static area(A) {
    return new l2(A);
  }
  static assist(A) {
    return new Q2(A);
  }
  static barcode(A) {
    return new E2(A);
  }
  static bind(A) {
    return new u2(A);
  }
  static bindItems(A) {
    return new Uo(A);
  }
  static bookend(A) {
    return new d2(A);
  }
  static boolean(A) {
    return new f2(A);
  }
  static border(A) {
    return new KC(A);
  }
  static break(A) {
    return new p2(A);
  }
  static breakAfter(A) {
    return new qC(A);
  }
  static breakBefore(A) {
    return new TC(A);
  }
  static button(A) {
    return new m2(A);
  }
  static calculate(A) {
    return new y2(A);
  }
  static caption(A) {
    return new w2(A);
  }
  static certificate(A) {
    return new D2(A);
  }
  static certificates(A) {
    return new b2(A);
  }
  static checkButton(A) {
    return new PC(A);
  }
  static choiceList(A) {
    return new WC(A);
  }
  static color(A) {
    return new k2(A);
  }
  static comb(A) {
    return new F2(A);
  }
  static connect(A) {
    return new S2(A);
  }
  static contentArea(A) {
    return new mI(A);
  }
  static corner(A) {
    return new ZC(A);
  }
  static date(A) {
    return new R2(A);
  }
  static dateTime(A) {
    return new G2(A);
  }
  static dateTimeEdit(A) {
    return new N2(A);
  }
  static decimal(A) {
    return new x2(A);
  }
  static defaultUi(A) {
    return new U2(A);
  }
  static desc(A) {
    return new M2(A);
  }
  static digestMethod(A) {
    return new L2(A);
  }
  static digestMethods(A) {
    return new J2(A);
  }
  static draw(A) {
    return new OC(A);
  }
  static edge(A) {
    return new gn(A);
  }
  static encoding(A) {
    return new H2(A);
  }
  static encodings(A) {
    return new Y2(A);
  }
  static encrypt(A) {
    return new v2(A);
  }
  static encryptData(A) {
    return new K2(A);
  }
  static encryption(A) {
    return new q2(A);
  }
  static encryptionMethod(A) {
    return new T2(A);
  }
  static encryptionMethods(A) {
    return new P2(A);
  }
  static event(A) {
    return new W2(A);
  }
  static exData(A) {
    return new Z2(A);
  }
  static exObject(A) {
    return new O2(A);
  }
  static exclGroup(A) {
    return new XC(A);
  }
  static execute(A) {
    return new X2(A);
  }
  static extras(A) {
    return new V2(A);
  }
  static field(A) {
    return new yI(A);
  }
  static fill(A) {
    return new j2(A);
  }
  static filter(A) {
    return new z2(A);
  }
  static float(A) {
    return new _2(A);
  }
  static font(A) {
    return new $2(A);
  }
  static format(A) {
    return new Au(A);
  }
  static handler(A) {
    return new tu(A);
  }
  static hyphenation(A) {
    return new eu(A);
  }
  static image(A) {
    return new VC(A);
  }
  static imageEdit(A) {
    return new iu(A);
  }
  static integer(A) {
    return new au(A);
  }
  static issuers(A) {
    return new su(A);
  }
  static items(A) {
    return new Mo(A);
  }
  static keep(A) {
    return new nu(A);
  }
  static keyUsage(A) {
    return new ru(A);
  }
  static line(A) {
    return new gu(A);
  }
  static linear(A) {
    return new ou(A);
  }
  static lockDocument(A) {
    return new Iu(A);
  }
  static manifest(A) {
    return new cu(A);
  }
  static margin(A) {
    return new Cu(A);
  }
  static mdp(A) {
    return new hu(A);
  }
  static medium(A) {
    return new Bu(A);
  }
  static message(A) {
    return new lu(A);
  }
  static numericEdit(A) {
    return new Qu(A);
  }
  static occur(A) {
    return new Eu(A);
  }
  static oid(A) {
    return new uu(A);
  }
  static oids(A) {
    return new du(A);
  }
  static overflow(A) {
    return new jC(A);
  }
  static pageArea(A) {
    return new Ha(A);
  }
  static pageSet(A) {
    return new Hs(A);
  }
  static para(A) {
    return new fu(A);
  }
  static passwordEdit(A) {
    return new pu(A);
  }
  static pattern(A) {
    return new mu(A);
  }
  static picture(A) {
    return new yu(A);
  }
  static proto(A) {
    return new wu(A);
  }
  static radial(A) {
    return new Du(A);
  }
  static reason(A) {
    return new bu(A);
  }
  static reasons(A) {
    return new ku(A);
  }
  static rectangle(A) {
    return new zC(A);
  }
  static ref(A) {
    return new Fu(A);
  }
  static script(A) {
    return new Su(A);
  }
  static setProperty(A) {
    return new Lo(A);
  }
  static signData(A) {
    return new Ru(A);
  }
  static signature(A) {
    return new Gu(A);
  }
  static signing(A) {
    return new Nu(A);
  }
  static solid(A) {
    return new xu(A);
  }
  static speak(A) {
    return new Uu(A);
  }
  static stipple(A) {
    return new Mu(A);
  }
  static subform(A) {
    return new _C(A);
  }
  static subformSet(A) {
    return new wI(A);
  }
  static subjectDN(A) {
    return new Lu(A);
  }
  static subjectDNs(A) {
    return new Ju(A);
  }
  static submit(A) {
    return new Hu(A);
  }
  static template(A) {
    return new DI(A);
  }
  static text(A) {
    return new $C(A);
  }
  static textEdit(A) {
    return new Ah(A);
  }
  static time(A) {
    return new Yu(A);
  }
  static timeStamp(A) {
    return new vu(A);
  }
  static toolTip(A) {
    return new Ku(A);
  }
  static traversal(A) {
    return new qu(A);
  }
  static traverse(A) {
    return new Tu(A);
  }
  static ui(A) {
    return new bI(A);
  }
  static validate(A) {
    return new Pu(A);
  }
  static value(A) {
    return new kI(A);
  }
  static variables(A) {
    return new Wu(A);
  }
}
const Q0 = gt.datasets.id;
function Rn(t) {
  const A = new $C({});
  return A[j] = t, A;
}
class Zu {
  constructor(A) {
    var e;
    this.root = A, this.datasets = A.datasets, this.data = ((e = A.datasets) == null ? void 0 : e.data) || new Fe(gt.datasets.id, "data"), this.emptyMerge = this.data[Qt]().length === 0, this.root.form = this.form = A.template[he]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    return this._bindElement(this.form, this.data), this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(A, e, i) {
    var a, s;
    if (A[ae] = e, A[Ms]()) if (e[Ba]()) {
      const r = e[hI]();
      A[Yt](Rn(r));
    } else if (A instanceof yI && ((s = (a = A.ui) == null ? void 0 : a.choiceList) == null ? void 0 : s.open) === "multiSelect") {
      const r = e[Qt]().map((n) => n[j].trim()).join(`
`);
      A[Yt](Rn(r));
    } else this._isConsumeData() && G("XFA - Nodes haven't the same type.");
    else !e[Ba]() || this._isMatchTemplate() ? this._bindElement(A, e) : G("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(A, e, i, a) {
    if (!A) return null;
    let s, r;
    for (let n = 0; n < 3; n++) {
      for (s = i[Qs](A, !1, !0); r = s.next().value, !!r; )
        if (e === r[Ba]()) return r;
      if (i[st] === gt.datasets.id && i[JA] === "data") break;
      i = i[yA]();
    }
    return a ? (s = this.data[Qs](A, !0, !1), r = s.next().value, r || (s = this.data[So](A, !0), r = s.next().value, r != null && r[Ba]() ? r : null)) : null;
  }
  _setProperties(A, e) {
    if (A.hasOwnProperty("setProperty")) for (const { ref: i, target: a, connection: s } of A.setProperty.children) {
      if (s || !i) continue;
      const r = ei(this.root, e, i, !1, !1);
      if (!r) {
        G(`XFA - Invalid reference: ${i}.`);
        continue;
      }
      const [n] = r;
      if (!n[ni](this.data)) {
        G("XFA - Invalid node: must be a data node.");
        continue;
      }
      const g = ei(this.root, A, a, !1, !1);
      if (!g) {
        G(`XFA - Invalid target: ${a}.`);
        continue;
      }
      const [o] = g;
      if (!o[ni](A)) {
        G("XFA - Invalid target: must be a property or subproperty.");
        continue;
      }
      const I = o[yA]();
      if (o instanceof Lo || I instanceof Lo) {
        G("XFA - Invalid target: cannot be a setProperty or one of its properties.");
        continue;
      }
      if (o instanceof Uo || I instanceof Uo) {
        G("XFA - Invalid target: cannot be a bindItems or one of its properties.");
        continue;
      }
      const C = n[It](), h = o[JA];
      if (o instanceof QI) {
        const c = /* @__PURE__ */ Object.create(null);
        c[h] = C;
        const B = Reflect.construct(Object.getPrototypeOf(I).constructor, [c]);
        I[h] = B[h];
      } else o.hasOwnProperty(j) ? (o[ae] = n, o[j] = C, o[ZA]()) : G("XFA - Invalid node to use in setProperty");
    }
  }
  _bindItems(A, e) {
    if (!A.hasOwnProperty("items") || !A.hasOwnProperty("bindItems") || A.bindItems.isEmpty()) return;
    for (const s of A.items.children) A[Bi](s);
    A.items.clear();
    const i = new Mo({}), a = new Mo({});
    A[$A](i), A.items.push(i), A[$A](a), A.items.push(a);
    for (const { ref: s, labelRef: r, valueRef: n, connection: g } of A.bindItems.children) {
      if (g || !s) continue;
      const o = ei(this.root, e, s, !1, !1);
      if (o) for (const I of o) {
        if (!I[ni](this.datasets)) {
          G(`XFA - Invalid ref (${s}): must be a datasets child.`);
          continue;
        }
        const C = ei(this.root, I, r, !0, !1);
        if (!C) {
          G(`XFA - Invalid label: ${r}.`);
          continue;
        }
        const [h] = C;
        if (!h[ni](this.datasets)) {
          G("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const c = ei(this.root, I, n, !0, !1);
        if (!c) {
          G(`XFA - Invalid value: ${n}.`);
          continue;
        }
        const [B] = c;
        if (!B[ni](this.datasets)) {
          G("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const l = Rn(h[It]()), Q = Rn(B[It]());
        i[$A](l), i.text.push(l), a[$A](Q), a.text.push(Q);
      }
      else G(`XFA - Invalid reference: ${s}.`);
    }
  }
  _bindOccurrences(A, e, i) {
    let a;
    if (e.length > 1 && (a = A[he](), a[Bi](a.occur), a.occur = null), this._bindValue(A, e[0], i), this._setProperties(A, e[0]), this._bindItems(A, e[0]), e.length === 1) return;
    const s = A[yA](), r = A[JA], n = s[Ro](A);
    for (let g = 1, o = e.length; g < o; g++) {
      const I = e[g], C = a[he]();
      s[r].push(C), s[_n](n + g, C), this._bindValue(C, I, i), this._setProperties(C, I), this._bindItems(C, I);
    }
  }
  _createOccurrences(A) {
    if (!this.emptyMerge) return;
    const { occur: e } = A;
    if (!e || e.initial <= 1) return;
    const i = A[yA](), a = A[JA];
    if (!(i[a] instanceof S)) return;
    let s;
    s = A.name ? i[a].children.filter((g) => g.name === A.name).length : i[a].children.length;
    const r = i[Ro](A) + 1, n = e.initial - s;
    if (n) {
      const g = A[he]();
      g[Bi](g.occur), g.occur = null, i[a].push(g), i[_n](r, g);
      for (let o = 1; o < n; o++) {
        const I = g[he]();
        i[a].push(I), i[_n](r + o, I);
      }
    }
  }
  _getOccurInfo(A) {
    const { name: e, occur: i } = A;
    if (!i || !e) return [1, 1];
    const a = i.max === -1 ? 1 / 0 : i.max;
    return [i.min, a];
  }
  _setAndBind(A, e) {
    this._setProperties(A, e), this._bindItems(A, e), this._bindElement(A, e);
  }
  _bindElement(A, e) {
    const i = [];
    this._createOccurrences(A);
    for (const a of A[Qt]()) {
      if (a[ae]) continue;
      if (this._mergeMode === void 0 && a[JA] === "subform") {
        this._mergeMode = a.mergeMode === "consumeData";
        const C = e[Qt]();
        if (C.length > 0) this._bindOccurrences(a, [C[0]], null);
        else if (this.emptyMerge) {
          const h = e[st] === Q0 ? -1 : e[st], c = a[ae] = new Fe(h, a.name || "root");
          e[$A](c), this._bindElement(a, c);
        }
        continue;
      }
      if (!a[Xi]()) continue;
      let s = !1, r = null, n = null, g = null;
      if (a.bind) {
        switch (a.bind.match) {
          case "none":
            this._setAndBind(a, e);
            continue;
          case "global":
            s = !0;
            break;
          case "dataRef":
            if (!a.bind.ref) {
              G(`XFA - ref is empty in node ${a[JA]}.`), this._setAndBind(a, e);
              continue;
            }
            n = a.bind.ref;
        }
        a.bind.picture && (r = a.bind.picture[j]);
      }
      const [o, I] = this._getOccurInfo(a);
      if (n) {
        if (g = ei(this.root, e, n, !0, !1), g === null) {
          if (g = I2(this.data, e, n), !g) continue;
          this._isConsumeData() && (g[De] = !0), this._setAndBind(a, g);
          continue;
        }
        this._isConsumeData() && (g = g.filter((C) => !C[De])), g.length > I ? g = g.slice(0, I) : g.length === 0 && (g = null), g && this._isConsumeData() && g.forEach((C) => {
          C[De] = !0;
        });
      } else {
        if (!a.name) {
          this._setAndBind(a, e);
          continue;
        }
        if (this._isConsumeData()) {
          const C = [];
          for (; C.length < I; ) {
            const h = this._findDataByNameToConsume(a.name, a[Ms](), e, s);
            if (!h) break;
            h[De] = !0, C.push(h);
          }
          g = C.length > 0 ? C : null;
        } else {
          if (g = e[Qs](a.name, !1, this.emptyMerge).next().value, !g) {
            if (o === 0) {
              i.push(a);
              continue;
            }
            const C = e[st] === Q0 ? -1 : e[st];
            g = a[ae] = new Fe(C, a.name), this.emptyMerge && (g[De] = !0), e[$A](g), this._setAndBind(a, g);
            continue;
          }
          this.emptyMerge && (g[De] = !0), g = [g];
        }
      }
      g ? this._bindOccurrences(a, g, r) : o > 0 ? this._setAndBind(a, e) : i.push(a);
    }
    i.forEach((a) => a[yA]()[Bi](a));
  }
}
class Ou {
  constructor(A, e) {
    this.data = e, this.dataset = A.datasets || null;
  }
  serialize(A) {
    const e = [[-1, this.data[Qt]()]];
    for (; e.length > 0; ) {
      const a = e.at(-1), [s, r] = a;
      if (s + 1 === r.length) {
        e.pop();
        continue;
      }
      const n = r[++a[0]], g = A.get(n[TA]);
      if (g) n[Yt](g);
      else {
        const I = n[fC]();
        for (const C of I.values()) {
          const h = A.get(C[TA]);
          if (h) {
            C[Yt](h);
            break;
          }
        }
      }
      const o = n[Qt]();
      o.length > 0 && e.push([-1, o]);
    }
    const i = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset) for (const a of this.dataset[Qt]()) a[JA] !== "data" && a[us](i);
    return this.data[us](i), i.push("</xfa:datasets>"), i.join("");
  }
}
const $ = gt.config.id;
class Xu extends Z {
  constructor(A) {
    super($, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new S();
  }
}
class Vu extends Z {
  constructor(A) {
    super($, "acrobat7", !0), this.dynamicRender = null;
  }
}
class ju extends PA {
  constructor(A) {
    super($, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class zu extends PA {
  constructor(A) {
    super($, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class _u extends ct {
  constructor(A) {
    super($, "addSilentPrint");
  }
}
class $u extends ct {
  constructor(A) {
    super($, "addViewerPreferences");
  }
}
class Ad extends kC {
  constructor(A) {
    super($, "adjustData");
  }
}
class td extends ue {
  constructor(A) {
    super($, "adobeExtensionLevel", 0, (e) => e >= 1 && e <= 8);
  }
}
class ed extends Z {
  constructor(A) {
    super($, "agent", !0), this.name = A.name ? A.name.trim() : "", this.common = new S();
  }
}
class id extends tt {
  constructor(A) {
    super($, "alwaysEmbed");
  }
}
class ad extends GA {
  constructor(A) {
    super($, "amd");
  }
}
class sd extends Z {
  constructor(A) {
    super($, "area"), this.level = pA({ data: A.level, defaultValue: 0, validate: (e) => e >= 1 && e <= 3 }), this.name = _(A.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class nd extends PA {
  constructor(A) {
    super($, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class rd extends PA {
  constructor(A) {
    super($, "autoSave", ["disabled", "enabled"]);
  }
}
class gd extends GA {
  constructor(A) {
    super($, "base");
  }
}
class od extends Z {
  constructor(A) {
    super($, "batchOutput"), this.format = _(A.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class Id extends tt {
  constructor(A) {
    super($, "behaviorOverride");
  }
  [ZA]() {
    this[j] = new Map(this[j].trim().split(/\s+/).filter((A) => A.includes(":")).map((A) => A.split(":", 2)));
  }
}
class cd extends Z {
  constructor(A) {
    super($, "cache", !0), this.templateCache = null;
  }
}
class Cd extends ct {
  constructor(A) {
    super($, "change");
  }
}
class hd extends Z {
  constructor(A) {
    super($, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new S();
  }
}
class Bd extends Z {
  constructor(A) {
    super($, "compress"), this.scope = _(A.scope, ["imageOnly", "document"]);
  }
}
class ld extends ct {
  constructor(A) {
    super($, "compressLogicalStructure");
  }
}
class Qd extends kC {
  constructor(A) {
    super($, "compressObjectStream");
  }
}
class Ed extends Z {
  constructor(A) {
    super($, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
  }
}
class ud extends Z {
  constructor(A) {
    super($, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new S();
  }
}
class dd extends PA {
  constructor(A) {
    super($, "conformance", ["A", "B"]);
  }
}
class fd extends ct {
  constructor(A) {
    super($, "contentCopy");
  }
}
class pd extends ue {
  constructor(A) {
    super($, "copies", 1, (e) => e >= 1);
  }
}
class md extends GA {
  constructor(A) {
    super($, "creator");
  }
}
class yd extends ue {
  constructor(A) {
    super($, "currentPage", 0, (e) => e >= 0);
  }
}
class wd extends Z {
  constructor(A) {
    super($, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new S(), this.transform = new S();
  }
}
class Dd extends Z {
  constructor(A) {
    super($, "debug", !0), this.uri = null;
  }
}
class bd extends tt {
  constructor(A) {
    super($, "defaultTypeface"), this.writingScript = _(A.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class kd extends PA {
  constructor(A) {
    super($, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class Fd extends ct {
  constructor(A) {
    super($, "documentAssembly");
  }
}
class Sd extends Z {
  constructor(A) {
    super($, "driver", !0), this.name = A.name ? A.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class Rd extends PA {
  constructor(A) {
    super($, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class Gd extends PA {
  constructor(A) {
    super($, "dynamicRender", ["forbidden", "required"]);
  }
}
class Nd extends ct {
  constructor(A) {
    super($, "embed");
  }
}
class xd extends ct {
  constructor(A) {
    super($, "encrypt");
  }
}
class Ud extends Z {
  constructor(A) {
    super($, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
  }
}
class Md extends PA {
  constructor(A) {
    super($, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Ld extends GA {
  constructor(A) {
    super($, "enforce");
  }
}
class Jd extends Z {
  constructor(A) {
    super($, "equate"), this.force = pA({ data: A.force, defaultValue: 1, validate: (e) => e === 0 }), this.from = A.from || "", this.to = A.to || "";
  }
}
class Hd extends Z {
  constructor(A) {
    super($, "equateRange"), this.from = A.from || "", this.to = A.to || "", this._unicodeRange = A.unicodeRange || "";
  }
  get unicodeRange() {
    const A = [], e = /U\+([0-9a-fA-F]+)/, i = this._unicodeRange;
    for (let a of i.split(",").map((s) => s.trim()).filter((s) => !!s))
      a = a.split("-", 2).map((s) => {
        const r = s.match(e);
        return r ? parseInt(r[1], 16) : 0;
      }), a.length === 1 && a.push(a[0]), A.push(a);
    return sA(this, "unicodeRange", A);
  }
}
class Yd extends tt {
  constructor(A) {
    super($, "exclude");
  }
  [ZA]() {
    this[j] = this[j].trim().split(/\s+/).filter((A) => A && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(A));
  }
}
class vd extends GA {
  constructor(A) {
    super($, "excludeNS");
  }
}
class Kd extends PA {
  constructor(A) {
    super($, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class qd extends Z {
  constructor(A) {
    super($, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new S(), this.defaultTypeface = new S(), this.neverEmbed = new S();
  }
}
class Td extends ct {
  constructor(A) {
    super($, "formFieldFilling");
  }
}
class Pd extends GA {
  constructor(A) {
    super($, "groupParent");
  }
}
class Wd extends PA {
  constructor(A) {
    super($, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class Zd extends GA {
  constructor(A) {
    super($, "includeXDPContent");
  }
}
class Od extends PA {
  constructor(A) {
    super($, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class Xd extends ct {
  constructor(A) {
    super($, "incrementalMerge");
  }
}
class Vd extends ct {
  constructor(A) {
    super($, "interactive");
  }
}
class jd extends PA {
  constructor(A) {
    super($, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class zd extends Z {
  constructor(A) {
    super($, "labelPrinter", !0), this.name = _(A.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class _d extends PA {
  constructor(A) {
    super($, "layout", ["paginate", "panel"]);
  }
}
class $d extends ue {
  constructor(A) {
    super($, "level", 0, (e) => e > 0);
  }
}
class A9 extends ct {
  constructor(A) {
    super($, "linearized");
  }
}
class t9 extends GA {
  constructor(A) {
    super($, "locale");
  }
}
class e9 extends GA {
  constructor(A) {
    super($, "localeSet");
  }
}
class i9 extends Z {
  constructor(A) {
    super($, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
  }
}
class a9 extends Z {
  constructor(A) {
    super($, "map", !0), this.equate = new S(), this.equateRange = new S();
  }
}
class s9 extends Z {
  constructor(A) {
    super($, "mediumInfo", !0), this.map = null;
  }
}
class n9 extends Z {
  constructor(A) {
    super($, "message", !0), this.msgId = null, this.severity = null;
  }
}
class r9 extends Z {
  constructor(A) {
    super($, "messaging", !0), this.message = new S();
  }
}
class g9 extends PA {
  constructor(A) {
    super($, "mode", ["append", "overwrite"]);
  }
}
class o9 extends ct {
  constructor(A) {
    super($, "modifyAnnots");
  }
}
class I9 extends ue {
  constructor(A) {
    super($, "msgId", 1, (e) => e >= 1);
  }
}
class c9 extends GA {
  constructor(A) {
    super($, "nameAttr");
  }
}
class C9 extends tt {
  constructor(A) {
    super($, "neverEmbed");
  }
}
class h9 extends ue {
  constructor(A) {
    super($, "numberOfCopies", null, (e) => e >= 2 && e <= 5);
  }
}
class B9 extends Z {
  constructor(A) {
    super($, "openAction", !0), this.destination = null;
  }
}
class l9 extends Z {
  constructor(A) {
    super($, "output", !0), this.to = null, this.type = null, this.uri = null;
  }
}
class Q9 extends GA {
  constructor(A) {
    super($, "outputBin");
  }
}
class E9 extends Z {
  constructor(A) {
    super($, "outputXSL", !0), this.uri = null;
  }
}
class u9 extends PA {
  constructor(A) {
    super($, "overprint", ["none", "both", "draw", "field"]);
  }
}
class d9 extends GA {
  constructor(A) {
    super($, "packets");
  }
  [ZA]() {
    this[j] !== "*" && (this[j] = this[j].trim().split(/\s+/).filter((A) => ["config", "datasets", "template", "xfdf", "xslt"].includes(A)));
  }
}
class f9 extends Z {
  constructor(A) {
    super($, "pageOffset"), this.x = pA({ data: A.x, defaultValue: "useXDCSetting", validate: (e) => !0 }), this.y = pA({ data: A.y, defaultValue: "useXDCSetting", validate: (e) => !0 });
  }
}
class p9 extends GA {
  constructor(A) {
    super($, "pageRange");
  }
  [ZA]() {
    const A = this[j].trim().split(/\s+/).map((i) => parseInt(i, 10)), e = [];
    for (let i = 0, a = A.length; i < a; i += 2) e.push(A.slice(i, i + 2));
    this[j] = e;
  }
}
class m9 extends PA {
  constructor(A) {
    super($, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class y9 extends PA {
  constructor(A) {
    super($, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class w9 extends ue {
  constructor(A) {
    super($, "part", 1, (e) => !1);
  }
}
class D9 extends Z {
  constructor(A) {
    super($, "pcl", !0), this.name = A.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
  }
}
class b9 extends Z {
  constructor(A) {
    super($, "pdf", !0), this.name = A.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
  }
}
class k9 extends Z {
  constructor(A) {
    super($, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
  }
}
class F9 extends Z {
  constructor(A) {
    super($, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
  }
}
class S9 extends ct {
  constructor(A) {
    super($, "pickTrayByPDFSize");
  }
}
class R9 extends GA {
  constructor(A) {
    super($, "picture");
  }
}
class G9 extends ct {
  constructor(A) {
    super($, "plaintextMetadata");
  }
}
class N9 extends PA {
  constructor(A) {
    super($, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class x9 extends Z {
  constructor(A) {
    super($, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new S(), this.labelPrinter = new S(), this.pcl = new S(), this.pdf = new S(), this.ps = new S(), this.submitUrl = new S(), this.webClient = new S(), this.zpl = new S();
  }
}
class U9 extends ct {
  constructor(A) {
    super($, "print");
  }
}
class M9 extends ct {
  constructor(A) {
    super($, "printHighQuality");
  }
}
class L9 extends PA {
  constructor(A) {
    super($, "printScaling", ["appdefault", "noScaling"]);
  }
}
class J9 extends GA {
  constructor(A) {
    super($, "printerName");
  }
}
class H9 extends GA {
  constructor(A) {
    super($, "producer");
  }
}
class Y9 extends Z {
  constructor(A) {
    super($, "ps", !0), this.name = A.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
  }
}
class v9 extends tt {
  constructor(A) {
    super($, "range");
  }
  [ZA]() {
    this[j] = this[j].trim().split(/\s*,\s*/, 2).map((A) => A.split("-").map((e) => parseInt(e.trim(), 10))).filter((A) => A.every((e) => !isNaN(e))).map((A) => (A.length === 1 && A.push(A[0]), A));
  }
}
class K9 extends tt {
  constructor(A) {
    super($, "record");
  }
  [ZA]() {
    this[j] = this[j].trim();
    const A = parseInt(this[j], 10);
    !isNaN(A) && A >= 0 && (this[j] = A);
  }
}
class q9 extends tt {
  constructor(A) {
    super($, "relevant");
  }
  [ZA]() {
    this[j] = this[j].trim().split(/\s+/);
  }
}
class T9 extends tt {
  constructor(A) {
    super($, "rename");
  }
  [ZA]() {
    this[j] = this[j].trim(), (this[j].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[j])) && G("XFA - Rename: invalid XFA name");
  }
}
class P9 extends PA {
  constructor(A) {
    super($, "renderPolicy", ["server", "client"]);
  }
}
class W9 extends PA {
  constructor(A) {
    super($, "runScripts", ["both", "client", "none", "server"]);
  }
}
class Z9 extends Z {
  constructor(A) {
    super($, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
  }
}
class O9 extends PA {
  constructor(A) {
    super($, "scriptModel", ["XFA", "none"]);
  }
}
class X9 extends PA {
  constructor(A) {
    super($, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class V9 extends Z {
  constructor(A) {
    super($, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
  }
}
class j9 extends Z {
  constructor(A) {
    super($, "staple"), this.mode = _(A.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class z9 extends GA {
  constructor(A) {
    super($, "startNode");
  }
}
class _9 extends ue {
  constructor(A) {
    super($, "startPage", 0, (e) => !0);
  }
}
class $9 extends PA {
  constructor(A) {
    super($, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class Af extends GA {
  constructor(A) {
    super($, "submitUrl");
  }
}
class tf extends ue {
  constructor(A) {
    super($, "subsetBelow", 100, (e) => e >= 0 && e <= 100);
  }
}
class ef extends ct {
  constructor(A) {
    super($, "suppressBanner");
  }
}
class af extends ct {
  constructor(A) {
    super($, "tagged");
  }
}
class sf extends Z {
  constructor(A) {
    super($, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
  }
}
class nf extends PA {
  constructor(A) {
    super($, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class rf extends PA {
  constructor(A) {
    super($, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class gf extends Z {
  constructor(A) {
    super($, "templateCache"), this.maxEntries = pA({ data: A.maxEntries, defaultValue: 5, validate: (e) => e >= 0 });
  }
}
class of extends Z {
  constructor(A) {
    super($, "trace", !0), this.area = new S();
  }
}
class If extends Z {
  constructor(A) {
    super($, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
  }
}
class cf extends PA {
  constructor(A) {
    super($, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class Cf extends GA {
  constructor(A) {
    super($, "uri");
  }
}
class hf extends PA {
  constructor(A) {
    super($, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class Bf extends tt {
  constructor(A) {
    super($, "validateApprovalSignatures");
  }
  [ZA]() {
    this[j] = this[j].trim().split(/\s+/).filter((A) => ["docReady", "postSign"].includes(A));
  }
}
class lf extends PA {
  constructor(A) {
    super($, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class Qf extends PA {
  constructor(A) {
    super($, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class Ef extends Z {
  constructor(A) {
    super($, "VersionControl"), this.outputBelow = _(A.outputBelow, ["warn", "error", "update"]), this.sourceAbove = _(A.sourceAbove, ["warn", "error"]), this.sourceBelow = _(A.sourceBelow, ["update", "maintain"]);
  }
}
class uf extends Z {
  constructor(A) {
    super($, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
  }
}
class df extends Z {
  constructor(A) {
    super($, "webClient", !0), this.name = A.name ? A.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class ff extends PA {
  constructor(A) {
    super($, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class pf extends tt {
  constructor(A) {
    super($, "window");
  }
  [ZA]() {
    const A = this[j].trim().split(/\s*,\s*/, 2).map((e) => parseInt(e, 10));
    A.some((e) => isNaN(e)) ? this[j] = [0, 0] : (A.length === 1 && A.push(A[0]), this[j] = A);
  }
}
class mf extends Z {
  constructor(A) {
    super($, "xdc", !0), this.uri = new S(), this.xsl = new S();
  }
}
class yf extends Z {
  constructor(A) {
    super($, "xdp", !0), this.packets = null;
  }
}
class wf extends Z {
  constructor(A) {
    super($, "xsl", !0), this.debug = null, this.uri = null;
  }
}
class Df extends Z {
  constructor(A) {
    super($, "zpl", !0), this.name = A.name ? A.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class Dr {
  static [Qe](A, e) {
    if (Dr.hasOwnProperty(A)) return Dr[A](e);
  }
  static acrobat(A) {
    return new Xu(A);
  }
  static acrobat7(A) {
    return new Vu(A);
  }
  static ADBE_JSConsole(A) {
    return new ju(A);
  }
  static ADBE_JSDebugger(A) {
    return new zu(A);
  }
  static addSilentPrint(A) {
    return new _u(A);
  }
  static addViewerPreferences(A) {
    return new $u(A);
  }
  static adjustData(A) {
    return new Ad(A);
  }
  static adobeExtensionLevel(A) {
    return new td(A);
  }
  static agent(A) {
    return new ed(A);
  }
  static alwaysEmbed(A) {
    return new id(A);
  }
  static amd(A) {
    return new ad(A);
  }
  static area(A) {
    return new sd(A);
  }
  static attributes(A) {
    return new nd(A);
  }
  static autoSave(A) {
    return new rd(A);
  }
  static base(A) {
    return new gd(A);
  }
  static batchOutput(A) {
    return new od(A);
  }
  static behaviorOverride(A) {
    return new Id(A);
  }
  static cache(A) {
    return new cd(A);
  }
  static change(A) {
    return new Cd(A);
  }
  static common(A) {
    return new hd(A);
  }
  static compress(A) {
    return new Bd(A);
  }
  static compressLogicalStructure(A) {
    return new ld(A);
  }
  static compressObjectStream(A) {
    return new Qd(A);
  }
  static compression(A) {
    return new Ed(A);
  }
  static config(A) {
    return new ud(A);
  }
  static conformance(A) {
    return new dd(A);
  }
  static contentCopy(A) {
    return new fd(A);
  }
  static copies(A) {
    return new pd(A);
  }
  static creator(A) {
    return new md(A);
  }
  static currentPage(A) {
    return new yd(A);
  }
  static data(A) {
    return new wd(A);
  }
  static debug(A) {
    return new Dd(A);
  }
  static defaultTypeface(A) {
    return new bd(A);
  }
  static destination(A) {
    return new kd(A);
  }
  static documentAssembly(A) {
    return new Fd(A);
  }
  static driver(A) {
    return new Sd(A);
  }
  static duplexOption(A) {
    return new Rd(A);
  }
  static dynamicRender(A) {
    return new Gd(A);
  }
  static embed(A) {
    return new Nd(A);
  }
  static encrypt(A) {
    return new xd(A);
  }
  static encryption(A) {
    return new Ud(A);
  }
  static encryptionLevel(A) {
    return new Md(A);
  }
  static enforce(A) {
    return new Ld(A);
  }
  static equate(A) {
    return new Jd(A);
  }
  static equateRange(A) {
    return new Hd(A);
  }
  static exclude(A) {
    return new Yd(A);
  }
  static excludeNS(A) {
    return new vd(A);
  }
  static flipLabel(A) {
    return new Kd(A);
  }
  static fontInfo(A) {
    return new qd(A);
  }
  static formFieldFilling(A) {
    return new Td(A);
  }
  static groupParent(A) {
    return new Pd(A);
  }
  static ifEmpty(A) {
    return new Wd(A);
  }
  static includeXDPContent(A) {
    return new Zd(A);
  }
  static incrementalLoad(A) {
    return new Od(A);
  }
  static incrementalMerge(A) {
    return new Xd(A);
  }
  static interactive(A) {
    return new Vd(A);
  }
  static jog(A) {
    return new jd(A);
  }
  static labelPrinter(A) {
    return new zd(A);
  }
  static layout(A) {
    return new _d(A);
  }
  static level(A) {
    return new $d(A);
  }
  static linearized(A) {
    return new A9(A);
  }
  static locale(A) {
    return new t9(A);
  }
  static localeSet(A) {
    return new e9(A);
  }
  static log(A) {
    return new i9(A);
  }
  static map(A) {
    return new a9(A);
  }
  static mediumInfo(A) {
    return new s9(A);
  }
  static message(A) {
    return new n9(A);
  }
  static messaging(A) {
    return new r9(A);
  }
  static mode(A) {
    return new g9(A);
  }
  static modifyAnnots(A) {
    return new o9(A);
  }
  static msgId(A) {
    return new I9(A);
  }
  static nameAttr(A) {
    return new c9(A);
  }
  static neverEmbed(A) {
    return new C9(A);
  }
  static numberOfCopies(A) {
    return new h9(A);
  }
  static openAction(A) {
    return new B9(A);
  }
  static output(A) {
    return new l9(A);
  }
  static outputBin(A) {
    return new Q9(A);
  }
  static outputXSL(A) {
    return new E9(A);
  }
  static overprint(A) {
    return new u9(A);
  }
  static packets(A) {
    return new d9(A);
  }
  static pageOffset(A) {
    return new f9(A);
  }
  static pageRange(A) {
    return new p9(A);
  }
  static pagination(A) {
    return new m9(A);
  }
  static paginationOverride(A) {
    return new y9(A);
  }
  static part(A) {
    return new w9(A);
  }
  static pcl(A) {
    return new D9(A);
  }
  static pdf(A) {
    return new b9(A);
  }
  static pdfa(A) {
    return new k9(A);
  }
  static permissions(A) {
    return new F9(A);
  }
  static pickTrayByPDFSize(A) {
    return new S9(A);
  }
  static picture(A) {
    return new R9(A);
  }
  static plaintextMetadata(A) {
    return new G9(A);
  }
  static presence(A) {
    return new N9(A);
  }
  static present(A) {
    return new x9(A);
  }
  static print(A) {
    return new U9(A);
  }
  static printHighQuality(A) {
    return new M9(A);
  }
  static printScaling(A) {
    return new L9(A);
  }
  static printerName(A) {
    return new J9(A);
  }
  static producer(A) {
    return new H9(A);
  }
  static ps(A) {
    return new Y9(A);
  }
  static range(A) {
    return new v9(A);
  }
  static record(A) {
    return new K9(A);
  }
  static relevant(A) {
    return new q9(A);
  }
  static rename(A) {
    return new T9(A);
  }
  static renderPolicy(A) {
    return new P9(A);
  }
  static runScripts(A) {
    return new W9(A);
  }
  static script(A) {
    return new Z9(A);
  }
  static scriptModel(A) {
    return new O9(A);
  }
  static severity(A) {
    return new X9(A);
  }
  static silentPrint(A) {
    return new V9(A);
  }
  static staple(A) {
    return new j9(A);
  }
  static startNode(A) {
    return new z9(A);
  }
  static startPage(A) {
    return new _9(A);
  }
  static submitFormat(A) {
    return new $9(A);
  }
  static submitUrl(A) {
    return new Af(A);
  }
  static subsetBelow(A) {
    return new tf(A);
  }
  static suppressBanner(A) {
    return new ef(A);
  }
  static tagged(A) {
    return new af(A);
  }
  static template(A) {
    return new sf(A);
  }
  static templateCache(A) {
    return new gf(A);
  }
  static threshold(A) {
    return new nf(A);
  }
  static to(A) {
    return new rf(A);
  }
  static trace(A) {
    return new of(A);
  }
  static transform(A) {
    return new If(A);
  }
  static type(A) {
    return new cf(A);
  }
  static uri(A) {
    return new Cf(A);
  }
  static validate(A) {
    return new hf(A);
  }
  static validateApprovalSignatures(A) {
    return new Bf(A);
  }
  static validationMessaging(A) {
    return new lf(A);
  }
  static version(A) {
    return new Qf(A);
  }
  static versionControl(A) {
    return new Ef(A);
  }
  static viewerPreferences(A) {
    return new uf(A);
  }
  static webClient(A) {
    return new df(A);
  }
  static whitespace(A) {
    return new ff(A);
  }
  static window(A) {
    return new pf(A);
  }
  static xdc(A) {
    return new mf(A);
  }
  static xdp(A) {
    return new yf(A);
  }
  static xsl(A) {
    return new wf(A);
  }
  static zpl(A) {
    return new Df(A);
  }
}
const ge = gt.connectionSet.id;
class bf extends Z {
  constructor(A) {
    super(ge, "connectionSet", !0), this.wsdlConnection = new S(), this.xmlConnection = new S(), this.xsdConnection = new S();
  }
}
class kf extends Z {
  constructor(A) {
    super(ge, "effectiveInputPolicy"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Ff extends Z {
  constructor(A) {
    super(ge, "effectiveOutputPolicy"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Sf extends GA {
  constructor(A) {
    super(ge, "operation"), this.id = A.id || "", this.input = A.input || "", this.name = A.name || "", this.output = A.output || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Rf extends GA {
  constructor(A) {
    super(ge, "rootElement"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Gf extends GA {
  constructor(A) {
    super(ge, "soapAction"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Nf extends GA {
  constructor(A) {
    super(ge, "soapAddress"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class xf extends GA {
  constructor(A) {
    super(ge, "uri"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Uf extends GA {
  constructor(A) {
    super(ge, "wsdlAddress"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Mf extends Z {
  constructor(A) {
    super(ge, "wsdlConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
  }
}
class Lf extends Z {
  constructor(A) {
    super(ge, "xmlConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.uri = null;
  }
}
class Jf extends Z {
  constructor(A) {
    super(ge, "xsdConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.rootElement = null, this.uri = null;
  }
}
class br {
  static [Qe](A, e) {
    if (br.hasOwnProperty(A)) return br[A](e);
  }
  static connectionSet(A) {
    return new bf(A);
  }
  static effectiveInputPolicy(A) {
    return new kf(A);
  }
  static effectiveOutputPolicy(A) {
    return new Ff(A);
  }
  static operation(A) {
    return new Sf(A);
  }
  static rootElement(A) {
    return new Rf(A);
  }
  static soapAction(A) {
    return new Gf(A);
  }
  static soapAddress(A) {
    return new Nf(A);
  }
  static uri(A) {
    return new xf(A);
  }
  static wsdlAddress(A) {
    return new Uf(A);
  }
  static wsdlConnection(A) {
    return new Mf(A);
  }
  static xmlConnection(A) {
    return new Lf(A);
  }
  static xsdConnection(A) {
    return new Jf(A);
  }
}
const Jo = gt.datasets.id;
class Hf extends Fe {
  constructor(A) {
    super(Jo, "data", A);
  }
  [Es]() {
    return !0;
  }
}
class Yf extends Z {
  constructor(A) {
    super(Jo, "datasets", !0), this.data = null, this.Signature = null;
  }
  [ke](A) {
    const e = A[JA];
    (e === "data" && A[st] === Jo || e === "Signature" && A[st] === gt.signature.id) && (this[e] = A), this[$A](A);
  }
}
class kr {
  static [Qe](A, e) {
    if (kr.hasOwnProperty(A)) return kr[A](e);
  }
  static datasets(A) {
    return new Yf(A);
  }
  static data(A) {
    return new Hf(A);
  }
}
const et = gt.localeSet.id;
class vf extends Z {
  constructor(A) {
    super(et, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new S(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new S(2);
  }
}
class Kf extends GA {
  constructor(A) {
    super(et, "currencySymbol"), this.name = _(A.name, ["symbol", "isoname", "decimal"]);
  }
}
class qf extends Z {
  constructor(A) {
    super(et, "currencySymbols", !0), this.currencySymbol = new S(3);
  }
}
class Tf extends GA {
  constructor(A) {
    super(et, "datePattern"), this.name = _(A.name, ["full", "long", "med", "short"]);
  }
}
class Pf extends Z {
  constructor(A) {
    super(et, "datePatterns", !0), this.datePattern = new S(4);
  }
}
class Wf extends tt {
  constructor(A) {
    super(et, "dateTimeSymbols");
  }
}
class Zf extends GA {
  constructor(A) {
    super(et, "day");
  }
}
class Of extends Z {
  constructor(A) {
    super(et, "dayNames", !0), this.abbr = pA({ data: A.abbr, defaultValue: 0, validate: (e) => e === 1 }), this.day = new S(7);
  }
}
class Xf extends GA {
  constructor(A) {
    super(et, "era");
  }
}
class Vf extends Z {
  constructor(A) {
    super(et, "eraNames", !0), this.era = new S(2);
  }
}
class jf extends Z {
  constructor(A) {
    super(et, "locale", !0), this.desc = A.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
  }
}
class zf extends Z {
  constructor(A) {
    super(et, "localeSet", !0), this.locale = new S();
  }
}
class _f extends GA {
  constructor(A) {
    super(et, "meridiem");
  }
}
class $f extends Z {
  constructor(A) {
    super(et, "meridiemNames", !0), this.meridiem = new S(2);
  }
}
class A3 extends GA {
  constructor(A) {
    super(et, "month");
  }
}
class t3 extends Z {
  constructor(A) {
    super(et, "monthNames", !0), this.abbr = pA({ data: A.abbr, defaultValue: 0, validate: (e) => e === 1 }), this.month = new S(12);
  }
}
class e3 extends GA {
  constructor(A) {
    super(et, "numberPattern"), this.name = _(A.name, ["full", "long", "med", "short"]);
  }
}
class i3 extends Z {
  constructor(A) {
    super(et, "numberPatterns", !0), this.numberPattern = new S(4);
  }
}
class a3 extends GA {
  constructor(A) {
    super(et, "numberSymbol"), this.name = _(A.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class s3 extends Z {
  constructor(A) {
    super(et, "numberSymbols", !0), this.numberSymbol = new S(5);
  }
}
class n3 extends GA {
  constructor(A) {
    super(et, "timePattern"), this.name = _(A.name, ["full", "long", "med", "short"]);
  }
}
class r3 extends Z {
  constructor(A) {
    super(et, "timePatterns", !0), this.timePattern = new S(4);
  }
}
class g3 extends Z {
  constructor(A) {
    super(et, "typeFace", !0), this.name = "" | A.name;
  }
}
class o3 extends Z {
  constructor(A) {
    super(et, "typeFaces", !0), this.typeFace = new S();
  }
}
class Fr {
  static [Qe](A, e) {
    if (Fr.hasOwnProperty(A)) return Fr[A](e);
  }
  static calendarSymbols(A) {
    return new vf(A);
  }
  static currencySymbol(A) {
    return new Kf(A);
  }
  static currencySymbols(A) {
    return new qf(A);
  }
  static datePattern(A) {
    return new Tf(A);
  }
  static datePatterns(A) {
    return new Pf(A);
  }
  static dateTimeSymbols(A) {
    return new Wf(A);
  }
  static day(A) {
    return new Zf(A);
  }
  static dayNames(A) {
    return new Of(A);
  }
  static era(A) {
    return new Xf(A);
  }
  static eraNames(A) {
    return new Vf(A);
  }
  static locale(A) {
    return new jf(A);
  }
  static localeSet(A) {
    return new zf(A);
  }
  static meridiem(A) {
    return new _f(A);
  }
  static meridiemNames(A) {
    return new $f(A);
  }
  static month(A) {
    return new A3(A);
  }
  static monthNames(A) {
    return new t3(A);
  }
  static numberPattern(A) {
    return new e3(A);
  }
  static numberPatterns(A) {
    return new i3(A);
  }
  static numberSymbol(A) {
    return new a3(A);
  }
  static numberSymbols(A) {
    return new s3(A);
  }
  static timePattern(A) {
    return new n3(A);
  }
  static timePatterns(A) {
    return new r3(A);
  }
  static typeFace(A) {
    return new g3(A);
  }
  static typeFaces(A) {
    return new o3(A);
  }
}
const I3 = gt.signature.id;
class c3 extends Z {
  constructor(A) {
    super(I3, "signature", !0);
  }
}
class Sr {
  static [Qe](A, e) {
    if (Sr.hasOwnProperty(A)) return Sr[A](e);
  }
  static signature(A) {
    return new c3(A);
  }
}
const C3 = gt.stylesheet.id;
class h3 extends Z {
  constructor(A) {
    super(C3, "stylesheet", !0);
  }
}
class Rr {
  static [Qe](A, e) {
    if (Rr.hasOwnProperty(A)) return Rr[A](e);
  }
  static stylesheet(A) {
    return new h3(A);
  }
}
const B3 = gt.xdp.id;
class l3 extends Z {
  constructor(A) {
    super(B3, "xdp", !0), this.uuid = A.uuid || "", this.timeStamp = A.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new S(), this.template = null;
  }
  [Go](A) {
    const e = gt[A[JA]];
    return e && A[st] === e.id;
  }
}
class Gr {
  static [Qe](A, e) {
    if (Gr.hasOwnProperty(A)) return Gr[A](e);
  }
  static xdp(A) {
    return new l3(A);
  }
}
const Q3 = gt.xhtml.id, Gn = Symbol(), E3 = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), u3 = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (t) => t === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (t) => `scaleX(${Math.max(0, Math.min(parseInt(t) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (t) => `scaleY(${Math.max(0, Math.min(parseInt(t) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (t, A) => fA(0.99 * (t = A.fontSize = oA(t)))], ["letter-spacing", (t) => fA(oA(t))], ["line-height", (t) => fA(oA(t))], ["margin", (t) => fA(oA(t))], ["margin-bottom", (t) => fA(oA(t))], ["margin-left", (t) => fA(oA(t))], ["margin-right", (t) => fA(oA(t))], ["margin-top", (t) => fA(oA(t))], ["text-indent", (t) => fA(oA(t))], ["font-family", (t) => t], ["vertical-align", (t) => fA(oA(t))]]), d3 = /\s+/g, f3 = /[\r\n]+/g, p3 = /\r\n?/g;
function m3(t, A, e) {
  const i = /* @__PURE__ */ Object.create(null);
  if (!t) return i;
  const a = /* @__PURE__ */ Object.create(null);
  for (const [s, r] of t.split(";").map((n) => n.split(":", 2))) {
    const n = u3.get(s);
    if (n === "") continue;
    let g = r;
    n && (g = typeof n == "string" ? n : n(r, a)), s.endsWith("scale") ? i.transform = i.transform ? `${i[s]} ${g}` : g : i[s.replaceAll(/-([a-zA-Z])/g, (o, I) => I.toUpperCase())] = g;
  }
  if (i.fontFamily && UC({ typeface: i.fontFamily, weight: i.fontWeight || "normal", posture: i.fontStyle || "normal", size: a.fontSize || 0 }, A, A[WA].fontFinder, i), e && i.verticalAlign && i.verticalAlign !== "0px" && i.fontSize) {
    const n = oA(i.fontSize);
    i.fontSize = fA(n * 0.583), i.verticalAlign = fA(Math.sign(oA(i.verticalAlign)) * n * 0.333);
  }
  return e && i.fontSize && (i.fontSize = `calc(${i.fontSize} * var(--scale-factor))`), GC(i), i;
}
const y3 = /* @__PURE__ */ new Set(["body", "html"]);
class Xt extends Fe {
  constructor(A, e) {
    super(Q3, e), this[Gn] = !1, this.style = A.style || "";
  }
  [ne](A) {
    super[ne](A), this.style = function(i) {
      return i.style ? i.style.trim().split(/\s*;\s*/).filter((a) => !!a).map((a) => a.split(/\s*:\s*/, 2)).filter(([a, s]) => (a === "font-family" && i[WA].usedTypefaces.add(s), E3.has(a))).map((a) => a.join(":")).join(";") : "";
    }(this);
  }
  [zr]() {
    return !y3.has(this[JA]);
  }
  [Te](A, e = !1) {
    e ? this[Gn] = !0 : (A = A.replaceAll(f3, ""), this.style.includes("xfa-spacerun:yes") || (A = A.replaceAll(d3, " "))), A && (this[j] += A);
  }
  [Re](A, e = !0) {
    const i = /* @__PURE__ */ Object.create(null), a = { top: NaN, bottom: NaN, left: NaN, right: NaN };
    let s = null;
    for (const [r, n] of this.style.split(";").map((g) => g.split(":", 2))) switch (r) {
      case "font-family":
        i.typeface = $r(n);
        break;
      case "font-size":
        i.size = oA(n);
        break;
      case "font-weight":
        i.weight = n;
        break;
      case "font-style":
        i.posture = n;
        break;
      case "letter-spacing":
        i.letterSpacing = oA(n);
        break;
      case "margin":
        const g = n.split(/ \t/).map((o) => oA(o));
        switch (g.length) {
          case 1:
            a.top = a.bottom = a.left = a.right = g[0];
            break;
          case 2:
            a.top = a.bottom = g[0], a.left = a.right = g[1];
            break;
          case 3:
            a.top = g[0], a.bottom = g[2], a.left = a.right = g[1];
            break;
          case 4:
            a.top = g[0], a.left = g[1], a.bottom = g[2], a.right = g[3];
        }
        break;
      case "margin-top":
        a.top = oA(n);
        break;
      case "margin-bottom":
        a.bottom = oA(n);
        break;
      case "margin-left":
        a.left = oA(n);
        break;
      case "margin-right":
        a.right = oA(n);
        break;
      case "line-height":
        s = oA(n);
    }
    if (A.pushData(i, a, s), this[j]) A.addString(this[j]);
    else for (const r of this[Qt]()) r[JA] !== "#text" ? r[Re](A) : A.addString(r[j]);
    e && A.popFont();
  }
  [uA](A) {
    const e = [];
    if (this[P] = { children: e }, this[ui]({}), e.length === 0 && !this[j]) return lA.EMPTY;
    let i;
    return i = this[Gn] ? this[j] ? this[j].replaceAll(p3, `
`) : void 0 : this[j] || void 0, lA.success({ name: this[JA], attributes: { href: this.href, style: m3(this.style, this, this[Gn]) }, children: e, value: i });
  }
}
class w3 extends Xt {
  constructor(A) {
    super(A, "a"), this.href = MC(A.href) || "";
  }
}
class D3 extends Xt {
  constructor(A) {
    super(A, "b");
  }
  [Re](A) {
    A.pushFont({ weight: "bold" }), super[Re](A), A.popFont();
  }
}
class b3 extends Xt {
  constructor(A) {
    super(A, "body");
  }
  [uA](A) {
    const e = super[uA](A), { html: i } = e;
    return i ? (i.name = "div", i.attributes.class = ["xfaRich"], e) : lA.EMPTY;
  }
}
class k3 extends Xt {
  constructor(A) {
    super(A, "br");
  }
  [It]() {
    return `
`;
  }
  [Re](A) {
    A.addString(`
`);
  }
  [uA](A) {
    return lA.success({ name: "br" });
  }
}
class F3 extends Xt {
  constructor(A) {
    super(A, "html");
  }
  [uA](A) {
    var i;
    const e = [];
    if (this[P] = { children: e }, this[ui]({}), e.length === 0) return lA.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, value: this[j] || "" });
    if (e.length === 1) {
      const a = e[0];
      if ((i = a.attributes) != null && i.class.includes("xfaRich")) return lA.success(a);
    }
    return lA.success({ name: "div", attributes: { class: ["xfaRich"], style: {} }, children: e });
  }
}
class S3 extends Xt {
  constructor(A) {
    super(A, "i");
  }
  [Re](A) {
    A.pushFont({ posture: "italic" }), super[Re](A), A.popFont();
  }
}
class R3 extends Xt {
  constructor(A) {
    super(A, "li");
  }
}
class G3 extends Xt {
  constructor(A) {
    super(A, "ol");
  }
}
class N3 extends Xt {
  constructor(A) {
    super(A, "p");
  }
  [Re](A) {
    super[Re](A, !1), A.addString(`
`), A.addPara(), A.popFont();
  }
  [It]() {
    return this[yA]()[Qt]().at(-1) === this ? super[It]() : super[It]() + `
`;
  }
}
class x3 extends Xt {
  constructor(A) {
    super(A, "span");
  }
}
class U3 extends Xt {
  constructor(A) {
    super(A, "sub");
  }
}
class M3 extends Xt {
  constructor(A) {
    super(A, "sup");
  }
}
class L3 extends Xt {
  constructor(A) {
    super(A, "ul");
  }
}
class Ya {
  static [Qe](A, e) {
    if (Ya.hasOwnProperty(A)) return Ya[A](e);
  }
  static a(A) {
    return new w3(A);
  }
  static b(A) {
    return new D3(A);
  }
  static body(A) {
    return new b3(A);
  }
  static br(A) {
    return new k3(A);
  }
  static html(A) {
    return new F3(A);
  }
  static i(A) {
    return new S3(A);
  }
  static li(A) {
    return new R3(A);
  }
  static ol(A) {
    return new G3(A);
  }
  static p(A) {
    return new N3(A);
  }
  static span(A) {
    return new x3(A);
  }
  static sub(A) {
    return new U3(A);
  }
  static sup(A) {
    return new M3(A);
  }
  static ul(A) {
    return new L3(A);
  }
}
const E0 = { config: Dr, connection: br, datasets: kr, localeSet: Fr, signature: Sr, stylesheet: Rr, template: wr, xdp: Gr, xhtml: Ya };
class u0 {
  constructor(A) {
    this.namespaceId = A;
  }
  [Qe](A, e) {
    return new Fe(this.namespaceId, A, e);
  }
}
class J3 extends Z {
  constructor(A) {
    super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[oa] = A;
  }
  [ke](A) {
    return this.element = A, !0;
  }
  [ZA]() {
    super[ZA](), this.element.template instanceof DI && (this[oa].set(pC, this.element), this.element.template[rs](this[oa]), this.element.template[oa] = this[oa]);
  }
}
class H3 extends Z {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [ke](A) {
    return !1;
  }
}
class Y3 {
  constructor(A = null) {
    this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(gt).map(({ id: e }) => e)), this._currentNamespace = A || new u0(++this._nextNsId);
  }
  buildRoot(A) {
    return new J3(A);
  }
  build({ nsPrefix: A, name: e, attributes: i, namespace: a, prefixes: s }) {
    const r = a !== null;
    if (r && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(a)), s && this._addNamespacePrefix(s), i.hasOwnProperty(hi)) {
      const o = E0.datasets, I = i[hi];
      let C = null;
      for (const [h, c] of Object.entries(I))
        if (this._getNamespaceToUse(h) === o) {
          C = { xfa: c };
          break;
        }
      C ? i[hi] = C : delete i[hi];
    }
    const n = this._getNamespaceToUse(A), g = (n == null ? void 0 : n[Qe](e, i)) || new H3();
    return g[Es]() && this._nsAgnosticLevel++, (r || s || g[Es]()) && (g[zn] = { hasNamespace: r, prefixes: s, nsAgnostic: g[Es]() }), g;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(A) {
    let e = this._namespaces.get(A);
    if (e) return e;
    for (const [i, { check: a }] of Object.entries(gt)) if (a(A)) {
      if (e = E0[i], e)
        return this._namespaces.set(A, e), e;
      break;
    }
    return e = new u0(++this._nextNsId), this._namespaces.set(A, e), e;
  }
  _addNamespacePrefix(A) {
    for (const { prefix: e, value: i } of A) {
      const a = this._searchNamespace(i);
      let s = this._namespacePrefixes.get(e);
      s || (s = [], this._namespacePrefixes.set(e, s)), s.push(a);
    }
  }
  _getNamespaceToUse(A) {
    if (!A) return this._currentNamespace;
    const e = this._namespacePrefixes.get(A);
    return (e == null ? void 0 : e.length) > 0 ? e.at(-1) : (G(`Unknown namespace prefix: ${A}.`), null);
  }
  clean(A) {
    const { hasNamespace: e, prefixes: i, nsAgnostic: a } = A;
    e && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach(({ prefix: s }) => {
      this._namespacePrefixes.get(s).pop();
    }), a && this._nsAgnosticLevel--;
  }
}
class Nr extends IC {
  constructor(A = null, e = !1) {
    super(), this._builder = new Y3(A), this._stack = [], this._globalData = { usedTypefaces: /* @__PURE__ */ new Set() }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = hs, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = e;
  }
  parse(A) {
    if (this.parseXml(A), this._errorCode === hs)
      return this._current[ZA](), this._current.element;
  }
  onText(A) {
    A = A.replace(this._nbsps, (e) => e.slice(1) + " "), this._richText || this._current[zr]() ? this._current[Te](A, this._richText) : this._whiteRegex.test(A) || this._current[Te](A.trim());
  }
  onCdata(A) {
    this._current[Te](A);
  }
  _mkAttributes(A, e) {
    let i = null, a = null;
    const s = /* @__PURE__ */ Object.create({});
    for (const { name: r, value: n } of A) if (r === "xmlns") i ? G(`XFA - multiple namespace definition in <${e}>`) : i = n;
    else if (r.startsWith("xmlns:")) {
      const g = r.substring(6);
      a || (a = []), a.push({ prefix: g, value: n });
    } else {
      const g = r.indexOf(":");
      if (g === -1) s[r] = n;
      else {
        let o = s[hi];
        o || (o = s[hi] = /* @__PURE__ */ Object.create(null));
        const [I, C] = [r.slice(0, g), r.slice(g + 1)];
        (o[I] || (o[I] = /* @__PURE__ */ Object.create(null)))[C] = n;
      }
    }
    return [i, a, s];
  }
  _getNameAndPrefix(A, e) {
    const i = A.indexOf(":");
    return i === -1 ? [A, null] : [A.substring(i + 1), e ? "" : A.substring(0, i)];
  }
  onBeginElement(A, e, i) {
    const [a, s, r] = this._mkAttributes(e, A), [n, g] = this._getNameAndPrefix(A, this._builder.isNsAgnostic()), o = this._builder.build({ nsPrefix: g, name: n, attributes: r, namespace: a, prefixes: s });
    o[WA] = this._globalData, i ? (o[ZA](), this._current[ke](o) && o[No](this._ids), o[ne](this._builder)) : (this._stack.push(this._current), this._current = o);
  }
  onEndElement(A) {
    const e = this._current;
    if (e[BI]() && typeof e[j] == "string") {
      const i = new Nr();
      i._globalData = this._globalData;
      const a = i.parse(e[j]);
      e[j] = null, e[ke](a);
    }
    e[ZA](), this._current = this._stack.pop(), this._current[ke](e) && e[No](this._ids), e[ne](this._builder);
  }
  onError(A) {
    this._errorCode = A;
  }
}
class on {
  constructor(A) {
    try {
      this.root = new Nr().parse(on._createDocument(A));
      const e = new Zu(this.root);
      this.form = e.bind(), this.dataHandler = new Ou(this.root, e.getData()), this.form[WA].template = this.form;
    } catch (e) {
      G(`XFA - an error occurred during parsing and binding: ${e}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const A = this.form[yC]();
    return new Promise((e, i) => {
      const a = () => {
        try {
          const s = A.next();
          s.done ? e(s.value) : setTimeout(a, 0);
        } catch (s) {
          i(s);
        }
      };
      setTimeout(a, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((A) => {
        const { width: e, height: i } = A.attributes.style;
        return [0, 0, parseInt(e), parseInt(i)];
      });
    } catch (A) {
      G(`XFA - an error occurred during layout: ${A}`);
    }
  }
  getBoundingBox(A) {
    return this.dims[A];
  }
  async getNumPages() {
    return this.pages || await this._createPages(), this.dims.length;
  }
  setImages(A) {
    this.form[WA].images = A;
  }
  setFonts(A) {
    this.form[WA].fontFinder = new n2(A);
    const e = [];
    for (let i of this.form[WA].usedTypefaces)
      i = $r(i), this.form[WA].fontFinder.find(i) || e.push(i);
    return e.length > 0 ? e : null;
  }
  appendFonts(A, e) {
    this.form[WA].fontFinder.add(A, e);
  }
  async getPages() {
    this.pages || await this._createPages();
    const A = this.pages;
    return this.pages = null, A;
  }
  serializeData(A) {
    return this.dataHandler.serialize(A);
  }
  static _createDocument(A) {
    return A["/xdp:xdp"] ? Object.values(A).join("") : A["xdp:xdp"];
  }
  static getRichTextAsHtml(A) {
    if (!A || typeof A != "string") return null;
    try {
      let e = new Nr(Ya, !0).parse(A);
      if (!["body", "xhtml"].includes(e[JA])) {
        const r = Ya.body({});
        r[$A](e), e = r;
      }
      const i = e[uA]();
      if (!i.success) return null;
      const { html: a } = i, { attributes: s } = a;
      return s && (s.class && (s.class = s.class.filter((r) => !r.startsWith("xfa"))), s.dir = "auto"), { html: a, str: e[It]() };
    } catch (e) {
      G(`XFA - an error occurred during parsing of rich text: ${e}`);
    }
    return null;
  }
}
class ri {
  static createGlobals(A) {
    return Promise.all([A.ensureCatalog("acroForm"), A.ensureDoc("xfaDatasets"), A.ensureCatalog("structTreeRoot"), A.ensureCatalog("baseUrl"), A.ensureCatalog("attachments")]).then(([e, i, a, s, r]) => ({ pdfManager: A, acroForm: e instanceof U ? e : U.empty, xfaDatasets: i, structTreeRoot: a, baseUrl: s, attachments: r }), (e) => (G(`createGlobals: "${e}".`), null));
  }
  static async create(A, e, i, a, s, r, n) {
    const g = s ? await this._getPageIndex(A, e, i.pdfManager) : null;
    return i.pdfManager.ensure(this, "_create", [A, e, i, a, s, r, g, n]);
  }
  static _create(A, e, i, a, s = !1, r = null, n = null, g = null) {
    const o = A.fetchIfRef(e);
    if (!(o instanceof U)) return;
    const { acroForm: I, pdfManager: C } = i, h = e instanceof rA ? e.toString() : `annot_${a.createObjId()}`;
    let c = o.get("Subtype");
    c = c instanceof T ? c.name : null;
    const B = { xref: A, ref: e, dict: o, subtype: c, id: h, annotationGlobals: i, collectFields: s, orphanFields: r, needAppearances: !s && I.get("NeedAppearances") === !0, pageIndex: n, evaluatorOptions: C.evaluatorOptions, pageRef: g };
    switch (c) {
      case "Link":
        return new W3(B);
      case "Text":
        return new P3(B);
      case "Widget":
        let l = ee({ dict: o, key: "FT" });
        switch (l = l instanceof T ? l.name : null, l) {
          case "Tx":
            return new K3(B);
          case "Btn":
            return new q3(B);
          case "Ch":
            return new T3(B);
          case "Sig":
            return new th(B);
        }
        return G(`Unimplemented widget field type "${l}", falling back to base field type.`), new le(B);
      case "Popup":
        return new eh(B);
      case "FreeText":
        return new Mg(B);
      case "Line":
        return new Z3(B);
      case "Square":
        return new O3(B);
      case "Circle":
        return new X3(B);
      case "PolyLine":
        return new ih(B);
      case "Polygon":
        return new ah(B);
      case "Caret":
        return new V3(B);
      case "Ink":
        return new is(B);
      case "Highlight":
        return new Lg(B);
      case "Underline":
        return new j3(B);
      case "Squiggly":
        return new z3(B);
      case "StrikeOut":
        return new _3(B);
      case "Stamp":
        return new Nn(B);
      case "FileAttachment":
        return new $3(B);
      default:
        return s || G(c ? `Unimplemented annotation type "${c}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new cn(B);
    }
  }
  static async _getPageIndex(A, e, i) {
    try {
      const a = await A.fetchIfRefAsync(e);
      if (!(a instanceof U)) return -1;
      const s = a.getRaw("P");
      if (s instanceof rA) try {
        return await i.ensureCatalog("getPageIndex", [s]);
      } catch (n) {
        RA(`_getPageIndex -- not a valid page reference: "${n}".`);
      }
      if (a.has("Kids")) return -1;
      const r = await i.ensureDoc("numPages");
      for (let n = 0; n < r; n++) {
        const g = await i.getPage(n), o = await i.ensure(g, "annotations");
        for (const I of o) if (I instanceof rA && Br(I, e)) return n;
      }
    } catch (a) {
      G(`_getPageIndex: "${a}".`);
    }
    return -1;
  }
  static generateImages(A, e, i) {
    if (!i)
      return G("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
    let a;
    for (const { bitmapId: s, bitmap: r } of A) r && (a || (a = /* @__PURE__ */ new Map()), a.set(s, Nn.createImage(r, e)));
    return a;
  }
  static async saveNewAnnotations(A, e, i, a, s) {
    const r = A.xref;
    let n;
    const g = [], { isOffscreenCanvasSupported: o } = A.options;
    for (const I of i) if (!I.deleted) switch (I.annotationType) {
      case YI:
        if (!n) {
          const h = new U(r);
          h.set("BaseFont", T.get("Helvetica")), h.set("Type", T.get("Font")), h.set("Subtype", T.get("Type1")), h.set("Encoding", T.get("WinAnsiEncoding")), n = r.getNewTemporaryRef(), s.put(n, { data: h });
        }
        g.push(Mg.createNewAnnotation(r, I, s, { evaluator: A, task: e, baseFontRef: n }));
        break;
      case vI:
        I.quadPoints ? g.push(Lg.createNewAnnotation(r, I, s)) : g.push(is.createNewAnnotation(r, I, s));
        break;
      case qI:
        g.push(is.createNewAnnotation(r, I, s));
        break;
      case KI:
        const C = o ? await (a == null ? void 0 : a.get(I.bitmapId)) : null;
        if (C != null && C.imageStream) {
          const { imageStream: h, smaskStream: c } = C;
          if (c) {
            const l = r.getNewTemporaryRef();
            s.put(l, { data: c }), h.dict.set("SMask", l);
          }
          const B = C.imageRef = r.getNewTemporaryRef();
          s.put(B, { data: h }), C.imageStream = C.smaskStream = null;
        }
        g.push(Nn.createNewAnnotation(r, I, s, { image: C }));
    }
    return { annotations: await Promise.all(g) };
  }
  static async printNewAnnotations(A, e, i, a, s) {
    if (!a) return null;
    const { options: r, xref: n } = e, g = [];
    for (const o of a) if (!o.deleted) switch (o.annotationType) {
      case YI:
        g.push(Mg.createNewPrintAnnotation(A, n, o, { evaluator: e, task: i, evaluatorOptions: r }));
        break;
      case vI:
        o.quadPoints ? g.push(Lg.createNewPrintAnnotation(A, n, o, { evaluatorOptions: r })) : g.push(is.createNewPrintAnnotation(A, n, o, { evaluatorOptions: r }));
        break;
      case qI:
        g.push(is.createNewPrintAnnotation(A, n, o, { evaluatorOptions: r }));
        break;
      case KI:
        const I = r.isOffscreenCanvasSupported ? await (s == null ? void 0 : s.get(o.bitmapId)) : null;
        if (I != null && I.imageStream) {
          const { imageStream: C, smaskStream: h } = I;
          h && C.dict.set("SMask", h), I.imageRef = new Na(C, C.length), I.imageStream = I.smaskStream = null;
        }
        g.push(Nn.createNewPrintAnnotation(A, n, o, { image: I, evaluatorOptions: r }));
    }
    return Promise.all(g);
  }
}
function wa(t, A = new Uint8ClampedArray(3)) {
  if (!Array.isArray(t)) return A;
  const e = A || new Uint8ClampedArray(3);
  switch (t.length) {
    case 0:
      return null;
    case 1:
      return kA.singletons.gray.getRgbItem(t, 0, e, 0), e;
    case 3:
      return kA.singletons.rgb.getRgbItem(t, 0, e, 0), e;
    case 4:
      return kA.singletons.cmyk.getRgbItem(t, 0, e, 0), e;
    default:
      return A;
  }
}
function vt(t) {
  return Array.from(t, (A) => A / 255);
}
function In(t, A) {
  const e = t.getArray("QuadPoints");
  if (!Gt(e, null) || e.length === 0 || e.length % 8 > 0) return null;
  const i = new Float32Array(e.length);
  for (let a = 0, s = e.length; a < s; a += 8) {
    const [r, n, g, o, I, C, h, c] = e.slice(a, a + 8), B = Math.min(r, g, I, h), l = Math.max(r, g, I, h), Q = Math.min(n, o, C, c), E = Math.max(n, o, C, c);
    if (A !== null && (B < A[0] || l > A[2] || Q < A[1] || E > A[3])) return null;
    i.set([B, E, l, E, B, Q, l, Q], a);
  }
  return i;
}
function Ho(t, A, e) {
  const [i, a, s, r] = nt.getAxialAlignedBoundingBox(A, e);
  if (i === s || a === r) return [1, 0, 0, 1, t[0], t[1]];
  const n = (t[2] - t[0]) / (s - i), g = (t[3] - t[1]) / (r - a);
  return [n, 0, 0, g, t[0] - i * n, t[1] - a * g];
}
class cn {
  constructor(A) {
    const { dict: e, xref: i, annotationGlobals: a, ref: s, orphanFields: r } = A, n = r == null ? void 0 : r.get(s);
    n && e.set("Parent", n), this.setTitle(e.get("T")), this.setContents(e.get("Contents")), this.setModificationDate(e.get("M")), this.setFlags(e.get("F")), this.setRectangle(e.getArray("Rect")), this.setColor(e.getArray("C")), this.setBorderStyle(e), this.setAppearance(e), this.setOptionalContent(e);
    const g = e.get("MK");
    this.setBorderAndBackgroundColors(g), this.setRotation(g, e), this.ref = A.ref instanceof rA ? A.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
    const o = !!(this.flags & Oh), I = !!(this.flags & Xh);
    if (this.data = { annotationFlags: this.flags, borderStyle: this.borderStyle, color: this.color, backgroundColor: this.backgroundColor, borderColor: this.borderColor, rotation: this.rotation, contentsObj: this._contents, hasAppearance: !!this.appearance, id: A.id, modificationDate: this.modificationDate, rect: this.rectangle, subtype: A.subtype, hasOwnCanvas: !1, noRotate: !!(this.flags & Zh), noHTML: o && I, isEditable: !1, structParent: -1 }, a.structTreeRoot) {
      let h = e.get("StructParent");
      this.data.structParent = h = Number.isInteger(h) && h >= 0 ? h : -1, a.structTreeRoot.addAnnotationIdToPage(A.pageRef, h);
    }
    if (A.collectFields) {
      const h = e.get("Kids");
      if (Array.isArray(h)) {
        const c = [];
        for (const B of h) B instanceof rA && c.push(B.toString());
        c.length !== 0 && (this.data.kidIds = c);
      }
      this.data.actions = Wr(i, e, T0), this.data.fieldName = this._constructFieldName(e), this.data.pageIndex = A.pageIndex;
    }
    const C = e.get("IT");
    C instanceof T && (this.data.it = C.name), this._isOffscreenCanvasSupported = A.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
  }
  _hasFlag(A, e) {
    return !!(A & e);
  }
  _buildFlags(A, e) {
    let { flags: i } = this;
    return A === void 0 ? e === void 0 ? void 0 : e ? i & ~Vi : i & ~$e | Vi : A ? (i |= Vi, e ? i & ~Ia | $e : i & ~$e | Ia) : (i &= ~($e | Ia), e ? i & ~Vi : i | Vi);
  }
  _isViewable(A) {
    return !this._hasFlag(A, Cn) && !this._hasFlag(A, Ia);
  }
  _isPrintable(A) {
    return this._hasFlag(A, Vi) && !this._hasFlag(A, $e) && !this._hasFlag(A, Cn);
  }
  mustBeViewed(A, e) {
    var a;
    const i = (a = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : a.noView;
    return i !== void 0 ? !i : this.viewable && !this._hasFlag(this.flags, $e);
  }
  mustBePrinted(A) {
    var i;
    const e = (i = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : i.noPrint;
    return e !== void 0 ? !e : this.printable;
  }
  mustBeViewedWhenEditing(A, e = null) {
    return A ? !this.data.isEditable : !(e != null && e.has(this.data.id));
  }
  get viewable() {
    return this.data.quadPoints !== null && (this.flags === 0 || this._isViewable(this.flags));
  }
  get printable() {
    return this.data.quadPoints !== null && this.flags !== 0 && this._isPrintable(this.flags);
  }
  _parseStringHelper(A) {
    const e = typeof A == "string" ? LA(A) : "";
    return { str: e, dir: e && iC(e).dir === "rtl" ? "rtl" : "ltr" };
  }
  setDefaultAppearance(A) {
    const { dict: e, annotationGlobals: i } = A, a = ee({ dict: e, key: "DA" }) || i.acroForm.get("DA");
    this._defaultAppearance = typeof a == "string" ? a : "", this.data.defaultAppearanceData = II(this._defaultAppearance);
  }
  setTitle(A) {
    this._title = this._parseStringHelper(A);
  }
  setContents(A) {
    this._contents = this._parseStringHelper(A);
  }
  setModificationDate(A) {
    this.modificationDate = typeof A == "string" ? A : null;
  }
  setFlags(A) {
    this.flags = Number.isInteger(A) && A > 0 ? A : 0, this.flags & Cn && this.constructor.name !== "Annotation" && (this.flags ^= Cn);
  }
  hasFlag(A) {
    return this._hasFlag(this.flags, A);
  }
  setRectangle(A) {
    this.rectangle = be(A, [0, 0, 0, 0]);
  }
  setColor(A) {
    this.color = wa(A);
  }
  setLineEndings(A) {
    if (this.lineEndings = ["None", "None"], Array.isArray(A) && A.length === 2) for (let e = 0; e < 2; e++) {
      const i = A[e];
      if (i instanceof T) switch (i.name) {
        case "None":
          continue;
        case "Square":
        case "Circle":
        case "Diamond":
        case "OpenArrow":
        case "ClosedArrow":
        case "Butt":
        case "ROpenArrow":
        case "RClosedArrow":
        case "Slash":
          this.lineEndings[e] = i.name;
          continue;
      }
      G(`Ignoring invalid lineEnding: ${i}`);
    }
  }
  setRotation(A, e) {
    this.rotation = 0;
    let i = A instanceof U ? A.get("R") || 0 : e.get("Rotate") || 0;
    Number.isInteger(i) && i !== 0 && (i %= 360, i < 0 && (i += 360), i % 90 == 0 && (this.rotation = i));
  }
  setBorderAndBackgroundColors(A) {
    A instanceof U ? (this.borderColor = wa(A.getArray("BC"), null), this.backgroundColor = wa(A.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(A) {
    if (this.borderStyle = new v3(), A instanceof U) if (A.has("BS")) {
      const e = A.get("BS");
      if (e instanceof U) {
        const i = e.get("Type");
        (!i || it(i, "Border")) && (this.borderStyle.setWidth(e.get("W"), this.rectangle), this.borderStyle.setStyle(e.get("S")), this.borderStyle.setDashArray(e.getArray("D")));
      }
    } else if (A.has("Border")) {
      const e = A.getArray("Border");
      Array.isArray(e) && e.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(e[0]), this.borderStyle.setVerticalCornerRadius(e[1]), this.borderStyle.setWidth(e[2], this.rectangle), e.length === 4 && this.borderStyle.setDashArray(e[3], !0));
    } else this.borderStyle.setWidth(0);
  }
  setAppearance(A) {
    this.appearance = null;
    const e = A.get("AP");
    if (!(e instanceof U)) return;
    const i = e.get("N");
    if (i instanceof FA) {
      this.appearance = i;
      return;
    }
    if (!(i instanceof U)) return;
    const a = A.get("AS");
    if (!(a instanceof T && i.has(a.name))) return;
    const s = i.get(a.name);
    s instanceof FA && (this.appearance = s);
  }
  setOptionalContent(A) {
    this.oc = null;
    const e = A.get("OC");
    e instanceof T ? G("setOptionalContent: Support for /Name-entry is not implemented.") : e instanceof U && (this.oc = e);
  }
  loadResources(A, e) {
    return e.dict.getAsync("Resources").then((i) => {
      if (i)
        return new mr(i, A, i.xref).load().then(function() {
          return i;
        });
    });
  }
  async getOperatorList(A, e, i, a) {
    const { hasOwnCanvas: s, id: r, rect: n } = this.data;
    let g = this.appearance;
    const o = !!(s && i & tr);
    if (o && (n[0] === n[2] || n[1] === n[3]))
      return this.data.hasOwnCanvas = !1, { opList: new Lt(), separateForm: !1, separateCanvas: !1 };
    if (!g) {
      if (!o) return { opList: new Lt(), separateForm: !1, separateCanvas: !1 };
      g = new Ht(""), g.dict = new U();
    }
    const I = g.dict, C = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], g), h = zg(I.getArray("BBox"), [0, 0, 1, 1]), c = ci(I.getArray("Matrix"), Be), B = Ho(n, h, c), l = new Lt();
    let Q;
    return this.oc && (Q = await A.parseMarkedContentProps(this.oc, null)), Q !== void 0 && l.addOp(ye, ["OC", Q]), l.addOp(r1, [r, n, B, c, o]), await A.getOperatorList({ stream: g, task: e, resources: C, operatorList: l, fallbackFontDict: this._fallbackFontDict }), l.addOp(g1, []), Q !== void 0 && l.addOp(Ra, []), this.reset(), { opList: l, separateForm: !1, separateCanvas: o };
  }
  async save(A, e, i, a) {
    return null;
  }
  get hasTextContent() {
    return !1;
  }
  async extractTextContent(A, e, i) {
    if (!this.appearance) return;
    const a = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), s = [], r = [];
    let n = null;
    const g = { desiredSize: Math.Infinity, ready: !0, enqueue(o, I) {
      for (const C of o.items) C.str !== void 0 && (n || (n = C.transform.slice(-2)), r.push(C.str), C.hasEOL && (s.push(r.join("").trimEnd()), r.length = 0));
    } };
    if (await A.getTextContent({ stream: this.appearance, task: e, resources: a, includeMarkedContent: !0, keepWhiteSpace: !0, sink: g, viewBox: i }), this.reset(), r.length && s.push(r.join("").trimEnd()), s.length > 1 || s[0]) {
      const o = this.appearance.dict, I = zg(o.getArray("BBox"), null), C = ci(o.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(n, I, C), this.data.textContent = s;
    }
  }
  _transformPoint(A, e, i) {
    const { rect: a } = this.data;
    e || (e = [0, 0, 1, 1]), i || (i = [1, 0, 0, 1, 0, 0]);
    const s = Ho(a, e, i);
    return s[4] -= a[0], s[5] -= a[1], A = nt.applyTransform(A, s), nt.applyTransform(A, i);
  }
  getFieldObject() {
    return this.data.kidIds ? { id: this.data.id, actions: this.data.actions, name: this.data.fieldName, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, type: "", kidIds: this.data.kidIds, page: this.data.pageIndex, rotation: this.rotation } : null;
  }
  reset() {
    for (const A of this._streams) A.reset();
  }
  _constructFieldName(A) {
    if (!A.has("T") && !A.has("Parent"))
      return G("Unknown field name, falling back to empty field name."), "";
    if (!A.has("Parent")) return LA(A.get("T"));
    const e = [];
    A.has("T") && e.unshift(LA(A.get("T")));
    let i = A;
    const a = new Bt();
    for (A.objId && a.put(A.objId); i.has("Parent") && (i = i.get("Parent"), !(!(i instanceof U) || i.objId && a.has(i.objId))); )
      i.objId && a.put(i.objId), i.has("T") && e.unshift(LA(i.get("T")));
    return e.join(".");
  }
}
class v3 {
  constructor() {
    this.width = 1, this.rawWidth = 1, this.style = ZI, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
  }
  setWidth(A, e = [0, 0, 0, 0]) {
    if (A instanceof T) this.width = 0;
    else if (typeof A == "number") {
      if (A > 0) {
        this.rawWidth = A;
        const i = (e[2] - e[0]) / 2, a = (e[3] - e[1]) / 2;
        i > 0 && a > 0 && (A > i || A > a) && (G(`AnnotationBorderStyle.setWidth - ignoring width: ${A}`), A = 1);
      }
      this.width = A;
    }
  }
  setStyle(A) {
    if (A instanceof T) switch (A.name) {
      case "S":
        this.style = ZI;
        break;
      case "D":
        this.style = eB;
        break;
      case "B":
        this.style = iB;
        break;
      case "I":
        this.style = aB;
        break;
      case "U":
        this.style = sB;
    }
  }
  setDashArray(A, e = !1) {
    if (Array.isArray(A)) {
      let i = !0, a = !0;
      for (const s of A) {
        if (!(+s >= 0)) {
          i = !1;
          break;
        }
        s > 0 && (a = !1);
      }
      A.length === 0 || i && !a ? (this.dashArray = A, e && this.setStyle(T.get("D"))) : this.width = 0;
    } else A && (this.width = 0);
  }
  setHorizontalCornerRadius(A) {
    Number.isInteger(A) && (this.horizontalCornerRadius = A);
  }
  setVerticalCornerRadius(A) {
    Number.isInteger(A) && (this.verticalCornerRadius = A);
  }
}
class Kt extends cn {
  constructor(A) {
    super(A);
    const { dict: e } = A;
    if (e.has("IRT")) {
      const a = e.getRaw("IRT");
      this.data.inReplyTo = a instanceof rA ? a.toString() : null;
      const s = e.get("RT");
      this.data.replyType = s instanceof T ? s.name : Wh;
    }
    let i = null;
    if (this.data.replyType === q0) {
      const a = e.get("IRT");
      this.setTitle(a.get("T")), this.data.titleObj = this._title, this.setContents(a.get("Contents")), this.data.contentsObj = this._contents, a.has("CreationDate") ? (this.setCreationDate(a.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, a.has("M") ? (this.setModificationDate(a.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i = a.getRaw("Popup"), a.has("C") ? (this.setColor(a.getArray("C")), this.data.color = this.color) : this.data.color = null;
    } else
      this.data.titleObj = this._title, this.setCreationDate(e.get("CreationDate")), this.data.creationDate = this.creationDate, i = e.getRaw("Popup"), e.has("C") || (this.data.color = null);
    this.data.popupRef = i instanceof rA ? i.toString() : null, e.has("RC") && (this.data.richText = on.getRichTextAsHtml(e.get("RC")));
  }
  setCreationDate(A) {
    this.creationDate = typeof A == "string" ? A : null;
  }
  _setDefaultAppearance({ xref: A, extra: e, strokeColor: i, fillColor: a, blendMode: s, strokeAlpha: r, fillAlpha: n, pointsCallback: g }) {
    let o = Number.MAX_VALUE, I = Number.MAX_VALUE, C = Number.MIN_VALUE, h = Number.MIN_VALUE;
    const c = ["q"];
    e && c.push(e), i && c.push(`${i[0]} ${i[1]} ${i[2]} RG`), a && c.push(`${a[0]} ${a[1]} ${a[2]} rg`);
    let B = this.data.quadPoints;
    B || (B = Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]));
    for (let y = 0, b = B.length; y < b; y += 8) {
      const [D, R, k, Y] = g(c, B.subarray(y, y + 8));
      o = Math.min(o, D), C = Math.max(C, R), I = Math.min(I, k), h = Math.max(h, Y);
    }
    c.push("Q");
    const l = new U(A), Q = new U(A);
    Q.set("Subtype", T.get("Form"));
    const E = new Ht(c.join(" "));
    E.dict = Q, l.set("Fm0", E);
    const u = new U(A);
    s && u.set("BM", T.get(s)), typeof r == "number" && u.set("CA", r), typeof n == "number" && u.set("ca", n);
    const f = new U(A);
    f.set("GS0", u);
    const d = new U(A);
    d.set("ExtGState", f), d.set("XObject", l);
    const p = new U(A);
    p.set("Resources", d);
    const m = this.data.rect = [o, I, C, h];
    p.set("BBox", m), this.appearance = new Ht("/GS0 gs /Fm0 Do"), this.appearance.dict = p, this._streams.push(this.appearance, E);
  }
  static async createNewAnnotation(A, e, i, a) {
    e.ref || (e.ref = A.getNewTemporaryRef());
    const s = e.ref, r = await this.createNewAppearanceStream(e, A, a);
    let n;
    if (r) {
      const g = A.getNewTemporaryRef();
      n = this.createNewDict(e, A, { apRef: g }), i.put(g, { data: r });
    } else n = this.createNewDict(e, A, {});
    return Number.isInteger(e.parentTreeId) && n.set("StructParent", e.parentTreeId), i.put(s, { data: n }), { ref: s };
  }
  static async createNewPrintAnnotation(A, e, i, a) {
    const s = await this.createNewAppearanceStream(i, e, a), r = this.createNewDict(i, e, s ? { ap: s } : {}), n = new this.prototype.constructor({ dict: r, xref: e, annotationGlobals: A, evaluatorOptions: a.evaluatorOptions });
    return i.ref && (n.ref = n.refToReplace = i.ref), n;
  }
}
class le extends cn {
  constructor(A) {
    var h;
    super(A);
    const { dict: e, xref: i, annotationGlobals: a } = A, s = this.data;
    this._needAppearances = A.needAppearances, s.annotationType = Ph, s.fieldName === void 0 && (s.fieldName = this._constructFieldName(e)), s.actions === void 0 && (s.actions = Wr(i, e, T0));
    let r = ee({ dict: e, key: "V", getArray: !0 });
    s.fieldValue = this._decodeFormValue(r);
    const n = ee({ dict: e, key: "DV", getArray: !0 });
    if (s.defaultFieldValue = this._decodeFormValue(n), r === void 0 && a.xfaDatasets) {
      const c = this._title.str;
      c && (this._hasValueFromXFA = !0, s.fieldValue = r = a.xfaDatasets.getValue(c));
    }
    r === void 0 && s.defaultFieldValue !== null && (s.fieldValue = s.defaultFieldValue), s.alternativeText = LA(e.get("TU") || ""), this.setDefaultAppearance(A), s.hasAppearance || (s.hasAppearance = this._needAppearances && s.fieldValue !== void 0 && s.fieldValue !== null);
    const g = ee({ dict: e, key: "FT" });
    s.fieldType = g instanceof T ? g.name : null;
    const o = ee({ dict: e, key: "DR" }), I = a.acroForm.get("DR"), C = (h = this.appearance) == null ? void 0 : h.dict.get("Resources");
    this._fieldResources = { localResources: o, acroFormResources: I, appearanceResources: C, mergedResources: U.merge({ xref: i, dictArray: [o, C, I], mergeSubDicts: !0 }) }, s.fieldFlags = ee({ dict: e, key: "Ff" }), (!Number.isInteger(s.fieldFlags) || s.fieldFlags < 0) && (s.fieldFlags = 0), s.readOnly = this.hasFieldFlag(Vh), s.required = this.hasFieldFlag(jh), s.hidden = this._hasFlag(s.annotationFlags, $e) || this._hasFlag(s.annotationFlags, Ia);
  }
  _decodeFormValue(A) {
    return Array.isArray(A) ? A.filter((e) => typeof e == "string").map((e) => LA(e)) : A instanceof T ? LA(A.name) : typeof A == "string" ? LA(A) : null;
  }
  hasFieldFlag(A) {
    return !!(this.data.fieldFlags & A);
  }
  _isViewable(A) {
    return !0;
  }
  mustBeViewed(A, e) {
    return e ? this.viewable : super.mustBeViewed(A, e) && !this._hasFlag(this.flags, Ia);
  }
  getRotationMatrix(A) {
    var i;
    let e = (i = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : i.rotation;
    return e === void 0 && (e = this.rotation), e === 0 ? Be : Qr(e, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
  }
  getBorderAndBackgroundAppearances(A) {
    var n;
    let e = (n = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : n.rotation;
    if (e === void 0 && (e = this.rotation), !this.backgroundColor && !this.borderColor) return "";
    const i = this.data.rect[2] - this.data.rect[0], a = this.data.rect[3] - this.data.rect[1], s = e === 0 || e === 180 ? `0 0 ${i} ${a} re` : `0 0 ${a} ${i} re`;
    let r = "";
    return this.backgroundColor && (r = `${Ke(this.backgroundColor, !0)} ${s} f `), this.borderColor && (r += `${this.borderStyle.width || 1} w ${Ke(this.borderColor, !1)} ${s} S `), r;
  }
  async getOperatorList(A, e, i, a) {
    if (i & v0 && !(this instanceof th) && !this.data.noHTML && !this.data.hasOwnCanvas) return { opList: new Lt(), separateForm: !0, separateCanvas: !1 };
    if (!this._hasText) return super.getOperatorList(A, e, i, a);
    const s = await this._getAppearance(A, e, i, a);
    if (this.appearance && s === null) return super.getOperatorList(A, e, i, a);
    const r = new Lt();
    if (!this._defaultAppearance || s === null) return { opList: r, separateForm: !1, separateCanvas: !1 };
    const n = !!(this.data.hasOwnCanvas && i & tr), g = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], o = Ho(this.data.rect, g, [1, 0, 0, 1, 0, 0]);
    let I;
    this.oc && (I = await A.parseMarkedContentProps(this.oc, null)), I !== void 0 && r.addOp(ye, ["OC", I]), r.addOp(r1, [this.data.id, this.data.rect, o, this.getRotationMatrix(a), n]);
    const C = new Ht(s);
    return await A.getOperatorList({ stream: C, task: e, resources: this._fieldResources.mergedResources, operatorList: r }), r.addOp(g1, []), I !== void 0 && r.addOp(Ra, []), { opList: r, separateForm: !1, separateCanvas: n };
  }
  _getMKDict(A) {
    const e = new U(null);
    return A && e.set("R", A), this.borderColor && e.set("BC", vt(this.borderColor)), this.backgroundColor && e.set("BG", vt(this.backgroundColor)), e.size > 0 ? e : null;
  }
  amendSavedDict(A, e) {
  }
  setValue(A, e, i, a) {
    const { dict: s, ref: r } = function(g, o, I) {
      const C = new Bt(), h = g, c = { dict: null, ref: null };
      for (; g instanceof U && !C.has(o) && (C.put(o), !g.has("T")); ) {
        if (!((o = g.getRaw("Parent")) instanceof rA)) return c;
        g = I.fetch(o);
      }
      return g instanceof U && g !== h && (c.dict = g, c.ref = o), c;
    }(A, this.ref, i);
    if (s) {
      if (!a.has(r)) {
        const n = s.clone();
        return n.set("V", e), a.put(r, { data: n }), n;
      }
    } else A.set("V", e);
    return null;
  }
  async save(A, e, i, a) {
    const s = i == null ? void 0 : i.get(this.data.id), r = this._buildFlags(s == null ? void 0 : s.noView, s == null ? void 0 : s.noPrint);
    let n = s == null ? void 0 : s.value, g = s == null ? void 0 : s.rotation;
    if (n === this.data.fieldValue || n === void 0) {
      if (!this._hasValueFromXFA && g === void 0 && r === void 0) return;
      n || (n = this.data.fieldValue);
    }
    if (g === void 0 && !this._hasValueFromXFA && Array.isArray(n) && Array.isArray(this.data.fieldValue) && Pi(n, this.data.fieldValue) && r === void 0) return;
    g === void 0 && (g = this.rotation);
    let o = null;
    if (!this._needAppearances && (o = await this._getAppearance(A, e, HI, i), o === null && r === void 0))
      return;
    let I = !1;
    o != null && o.needAppearances && (I = !0, o = null);
    const { xref: C } = A, h = C.fetchIfRef(this.ref);
    if (!(h instanceof U)) return;
    const c = new U(C);
    for (const E of h.getKeys()) E !== "AP" && c.set(E, h.getRaw(E));
    if (r !== void 0 && (c.set("F", r), o === null && !I)) {
      const E = h.getRaw("AP");
      E && c.set("AP", E);
    }
    const B = { path: this.data.fieldName, value: n }, l = this.setValue(c, Array.isArray(n) ? n.map(ie) : ie(n), C, a);
    this.amendSavedDict(i, l || c);
    const Q = this._getMKDict(g);
    if (Q && c.set("MK", Q), a.put(this.ref, { data: c, xfa: B, needAppearances: I }), o !== null) {
      const E = C.getNewTemporaryRef(), u = new U(C);
      c.set("AP", u), u.set("N", E);
      const f = this._getSaveFieldResources(C), d = new Ht(o), p = d.dict = new U(C);
      p.set("Subtype", T.get("Form")), p.set("Resources", f), p.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const m = this.getRotationMatrix(i);
      m !== Be && p.set("Matrix", m), a.put(E, { data: d, xfa: null, needAppearances: !1 });
    }
    c.set("M", `D:${We()}`);
  }
  async _getAppearance(A, e, i, a) {
    if (this.hasFieldFlag(qg)) return null;
    const s = a == null ? void 0 : a.get(this.data.id);
    let r, n;
    if (s && (r = s.formattedValue || s.value, n = s.rotation), n === void 0 && r === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
    const g = this.getBorderAndBackgroundAppearances(a);
    if (r === void 0 && (r = this.data.fieldValue, !r))
      return `/Tx BMC q ${g}Q EMC`;
    if (Array.isArray(r) && r.length === 1 && (r = r[0]), Rt(typeof r == "string", "Expected `value` to be a string."), r = r.trimEnd(), this.data.combo) {
      const y = this.data.options.find(({ exportValue: b }) => r === b);
      r = (y == null ? void 0 : y.displayValue) || r;
    }
    if (r === "") return `/Tx BMC q ${g}Q EMC`;
    n === void 0 && (n = this.rotation);
    let o, I = -1;
    this.data.multiLine ? (o = r.split(/\r\n?|\n/).map((y) => y.normalize("NFC")), I = o.length) : o = [r.replace(/\r\n?|\n/, "").normalize("NFC")];
    let C = this.data.rect[3] - this.data.rect[1], h = this.data.rect[2] - this.data.rect[0];
    n !== 90 && n !== 270 || ([h, C] = [C, h]), this._defaultAppearance || (this.data.defaultAppearanceData = II(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let c, B, l, Q = await le._getFontData(A, e, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    const E = [];
    let u = !1;
    for (const y of o) {
      const b = Q.encodeString(y);
      b.length > 1 && (u = !0), E.push(b.join(""));
    }
    if (u && i & HI) return { needAppearances: !0 };
    if (u && this._isOffscreenCanvasSupported) {
      const y = this.data.comb ? "monospace" : "sans-serif", b = new we(A.xref, y), D = b.createFontResources(o.join("")), R = D.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const V = this._fieldResources.mergedResources.get("Font");
        for (const eA of R.getKeys()) V.set(eA, R.getRaw(eA));
      } else this._fieldResources.mergedResources.set("Font", R);
      const k = b.fontName.name;
      Q = await le._getFontData(A, e, { fontName: k, fontSize: 0 }, D);
      for (let V = 0, eA = E.length; V < eA; V++) E[V] = y1(o[V]);
      const Y = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = k, [c, B, l] = this._computeFontSize(C - 2, h - 4, r, Q, I), this.data.defaultAppearanceData = Y;
    } else
      this._isOffscreenCanvasSupported || G("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [c, B, l] = this._computeFontSize(C - 2, h - 4, r, Q, I);
    let f = Q.descent;
    f = isNaN(f) ? MI * l : Math.max(MI * l, Math.abs(f) * B);
    const d = Math.min(Math.floor((C - B) / 2), 1), p = this.data.textAlignment;
    if (this.data.multiLine) return this._getMultilineAppearance(c, E, Q, B, h, C, p, 2, d, f, l, a);
    if (this.data.comb) return this._getCombAppearance(c, Q, E[0], B, h, C, 2, d, f, l, a);
    const m = d + f;
    return p === 0 || p > 2 ? `/Tx BMC q ${g}BT ` + c + ` 1 0 0 1 ${vA(2)} ${vA(m)} Tm (${Ga(E[0])}) Tj ET Q EMC` : `/Tx BMC q ${g}BT ` + c + ` 1 0 0 1 0 0 Tm ${this._renderText(E[0], Q, B, h, p, { shift: 0 }, 2, m)} ET Q EMC`;
  }
  static async _getFontData(A, e, i, a) {
    const s = new Lt(), r = { font: null, clone() {
      return this;
    } }, { fontName: n, fontSize: g } = i;
    return await A.handleSetFont(a, [n && T.get(n), g], null, s, e, r, null), r.font;
  }
  _getTextWidth(A, e) {
    return e.charsToGlyphs(A).reduce((i, a) => i + a.width, 0) / 1e3;
  }
  _computeFontSize(A, e, i, a, s) {
    let { fontSize: r } = this.data.defaultAppearanceData, n = (r || 12) * Hi, g = Math.round(A / n);
    if (!r) {
      const o = (h) => Math.floor(100 * h) / 100;
      if (s === -1) {
        const h = this._getTextWidth(i, a);
        r = o(Math.min(A / Hi, e / h)), g = 1;
      } else {
        const h = i.split(/\r\n?|\n/), c = [];
        for (const l of h) {
          const Q = a.encodeString(l).join(""), E = a.charsToGlyphs(Q), u = a.getCharPositions(Q);
          c.push({ line: Q, glyphs: E, positions: u });
        }
        const B = (l) => {
          let Q = 0;
          for (const E of c)
            if (Q += this._splitLine(null, a, l, e, E).length * l, Q > A) return !0;
          return !1;
        };
        for (g = Math.max(g, s); n = A / g, r = o(n / Hi), !!B(r); )
          g++;
      }
      const { fontName: I, fontColor: C } = this.data.defaultAppearanceData;
      this._defaultAppearance = function({ fontSize: c, fontName: B, fontColor: l }) {
        return `/${zo(B)} ${c} Tf ${Ke(l, !0)}`;
      }({ fontSize: r, fontName: I, fontColor: C });
    }
    return [this._defaultAppearance, r, A / g];
  }
  _renderText(A, e, i, a, s, r, n, g) {
    let o;
    s === 1 ? o = (a - this._getTextWidth(A, e) * i) / 2 : s === 2 ? o = a - this._getTextWidth(A, e) * i - n : o = n;
    const I = vA(o - r.shift);
    return r.shift = o, `${I} ${g = vA(g)} Td (${Ga(A)}) Tj`;
  }
  _getSaveFieldResources(A) {
    var r;
    const { localResources: e, appearanceResources: i, acroFormResources: a } = this._fieldResources, s = (r = this.data.defaultAppearanceData) == null ? void 0 : r.fontName;
    if (!s) return e || U.empty;
    for (const n of [e, i]) if (n instanceof U) {
      const g = n.get("Font");
      if (g instanceof U && g.has(s)) return n;
    }
    if (a instanceof U) {
      const n = a.get("Font");
      if (n instanceof U && n.has(s)) {
        const g = new U(A);
        g.set(s, n.getRaw(s));
        const o = new U(A);
        return o.set("Font", g), U.merge({ xref: A, dictArray: [o, e], mergeSubDicts: !0 });
      }
    }
    return e || U.empty;
  }
  getFieldObject() {
    return null;
  }
}
class K3 extends le {
  constructor(A) {
    super(A);
    const { dict: e } = A;
    e.has("PMD") && (this.flags |= $e, this.data.hidden = !0, G("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0, typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
    let i = ee({ dict: e, key: "Q" });
    (!Number.isInteger(i) || i < 0 || i > 2) && (i = null), this.data.textAlignment = i;
    let a = ee({ dict: e, key: "MaxLen" });
    (!Number.isInteger(a) || a < 0) && (a = 0), this.data.maxLen = a, this.data.multiLine = this.hasFieldFlag(PI), this.data.comb = this.hasFieldFlag(tB) && !this.hasFieldFlag(PI) && !this.hasFieldFlag(qg) && !this.hasFieldFlag(_h) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(AB);
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(A, e, i, a, s, r, n, g, o, I, C) {
    const h = s / this.data.maxLen, c = this.getBorderAndBackgroundAppearances(C), B = [], l = e.getCharPositions(i);
    for (const [E, u] of l) B.push(`(${Ga(i.substring(E, u))}) Tj`);
    const Q = B.join(` ${vA(h)} 0 Td `);
    return `/Tx BMC q ${c}BT ` + A + ` 1 0 0 1 ${vA(n)} ${vA(g + o)} Tm ${Q} ET Q EMC`;
  }
  _getMultilineAppearance(A, e, i, a, s, r, n, g, o, I, C, h) {
    const c = [], B = s - 2 * g, l = { shift: 0 };
    for (let u = 0, f = e.length; u < f; u++) {
      const d = e[u], p = this._splitLine(d, i, a, B);
      for (let m = 0, y = p.length; m < y; m++) {
        const b = p[m], D = u === 0 && m === 0 ? -o - (C - I) : -C;
        c.push(this._renderText(b, i, a, s, n, l, g, D));
      }
    }
    const Q = this.getBorderAndBackgroundAppearances(h), E = c.join(`
`);
    return `/Tx BMC q ${Q}BT ` + A + ` 1 0 0 1 0 ${vA(r)} Tm ${E} ET Q EMC`;
  }
  _splitLine(A, e, i, a, s = {}) {
    A = s.line || A;
    const r = s.glyphs || e.charsToGlyphs(A);
    if (r.length <= 1) return [A];
    const n = s.positions || e.getCharPositions(A), g = i / 1e3, o = [];
    let I = -1, C = -1, h = -1, c = 0, B = 0;
    for (let l = 0, Q = r.length; l < Q; l++) {
      const [E, u] = n[l], f = r[l], d = f.width * g;
      f.unicode === " " ? B + d > a ? (o.push(A.substring(c, E)), c = E, B = d, I = -1, h = -1) : (B += d, I = E, C = u, h = l) : B + d > a ? I !== -1 ? (o.push(A.substring(c, C)), c = C, l = h + 1, I = -1, B = 0) : (o.push(A.substring(c, E)), c = E, B = d) : B += d;
    }
    return c < A.length && o.push(A.substring(c, A.length)), o;
  }
  async extractTextContent(A, e, i) {
    await super.extractTextContent(A, e, i);
    const a = this.data.textContent;
    if (!a) return;
    const s = a.join(`
`);
    if (s === this.data.fieldValue) return;
    const r = s.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (n, g) => g ? `\\${g}` : "\\s+");
    new RegExp(`^\\s*${r}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split(`
`));
  }
  getFieldObject() {
    return { id: this.data.id, value: this.data.fieldValue, defaultValue: this.data.defaultFieldValue || "", multiline: this.data.multiLine, password: this.hasFieldFlag(qg), charLimit: this.data.maxLen, comb: this.data.comb, editable: !this.data.readOnly, hidden: this.data.hidden, name: this.data.fieldName, rect: this.data.rect, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: "text" };
  }
}
class q3 extends le {
  constructor(A) {
    super(A), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(WI) && !this.hasFieldFlag(og), this.data.radioButton = this.hasFieldFlag(WI) && !this.hasFieldFlag(og), this.data.pushButton = this.hasFieldFlag(og), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(A) : this.data.radioButton ? this._processRadioButton(A) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this.data.noHTML = !1, this._processPushButton(A)) : G("Invalid field flags for button widget annotation");
  }
  async getOperatorList(A, e, i, a) {
    if (this.data.pushButton) return super.getOperatorList(A, e, i, !1, a);
    let s = null, r = null;
    if (a) {
      const g = a.get(this.data.id);
      s = g ? g.value : null, r = g ? g.rotation : null;
    }
    if (s === null && this.appearance) return super.getOperatorList(A, e, i, a);
    s == null && (s = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const n = s ? this.checkedAppearance : this.uncheckedAppearance;
    if (n) {
      const g = this.appearance, o = ci(n.dict.getArray("Matrix"), Be);
      r && n.dict.set("Matrix", this.getRotationMatrix(a)), this.appearance = n;
      const I = super.getOperatorList(A, e, i, a);
      return this.appearance = g, n.dict.set("Matrix", o), I;
    }
    return { opList: new Lt(), separateForm: !1, separateCanvas: !1 };
  }
  async save(A, e, i, a) {
    this.data.checkBox ? this._saveCheckbox(A, e, i, a) : this.data.radioButton && this._saveRadioButton(A, e, i, a);
  }
  async _saveCheckbox(A, e, i, a) {
    if (!i) return;
    const s = i.get(this.data.id), r = this._buildFlags(s == null ? void 0 : s.noView, s == null ? void 0 : s.noPrint);
    let n = s == null ? void 0 : s.rotation, g = s == null ? void 0 : s.value;
    if (n === void 0 && r === void 0 && (g === void 0 || this.data.fieldValue === this.data.exportValue === g))
      return;
    let o = A.xref.fetchIfRef(this.ref);
    if (!(o instanceof U)) return;
    o = o.clone(), n === void 0 && (n = this.rotation), g === void 0 && (g = this.data.fieldValue === this.data.exportValue);
    const I = { path: this.data.fieldName, value: g ? this.data.exportValue : "" }, C = T.get(g ? this.data.exportValue : "Off");
    this.setValue(o, C, A.xref, a), o.set("AS", C), o.set("M", `D:${We()}`), r !== void 0 && o.set("F", r);
    const h = this._getMKDict(n);
    h && o.set("MK", h), a.put(this.ref, { data: o, xfa: I, needAppearances: !1 });
  }
  async _saveRadioButton(A, e, i, a) {
    if (!i) return;
    const s = i.get(this.data.id), r = this._buildFlags(s == null ? void 0 : s.noView, s == null ? void 0 : s.noPrint);
    let n = s == null ? void 0 : s.rotation, g = s == null ? void 0 : s.value;
    if (n === void 0 && r === void 0 && (g === void 0 || this.data.fieldValue === this.data.buttonValue === g))
      return;
    let o = A.xref.fetchIfRef(this.ref);
    if (!(o instanceof U)) return;
    o = o.clone(), g === void 0 && (g = this.data.fieldValue === this.data.buttonValue), n === void 0 && (n = this.rotation);
    const I = { path: this.data.fieldName, value: g ? this.data.buttonValue : "" }, C = T.get(g ? this.data.buttonValue : "Off");
    g && this.setValue(o, C, A.xref, a), o.set("AS", C), o.set("M", `D:${We()}`), r !== void 0 && o.set("F", r);
    const h = this._getMKDict(n);
    h && o.set("MK", h), a.put(this.ref, { data: o, xfa: I, needAppearances: !1 });
  }
  _getDefaultCheckedAppearance(A, e) {
    const i = this.data.rect[2] - this.data.rect[0], a = this.data.rect[3] - this.data.rect[1], s = [0, 0, i, a], r = 0.8 * Math.min(i, a);
    let n, g;
    e === "check" ? (n = { width: 0.755 * r, height: 0.705 * r }, g = "3") : e === "disc" ? (n = { width: 0.791 * r, height: 0.705 * r }, g = "l") : xA(`_getDefaultCheckedAppearance - unsupported type: ${e}`);
    const o = `q BT /PdfJsZaDb ${r} Tf 0 g ${vA((i - n.width) / 2)} ${vA((a - n.height) / 2)} Td (${g}) Tj ET Q`, I = new U(A.xref);
    I.set("FormType", 1), I.set("Subtype", T.get("Form")), I.set("Type", T.get("XObject")), I.set("BBox", s), I.set("Matrix", [1, 0, 0, 1, 0, 0]), I.set("Length", o.length);
    const C = new U(A.xref), h = new U(A.xref);
    h.set("PdfJsZaDb", this.fallbackFontDict), C.set("Font", h), I.set("Resources", C), this.checkedAppearance = new Ht(o), this.checkedAppearance.dict = I, this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(A) {
    const e = A.dict.get("AP");
    if (!(e instanceof U)) return;
    const i = e.get("N");
    if (!(i instanceof U)) return;
    const a = this._decodeFormValue(A.dict.get("AS"));
    typeof a == "string" && (this.data.fieldValue = a);
    const s = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", r = i.getKeys();
    if (r.length === 0) r.push("Off", s);
    else if (r.length === 1) r[0] === "Off" ? r.push(s) : r.unshift("Off");
    else if (r.includes(s))
      r.length = 0, r.push("Off", s);
    else {
      const o = r.find((I) => I !== "Off");
      r.length = 0, r.push("Off", o);
    }
    r.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = r[1];
    const n = i.get(this.data.exportValue);
    this.checkedAppearance = n instanceof FA ? n : null;
    const g = i.get("Off");
    this.uncheckedAppearance = g instanceof FA ? g : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(A, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(A) {
    this.data.buttonValue = null;
    const e = A.dict.get("Parent");
    if (e instanceof U) {
      this.parent = A.dict.getRaw("Parent");
      const n = e.get("V");
      n instanceof T && (this.data.fieldValue = this._decodeFormValue(n));
    }
    const i = A.dict.get("AP");
    if (!(i instanceof U)) return;
    const a = i.get("N");
    if (!(a instanceof U)) return;
    for (const n of a.getKeys()) if (n !== "Off") {
      this.data.buttonValue = this._decodeFormValue(n);
      break;
    }
    const s = a.get(this.data.buttonValue);
    this.checkedAppearance = s instanceof FA ? s : null;
    const r = a.get("Off");
    this.uncheckedAppearance = r instanceof FA ? r : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(A, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(A) {
    const { dict: e, annotationGlobals: i } = A;
    e.has("A") || e.has("AA") || this.data.alternativeText ? (this.data.isTooltipOnly = !e.has("A") && !e.has("AA"), xs.parseDestDictionary({ destDict: e, resultObj: this.data, docBaseUrl: i.baseUrl, docAttachments: i.attachments })) : G("Push buttons without action dictionaries are not supported");
  }
  getFieldObject() {
    let A, e = "button";
    return this.data.checkBox ? (e = "checkbox", A = this.data.exportValue) : this.data.radioButton && (e = "radiobutton", A = this.data.buttonValue), { id: this.data.id, value: this.data.fieldValue || "Off", defaultValue: this.data.defaultFieldValue, exportValues: A, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, hidden: this.data.hidden, actions: this.data.actions, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: e };
  }
  get fallbackFontDict() {
    const A = new U();
    return A.set("BaseFont", T.get("ZapfDingbats")), A.set("Type", T.get("FallbackType")), A.set("Subtype", T.get("FallbackType")), A.set("Encoding", T.get("ZapfDingbatsEncoding")), sA(this, "fallbackFontDict", A);
  }
}
class T3 extends le {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    this.indices = e.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
    const a = ee({ dict: e, key: "Opt" });
    if (Array.isArray(a)) for (let s = 0, r = a.length; s < r; s++) {
      const n = i.fetchIfRef(a[s]), g = Array.isArray(n);
      this.data.options[s] = { exportValue: this._decodeFormValue(g ? i.fetchIfRef(n[0]) : n), displayValue: this._decodeFormValue(g ? i.fetchIfRef(n[1]) : n) };
    }
    if (this.hasIndices) {
      this.data.fieldValue = [];
      const s = this.data.options.length;
      for (const r of this.indices) Number.isInteger(r) && r >= 0 && r < s && this.data.fieldValue.push(this.data.options[r].exportValue);
    } else typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
    this.data.options.length === 0 && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((s) => ({ exportValue: s, displayValue: s }))), this.data.combo = this.hasFieldFlag(zh), this.data.multiSelect = this.hasFieldFlag($h), this._hasText = !0;
  }
  getFieldObject() {
    const A = this.data.combo ? "combobox" : "listbox", e = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return { id: this.data.id, value: e, defaultValue: this.data.defaultFieldValue, editable: !this.data.readOnly, name: this.data.fieldName, rect: this.data.rect, numItems: this.data.fieldValue.length, multipleSelection: this.data.multiSelect, hidden: this.data.hidden, actions: this.data.actions, items: this.data.options, page: this.data.pageIndex, strokeColor: this.data.borderColor, fillColor: this.data.backgroundColor, rotation: this.rotation, type: A };
  }
  amendSavedDict(A, e) {
    var r;
    if (!this.hasIndices) return;
    let i = (r = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : r.value;
    Array.isArray(i) || (i = [i]);
    const a = [], { options: s } = this.data;
    for (let n = 0, g = 0, o = s.length; n < o; n++) s[n].exportValue === i[g] && (a.push(n), g += 1);
    e.set("I", a);
  }
  async _getAppearance(A, e, i, a) {
    if (this.data.combo) return super._getAppearance(A, e, i, a);
    let s, r;
    const n = a == null ? void 0 : a.get(this.data.id);
    if (n && (r = n.rotation, s = n.value), r === void 0 && s === void 0 && !this._needAppearances) return null;
    s === void 0 ? s = this.data.fieldValue : Array.isArray(s) || (s = [s]);
    let g = this.data.rect[3] - this.data.rect[1], o = this.data.rect[2] - this.data.rect[0];
    r !== 90 && r !== 270 || ([o, g] = [g, o]);
    const I = this.data.options.length, C = [];
    for (let m = 0; m < I; m++) {
      const { exportValue: y } = this.data.options[m];
      s.includes(y) && C.push(m);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = II(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const h = await le._getFontData(A, e, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let c, { fontSize: B } = this.data.defaultAppearanceData;
    if (B) c = this._defaultAppearance;
    else {
      const m = (g - 1) / I;
      let y, b = -1;
      for (const { displayValue: D } of this.data.options) {
        const R = this._getTextWidth(D, h);
        R > b && (b = R, y = D);
      }
      [c, B] = this._computeFontSize(m, o - 4, y, h, -1);
    }
    const l = B * Hi, Q = (l - B) / 2, E = Math.floor(g / l);
    let u = 0;
    if (C.length > 0) {
      const m = Math.min(...C), y = Math.max(...C);
      u = Math.max(0, y - E + 1), u > m && (u = m);
    }
    const f = Math.min(u + E + 1, I), d = ["/Tx BMC q", `1 1 ${o} ${g} re W n`];
    if (C.length) {
      d.push("0.600006 0.756866 0.854904 rg");
      for (const m of C) u <= m && m < f && d.push(`1 ${g - (m - u + 1) * l} ${o} ${l} re f`);
    }
    d.push("BT", c, `1 0 0 1 0 ${g} Tm`);
    const p = { shift: 0 };
    for (let m = u; m < f; m++) {
      const { displayValue: y } = this.data.options[m], b = m === u ? Q : 0;
      d.push(this._renderText(y, h, B, o, 0, p, 2, -l + b));
    }
    return d.push("ET Q EMC"), d.join(`
`);
  }
}
class th extends le {
  constructor(A) {
    super(A), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return { id: this.data.id, value: null, page: this.data.pageIndex, type: "signature" };
  }
}
class P3 extends Kt {
  constructor(A) {
    super(A), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const { dict: e } = A;
    this.data.annotationType = kh, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = e.has("Name") ? e.get("Name").name : "Note"), e.has("State") ? (this.data.state = e.get("State") || null, this.data.stateModel = e.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
  }
}
class W3 extends cn {
  constructor(A) {
    var s;
    super(A);
    const { dict: e, annotationGlobals: i } = A;
    this.data.annotationType = Fh, this.data.noHTML = !1;
    const a = In(e, this.rectangle);
    a && (this.data.quadPoints = a), (s = this.data).borderColor || (s.borderColor = this.data.color), xs.parseDestDictionary({ destDict: e, resultObj: this.data, docBaseUrl: i.baseUrl, docAttachments: i.attachments });
  }
}
class eh extends cn {
  constructor(A) {
    super(A);
    const { dict: e } = A;
    this.data.annotationType = qh, this.data.noHTML = !1, this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
    let i = e.get("Parent");
    if (!i) {
      G("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    if (this.data.parentRect = be(i.getArray("Rect"), null), it(i.get("RT"), q0) && (i = i.get("IRT")), i.has("M") ? (this.setModificationDate(i.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i.has("C") ? (this.setColor(i.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
      const a = i.get("F");
      this._isViewable(a) && this.setFlags(a);
    }
    this.setTitle(i.get("T")), this.data.titleObj = this._title, this.setContents(i.get("Contents")), this.data.contentsObj = this._contents, i.has("RC") && (this.data.richText = on.getRichTextAsHtml(i.get("RC"))), this.data.open = !!e.get("Open");
  }
}
class Mg extends Kt {
  constructor(A) {
    var a;
    super(A), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
    const { evaluatorOptions: e, xref: i } = A;
    if (this.data.annotationType = Sh, this.setDefaultAppearance(A), this._hasAppearance = !!this.appearance, this._hasAppearance) {
      const { fontColor: s, fontSize: r } = function(g, o, I) {
        return new jE(g, o, I).parse();
      }(this.appearance, e, i);
      this.data.defaultAppearanceData.fontColor = s, this.data.defaultAppearanceData.fontSize = r || 10;
    } else {
      (a = this.data.defaultAppearanceData).fontSize || (a.fontSize = 10);
      const { fontColor: s, fontSize: r } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((I) => I.trimEnd());
        const { coords: n, bbox: g, matrix: o } = we.getFirstPositionInfo(this.rectangle, this.rotation, r);
        this.data.textPosition = this._transformPoint(n, g, o);
      }
      if (this._isOffscreenCanvasSupported) {
        const n = A.dict.get("CA"), g = new we(i, "sans-serif");
        this.appearance = g.createAppearance(this._contents.str, this.rectangle, this.rotation, r, s, n), this._streams.push(this.appearance);
      } else G("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(A, e, { apRef: i, ap: a }) {
    const { color: s, fontSize: r, oldAnnotation: n, rect: g, rotation: o, user: I, value: C } = A, h = n || new U(e);
    h.set("Type", T.get("Annot")), h.set("Subtype", T.get("FreeText")), n ? (h.set("M", `D:${We()}`), h.delete("RC")) : h.set("CreationDate", `D:${We()}`), h.set("Rect", g);
    const c = `/Helv ${r} Tf ${Ke(s, !0)}`;
    if (h.set("DA", c), h.set("Contents", ie(C)), h.set("F", 4), h.set("Border", [0, 0, 0]), h.set("Rotate", o), I && h.set("T", ie(I)), i || a) {
      const B = new U(e);
      h.set("AP", B), i ? B.set("N", i) : B.set("N", a);
    }
    return h;
  }
  static async createNewAppearanceStream(A, e, i) {
    const { baseFontRef: a, evaluator: s, task: r } = i, { color: n, fontSize: g, rect: o, rotation: I, value: C } = A, h = new U(e), c = new U(e);
    if (a) c.set("Helv", a);
    else {
      const F = new U(e);
      F.set("BaseFont", T.get("Helvetica")), F.set("Type", T.get("Font")), F.set("Subtype", T.get("Type1")), F.set("Encoding", T.get("WinAnsiEncoding")), c.set("Helv", F);
    }
    h.set("Font", c);
    const B = await le._getFontData(s, r, { fontName: "Helv", fontSize: g }, h), [l, Q, E, u] = o;
    let f = E - l, d = u - Q;
    I % 180 != 0 && ([f, d] = [d, f]);
    const p = C.split(`
`), m = g / 1e3;
    let y = -1 / 0;
    const b = [];
    for (let F of p) {
      const w = B.encodeString(F);
      if (w.length > 1) return null;
      F = w.join(""), b.push(F);
      let x = 0;
      const J = B.charsToGlyphs(F);
      for (const M of J) x += M.width * m;
      y = Math.max(y, x);
    }
    let D = 1;
    y > f && (D = f / y);
    let R = 1;
    const k = Hi * g, Y = 1 * g, V = k * p.length;
    V > d && (R = d / V);
    const eA = g * Math.min(D, R);
    let AA, O, L;
    switch (I) {
      case 0:
        L = [1, 0, 0, 1], O = [o[0], o[1], f, d], AA = [o[0], o[3] - Y];
        break;
      case 90:
        L = [0, 1, -1, 0], O = [o[1], -o[2], f, d], AA = [o[1], -o[0] - Y];
        break;
      case 180:
        L = [-1, 0, 0, -1], O = [-o[2], -o[3], f, d], AA = [-o[2], -o[1] - Y];
        break;
      case 270:
        L = [0, -1, 1, 0], O = [-o[3], o[0], f, d], AA = [-o[3], o[2] - Y];
    }
    const v = ["q", `${L.join(" ")} 0 0 cm`, `${O.join(" ")} re W n`, "BT", `${Ke(n, !0)}`, `0 Tc /Helv ${vA(eA)} Tf`];
    v.push(`${AA.join(" ")} Td (${Ga(b[0])}) Tj`);
    const W = vA(k);
    for (let F = 1, w = b.length; F < w; F++) {
      const x = b[F];
      v.push(`0 -${W} Td (${Ga(x)}) Tj`);
    }
    v.push("ET", "Q");
    const K = v.join(`
`), q = new U(e);
    q.set("FormType", 1), q.set("Subtype", T.get("Form")), q.set("Type", T.get("XObject")), q.set("BBox", o), q.set("Resources", h), q.set("Matrix", [1, 0, 0, 1, -o[0], -o[1]]);
    const N = new Ht(K);
    return N.dict = q, N;
  }
}
class Z3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    this.data.annotationType = Rh, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const a = zg(e.getArray("L"), [0, 0, 0, 0]);
    if (this.data.lineCoordinates = nt.normalizeRect(a), this.setLineEndings(e.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
      const s = this.color ? vt(this.color) : [0, 0, 0], r = e.get("CA"), n = wa(e.getArray("IC"), null), g = n ? vt(n) : null, o = g ? r : null, I = this.borderStyle.width || 1, C = 2 * I, h = [this.data.lineCoordinates[0] - C, this.data.lineCoordinates[1] - C, this.data.lineCoordinates[2] + C, this.data.lineCoordinates[3] + C];
      nt.intersect(this.rectangle, h) || (this.rectangle = h), this._setDefaultAppearance({ xref: i, extra: `${I} w`, strokeColor: s, fillColor: g, strokeAlpha: r, fillAlpha: o, pointsCallback: (c, B) => (c.push(`${a[0]} ${a[1]} m`, `${a[2]} ${a[3]} l`, "S"), [B[0] - I, B[2] + I, B[7] - I, B[3] + I]) });
    }
  }
}
class O3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Gh, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, !this.appearance) {
      const a = this.color ? vt(this.color) : [0, 0, 0], s = e.get("CA"), r = wa(e.getArray("IC"), null), n = r ? vt(r) : null, g = n ? s : null;
      if (this.borderStyle.width === 0 && !n) return;
      this._setDefaultAppearance({ xref: i, extra: `${this.borderStyle.width} w`, strokeColor: a, fillColor: n, strokeAlpha: s, fillAlpha: g, pointsCallback: (o, I) => {
        const C = I[4] + this.borderStyle.width / 2, h = I[5] + this.borderStyle.width / 2, c = I[6] - I[4] - this.borderStyle.width, B = I[3] - I[7] - this.borderStyle.width;
        return o.push(`${C} ${h} ${c} ${B} re`), n ? o.push("B") : o.push("S"), [I[0], I[2], I[7], I[3]];
      } });
    }
  }
}
class X3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Nh, !this.appearance) {
      const a = this.color ? vt(this.color) : [0, 0, 0], s = e.get("CA"), r = wa(e.getArray("IC"), null), n = r ? vt(r) : null, g = n ? s : null;
      if (this.borderStyle.width === 0 && !n) return;
      const o = 4 / 3 * Math.tan(Math.PI / 8);
      this._setDefaultAppearance({ xref: i, extra: `${this.borderStyle.width} w`, strokeColor: a, fillColor: n, strokeAlpha: s, fillAlpha: g, pointsCallback: (I, C) => {
        const h = C[0] + this.borderStyle.width / 2, c = C[1] - this.borderStyle.width / 2, B = C[6] - this.borderStyle.width / 2, l = C[7] + this.borderStyle.width / 2, Q = h + (B - h) / 2, E = c + (l - c) / 2, u = (B - h) / 2 * o, f = (l - c) / 2 * o;
        return I.push(`${Q} ${l} m`, `${Q + u} ${l} ${B} ${E + f} ${B} ${E} c`, `${B} ${E - f} ${Q + u} ${c} ${Q} ${c} c`, `${Q - u} ${c} ${h} ${E - f} ${h} ${E} c`, `${h} ${E + f} ${Q - u} ${l} ${Q} ${l} c`, "h"), n ? I.push("B") : I.push("S"), [C[0], C[2], C[7], C[3]];
      } });
    }
  }
}
class ih extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    this.data.annotationType = Uh, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.vertices = null, this instanceof ah || (this.setLineEndings(e.getArray("LE")), this.data.lineEndings = this.lineEndings);
    const a = e.getArray("Vertices");
    if (!Gt(a, null)) return;
    const s = this.data.vertices = Float32Array.from(a);
    if (!this.appearance) {
      const r = this.color ? vt(this.color) : [0, 0, 0], n = e.get("CA"), g = this.borderStyle.width || 1, o = 2 * g, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let C = 0, h = s.length; C < h; C += 2)
        I[0] = Math.min(I[0], s[C] - o), I[1] = Math.min(I[1], s[C + 1] - o), I[2] = Math.max(I[2], s[C] + o), I[3] = Math.max(I[3], s[C + 1] + o);
      nt.intersect(this.rectangle, I) || (this.rectangle = I), this._setDefaultAppearance({ xref: i, extra: `${g} w`, strokeColor: r, strokeAlpha: n, pointsCallback: (C, h) => {
        for (let c = 0, B = s.length; c < B; c += 2) C.push(`${s[c]} ${s[c + 1]} ${c === 0 ? "m" : "l"}`);
        return C.push("S"), [h[0], h[2], h[7], h[3]];
      } });
    }
  }
}
class ah extends ih {
  constructor(A) {
    super(A), this.data.annotationType = xh;
  }
}
class V3 extends Kt {
  constructor(A) {
    super(A), this.data.annotationType = vh;
  }
}
class is extends Kt {
  constructor(A) {
    super(A), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const { dict: e, xref: i } = A;
    this.data.annotationType = Kh, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = e.get("CA") || 1;
    const a = e.getArray("InkList");
    if (Array.isArray(a)) {
      for (let s = 0, r = a.length; s < r; ++s) {
        if (!Array.isArray(a[s])) continue;
        const n = new Float32Array(a[s].length);
        this.data.inkLists.push(n);
        for (let g = 0, o = a[s].length; g < o; g += 2) {
          const I = i.fetchIfRef(a[s][g]), C = i.fetchIfRef(a[s][g + 1]);
          typeof I == "number" && typeof C == "number" && (n[g] = I, n[g + 1] = C);
        }
      }
      if (!this.appearance) {
        const s = this.color ? vt(this.color) : [0, 0, 0], r = e.get("CA"), n = this.borderStyle.width || 1, g = 2 * n, o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const I of this.data.inkLists) for (let C = 0, h = I.length; C < h; C += 2)
          o[0] = Math.min(o[0], I[C] - g), o[1] = Math.min(o[1], I[C + 1] - g), o[2] = Math.max(o[2], I[C] + g), o[3] = Math.max(o[3], I[C + 1] + g);
        nt.intersect(this.rectangle, o) || (this.rectangle = o), this._setDefaultAppearance({ xref: i, extra: `${n} w`, strokeColor: s, strokeAlpha: r, pointsCallback: (I, C) => {
          for (const h of this.data.inkLists) {
            for (let c = 0, B = h.length; c < B; c += 2) I.push(`${h[c]} ${h[c + 1]} ${c === 0 ? "m" : "l"}`);
            I.push("S");
          }
          return [C[0], C[2], C[7], C[3]];
        } });
      }
    }
  }
  static createNewDict(A, e, { apRef: i, ap: a }) {
    const { oldAnnotation: s, color: r, opacity: n, paths: g, outlines: o, rect: I, rotation: C, thickness: h, user: c } = A, B = s || new U(e);
    B.set("Type", T.get("Annot")), B.set("Subtype", T.get("Ink")), B.set(s ? "M" : "CreationDate", `D:${We()}`), B.set("Rect", I), B.set("InkList", (o == null ? void 0 : o.points) || g.points), B.set("F", 4), B.set("Rotate", C), c && B.set("T", ie(c)), o && B.set("IT", T.get("InkHighlight"));
    const l = new U(e);
    B.set("BS", l), l.set("W", h), B.set("C", Array.from(r, (E) => E / 255)), B.set("CA", n);
    const Q = new U(e);
    return B.set("AP", Q), i ? Q.set("N", i) : Q.set("N", a), B;
  }
  static async createNewAppearanceStream(A, e, i) {
    if (A.outlines) return this.createNewAppearanceStreamForHighlight(A, e, i);
    const { color: a, rect: s, paths: r, thickness: n, opacity: g } = A, o = [`${n} w 1 J 1 j`, `${Ke(a, !1)}`];
    g !== 1 && o.push("/R0 gs");
    for (const c of r.lines) {
      o.push(`${vA(c[4])} ${vA(c[5])} m`);
      for (let B = 6, l = c.length; B < l; B += 6) if (isNaN(c[B])) o.push(`${vA(c[B + 4])} ${vA(c[B + 5])} l`);
      else {
        const [Q, E, u, f, d, p] = c.slice(B, B + 6);
        o.push([Q, E, u, f, d, p].map(vA).join(" ") + " c");
      }
      c.length === 6 && o.push(`${vA(c[4])} ${vA(c[5])} l`);
    }
    o.push("S");
    const I = o.join(`
`), C = new U(e);
    if (C.set("FormType", 1), C.set("Subtype", T.get("Form")), C.set("Type", T.get("XObject")), C.set("BBox", s), C.set("Length", I.length), g !== 1) {
      const c = new U(e), B = new U(e), l = new U(e);
      l.set("CA", g), l.set("Type", T.get("ExtGState")), B.set("R0", l), c.set("ExtGState", B), C.set("Resources", c);
    }
    const h = new Ht(I);
    return h.dict = C, h;
  }
  static async createNewAppearanceStreamForHighlight(A, e, i) {
    const { color: a, rect: s, outlines: { outline: r }, opacity: n } = A, g = [`${Ke(a, !0)}`, "/R0 gs"];
    g.push(`${vA(r[4])} ${vA(r[5])} m`);
    for (let l = 6, Q = r.length; l < Q; l += 6) if (isNaN(r[l])) g.push(`${vA(r[l + 4])} ${vA(r[l + 5])} l`);
    else {
      const [E, u, f, d, p, m] = r.slice(l, l + 6);
      g.push([E, u, f, d, p, m].map(vA).join(" ") + " c");
    }
    g.push("h f");
    const o = g.join(`
`), I = new U(e);
    I.set("FormType", 1), I.set("Subtype", T.get("Form")), I.set("Type", T.get("XObject")), I.set("BBox", s), I.set("Length", o.length);
    const C = new U(e), h = new U(e);
    C.set("ExtGState", h), I.set("Resources", C);
    const c = new U(e);
    h.set("R0", c), c.set("BM", T.get("Multiply")), n !== 1 && (c.set("ca", n), c.set("Type", T.get("ExtGState")));
    const B = new Ht(o);
    return B.dict = I, B;
  }
}
class Lg extends Kt {
  constructor(A) {
    var a;
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Mh, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = e.get("CA") || 1, this.data.quadPoints = In(e, null)) {
      const s = (a = this.appearance) == null ? void 0 : a.dict.get("Resources");
      if (!this.appearance || !(s != null && s.has("ExtGState"))) {
        this.appearance && G("HighlightAnnotation - ignoring built-in appearance stream.");
        const r = this.color ? vt(this.color) : [1, 1, 0], n = e.get("CA");
        this._setDefaultAppearance({ xref: i, fillColor: r, blendMode: "Multiply", fillAlpha: n, pointsCallback: (g, o) => (g.push(`${o[0]} ${o[1]} m`, `${o[2]} ${o[3]} l`, `${o[6]} ${o[7]} l`, `${o[4]} ${o[5]} l`, "f"), [o[0], o[2], o[7], o[3]]) });
      }
    } else this.data.popupRef = null;
  }
  static createNewDict(A, e, { apRef: i, ap: a }) {
    const { color: s, oldAnnotation: r, opacity: n, rect: g, rotation: o, user: I, quadPoints: C } = A, h = r || new U(e);
    if (h.set("Type", T.get("Annot")), h.set("Subtype", T.get("Highlight")), h.set(r ? "M" : "CreationDate", `D:${We()}`), h.set("CreationDate", `D:${We()}`), h.set("Rect", g), h.set("F", 4), h.set("Border", [0, 0, 0]), h.set("Rotate", o), h.set("QuadPoints", C), h.set("C", Array.from(s, (c) => c / 255)), h.set("CA", n), I && h.set("T", ie(I)), i || a) {
      const c = new U(e);
      h.set("AP", c), c.set("N", i || a);
    }
    return h;
  }
  static async createNewAppearanceStream(A, e, i) {
    const { color: a, rect: s, outlines: r, opacity: n } = A, g = [`${Ke(a, !0)}`, "/R0 gs"], o = [];
    for (const Q of r) {
      o.length = 0, o.push(`${vA(Q[0])} ${vA(Q[1])} m`);
      for (let E = 2, u = Q.length; E < u; E += 2) o.push(`${vA(Q[E])} ${vA(Q[E + 1])} l`);
      o.push("h"), g.push(o.join(`
`));
    }
    g.push("f*");
    const I = g.join(`
`), C = new U(e);
    C.set("FormType", 1), C.set("Subtype", T.get("Form")), C.set("Type", T.get("XObject")), C.set("BBox", s), C.set("Length", I.length);
    const h = new U(e), c = new U(e);
    h.set("ExtGState", c), C.set("Resources", h);
    const B = new U(e);
    c.set("R0", B), B.set("BM", T.get("Multiply")), n !== 1 && (B.set("ca", n), B.set("Type", T.get("ExtGState")));
    const l = new Ht(I);
    return l.dict = C, l;
  }
}
class j3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Lh, this.data.quadPoints = In(e, null)) {
      if (!this.appearance) {
        const a = this.color ? vt(this.color) : [0, 0, 0], s = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 0.571 w", strokeColor: a, strokeAlpha: s, pointsCallback: (r, n) => (r.push(`${n[4]} ${n[5] + 1.3} m`, `${n[6]} ${n[7] + 1.3} l`, "S"), [n[0], n[2], n[7], n[3]]) });
      }
    } else this.data.popupRef = null;
  }
}
class z3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Jh, this.data.quadPoints = In(e, null)) {
      if (!this.appearance) {
        const a = this.color ? vt(this.color) : [0, 0, 0], s = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 1 w", strokeColor: a, strokeAlpha: s, pointsCallback: (r, n) => {
          const g = (n[1] - n[5]) / 6;
          let o = g, I = n[4];
          const C = n[5], h = n[6];
          r.push(`${I} ${C + o} m`);
          do
            I += 2, o = o === 0 ? g : 0, r.push(`${I} ${C + o} l`);
          while (I < h);
          return r.push("S"), [n[4], h, C - 2 * g, C + 2 * g];
        } });
      }
    } else this.data.popupRef = null;
  }
}
class _3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A;
    if (this.data.annotationType = Hh, this.data.quadPoints = In(e, null)) {
      if (!this.appearance) {
        const a = this.color ? vt(this.color) : [0, 0, 0], s = e.get("CA");
        this._setDefaultAppearance({ xref: i, extra: "[] 0 d 1 w", strokeColor: a, strokeAlpha: s, pointsCallback: (r, n) => (r.push((n[0] + n[4]) / 2 + " " + (n[1] + n[5]) / 2 + " m", (n[2] + n[6]) / 2 + " " + (n[3] + n[7]) / 2 + " l", "S"), [n[0], n[2], n[7], n[3]]) });
      }
    } else this.data.popupRef = null;
  }
}
var Fa;
class Nn extends Kt {
  constructor(e) {
    super(e);
    MA(this, Fa);
    this.data.annotationType = Yh, Vt(this, Fa, this.data.hasOwnCanvas = this.data.noRotate), this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
  }
  mustBeViewedWhenEditing(e, i = null) {
    return e ? this.data.isEditable ? (Vt(this, Fa, this.data.hasOwnCanvas), this.data.hasOwnCanvas = !0, !0) : !1 : (this.data.hasOwnCanvas = NA(this, Fa), !(i != null && i.has(this.data.id)));
  }
  static async createImage(e, i) {
    const { width: a, height: s } = e, r = new OffscreenCanvas(a, s), n = r.getContext("2d", { alpha: !0 });
    n.drawImage(e, 0, 0);
    const g = n.getImageData(0, 0, a, s).data, o = new Uint32Array(g.buffer), I = o.some(Jt.isLittleEndian ? (Q) => Q >>> 24 != 255 : (Q) => (255 & Q) != 255);
    I && (n.fillStyle = "white", n.fillRect(0, 0, a, s), n.drawImage(e, 0, 0));
    const C = r.convertToBlob({ type: "image/jpeg", quality: 1 }).then((Q) => Q.arrayBuffer()), h = T.get("XObject"), c = T.get("Image"), B = new U(i);
    B.set("Type", h), B.set("Subtype", c), B.set("BitsPerComponent", 8), B.set("ColorSpace", T.get("DeviceRGB")), B.set("Filter", T.get("DCTDecode")), B.set("BBox", [0, 0, a, s]), B.set("Width", a), B.set("Height", s);
    let l = null;
    if (I) {
      const Q = new Uint8Array(o.length);
      if (Jt.isLittleEndian) for (let u = 0, f = o.length; u < f; u++) Q[u] = o[u] >>> 24;
      else for (let u = 0, f = o.length; u < f; u++) Q[u] = 255 & o[u];
      const E = new U(i);
      E.set("Type", h), E.set("Subtype", c), E.set("BitsPerComponent", 8), E.set("ColorSpace", T.get("DeviceGray")), E.set("Width", a), E.set("Height", s), l = new At(Q, 0, 0, E);
    }
    return { imageStream: new At(await C, 0, 0, B), smaskStream: l, width: a, height: s };
  }
  static createNewDict(e, i, { apRef: a, ap: s }) {
    const { oldAnnotation: r, rect: n, rotation: g, user: o } = e, I = r || new U(i);
    if (I.set("Type", T.get("Annot")), I.set("Subtype", T.get("Stamp")), I.set(r ? "M" : "CreationDate", `D:${We()}`), I.set("Rect", n), I.set("F", 4), I.set("Border", [0, 0, 0]), I.set("Rotate", g), o && I.set("T", ie(o)), a || s) {
      const C = new U(i);
      I.set("AP", C), a ? C.set("N", a) : C.set("N", s);
    }
    return I;
  }
  static async createNewAppearanceStream(e, i, a) {
    if (e.oldAnnotation) return null;
    const { rotation: s } = e, { imageRef: r, width: n, height: g } = a.image, o = new U(i), I = new U(i);
    o.set("XObject", I), I.set("Im0", r);
    const C = `q ${n} 0 0 ${g} 0 0 cm /Im0 Do Q`, h = new U(i);
    if (h.set("FormType", 1), h.set("Subtype", T.get("Form")), h.set("Type", T.get("XObject")), h.set("BBox", [0, 0, n, g]), h.set("Resources", o), s) {
      const B = Qr(s, n, g);
      h.set("Matrix", B);
    }
    const c = new Ht(C);
    return c.dict = h, c;
  }
}
Fa = new WeakMap();
class $3 extends Kt {
  constructor(A) {
    super(A);
    const { dict: e, xref: i } = A, a = new wo(e.get("FS"), i);
    this.data.annotationType = Th, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.file = a.serializable;
    const s = e.get("Name");
    this.data.name = s instanceof T ? LA(s.name) : "PushPin";
    const r = e.get("ca");
    this.data.fillAlpha = typeof r == "number" && r >= 0 && r <= 1 ? r : null;
  }
}
class A5 extends Dt {
  constructor(A, e, i) {
    super(e), this.str = A, this.dict = A.dict, this.decrypt = i, this.nextChunk = null, this.initialized = !1;
  }
  readBlock() {
    var s;
    let A;
    if (this.initialized ? A = this.nextChunk : (A = this.str.getBytes(512), this.initialized = !0), !A || A.length === 0) {
      this.eof = !0;
      return;
    }
    this.nextChunk = this.str.getBytes(512);
    const e = ((s = this.nextChunk) == null ? void 0 : s.length) > 0;
    A = (0, this.decrypt)(A, !e);
    const i = this.bufferLength, a = i + A.length;
    this.ensureBuffer(a).set(A, i), this.bufferLength = a;
  }
}
class bi {
  constructor(A) {
    this.a = 0, this.b = 0;
    const e = new Uint8Array(256), i = A.length;
    for (let a = 0; a < 256; ++a) e[a] = a;
    for (let a = 0, s = 0; a < 256; ++a) {
      const r = e[a];
      s = s + r + A[a % i] & 255, e[a] = e[s], e[s] = r;
    }
    this.s = e;
  }
  encryptBlock(A) {
    let e = this.a, i = this.b;
    const a = this.s, s = A.length, r = new Uint8Array(s);
    for (let n = 0; n < s; ++n) {
      e = e + 1 & 255;
      const g = a[e];
      i = i + g & 255;
      const o = a[i];
      a[e] = o, a[i] = g, r[n] = A[n] ^ a[g + o & 255];
    }
    return this.a = e, this.b = i, r;
  }
  decryptBlock(A) {
    return this.encryptBlock(A);
  }
  encrypt(A) {
    return this.encryptBlock(A);
  }
}
const ii = function() {
  const A = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), e = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  return function(a, s, r) {
    let n = 1732584193, g = -271733879, o = -1732584194, I = 271733878;
    const C = r + 72 & -64, h = new Uint8Array(C);
    let c, B;
    for (c = 0; c < r; ++c) h[c] = a[s++];
    h[c++] = 128;
    const l = C - 8;
    for (; c < l; ) h[c++] = 0;
    h[c++] = r << 3 & 255, h[c++] = r >> 5 & 255, h[c++] = r >> 13 & 255, h[c++] = r >> 21 & 255, h[c++] = r >>> 29 & 255, h[c++] = 0, h[c++] = 0, h[c++] = 0;
    const Q = new Int32Array(16);
    for (c = 0; c < C; ) {
      for (B = 0; B < 16; ++B, c += 4) Q[B] = h[c] | h[c + 1] << 8 | h[c + 2] << 16 | h[c + 3] << 24;
      let E, u, f = n, d = g, p = o, m = I;
      for (B = 0; B < 64; ++B) {
        B < 16 ? (E = d & p | ~d & m, u = B) : B < 32 ? (E = m & d | ~m & p, u = 5 * B + 1 & 15) : B < 48 ? (E = d ^ p ^ m, u = 3 * B + 5 & 15) : (E = p ^ (d | ~m), u = 7 * B & 15);
        const y = m, b = f + E + e[B] + Q[u] | 0, D = A[B];
        m = p, p = d, d = d + (b << D | b >>> 32 - D) | 0, f = y;
      }
      n = n + f | 0, g = g + d | 0, o = o + p | 0, I = I + m | 0;
    }
    return new Uint8Array([255 & n, n >> 8 & 255, n >> 16 & 255, n >>> 24 & 255, 255 & g, g >> 8 & 255, g >> 16 & 255, g >>> 24 & 255, 255 & o, o >> 8 & 255, o >> 16 & 255, o >>> 24 & 255, 255 & I, I >> 8 & 255, I >> 16 & 255, I >>> 24 & 255]);
  };
}();
class nA {
  constructor(A, e) {
    this.high = 0 | A, this.low = 0 | e;
  }
  and(A) {
    this.high &= A.high, this.low &= A.low;
  }
  xor(A) {
    this.high ^= A.high, this.low ^= A.low;
  }
  or(A) {
    this.high |= A.high, this.low |= A.low;
  }
  shiftRight(A) {
    A >= 32 ? (this.low = this.high >>> A - 32 | 0, this.high = 0) : (this.low = this.low >>> A | this.high << 32 - A, this.high = this.high >>> A | 0);
  }
  shiftLeft(A) {
    A >= 32 ? (this.high = this.low << A - 32, this.low = 0) : (this.high = this.high << A | this.low >>> 32 - A, this.low <<= A);
  }
  rotateRight(A) {
    let e, i;
    32 & A ? (i = this.low, e = this.high) : (e = this.low, i = this.high), A &= 31, this.low = e >>> A | i << 32 - A, this.high = i >>> A | e << 32 - A;
  }
  not() {
    this.high = ~this.high, this.low = ~this.low;
  }
  add(A) {
    const e = (this.low >>> 0) + (A.low >>> 0);
    let i = (this.high >>> 0) + (A.high >>> 0);
    e > 4294967295 && (i += 1), this.low = 0 | e, this.high = 0 | i;
  }
  copyTo(A, e) {
    A[e] = this.high >>> 24 & 255, A[e + 1] = this.high >> 16 & 255, A[e + 2] = this.high >> 8 & 255, A[e + 3] = 255 & this.high, A[e + 4] = this.low >>> 24 & 255, A[e + 5] = this.low >> 16 & 255, A[e + 6] = this.low >> 8 & 255, A[e + 7] = 255 & this.low;
  }
  assign(A) {
    this.high = A.high, this.low = A.low;
  }
}
const la = /* @__PURE__ */ function() {
  function A(g, o) {
    return g >>> o | g << 32 - o;
  }
  function e(g, o, I) {
    return g & o ^ ~g & I;
  }
  function i(g, o, I) {
    return g & o ^ g & I ^ o & I;
  }
  function a(g) {
    return A(g, 2) ^ A(g, 13) ^ A(g, 22);
  }
  function s(g) {
    return A(g, 6) ^ A(g, 11) ^ A(g, 25);
  }
  function r(g) {
    return A(g, 7) ^ A(g, 18) ^ g >>> 3;
  }
  const n = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  return function(o, I, C) {
    let h = 1779033703, c = 3144134277, B = 1013904242, l = 2773480762, Q = 1359893119, E = 2600822924, u = 528734635, f = 1541459225;
    const d = 64 * Math.ceil((C + 9) / 64), p = new Uint8Array(d);
    let m, y;
    for (m = 0; m < C; ++m) p[m] = o[I++];
    p[m++] = 128;
    const b = d - 8;
    for (; m < b; ) p[m++] = 0;
    p[m++] = 0, p[m++] = 0, p[m++] = 0, p[m++] = C >>> 29 & 255, p[m++] = C >> 21 & 255, p[m++] = C >> 13 & 255, p[m++] = C >> 5 & 255, p[m++] = C << 3 & 255;
    const D = new Uint32Array(64);
    for (m = 0; m < d; ) {
      for (y = 0; y < 16; ++y)
        D[y] = p[m] << 24 | p[m + 1] << 16 | p[m + 2] << 8 | p[m + 3], m += 4;
      for (y = 16; y < 64; ++y) D[y] = (A(R = D[y - 2], 17) ^ A(R, 19) ^ R >>> 10) + D[y - 7] + r(D[y - 15]) + D[y - 16] | 0;
      let k, Y, V = h, eA = c, AA = B, O = l, L = Q, v = E, W = u, K = f;
      for (y = 0; y < 64; ++y)
        k = K + s(L) + e(L, v, W) + n[y] + D[y], Y = a(V) + i(V, eA, AA), K = W, W = v, v = L, L = O + k | 0, O = AA, AA = eA, eA = V, V = k + Y | 0;
      h = h + V | 0, c = c + eA | 0, B = B + AA | 0, l = l + O | 0, Q = Q + L | 0, E = E + v | 0, u = u + W | 0, f = f + K | 0;
    }
    var R;
    return new Uint8Array([h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, B >> 24 & 255, B >> 16 & 255, B >> 8 & 255, 255 & B, l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, 255 & l, Q >> 24 & 255, Q >> 16 & 255, Q >> 8 & 255, 255 & Q, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, 255 & f]);
  };
}(), d0 = function() {
  function A(g, o, I, C, h) {
    g.assign(o), g.and(I), h.assign(o), h.not(), h.and(C), g.xor(h);
  }
  function e(g, o, I, C, h) {
    g.assign(o), g.and(I), h.assign(o), h.and(C), g.xor(h), h.assign(I), h.and(C), g.xor(h);
  }
  function i(g, o, I) {
    g.assign(o), g.rotateRight(28), I.assign(o), I.rotateRight(34), g.xor(I), I.assign(o), I.rotateRight(39), g.xor(I);
  }
  function a(g, o, I) {
    g.assign(o), g.rotateRight(14), I.assign(o), I.rotateRight(18), g.xor(I), I.assign(o), I.rotateRight(41), g.xor(I);
  }
  function s(g, o, I) {
    g.assign(o), g.rotateRight(1), I.assign(o), I.rotateRight(8), g.xor(I), I.assign(o), I.shiftRight(7), g.xor(I);
  }
  function r(g, o, I) {
    g.assign(o), g.rotateRight(19), I.assign(o), I.rotateRight(61), g.xor(I), I.assign(o), I.shiftRight(6), g.xor(I);
  }
  const n = [new nA(1116352408, 3609767458), new nA(1899447441, 602891725), new nA(3049323471, 3964484399), new nA(3921009573, 2173295548), new nA(961987163, 4081628472), new nA(1508970993, 3053834265), new nA(2453635748, 2937671579), new nA(2870763221, 3664609560), new nA(3624381080, 2734883394), new nA(310598401, 1164996542), new nA(607225278, 1323610764), new nA(1426881987, 3590304994), new nA(1925078388, 4068182383), new nA(2162078206, 991336113), new nA(2614888103, 633803317), new nA(3248222580, 3479774868), new nA(3835390401, 2666613458), new nA(4022224774, 944711139), new nA(264347078, 2341262773), new nA(604807628, 2007800933), new nA(770255983, 1495990901), new nA(1249150122, 1856431235), new nA(1555081692, 3175218132), new nA(1996064986, 2198950837), new nA(2554220882, 3999719339), new nA(2821834349, 766784016), new nA(2952996808, 2566594879), new nA(3210313671, 3203337956), new nA(3336571891, 1034457026), new nA(3584528711, 2466948901), new nA(113926993, 3758326383), new nA(338241895, 168717936), new nA(666307205, 1188179964), new nA(773529912, 1546045734), new nA(1294757372, 1522805485), new nA(1396182291, 2643833823), new nA(1695183700, 2343527390), new nA(1986661051, 1014477480), new nA(2177026350, 1206759142), new nA(2456956037, 344077627), new nA(2730485921, 1290863460), new nA(2820302411, 3158454273), new nA(3259730800, 3505952657), new nA(3345764771, 106217008), new nA(3516065817, 3606008344), new nA(3600352804, 1432725776), new nA(4094571909, 1467031594), new nA(275423344, 851169720), new nA(430227734, 3100823752), new nA(506948616, 1363258195), new nA(659060556, 3750685593), new nA(883997877, 3785050280), new nA(958139571, 3318307427), new nA(1322822218, 3812723403), new nA(1537002063, 2003034995), new nA(1747873779, 3602036899), new nA(1955562222, 1575990012), new nA(2024104815, 1125592928), new nA(2227730452, 2716904306), new nA(2361852424, 442776044), new nA(2428436474, 593698344), new nA(2756734187, 3733110249), new nA(3204031479, 2999351573), new nA(3329325298, 3815920427), new nA(3391569614, 3928383900), new nA(3515267271, 566280711), new nA(3940187606, 3454069534), new nA(4118630271, 4000239992), new nA(116418474, 1914138554), new nA(174292421, 2731055270), new nA(289380356, 3203993006), new nA(460393269, 320620315), new nA(685471733, 587496836), new nA(852142971, 1086792851), new nA(1017036298, 365543100), new nA(1126000580, 2618297676), new nA(1288033470, 3409855158), new nA(1501505948, 4234509866), new nA(1607167915, 987167468), new nA(1816402316, 1246189591)];
  return function(o, I, C, h = !1) {
    let c, B, l, Q, E, u, f, d;
    h ? (c = new nA(3418070365, 3238371032), B = new nA(1654270250, 914150663), l = new nA(2438529370, 812702999), Q = new nA(355462360, 4144912697), E = new nA(1731405415, 4290775857), u = new nA(2394180231, 1750603025), f = new nA(3675008525, 1694076839), d = new nA(1203062813, 3204075428)) : (c = new nA(1779033703, 4089235720), B = new nA(3144134277, 2227873595), l = new nA(1013904242, 4271175723), Q = new nA(2773480762, 1595750129), E = new nA(1359893119, 2917565137), u = new nA(2600822924, 725511199), f = new nA(528734635, 4215389547), d = new nA(1541459225, 327033209));
    const p = 128 * Math.ceil((C + 17) / 128), m = new Uint8Array(p);
    let y, b;
    for (y = 0; y < C; ++y) m[y] = o[I++];
    m[y++] = 128;
    const D = p - 16;
    for (; y < D; ) m[y++] = 0;
    m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = 0, m[y++] = C >>> 29 & 255, m[y++] = C >> 21 & 255, m[y++] = C >> 13 & 255, m[y++] = C >> 5 & 255, m[y++] = C << 3 & 255;
    const R = new Array(80);
    for (y = 0; y < 80; y++) R[y] = new nA(0, 0);
    let k = new nA(0, 0), Y = new nA(0, 0), V = new nA(0, 0), eA = new nA(0, 0), AA = new nA(0, 0), O = new nA(0, 0), L = new nA(0, 0), v = new nA(0, 0);
    const W = new nA(0, 0), K = new nA(0, 0), q = new nA(0, 0), N = new nA(0, 0);
    let F, w;
    for (y = 0; y < p; ) {
      for (b = 0; b < 16; ++b)
        R[b].high = m[y] << 24 | m[y + 1] << 16 | m[y + 2] << 8 | m[y + 3], R[b].low = m[y + 4] << 24 | m[y + 5] << 16 | m[y + 6] << 8 | m[y + 7], y += 8;
      for (b = 16; b < 80; ++b)
        F = R[b], r(F, R[b - 2], N), F.add(R[b - 7]), s(q, R[b - 15], N), F.add(q), F.add(R[b - 16]);
      for (k.assign(c), Y.assign(B), V.assign(l), eA.assign(Q), AA.assign(E), O.assign(u), L.assign(f), v.assign(d), b = 0; b < 80; ++b)
        W.assign(v), a(q, AA, N), W.add(q), A(q, AA, O, L, N), W.add(q), W.add(n[b]), W.add(R[b]), i(K, k, N), e(q, k, Y, V, N), K.add(q), F = v, v = L, L = O, O = AA, eA.add(W), AA = eA, eA = V, V = Y, Y = k, F.assign(W), F.add(K), k = F;
      c.add(k), B.add(Y), l.add(V), Q.add(eA), E.add(AA), u.add(O), f.add(L), d.add(v);
    }
    return h ? (w = new Uint8Array(48), c.copyTo(w, 0), B.copyTo(w, 8), l.copyTo(w, 16), Q.copyTo(w, 24), E.copyTo(w, 32), u.copyTo(w, 40)) : (w = new Uint8Array(64), c.copyTo(w, 0), B.copyTo(w, 8), l.copyTo(w, 16), Q.copyTo(w, 24), E.copyTo(w, 32), u.copyTo(w, 40), f.copyTo(w, 48), d.copyTo(w, 56)), w;
  };
}();
class t5 {
  decryptBlock(A) {
    return A;
  }
  encrypt(A) {
    return A;
  }
}
class FI {
  constructor() {
    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
    for (let A = 0; A < 256; A++) this._mixCol[A] = A < 128 ? A << 1 : A << 1 ^ 27;
    this.buffer = new Uint8Array(16), this.bufferPosition = 0;
  }
  _expandKey(A) {
    xA("Cannot call `_expandKey` on the base class");
  }
  _decrypt(A, e) {
    let i, a, s;
    const r = new Uint8Array(16);
    r.set(A);
    for (let n = 0, g = this._keySize; n < 16; ++n, ++g) r[n] ^= e[g];
    for (let n = this._cyclesOfRepetition - 1; n >= 1; --n) {
      i = r[13], r[13] = r[9], r[9] = r[5], r[5] = r[1], r[1] = i, i = r[14], a = r[10], r[14] = r[6], r[10] = r[2], r[6] = i, r[2] = a, i = r[15], a = r[11], s = r[7], r[15] = r[3], r[11] = i, r[7] = a, r[3] = s;
      for (let g = 0; g < 16; ++g) r[g] = this._inv_s[r[g]];
      for (let g = 0, o = 16 * n; g < 16; ++g, ++o) r[g] ^= e[o];
      for (let g = 0; g < 16; g += 4) {
        const o = this._mix[r[g]], I = this._mix[r[g + 1]], C = this._mix[r[g + 2]], h = this._mix[r[g + 3]];
        i = o ^ I >>> 8 ^ I << 24 ^ C >>> 16 ^ C << 16 ^ h >>> 24 ^ h << 8, r[g] = i >>> 24 & 255, r[g + 1] = i >> 16 & 255, r[g + 2] = i >> 8 & 255, r[g + 3] = 255 & i;
      }
    }
    i = r[13], r[13] = r[9], r[9] = r[5], r[5] = r[1], r[1] = i, i = r[14], a = r[10], r[14] = r[6], r[10] = r[2], r[6] = i, r[2] = a, i = r[15], a = r[11], s = r[7], r[15] = r[3], r[11] = i, r[7] = a, r[3] = s;
    for (let n = 0; n < 16; ++n)
      r[n] = this._inv_s[r[n]], r[n] ^= e[n];
    return r;
  }
  _encrypt(A, e) {
    const i = this._s;
    let a, s, r;
    const n = new Uint8Array(16);
    n.set(A);
    for (let g = 0; g < 16; ++g) n[g] ^= e[g];
    for (let g = 1; g < this._cyclesOfRepetition; g++) {
      for (let o = 0; o < 16; ++o) n[o] = i[n[o]];
      r = n[1], n[1] = n[5], n[5] = n[9], n[9] = n[13], n[13] = r, r = n[2], s = n[6], n[2] = n[10], n[6] = n[14], n[10] = r, n[14] = s, r = n[3], s = n[7], a = n[11], n[3] = n[15], n[7] = r, n[11] = s, n[15] = a;
      for (let o = 0; o < 16; o += 4) {
        const I = n[o + 0], C = n[o + 1], h = n[o + 2], c = n[o + 3];
        a = I ^ C ^ h ^ c, n[o + 0] ^= a ^ this._mixCol[I ^ C], n[o + 1] ^= a ^ this._mixCol[C ^ h], n[o + 2] ^= a ^ this._mixCol[h ^ c], n[o + 3] ^= a ^ this._mixCol[c ^ I];
      }
      for (let o = 0, I = 16 * g; o < 16; ++o, ++I) n[o] ^= e[I];
    }
    for (let g = 0; g < 16; ++g) n[g] = i[n[g]];
    r = n[1], n[1] = n[5], n[5] = n[9], n[9] = n[13], n[13] = r, r = n[2], s = n[6], n[2] = n[10], n[6] = n[14], n[10] = r, n[14] = s, r = n[3], s = n[7], a = n[11], n[3] = n[15], n[7] = r, n[11] = s, n[15] = a;
    for (let g = 0, o = this._keySize; g < 16; ++g, ++o) n[g] ^= e[o];
    return n;
  }
  _decryptBlock2(A, e) {
    const i = A.length;
    let a = this.buffer, s = this.bufferPosition;
    const r = [];
    let n = this.iv;
    for (let I = 0; I < i; ++I) {
      if (a[s] = A[I], ++s, s < 16) continue;
      const C = this._decrypt(a, this._key);
      for (let h = 0; h < 16; ++h) C[h] ^= n[h];
      n = a, r.push(C), a = new Uint8Array(16), s = 0;
    }
    if (this.buffer = a, this.bufferLength = s, this.iv = n, r.length === 0) return new Uint8Array(0);
    let g = 16 * r.length;
    if (e) {
      const I = r.at(-1);
      let C = I[15];
      if (C <= 16) {
        for (let h = 15, c = 16 - C; h >= c; --h) if (I[h] !== C) {
          C = 0;
          break;
        }
        g -= C, r[r.length - 1] = I.subarray(0, 16 - C);
      }
    }
    const o = new Uint8Array(g);
    for (let I = 0, C = 0, h = r.length; I < h; ++I, C += 16) o.set(r[I], C);
    return o;
  }
  decryptBlock(A, e, i = null) {
    const a = A.length, s = this.buffer;
    let r = this.bufferPosition;
    if (i) this.iv = i;
    else {
      for (let n = 0; r < 16 && n < a; ++n, ++r) s[r] = A[n];
      if (r < 16)
        return this.bufferLength = r, new Uint8Array(0);
      this.iv = s, A = A.subarray(16);
    }
    return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(A, e);
  }
  encrypt(A, e) {
    const i = A.length;
    let a = this.buffer, s = this.bufferPosition;
    const r = [];
    e || (e = new Uint8Array(16));
    for (let o = 0; o < i; ++o) {
      if (a[s] = A[o], ++s, s < 16) continue;
      for (let C = 0; C < 16; ++C) a[C] ^= e[C];
      const I = this._encrypt(a, this._key);
      e = I, r.push(I), a = new Uint8Array(16), s = 0;
    }
    if (this.buffer = a, this.bufferLength = s, this.iv = e, r.length === 0) return new Uint8Array(0);
    const n = 16 * r.length, g = new Uint8Array(n);
    for (let o = 0, I = 0, C = r.length; o < C; ++o, I += 16) g.set(r[o], I);
    return g;
  }
}
class sh extends FI {
  constructor(A) {
    super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(A);
  }
  _expandKey(A) {
    const e = this._s, i = this._rcon, a = new Uint8Array(176);
    a.set(A);
    for (let s = 16, r = 1; s < 176; ++r) {
      let n = a[s - 3], g = a[s - 2], o = a[s - 1], I = a[s - 4];
      n = e[n], g = e[g], o = e[o], I = e[I], n ^= i[r];
      for (let C = 0; C < 4; ++C)
        a[s] = n ^= a[s - 16], s++, a[s] = g ^= a[s - 16], s++, a[s] = o ^= a[s - 16], s++, a[s] = I ^= a[s - 16], s++;
    }
    return a;
  }
}
class Ys extends FI {
  constructor(A) {
    super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(A);
  }
  _expandKey(A) {
    const e = this._s, i = new Uint8Array(240);
    i.set(A);
    let a, s, r, n, g = 1;
    for (let o = 32, I = 1; o < 240; ++I) {
      o % 32 == 16 ? (a = e[a], s = e[s], r = e[r], n = e[n]) : o % 32 == 0 && (a = i[o - 3], s = i[o - 2], r = i[o - 1], n = i[o - 4], a = e[a], s = e[s], r = e[r], n = e[n], a ^= g, (g <<= 1) >= 256 && (g = 255 & (27 ^ g)));
      for (let C = 0; C < 4; ++C)
        i[o] = a ^= i[o - 32], o++, i[o] = s ^= i[o - 32], o++, i[o] = r ^= i[o - 32], o++, i[o] = n ^= i[o - 32], o++;
    }
    return i;
  }
}
class e5 {
  checkOwnerPassword(A, e, i, a) {
    const s = new Uint8Array(A.length + 56);
    return s.set(A, 0), s.set(e, A.length), s.set(i, A.length + e.length), Pi(la(s, 0, s.length), a);
  }
  checkUserPassword(A, e, i) {
    const a = new Uint8Array(A.length + 8);
    return a.set(A, 0), a.set(e, A.length), Pi(la(a, 0, a.length), i);
  }
  getOwnerKey(A, e, i, a) {
    const s = new Uint8Array(A.length + 56);
    s.set(A, 0), s.set(e, A.length), s.set(i, A.length + e.length);
    const r = la(s, 0, s.length);
    return new Ys(r).decryptBlock(a, !1, new Uint8Array(16));
  }
  getUserKey(A, e, i) {
    const a = new Uint8Array(A.length + 8);
    a.set(A, 0), a.set(e, A.length);
    const s = la(a, 0, a.length);
    return new Ys(s).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class i5 {
  _hash(A, e, i) {
    let a = la(e, 0, e.length).subarray(0, 32), s = [0], r = 0;
    for (; r < 64 || s.at(-1) > r - 32; ) {
      const I = A.length + a.length + i.length, C = new Uint8Array(I);
      let h = 0;
      C.set(A, h), h += A.length, C.set(a, h), h += a.length, C.set(i, h);
      const c = new Uint8Array(64 * I);
      for (let l = 0, Q = 0; l < 64; l++, Q += I) c.set(C, Q);
      s = new sh(a.subarray(0, 16)).encrypt(c, a.subarray(16, 32));
      const B = s.slice(0, 16).reduce((l, Q) => l + Q, 0) % 3;
      B === 0 ? a = la(s, 0, s.length) : B === 1 ? a = (n = s, g = 0, o = s.length, d0(n, g, o, !0)) : B === 2 && (a = d0(s, 0, s.length)), r++;
    }
    var n, g, o;
    return a.subarray(0, 32);
  }
  checkOwnerPassword(A, e, i, a) {
    const s = new Uint8Array(A.length + 56);
    return s.set(A, 0), s.set(e, A.length), s.set(i, A.length + e.length), Pi(this._hash(A, s, i), a);
  }
  checkUserPassword(A, e, i) {
    const a = new Uint8Array(A.length + 8);
    return a.set(A, 0), a.set(e, A.length), Pi(this._hash(A, a, []), i);
  }
  getOwnerKey(A, e, i, a) {
    const s = new Uint8Array(A.length + 56);
    s.set(A, 0), s.set(e, A.length), s.set(i, A.length + e.length);
    const r = this._hash(A, s, i);
    return new Ys(r).decryptBlock(a, !1, new Uint8Array(16));
  }
  getUserKey(A, e, i) {
    const a = new Uint8Array(A.length + 8);
    a.set(A, 0), a.set(e, A.length);
    const s = this._hash(A, a, []);
    return new Ys(s).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class f0 {
  constructor(A, e) {
    this.StringCipherConstructor = A, this.StreamCipherConstructor = e;
  }
  createStream(A, e) {
    const i = new this.StreamCipherConstructor();
    return new A5(A, e, function(s, r) {
      return i.decryptBlock(s, r);
    });
  }
  decryptString(A) {
    const e = new this.StringCipherConstructor();
    let i = ut(A);
    return i = e.decryptBlock(i, !0), Mt(i);
  }
  encryptString(A) {
    const e = new this.StringCipherConstructor();
    if (e instanceof FI) {
      const a = 16 - A.length % 16;
      A += String.fromCharCode(a).repeat(a);
      const s = new Uint8Array(16);
      if (typeof crypto < "u") crypto.getRandomValues(s);
      else for (let g = 0; g < 16; g++) s[g] = Math.floor(256 * Math.random());
      let r = ut(A);
      r = e.encrypt(r, s);
      const n = new Uint8Array(16 + r.length);
      return n.set(s), n.set(r, 16), Mt(n);
    }
    let i = ut(A);
    return i = e.encrypt(i), Mt(i);
  }
}
var Li, wt, nh, vo, rh, $n, Ko;
const Mi = class Mi {
  constructor(A, e, i) {
    MA(this, wt);
    const a = A.get("Filter");
    if (!it(a, "Standard")) throw new X("unknown encryption method");
    this.filterName = a.name, this.dict = A;
    const s = A.get("V");
    if (!Number.isInteger(s) || s !== 1 && s !== 2 && s !== 4 && s !== 5) throw new X("unsupported encryption algorithm");
    this.algorithm = s;
    let r = A.get("Length");
    if (!r) if (s <= 3) r = 40;
    else {
      const E = A.get("CF"), u = A.get("StmF");
      if (E instanceof U && u instanceof T) {
        E.suppressEncryption = !0;
        const f = E.get(u.name);
        r = (f == null ? void 0 : f.get("Length")) || 128, r < 40 && (r <<= 3);
      }
    }
    if (!Number.isInteger(r) || r < 40 || r % 8 != 0) throw new X("invalid key length");
    const n = ut(A.get("O")), g = ut(A.get("U")), o = n.subarray(0, 32), I = g.subarray(0, 32), C = A.get("P"), h = A.get("R"), c = (s === 4 || s === 5) && A.get("EncryptMetadata") !== !1;
    this.encryptMetadata = c;
    const B = ut(e);
    let l, Q;
    if (i) {
      if (h === 6) try {
        i = Xg(i);
      } catch {
        G("CipherTransformFactory: Unable to convert UTF8 encoded password.");
      }
      l = ut(i);
    }
    if (s !== 5) Q = CA(this, wt, vo).call(this, B, l, o, I, C, h, r, c);
    else {
      const E = n.subarray(32, 40), u = n.subarray(40, 48), f = g.subarray(0, 48), d = g.subarray(32, 40), p = g.subarray(40, 48), m = ut(A.get("OE")), y = ut(A.get("UE")), b = ut(A.get("Perms"));
      Q = CA(this, wt, nh).call(this, h, l, o, E, u, f, I, d, p, m, y, b);
    }
    if (!Q && !i) throw new cr("No password given", LB);
    if (!Q && i) {
      const E = CA(this, wt, rh).call(this, l, o, h, r);
      Q = CA(this, wt, vo).call(this, B, E, o, I, C, h, r, c);
    }
    if (!Q) throw new cr("Incorrect Password", JB);
    if (this.encryptionKey = Q, s >= 4) {
      const E = A.get("CF");
      E instanceof U && (E.suppressEncryption = !0), this.cf = E, this.stmf = A.get("StmF") || T.get("Identity"), this.strf = A.get("StrF") || T.get("Identity"), this.eff = A.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(A, e) {
    if (this.algorithm === 4 || this.algorithm === 5) return new f0(CA(this, wt, Ko).call(this, this.cf, this.strf, A, e, this.encryptionKey), CA(this, wt, Ko).call(this, this.cf, this.stmf, A, e, this.encryptionKey));
    const i = CA(this, wt, $n).call(this, A, e, this.encryptionKey, !1), a = function() {
      return new bi(i);
    };
    return new f0(a, a);
  }
};
Li = new WeakMap(), wt = new WeakSet(), nh = function(A, e, i, a, s, r, n, g, o, I, C, h) {
  if (e) {
    const B = Math.min(127, e.length);
    e = e.subarray(0, B);
  } else e = [];
  const c = A === 6 ? new i5() : new e5();
  return c.checkUserPassword(e, g, n) ? c.getUserKey(e, o, C) : e.length && c.checkOwnerPassword(e, a, r, i) ? c.getOwnerKey(e, s, r, I) : null;
}, vo = function(A, e, i, a, s, r, n, g) {
  const o = 40 + i.length + A.length, I = new Uint8Array(o);
  let C, h, c = 0;
  if (e)
    for (h = Math.min(32, e.length); c < h; ++c) I[c] = e[c];
  for (C = 0; c < 32; ) I[c++] = NA(Mi, Li)[C++];
  for (C = 0, h = i.length; C < h; ++C) I[c++] = i[C];
  for (I[c++] = 255 & s, I[c++] = s >> 8 & 255, I[c++] = s >> 16 & 255, I[c++] = s >>> 24 & 255, C = 0, h = A.length; C < h; ++C) I[c++] = A[C];
  r >= 4 && !g && (I[c++] = 255, I[c++] = 255, I[c++] = 255, I[c++] = 255);
  let B = ii(I, 0, c);
  const l = n >> 3;
  if (r >= 3) for (C = 0; C < 50; ++C) B = ii(B, 0, l);
  const Q = B.subarray(0, l);
  let E, u;
  if (r >= 3) {
    for (c = 0; c < 32; ++c) I[c] = NA(Mi, Li)[c];
    for (C = 0, h = A.length; C < h; ++C) I[c++] = A[C];
    E = new bi(Q), u = E.encryptBlock(ii(I, 0, c)), h = Q.length;
    const f = new Uint8Array(h);
    for (C = 1; C <= 19; ++C) {
      for (let d = 0; d < h; ++d) f[d] = Q[d] ^ C;
      E = new bi(f), u = E.encryptBlock(u);
    }
    for (C = 0, h = u.length; C < h; ++C) if (a[C] !== u[C]) return null;
  } else
    for (E = new bi(Q), u = E.encryptBlock(NA(Mi, Li)), C = 0, h = u.length; C < h; ++C) if (a[C] !== u[C]) return null;
  return Q;
}, rh = function(A, e, i, a) {
  const s = new Uint8Array(32);
  let r = 0;
  const n = Math.min(32, A.length);
  for (; r < n; ++r) s[r] = A[r];
  let g = 0;
  for (; r < 32; ) s[r++] = NA(Mi, Li)[g++];
  let o = ii(s, 0, r);
  const I = a >> 3;
  if (i >= 3) for (g = 0; g < 50; ++g) o = ii(o, 0, o.length);
  let C, h;
  if (i >= 3) {
    h = e;
    const c = new Uint8Array(I);
    for (g = 19; g >= 0; g--) {
      for (let B = 0; B < I; ++B) c[B] = o[B] ^ g;
      C = new bi(c), h = C.encryptBlock(h);
    }
  } else
    C = new bi(o.subarray(0, I)), h = C.encryptBlock(e);
  return h;
}, $n = function(A, e, i, a = !1) {
  const s = new Uint8Array(i.length + 9), r = i.length;
  let n;
  for (n = 0; n < r; ++n) s[n] = i[n];
  return s[n++] = 255 & A, s[n++] = A >> 8 & 255, s[n++] = A >> 16 & 255, s[n++] = 255 & e, s[n++] = e >> 8 & 255, a && (s[n++] = 115, s[n++] = 65, s[n++] = 108, s[n++] = 84), ii(s, 0, n).subarray(0, Math.min(i.length + 5, 16));
}, Ko = function(A, e, i, a, s) {
  if (!(e instanceof T)) throw new X("Invalid crypt filter name.");
  const r = this, n = A.get(e.name), g = n == null ? void 0 : n.get("CFM");
  if (!g || g.name === "None") return function() {
    return new t5();
  };
  if (g.name === "V2") return function() {
    var o;
    return new bi(CA(o = r, wt, $n).call(o, i, a, s, !1));
  };
  if (g.name === "AESV2") return function() {
    var o;
    return new sh(CA(o = r, wt, $n).call(o, i, a, s, !0));
  };
  if (g.name === "AESV3") return function() {
    return new Ys(s);
  };
  throw new X("Unknown crypto method");
}, MA(Mi, Li, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
let Yo = Mi;
function p0(t) {
  try {
    return ws(t);
  } catch (A) {
    return G(`UTF-8 decoding failed: "${A}".`), t;
  }
}
class a5 extends jr {
  constructor(A) {
    super(A), this.node = null;
  }
  onEndElement(A) {
    const e = super.onEndElement(A);
    if (e && A === "xfa:datasets")
      throw this.node = e, new Error("Aborting DatasetXMLParser.");
  }
}
class s5 {
  constructor(A) {
    if (A.datasets) this.node = new jr({ hasAttributes: !0 }).parseFromString(A.datasets).documentElement;
    else {
      const e = new a5({ hasAttributes: !0 });
      try {
        e.parseFromString(A["xdp:xdp"]);
      } catch {
      }
      this.node = e.node;
    }
  }
  getValue(A) {
    if (!this.node || !A) return "";
    const e = this.node.searchNode(f1(A), 0);
    if (!e) return "";
    const i = e.firstChild;
    return (i == null ? void 0 : i.nodeName) === "value" ? e.children.map((a) => p0(a.textContent)) : p0(e.textContent);
  }
}
var _s;
class n5 {
  constructor(A, e) {
    MA(this, _s, null);
    this.stream = A, this.pdfManager = e, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new Bt(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
  }
  getNewPersistentRef(A) {
    this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
    const e = this._newPersistentRefNum++;
    return this._cacheMap.set(e, A), rA.get(e, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
      this._persistentRefsCache = /* @__PURE__ */ new Map();
      for (let A = this._newTemporaryRefNum; A < this._newPersistentRefNum; A++)
        this._persistentRefsCache.set(A, this._cacheMap.get(A)), this._cacheMap.delete(A);
    }
    return rA.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    if (this._newTemporaryRefNum = null, this._persistentRefsCache) for (const [A, e] of this._persistentRefsCache) this._cacheMap.set(A, e);
    this._persistentRefsCache = null;
  }
  setStartXRef(A) {
    this.startXRefQueue = [A];
  }
  parse(A = !1) {
    let e, i, a;
    A ? (G("Indexing all PDF objects"), e = this.indexObjects()) : e = this.readXRef(), e.assignXref(this), this.trailer = e;
    try {
      i = e.get("Encrypt");
    } catch (s) {
      if (s instanceof OA) throw s;
      G(`XRef.parse - Invalid "Encrypt" reference: "${s}".`);
    }
    if (i instanceof U) {
      const s = e.get("ID"), r = s != null && s.length ? s[0] : "";
      i.suppressEncryption = !0, this.encrypt = new Yo(i, r, this.pdfManager.password);
    }
    try {
      a = e.get("Root");
    } catch (s) {
      if (s instanceof OA) throw s;
      G(`XRef.parse - Invalid "Root" reference: "${s}".`);
    }
    if (a instanceof U) try {
      if (a.get("Pages") instanceof U) {
        this.root = a;
        return;
      }
    } catch (s) {
      if (s instanceof OA) throw s;
      G(`XRef.parse - Invalid "Pages" reference: "${s}".`);
    }
    throw A ? new hr("Invalid Root reference.") : new fa();
  }
  processXRefTable(A) {
    if ("tableState" in this || (this.tableState = { entryNum: 0, streamPos: A.lexer.stream.pos, parserBuf1: A.buf1, parserBuf2: A.buf2 }), !ht(this.readXRefTable(A), "trailer")) throw new X("Invalid XRef table: could not find trailer dictionary");
    let e = A.getObj();
    if (e instanceof U || !e.dict || (e = e.dict), !(e instanceof U)) throw new X("Invalid XRef table: could not parse trailer dictionary");
    return delete this.tableState, e;
  }
  readXRefTable(A) {
    const e = A.lexer.stream, i = this.tableState;
    e.pos = i.streamPos, A.buf1 = i.parserBuf1, A.buf2 = i.parserBuf2;
    let a;
    for (; ; ) {
      if (!("firstEntryNum" in i) || !("entryCount" in i)) {
        if (ht(a = A.getObj(), "trailer")) break;
        i.firstEntryNum = a, i.entryCount = A.getObj();
      }
      let s = i.firstEntryNum;
      const r = i.entryCount;
      if (!Number.isInteger(s) || !Number.isInteger(r)) throw new X("Invalid XRef table: wrong types in subsection header");
      for (let n = i.entryNum; n < r; n++) {
        i.streamPos = e.pos, i.entryNum = n, i.parserBuf1 = A.buf1, i.parserBuf2 = A.buf2;
        const g = {};
        g.offset = A.getObj(), g.gen = A.getObj();
        const o = A.getObj();
        if (o instanceof ot) switch (o.cmd) {
          case "f":
            g.free = !0;
            break;
          case "n":
            g.uncompressed = !0;
        }
        if (!Number.isInteger(g.offset) || !Number.isInteger(g.gen) || !g.free && !g.uncompressed) throw new X(`Invalid entry in XRef subsection: ${s}, ${r}`);
        n === 0 && g.free && s === 1 && (s = 0), this.entries[n + s] || (this.entries[n + s] = g);
      }
      i.entryNum = 0, i.streamPos = e.pos, i.parserBuf1 = A.buf1, i.parserBuf2 = A.buf2, delete i.firstEntryNum, delete i.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free) throw new X("Invalid XRef table: unexpected first object");
    return a;
  }
  processXRefStream(A) {
    if (!("streamState" in this)) {
      const e = A.dict, i = e.get("W");
      let a = e.get("Index");
      a || (a = [0, e.get("Size")]), this.streamState = { entryRanges: a, byteWidths: i, entryNum: 0, streamPos: A.pos };
    }
    return this.readXRefStream(A), delete this.streamState, A.dict;
  }
  readXRefStream(A) {
    const e = this.streamState;
    A.pos = e.streamPos;
    const [i, a, s] = e.byteWidths, r = e.entryRanges;
    for (; r.length > 0; ) {
      const [n, g] = r;
      if (!Number.isInteger(n) || !Number.isInteger(g)) throw new X(`Invalid XRef range fields: ${n}, ${g}`);
      if (!Number.isInteger(i) || !Number.isInteger(a) || !Number.isInteger(s)) throw new X(`Invalid XRef entry fields length: ${n}, ${g}`);
      for (let o = e.entryNum; o < g; ++o) {
        e.entryNum = o, e.streamPos = A.pos;
        let I = 0, C = 0, h = 0;
        for (let B = 0; B < i; ++B) {
          const l = A.getByte();
          if (l === -1) throw new X("Invalid XRef byteWidths 'type'.");
          I = I << 8 | l;
        }
        i === 0 && (I = 1);
        for (let B = 0; B < a; ++B) {
          const l = A.getByte();
          if (l === -1) throw new X("Invalid XRef byteWidths 'offset'.");
          C = C << 8 | l;
        }
        for (let B = 0; B < s; ++B) {
          const l = A.getByte();
          if (l === -1) throw new X("Invalid XRef byteWidths 'generation'.");
          h = h << 8 | l;
        }
        const c = {};
        switch (c.offset = C, c.gen = h, I) {
          case 0:
            c.free = !0;
            break;
          case 1:
            c.uncompressed = !0;
            break;
          case 2:
            break;
          default:
            throw new X(`Invalid XRef entry type: ${I}`);
        }
        this.entries[n + o] || (this.entries[n + o] = c);
      }
      e.entryNum = 0, e.streamPos = A.pos, r.splice(0, 2);
    }
  }
  indexObjects() {
    function A(d, p) {
      let m = "", y = d[p];
      for (; y !== 10 && y !== 13 && y !== 60 && !(++p >= d.length); )
        m += String.fromCharCode(y), y = d[p];
      return m;
    }
    function e(d, p, m) {
      const y = m.length, b = d.length;
      let D = 0;
      for (; p < b; ) {
        let R = 0;
        for (; R < y && d[p + R] === m[R]; ) ++R;
        if (R >= y) break;
        p++, D++;
      }
      return D;
    }
    const i = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, a = /\b(startxref|\d+\s+\d+\s+obj)\b/g, s = /^(\d+)\s+(\d+)\s+obj\b/, r = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), n = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), g = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0, this._cacheMap.clear();
    const o = this.stream;
    o.pos = 0;
    const I = o.getBytes(), C = Mt(I), h = I.length;
    let c = o.start;
    const B = [], l = [];
    for (; c < h; ) {
      let d = I[c];
      if (d === 9 || d === 10 || d === 13 || d === 32) {
        ++c;
        continue;
      }
      if (d === 37) {
        do {
          if (++c, c >= h) break;
          d = I[c];
        } while (d !== 10 && d !== 13);
        continue;
      }
      const p = A(I, c);
      let m;
      if (p.startsWith("xref") && (p.length === 4 || /\s/.test(p[4])))
        c += e(I, c, r), B.push(c), c += e(I, c, n);
      else if (m = s.exec(p)) {
        const y = 0 | m[1], b = 0 | m[2], D = c + p.length;
        let R, k = !1;
        if (this.entries[y]) {
          if (this.entries[y].gen === b) try {
            new ti({ lexer: new Ce(o.makeSubStream(D)) }).getObj(), k = !0;
          } catch (AA) {
            AA instanceof jg ? G(`indexObjects -- checking object (${p}): "${AA}".`) : k = !0;
          }
        } else k = !0;
        k && (this.entries[y] = { offset: c - o.start, gen: b, uncompressed: !0 }), i.lastIndex = D;
        const Y = i.exec(C);
        Y ? (R = i.lastIndex + 1 - c, Y[1] !== "endobj" && (G(`indexObjects: Found "${Y[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), R -= Y[1].length + 1)) : R = h - c;
        const V = I.subarray(c, c + R), eA = e(V, 0, g);
        eA < R && V[eA + 5] < 64 && (l.push(c - o.start), this._xrefStms.add(c - o.start)), c += R;
      } else if (p.startsWith("trailer") && (p.length === 7 || /\s/.test(p[7]))) {
        B.push(c);
        const y = c + p.length;
        let b;
        a.lastIndex = y;
        const D = a.exec(C);
        D ? (b = a.lastIndex + 1 - c, D[1] !== "startxref" && (G(`indexObjects: Found "${D[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), b -= D[1].length + 1)) : b = h - c, c += b;
      } else c += p.length + 1;
    }
    for (const d of l)
      this.startXRefQueue.push(d), this.readXRef(!0);
    const Q = [];
    let E, u, f = !1;
    for (const d of B) {
      o.pos = d;
      const p = new ti({ lexer: new Ce(o), xref: this, allowStreams: !0, recoveryMode: !0 });
      if (!ht(p.getObj(), "trailer")) continue;
      const m = p.getObj();
      m instanceof U && (Q.push(m), m.has("Encrypt") && (f = !0));
    }
    for (const d of [...Q, "genFallback", ...Q]) {
      if (d === "genFallback") {
        if (!u) break;
        this._generationFallback = !0;
        continue;
      }
      let p = !1;
      try {
        const m = d.get("Root");
        if (!(m instanceof U)) continue;
        const y = m.get("Pages");
        if (!(y instanceof U)) continue;
        const b = y.get("Count");
        Number.isInteger(b) && (p = !0);
      } catch (m) {
        u = m;
        continue;
      }
      if (p && (!f || d.has("Encrypt")) && d.has("ID")) return d;
      E = d;
    }
    if (E) return E;
    if (this.topDict) return this.topDict;
    if (!Q.length) for (const [d, p] of this.entries.entries()) {
      if (!p) continue;
      const m = rA.get(d, p.gen);
      let y;
      try {
        y = this.fetch(m);
      } catch {
        continue;
      }
      if (y instanceof FA && (y = y.dict), y instanceof U && y.has("Root")) return y;
    }
    throw new hr("Invalid PDF structure.");
  }
  readXRef(A = !1) {
    const e = this.stream, i = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const a = this.startXRefQueue[0];
        if (i.has(a)) {
          G("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
          continue;
        }
        i.add(a), e.pos = a + e.start;
        const s = new ti({ lexer: new Ce(e), xref: this, allowStreams: !0 });
        let r, n = s.getObj();
        if (ht(n, "xref"))
          r = this.processXRefTable(s), this.topDict || (this.topDict = r), n = r.get("XRefStm"), Number.isInteger(n) && !this._xrefStms.has(n) && (this._xrefStms.add(n), this.startXRefQueue.push(n), NA(this, _s) ?? Vt(this, _s, n));
        else {
          if (!Number.isInteger(n)) throw new X("Invalid XRef stream header");
          if (!(Number.isInteger(s.getObj()) && ht(s.getObj(), "obj") && (n = s.getObj()) instanceof FA)) throw new X("Invalid XRef stream");
          if (r = this.processXRefStream(n), this.topDict || (this.topDict = r), !r) throw new X("Failed to read XRef stream");
        }
        n = r.get("Prev"), Number.isInteger(n) ? this.startXRefQueue.push(n) : n instanceof rA && this.startXRefQueue.push(n.num);
      } catch (a) {
        if (a instanceof OA) throw a;
        RA("(while reading XRef): " + a);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict) return this.topDict;
    if (!A) throw new fa();
  }
  get lastXRefStreamPos() {
    return NA(this, _s) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(A) {
    const e = this.entries[A];
    return e && !e.free && e.offset ? e : null;
  }
  fetchIfRef(A, e = !1) {
    return A instanceof rA ? this.fetch(A, e) : A;
  }
  fetch(A, e = !1) {
    if (!(A instanceof rA)) throw new Error("ref object is not a reference");
    const i = A.num, a = this._cacheMap.get(i);
    if (a !== void 0)
      return a instanceof U && !a.objId && (a.objId = A.toString()), a;
    let s = this.getEntry(i);
    if (s === null)
      return this._cacheMap.set(i, s), s;
    if (this._pendingRefs.has(A))
      return this._pendingRefs.remove(A), G(`Ignoring circular reference: ${A}.`), PB;
    this._pendingRefs.put(A);
    try {
      s = s.uncompressed ? this.fetchUncompressed(A, s, e) : this.fetchCompressed(A, s, e), this._pendingRefs.remove(A);
    } catch (r) {
      throw this._pendingRefs.remove(A), r;
    }
    return s instanceof U ? s.objId = A.toString() : s instanceof FA && (s.dict.objId = A.toString()), s;
  }
  fetchUncompressed(A, e, i = !1) {
    const a = A.gen;
    let s = A.num;
    if (e.gen !== a) {
      const C = `Inconsistent generation in XRef: ${A}`;
      if (this._generationFallback && e.gen < a)
        return G(C), this.fetchUncompressed(rA.get(s, e.gen), e, i);
      throw new Ii(C);
    }
    const r = this.stream.makeSubStream(e.offset + this.stream.start), n = new ti({ lexer: new Ce(r), xref: this, allowStreams: !0 }), g = n.getObj(), o = n.getObj(), I = n.getObj();
    if (g !== s || o !== a || !(I instanceof ot)) throw new Ii(`Bad (uncompressed) XRef entry: ${A}`);
    if (I.cmd !== "obj") {
      if (I.cmd.startsWith("obj") && (s = parseInt(I.cmd.substring(3), 10), !Number.isNaN(s)))
        return s;
      throw new Ii(`Bad (uncompressed) XRef entry: ${A}`);
    }
    return (e = this.encrypt && !i ? n.getObj(this.encrypt.createCipherTransform(s, a)) : n.getObj()) instanceof FA || this._cacheMap.set(s, e), e;
  }
  fetchCompressed(A, e, i = !1) {
    const a = e.offset, s = this.fetch(rA.get(a, 0));
    if (!(s instanceof FA)) throw new X("bad ObjStm stream");
    const r = s.dict.get("First"), n = s.dict.get("N");
    if (!Number.isInteger(r) || !Number.isInteger(n)) throw new X("invalid first and n parameters for ObjStm stream");
    let g = new ti({ lexer: new Ce(s), xref: this, allowStreams: !0 });
    const o = new Array(n), I = new Array(n);
    for (let c = 0; c < n; ++c) {
      const B = g.getObj();
      if (!Number.isInteger(B)) throw new X(`invalid object number in the ObjStm stream: ${B}`);
      const l = g.getObj();
      if (!Number.isInteger(l)) throw new X(`invalid object offset in the ObjStm stream: ${l}`);
      o[c] = B, I[c] = l;
    }
    const C = (s.start || 0) + r, h = new Array(n);
    for (let c = 0; c < n; ++c) {
      const B = c < n - 1 ? I[c + 1] - I[c] : void 0;
      if (B < 0) throw new X("Invalid offset in the ObjStm stream.");
      g = new ti({ lexer: new Ce(s.makeSubStream(C + I[c], B, s.dict)), xref: this, allowStreams: !0 });
      const l = g.getObj();
      if (h[c] = l, l instanceof FA) continue;
      const Q = o[c], E = this.entries[Q];
      E && E.offset === a && E.gen === c && this._cacheMap.set(Q, l);
    }
    if ((e = h[e.gen]) === void 0) throw new Ii(`Bad (compressed) XRef entry: ${A}`);
    return e;
  }
  async fetchIfRefAsync(A, e) {
    return A instanceof rA ? this.fetchAsync(A, e) : A;
  }
  async fetchAsync(A, e) {
    try {
      return this.fetch(A, e);
    } catch (i) {
      if (!(i instanceof OA)) throw i;
      return await this.pdfManager.requestRange(i.begin, i.end), this.fetchAsync(A, e);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
_s = new WeakMap();
const r5 = [0, 0, 612, 792];
var $s, qo;
class m0 {
  constructor({ pdfManager: A, xref: e, pageIndex: i, pageDict: a, ref: s, globalIdFactory: r, fontCache: n, builtInCMapCache: g, standardFontDataCache: o, globalImageCache: I, systemFontCache: C, nonBlendModesSet: h, xfaFactory: c }) {
    MA(this, $s);
    this.pdfManager = A, this.pageIndex = i, this.pageDict = a, this.xref = e, this.ref = s, this.fontCache = n, this.builtInCMapCache = g, this.standardFontDataCache = o, this.globalImageCache = I, this.systemFontCache = C, this.nonBlendModesSet = h, this.evaluatorOptions = A.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = c;
    const B = { obj: 0 };
    this._localIdFactory = class extends r {
      static createObjId() {
        return `p${i}_${++B.obj}`;
      }
      static getPageObjId() {
        return `p${s.toString()}`;
      }
    };
  }
  _getInheritableProperty(A, e = !1) {
    const i = ee({ dict: this.pageDict, key: A, getArray: e, stopWhenFound: !1 });
    return Array.isArray(i) ? i.length !== 1 && i[0] instanceof U ? U.merge({ xref: this.xref, dictArray: i }) : i[0] : i;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const A = this._getInheritableProperty("Resources");
    return sA(this, "resources", A instanceof U ? A : U.empty);
  }
  _getBoundingBox(A) {
    if (this.xfaData) return this.xfaData.bbox;
    const e = be(this._getInheritableProperty(A, !0), null);
    if (e) {
      if (e[2] - e[0] > 0 && e[3] - e[1] > 0) return e;
      G(`Empty, or invalid, /${A} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return sA(this, "mediaBox", this._getBoundingBox("MediaBox") || r5);
  }
  get cropBox() {
    return sA(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    const A = this.pageDict.get("UserUnit");
    return sA(this, "userUnit", typeof A == "number" && A > 0 ? A : 1);
  }
  get view() {
    const { cropBox: A, mediaBox: e } = this;
    if (A !== e && !Pi(A, e)) {
      const i = nt.intersect(A, e);
      if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0) return sA(this, "view", i);
      G("Empty /CropBox and /MediaBox intersection.");
    }
    return sA(this, "view", e);
  }
  get rotate() {
    let A = this._getInheritableProperty("Rotate") || 0;
    return A % 90 != 0 ? A = 0 : A >= 360 ? A %= 360 : A < 0 && (A = (A % 360 + 360) % 360), sA(this, "rotate", A);
  }
  _onSubStreamError(A, e) {
    if (!this.evaluatorOptions.ignoreErrors) throw A;
    G(`getContentStream - ignoring sub-stream (${e}): "${A}".`);
  }
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then((A) => A instanceof FA ? A : Array.isArray(A) ? new Il(A, this._onSubStreamError.bind(this)) : new $g());
  }
  get xfaData() {
    return sA(this, "xfaData", this.xfaFactory ? { bbox: this.xfaFactory.getBoundingBox(this.pageIndex) } : null);
  }
  async saveNewAnnotations(A, e, i, a, s) {
    if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
    const r = new He({ xref: this.xref, handler: A, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), n = new xt(), g = new Bt();
    await CA(this, $s, qo).call(this, i, n, g);
    const o = this.pageDict, I = this.annotations.filter((c) => !(c instanceof rA && n.has(c))), C = await ri.saveNewAnnotations(r, e, i, a, s);
    for (const { ref: c } of C.annotations) c instanceof rA && !g.has(c) && I.push(c);
    const h = o.clone();
    h.set("Annots", I), s.put(this.ref, { data: h });
    for (const c of n) s.put(c, { data: null });
  }
  save(A, e, i, a) {
    const s = new He({ xref: this.xref, handler: A, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions });
    return this._parsedAnnotations.then(function(r) {
      const n = [];
      for (const g of r) n.push(g.save(s, e, i, a).catch(function(o) {
        return G(`save - ignoring annotation data during "${e.name}" task: "${o}".`), null;
      }));
      return Promise.all(n);
    });
  }
  loadResources(A) {
    return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new mr(this.resources, A, this.xref).load());
  }
  getOperatorList({ handler: A, sink: e, task: i, intent: a, cacheKey: s, annotationStorage: r = null, modifiedIds: n = null }) {
    const g = this.getContentStream(), o = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), I = new He({ xref: this.xref, handler: A, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }), C = this.xfaFactory ? null : m1(r), h = C == null ? void 0 : C.get(this.pageIndex);
    let c = Promise.resolve(null), B = null;
    if (h) {
      const Q = this.pdfManager.ensureDoc("annotationGlobals");
      let E;
      const u = /* @__PURE__ */ new Set();
      for (const { bitmapId: d, bitmap: p } of h) !d || p || u.has(d) || u.add(d);
      const { isOffscreenCanvasSupported: f } = this.evaluatorOptions;
      if (u.size > 0) {
        const d = h.slice();
        for (const [p, m] of r) p.startsWith(K0) && m.bitmap && u.has(m.bitmapId) && d.push(m);
        E = ri.generateImages(d, this.xref, f);
      } else E = ri.generateImages(h, this.xref, f);
      B = new Bt(), c = Promise.all([Q, CA(this, $s, qo).call(this, h, B, null)]).then(([d]) => d ? ri.printNewAnnotations(d, I, i, h, E) : null);
    }
    const l = Promise.all([g, o]).then(([Q]) => {
      const E = new Lt(a, e);
      return A.send("StartRenderPage", { transparency: I.hasBlendModes(this.resources, this.nonBlendModesSet), pageIndex: this.pageIndex, cacheKey: s }), I.getOperatorList({ stream: Q, task: i, resources: this.resources, operatorList: E }).then(function() {
        return E;
      });
    });
    return Promise.all([l, this._parsedAnnotations, c]).then(function([Q, E, u]) {
      if (u) {
        E = E.filter((D) => !(D.ref && B.has(D.ref)));
        for (let D = 0, R = u.length; D < R; D++) {
          const k = u[D];
          if (k.refToReplace) {
            const Y = E.findIndex((V) => V.ref && Br(V.ref, k.refToReplace));
            Y >= 0 && (E.splice(Y, 1, k), u.splice(D--, 1), R--);
          }
        }
        E = E.concat(u);
      }
      if (E.length === 0 || a & mh)
        return Q.flush(!0), { length: Q.totalLength };
      const f = !!(a & v0), d = !!(a & yh), p = !!(a & LI), m = !!(a & tr), y = !!(a & JI), b = [];
      for (const D of E) (p || m && D.mustBeViewed(r, f) && D.mustBeViewedWhenEditing(d, n) || y && D.mustBePrinted(r)) && b.push(D.getOperatorList(I, i, a, r).catch(function(R) {
        return G(`getOperatorList - ignoring annotation data during "${i.name}" task: "${R}".`), { opList: null, separateForm: !1, separateCanvas: !1 };
      }));
      return Promise.all(b).then(function(D) {
        let R = !1, k = !1;
        for (const { opList: Y, separateForm: V, separateCanvas: eA } of D)
          Q.addOpList(Y), R || (R = V), k || (k = eA);
        return Q.flush(!0, { form: R, canvas: k }), { length: Q.totalLength };
      });
    });
  }
  async extractTextContent({ handler: A, task: e, includeMarkedContent: i, disableNormalization: a, sink: s }) {
    const r = this.getContentStream(), n = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]), g = this.pdfManager.ensureCatalog("lang"), [o, , I] = await Promise.all([r, n, g]);
    return new He({ xref: this.xref, handler: A, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions }).getTextContent({ stream: o, task: e, resources: this.resources, includeMarkedContent: i, disableNormalization: a, sink: s, viewBox: this.view, lang: I });
  }
  async getStructTree() {
    const A = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!A) return null;
    await this._parsedAnnotations;
    const e = await this.pdfManager.ensure(this, "_parseStructTree", [A]);
    return this.pdfManager.ensure(e, "serializable");
  }
  _parseStructTree(A) {
    const e = new EC(A, this.pageDict);
    return e.parse(this.ref), e;
  }
  async getAnnotationsData(A, e, i) {
    const a = await this._parsedAnnotations;
    if (a.length === 0) return a;
    const s = [], r = [];
    let n;
    const g = !!(i & LI), o = !!(i & tr), I = !!(i & JI);
    for (const C of a) {
      const h = g || o && C.viewable;
      (h || I && C.printable) && s.push(C.data), C.hasTextContent && h && (n || (n = new He({ xref: this.xref, handler: A, pageIndex: this.pageIndex, idFactory: this._localIdFactory, fontCache: this.fontCache, builtInCMapCache: this.builtInCMapCache, standardFontDataCache: this.standardFontDataCache, globalImageCache: this.globalImageCache, systemFontCache: this.systemFontCache, options: this.evaluatorOptions })), r.push(C.extractTextContent(n, e, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(c) {
        G(`getAnnotationsData - ignoring textContent during "${e.name}" task: "${c}".`);
      })));
    }
    return await Promise.all(r), s;
  }
  get annotations() {
    const A = this._getInheritableProperty("Annots");
    return sA(this, "annotations", Array.isArray(A) ? A : []);
  }
  get _parsedAnnotations() {
    return sA(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (A) => {
      if (A.length === 0) return A;
      const [e, i] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
      if (!e) return [];
      const a = i == null ? void 0 : i.orphanFields, s = [];
      for (const o of A) s.push(ri.create(this.xref, o, e, this._localIdFactory, !1, a, this.ref).catch(function(I) {
        return G(`_parsedAnnotations: "${I}".`), null;
      }));
      const r = [];
      let n, g;
      for (const o of await Promise.all(s)) o && (o instanceof le ? (g || (g = [])).push(o) : o instanceof eh ? (n || (n = [])).push(o) : r.push(o));
      return g && r.push(...g), n && r.push(...n), r;
    }));
  }
  get jsActions() {
    return sA(this, "jsActions", Wr(this.xref, this.pageDict, rB));
  }
}
$s = new WeakSet(), qo = async function(A, e, i) {
  const a = [];
  for (const s of A) if (s.id) {
    const r = rA.fromString(s.id);
    if (!r) {
      G(`A non-linked annotation cannot be modified: ${s.id}`);
      continue;
    }
    if (s.deleted) {
      if (e.put(r, r), s.popupRef) {
        const n = rA.fromString(s.popupRef);
        n && e.put(n, n);
      }
      continue;
    }
    i == null || i.put(r), s.ref = r, a.push(this.xref.fetchAsync(r).then((n) => {
      n instanceof U && (s.oldAnnotation = n.clone());
    }, () => {
      G(`Cannot fetch \`oldAnnotation\` for: ${r}.`);
    })), delete s.id;
  }
  await Promise.all(a);
};
const y0 = new Uint8Array([37, 80, 68, 70, 45]), w0 = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), g5 = new Uint8Array([101, 110, 100, 111, 98, 106]);
function Jg(t, A, e = 1024, i = !1) {
  const a = A.length, s = t.peekBytes(e), r = s.length - a;
  if (r <= 0) return !1;
  if (i) {
    const n = a - 1;
    let g = s.length - 1;
    for (; g >= n; ) {
      let o = 0;
      for (; o < a && s[g - o] === A[n - o]; ) o++;
      if (o >= a)
        return t.pos += g - n, !0;
      g--;
    }
  } else {
    let n = 0;
    for (; n <= r; ) {
      let g = 0;
      for (; g < a && s[n + g] === A[g]; ) g++;
      if (g >= a)
        return t.pos += n, !0;
      n++;
    }
  }
  return !1;
}
var An, To;
class gh {
  constructor(A, e) {
    MA(this, An);
    if (e.length <= 0) throw new hr("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = A, this.stream = e, this.xref = new n5(e, A), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
    const i = { font: 0 };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${A.docId}`;
      }
      static createFontId() {
        return "f" + ++i.font;
      }
      static createObjId() {
        xA("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        xA("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(A) {
    this.xref.parse(A), this.catalog = new xs(this.pdfManager, this.xref);
  }
  get linearization() {
    let A = null;
    try {
      A = Tl.create(this.stream);
    } catch (e) {
      if (e instanceof OA) throw e;
      RA(e);
    }
    return sA(this, "linearization", A);
  }
  get startXRef() {
    const A = this.stream;
    let e = 0;
    if (this.linearization) {
      if (A.reset(), Jg(A, g5)) {
        A.skip(6);
        let i = A.peekByte();
        for (; Zt(i); )
          A.pos++, i = A.peekByte();
        e = A.pos - A.start;
      }
    } else {
      const a = w0.length;
      let s = !1, r = A.end;
      for (; !s && r > 0; )
        r -= 1024 - a, r < 0 && (r = 0), A.pos = r, s = Jg(A, w0, 1024, !0);
      if (s) {
        A.skip(9);
        let n;
        do
          n = A.getByte();
        while (Zt(n));
        let g = "";
        for (; n >= 32 && n <= 57; )
          g += String.fromCharCode(n), n = A.getByte();
        e = parseInt(g, 10), isNaN(e) && (e = 0);
      }
    }
    return sA(this, "startXRef", e);
  }
  checkHeader() {
    const A = this.stream;
    if (A.reset(), !Jg(A, y0)) return;
    A.moveStart(), A.skip(y0.length);
    let e, i = "";
    for (; (e = A.getByte()) > 32 && i.length < 7; ) i += String.fromCharCode(e);
    u1.test(i) ? this._version = i : G(`Invalid PDF header version: ${i}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let A = 0;
    return A = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages, sA(this, "numPages", A);
  }
  _hasOnlyDocumentSignatures(A, e = 0) {
    return !!Array.isArray(A) && A.every((i) => {
      if (!((i = this.xref.fetchIfRef(i)) instanceof U)) return !1;
      if (i.has("Kids"))
        return ++e > 10 ? (G("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(i.get("Kids"), e);
      const a = it(i.get("FT"), "Sig"), s = i.get("Rect"), r = Array.isArray(s) && s.every((n) => n === 0);
      return a && r;
    });
  }
  get _xfaStreams() {
    const A = this.catalog.acroForm;
    if (!A) return null;
    const e = A.get("XFA"), i = { "xdp:xdp": "", template: "", datasets: "", config: "", connectionSet: "", localeSet: "", stylesheet: "", "/xdp:xdp": "" };
    if (e instanceof FA && !e.isEmpty)
      return i["xdp:xdp"] = e, i;
    if (!Array.isArray(e) || e.length === 0) return null;
    for (let a = 0, s = e.length; a < s; a += 2) {
      let r;
      if (r = a === 0 ? "xdp:xdp" : a === s - 2 ? "/xdp:xdp" : e[a], !i.hasOwnProperty(r)) continue;
      const n = this.xref.fetchIfRef(e[a + 1]);
      n instanceof FA && !n.isEmpty && (i[r] = n);
    }
    return i;
  }
  get xfaDatasets() {
    const A = this._xfaStreams;
    if (!A) return sA(this, "xfaDatasets", null);
    for (const e of ["datasets", "xdp:xdp"]) {
      const i = A[e];
      if (i) try {
        const a = ws(i.getString());
        return sA(this, "xfaDatasets", new s5({ [e]: a }));
      } catch {
        G("XFA - Invalid utf-8 string.");
        break;
      }
    }
    return sA(this, "xfaDatasets", null);
  }
  get xfaData() {
    const A = this._xfaStreams;
    if (!A) return null;
    const e = /* @__PURE__ */ Object.create(null);
    for (const [i, a] of Object.entries(A)) if (a) try {
      e[i] = ws(a.getString());
    } catch {
      return G("XFA - Invalid utf-8 string."), null;
    }
    return e;
  }
  get xfaFactory() {
    let A;
    return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (A = this.xfaData), sA(this, "xfaFactory", A ? new on(A) : null);
  }
  get isPureXfa() {
    return !!this.xfaFactory && this.xfaFactory.isValid();
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async loadXfaImages() {
    const A = await this.pdfManager.ensureCatalog("xfaImages");
    if (!A) return;
    const e = A.getKeys();
    await new mr(A, e, this.xref).load();
    const a = /* @__PURE__ */ new Map();
    for (const s of e) {
      const r = A.get(s);
      r instanceof FA && a.set(s, r.getBytes());
    }
    this.xfaFactory.setImages(a);
  }
  async loadXfaFonts(A, e) {
    const i = await this.pdfManager.ensureCatalog("acroForm");
    if (!i) return;
    const a = await i.getAsync("DR");
    if (!(a instanceof U)) return;
    await new mr(a, ["Font"], this.xref).load();
    const r = a.get("Font");
    if (!(r instanceof U)) return;
    const n = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
    n.useSystemFonts = !1;
    const g = new He({ xref: this.xref, handler: A, pageIndex: -1, idFactory: this._globalIdFactory, fontCache: this.catalog.fontCache, builtInCMapCache: this.catalog.builtInCMapCache, standardFontDataCache: this.catalog.standardFontDataCache, options: n }), o = new Lt(), I = [], C = { get font() {
      return I.at(-1);
    }, set font(l) {
      I.push(l);
    }, clone() {
      return this;
    } }, h = [];
    for (const [l, Q] of r) {
      const E = Q.get("FontDescriptor");
      if (!(E instanceof U)) continue;
      let u = E.get("FontFamily");
      u = u.replaceAll(/[ ]+(\d)/g, "$1");
      const f = { fontFamily: u, fontWeight: E.get("FontWeight"), italicAngle: -E.get("ItalicAngle") };
      VB(f) && h.push(g.handleSetFont(a, [T.get(l), 1], null, o, e, C, null, f).catch(function(d) {
        return G(`loadXfaFonts: "${d}".`), null;
      }));
    }
    await Promise.all(h);
    const c = this.xfaFactory.setFonts(I);
    if (!c) return;
    n.ignoreErrors = !0, h.length = 0, I.length = 0;
    const B = /* @__PURE__ */ new Set();
    for (const l of c) gI(`${l}-Regular`) || B.add(l);
    B.size && c.push("PdfJS-Fallback");
    for (const l of c) if (!B.has(l)) for (const Q of [{ name: "Regular", fontWeight: 400, italicAngle: 0 }, { name: "Bold", fontWeight: 700, italicAngle: 0 }, { name: "Italic", fontWeight: 400, italicAngle: 12 }, { name: "BoldItalic", fontWeight: 700, italicAngle: 12 }]) {
      const E = `${l}-${Q.name}`, u = $1(E);
      h.push(g.handleSetFont(a, [T.get(E), 1], null, o, e, C, u, { fontFamily: l, fontWeight: Q.fontWeight, italicAngle: Q.italicAngle }).catch(function(f) {
        return G(`loadXfaFonts: "${f}".`), null;
      }));
    }
    await Promise.all(h), this.xfaFactory.appendFonts(I, B);
  }
  async serializeXfaData(A) {
    return this.xfaFactory ? this.xfaFactory.serializeData(A) : null;
  }
  get version() {
    return this.catalog.version || this._version;
  }
  get formInfo() {
    const A = { hasFields: !1, hasAcroForm: !1, hasXfa: !1, hasSignatures: !1 }, e = this.catalog.acroForm;
    if (!e) return sA(this, "formInfo", A);
    try {
      const i = e.get("Fields"), a = Array.isArray(i) && i.length > 0;
      A.hasFields = a;
      const s = e.get("XFA");
      A.hasXfa = Array.isArray(s) && s.length > 0 || s instanceof FA && !s.isEmpty;
      const r = !!(1 & e.get("SigFlags")), n = r && this._hasOnlyDocumentSignatures(i);
      A.hasAcroForm = a && !n, A.hasSignatures = r;
    } catch (i) {
      if (i instanceof OA) throw i;
      G(`Cannot fetch form information: "${i}".`);
    }
    return sA(this, "formInfo", A);
  }
  get documentInfo() {
    const A = { PDFFormatVersion: this.version, Language: this.catalog.lang, EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null, IsLinearized: !!this.linearization, IsAcroFormPresent: this.formInfo.hasAcroForm, IsXFAPresent: this.formInfo.hasXfa, IsCollectionPresent: !!this.catalog.collection, IsSignaturesPresent: this.formInfo.hasSignatures };
    let e;
    try {
      e = this.xref.trailer.get("Info");
    } catch (i) {
      if (i instanceof OA) throw i;
      RA("The document information dictionary is invalid.");
    }
    if (!(e instanceof U)) return sA(this, "documentInfo", A);
    for (const i of e.getKeys()) {
      const a = e.get(i);
      switch (i) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if (typeof a == "string") {
            A[i] = LA(a);
            continue;
          }
          break;
        case "Trapped":
          if (a instanceof T) {
            A[i] = a;
            continue;
          }
          break;
        default:
          let s;
          switch (typeof a) {
            case "string":
              s = LA(a);
              break;
            case "number":
            case "boolean":
              s = a;
              break;
            default:
              a instanceof T && (s = a);
          }
          if (s === void 0) {
            G(`Bad value, for custom key "${i}", in Info: ${a}.`);
            continue;
          }
          A.Custom || (A.Custom = /* @__PURE__ */ Object.create(null)), A.Custom[i] = s;
          continue;
      }
      G(`Bad value, for key "${i}", in Info: ${a}.`);
    }
    return sA(this, "documentInfo", A);
  }
  get fingerprints() {
    const A = "\0".repeat(16);
    function e(r) {
      return typeof r == "string" && r.length === 16 && r !== A;
    }
    const i = this.xref.trailer.get("ID");
    let a, s;
    return Array.isArray(i) && e(i[0]) ? (a = ut(i[0]), i[1] !== i[0] && e(i[1]) && (s = ut(i[1]))) : a = ii(this.stream.getByteRange(0, 1024), 0, 1024), sA(this, "fingerprints", [_I(a), s ? _I(s) : null]);
  }
  async _getLinearizationPage(A) {
    const { catalog: e, linearization: i, xref: a } = this, s = rA.get(i.objectNumberFirst, 0);
    try {
      const r = await a.fetchAsync(s);
      if (r instanceof U) {
        let n = r.getRaw("Type");
        if (n instanceof rA && (n = await a.fetchAsync(n)), it(n, "Page") || !r.has("Type") && !r.has("Kids") && r.has("Contents"))
          return e.pageKidsCountCache.has(s) || e.pageKidsCountCache.put(s, 1), e.pageIndexCache.has(s) || e.pageIndexCache.put(s, 0), [r, s];
      }
      throw new X("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (r) {
      return G(`_getLinearizationPage: "${r.message}".`), e.getPageDict(A);
    }
  }
  getPage(A) {
    const e = this._pagePromises.get(A);
    if (e) return e;
    const { catalog: i, linearization: a, xfaFactory: s } = this;
    let r;
    return r = s ? Promise.resolve([U.empty, null]) : (a == null ? void 0 : a.pageFirst) === A ? this._getLinearizationPage(A) : i.getPageDict(A), r = r.then(([n, g]) => new m0({ pdfManager: this.pdfManager, xref: this.xref, pageIndex: A, pageDict: n, ref: g, globalIdFactory: this._globalIdFactory, fontCache: i.fontCache, builtInCMapCache: i.builtInCMapCache, standardFontDataCache: i.standardFontDataCache, globalImageCache: i.globalImageCache, systemFontCache: i.systemFontCache, nonBlendModesSet: i.nonBlendModesSet, xfaFactory: s })), this._pagePromises.set(A, r), r;
  }
  async checkFirstPage(A = !1) {
    if (!A) try {
      await this.getPage(0);
    } catch (e) {
      if (e instanceof Ii)
        throw this._pagePromises.delete(0), await this.cleanup(), new fa();
    }
  }
  async checkLastPage(A = !1) {
    const { catalog: e, pdfManager: i } = this;
    e.setActualNumPages();
    let a;
    try {
      if (await Promise.all([i.ensureDoc("xfaFactory"), i.ensureDoc("linearization"), i.ensureCatalog("numPages")]), this.xfaFactory) return;
      if (a = this.linearization ? this.linearization.numPages : e.numPages, !Number.isInteger(a)) throw new X("Page count is not an integer.");
      if (a <= 1) return;
      await this.getPage(a - 1);
    } catch (s) {
      if (this._pagePromises.delete(a - 1), await this.cleanup(), s instanceof Ii && !A) throw new fa();
      G(`checkLastPage - invalid /Pages tree /Count: ${a}.`);
      let r;
      try {
        r = await e.getAllPageDicts(A);
      } catch (n) {
        if (n instanceof Ii && !A) throw new fa();
        e.setActualNumPages(1);
        return;
      }
      for (const [n, [g, o]] of r) {
        let I;
        g instanceof Error ? (I = Promise.reject(g), I.catch(() => {
        })) : I = Promise.resolve(new m0({ pdfManager: i, xref: this.xref, pageIndex: n, pageDict: g, ref: o, globalIdFactory: this._globalIdFactory, fontCache: e.fontCache, builtInCMapCache: e.builtInCMapCache, standardFontDataCache: e.standardFontDataCache, globalImageCache: e.globalImageCache, systemFontCache: e.systemFontCache, nonBlendModesSet: e.nonBlendModesSet, xfaFactory: null })), this._pagePromises.set(n, I);
      }
      e.setActualNumPages(r.size);
    }
  }
  fontFallback(A, e) {
    return this.catalog.fontFallback(A, e);
  }
  async cleanup(A = !1) {
    return this.catalog ? this.catalog.cleanup(A) : cI();
  }
  get fieldObjects() {
    return sA(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (A) => {
      if (!A.hasFields) return null;
      const [e, i] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]);
      if (!e) return null;
      const a = new Bt(), s = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Map(), n = new xt();
      for (const o of await i.getAsync("Fields")) await CA(this, An, To).call(this, "", null, o, r, e, a, n);
      const g = [];
      for (const [o, I] of r) g.push(Promise.all(I).then((C) => {
        (C = C.filter((h) => !!h)).length > 0 && (s[o] = C);
      }));
      return await Promise.all(g), { allFields: s, orphanFields: n };
    }));
  }
  get hasJSActions() {
    return sA(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
  }
  async _parseHasJSActions() {
    const [A, e] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return !!A || !!e && Object.values(e.allFields).some((i) => i.some((a) => a.actions !== null));
  }
  get calculationOrderIds() {
    var i;
    const A = (i = this.catalog.acroForm) == null ? void 0 : i.get("CO");
    if (!Array.isArray(A) || A.length === 0) return sA(this, "calculationOrderIds", null);
    const e = [];
    for (const a of A) a instanceof rA && e.push(a.toString());
    return sA(this, "calculationOrderIds", e.length ? e : null);
  }
  get annotationGlobals() {
    return sA(this, "annotationGlobals", ri.createGlobals(this.pdfManager));
  }
}
An = new WeakSet(), To = async function(A, e, i, a, s, r, n) {
  const { xref: g } = this;
  if (!(i instanceof rA) || r.has(i)) return;
  r.put(i);
  const o = await g.fetchAsync(i);
  if (!(o instanceof U)) return;
  if (o.has("T")) {
    const C = LA(await o.getAsync("T"));
    A = A === "" ? C : `${A}.${C}`;
  } else {
    let C = o;
    for (; ; ) {
      if (C = C.getRaw("Parent") || e, C instanceof rA) {
        if (r.has(C)) break;
        C = await g.fetchAsync(C);
      }
      if (!(C instanceof U)) break;
      if (C.has("T")) {
        const h = LA(await C.getAsync("T"));
        A = A === "" ? h : `${A}.${h}`;
        break;
      }
    }
  }
  if (e && !o.has("Parent") && it(o.get("Subtype"), "Widget") && n.put(i, e), a.has(A) || a.set(A, []), a.get(A).push(ri.create(g, i, s, null, !0, n, null).then((C) => C == null ? void 0 : C.getFieldObject()).catch(function(C) {
    return G(`#collectFieldObjects: "${C}".`), null;
  })), !o.has("Kids")) return;
  const I = await o.getAsync("Kids");
  if (Array.isArray(I)) for (const C of I) await CA(this, An, To).call(this, A, i, C, a, s, r, n);
};
class oh {
  constructor(A) {
    var e, i;
    this._docBaseUrl = function(s) {
      if (s) {
        const r = Ir(s);
        if (r) return r.href;
        G(`Invalid absolute docBaseUrl: "${s}".`);
      }
      return null;
    }(A.docBaseUrl), this._docId = A.docId, this._password = A.password, this.enableXfa = A.enableXfa, (e = A.evaluatorOptions).isOffscreenCanvasSupported && (e.isOffscreenCanvasSupported = Jt.isOffscreenCanvasSupported), (i = A.evaluatorOptions).isImageDecoderSupported && (i.isImageDecoderSupported = Jt.isImageDecoderSupported), this.evaluatorOptions = Object.freeze(A.evaluatorOptions);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  get catalog() {
    return this.pdfDocument.catalog;
  }
  ensureDoc(A, e) {
    return this.ensure(this.pdfDocument, A, e);
  }
  ensureXRef(A, e) {
    return this.ensure(this.pdfDocument.xref, A, e);
  }
  ensureCatalog(A, e) {
    return this.ensure(this.pdfDocument.catalog, A, e);
  }
  getPage(A) {
    return this.pdfDocument.getPage(A);
  }
  fontFallback(A, e) {
    return this.pdfDocument.fontFallback(A, e);
  }
  loadXfaFonts(A, e) {
    return this.pdfDocument.loadXfaFonts(A, e);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(A) {
    return this.pdfDocument.serializeXfaData(A);
  }
  cleanup(A = !1) {
    return this.pdfDocument.cleanup(A);
  }
  async ensure(A, e, i) {
    xA("Abstract method `ensure` called");
  }
  requestRange(A, e) {
    xA("Abstract method `requestRange` called");
  }
  requestLoadedStream(A = !1) {
    xA("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(A) {
    xA("Abstract method `sendProgressiveData` called");
  }
  updatePassword(A) {
    this._password = A;
  }
  terminate(A) {
    xA("Abstract method `terminate` called");
  }
}
class D0 extends oh {
  constructor(A) {
    super(A);
    const e = new At(A.source);
    this.pdfDocument = new gh(this, e), this._loadedStreamPromise = Promise.resolve(e);
  }
  async ensure(A, e, i) {
    const a = A[e];
    return typeof a == "function" ? a.apply(A, i) : a;
  }
  requestRange(A, e) {
    return Promise.resolve();
  }
  requestLoadedStream(A = !1) {
    return this._loadedStreamPromise;
  }
  terminate(A) {
  }
}
class o5 extends oh {
  constructor(A) {
    super(A), this.streamManager = new _B(A.source, { msgHandler: A.handler, length: A.length, disableAutoFetch: A.disableAutoFetch, rangeChunkSize: A.rangeChunkSize }), this.pdfDocument = new gh(this, this.streamManager.getStream());
  }
  async ensure(A, e, i) {
    try {
      const a = A[e];
      return typeof a == "function" ? a.apply(A, i) : a;
    } catch (a) {
      if (!(a instanceof OA)) throw a;
      return await this.requestRange(a.begin, a.end), this.ensure(A, e, i);
    }
  }
  requestRange(A, e) {
    return this.streamManager.requestRange(A, e);
  }
  requestLoadedStream(A = !1) {
    return this.streamManager.requestAllChunks(A);
  }
  sendProgressiveData(A) {
    this.streamManager.onReceiveData({ chunk: A });
  }
  terminate(A) {
    this.streamManager.abort(A);
  }
}
async function b0(t, A, e, { encrypt: i = null }) {
  const a = i == null ? void 0 : i.createCipherTransform(t.num, t.gen);
  e.push(`${t.num} ${t.gen} obj
`), A instanceof U ? await rg(A, e, a) : A instanceof FA ? await Ih(A, e, a) : (Array.isArray(A) || ArrayBuffer.isView(A)) && await ch(A, e, a), e.push(`
endobj
`);
}
async function rg(t, A, e) {
  A.push("<<");
  for (const i of t.getKeys())
    A.push(` /${zo(i)} `), await Ch(t.getRaw(i), A, e);
  A.push(">>");
}
async function Ih(t, A, e) {
  let i = t.getBytes();
  const { dict: a } = t, [s, r] = await Promise.all([a.getAsync("Filter"), a.getAsync("DecodeParms")]), n = it(Array.isArray(s) ? await a.xref.fetchIfRefAsync(s[0]) : s, "FlateDecode");
  if (i.length >= 256 || n) try {
    const o = new CompressionStream("deflate"), I = o.writable.getWriter();
    await I.ready, I.write(i).then(async () => {
      await I.ready, await I.close();
    }).catch(() => {
    });
    const C = await new Response(o.readable).arrayBuffer();
    i = new Uint8Array(C);
    let h, c;
    s ? n || (h = Array.isArray(s) ? [T.get("FlateDecode"), ...s] : [T.get("FlateDecode"), s], r && (c = Array.isArray(r) ? [null, ...r] : [null, r])) : h = T.get("FlateDecode"), h && a.set("Filter", h), c && a.set("DecodeParms", c);
  } catch (o) {
    RA(`writeStream - cannot compress data: "${o}".`);
  }
  let g = Mt(i);
  e && (g = e.encryptString(g)), a.set("Length", g.length), await rg(a, A, e), A.push(` stream
`, g, `
endstream`);
}
async function ch(t, A, e) {
  A.push("[");
  let i = !0;
  for (const a of t)
    i ? i = !1 : A.push(" "), await Ch(a, A, e);
  A.push("]");
}
async function Ch(t, A, e) {
  t instanceof T ? A.push(`/${zo(t.name)}`) : t instanceof rA ? A.push(`${t.num} ${t.gen} R`) : Array.isArray(t) || ArrayBuffer.isView(t) ? await ch(t, A, e) : typeof t == "string" ? (e && (t = e.encryptString(t)), A.push(`(${Ga(t)})`)) : typeof t == "number" ? A.push(vA(t)) : typeof t == "boolean" ? A.push(t.toString()) : t instanceof U ? await rg(t, A, e) : t instanceof FA ? await Ih(t, A, e) : t === null ? A.push("null") : G(`Unhandled value in writer: ${typeof t}, please file a bug.`);
}
function Hg(t, A, e, i) {
  for (let a = A + e - 1; a > e - 1; a--)
    i[a] = 255 & t, t >>= 8;
  return e + A;
}
function hh(t, A, e) {
  for (let i = 0, a = t.length; i < a; i++) e[A + i] = 255 & t.charCodeAt(i);
}
function I5({ xfaData: t, xfaDatasetsRef: A, changes: e, xref: i }) {
  t === null && (t = function(r, n) {
    const g = new jr({ hasAttributes: !0 }).parseFromString(r);
    for (const { xfa: I } of n) {
      if (!I) continue;
      const { path: C, value: h } = I;
      if (!C) continue;
      const c = f1(C);
      let B = g.documentElement.searchNode(c, 0);
      !B && c.length > 1 && (B = g.documentElement.searchNode([c.at(-1)], 0)), B ? B.childNodes = Array.isArray(h) ? h.map((l) => new Bs("value", l)) : [new Bs("#text", h)] : G(`Node not found for path: ${C}`);
    }
    const o = [];
    return g.documentElement.dump(o), o.join("");
  }(i.fetchIfRef(A).getString(), e));
  const a = new Ht(t);
  a.dict = new U(i), a.dict.set("Type", T.get("EmbeddedFile")), e.put(A, { data: a });
}
function k0(t) {
  const A = [];
  for (const { ref: e } of t) e.num === A.at(-2) + A.at(-1) ? A[A.length - 1] += 1 : A.push(e.num, 1);
  return A;
}
function F0(t, A, e) {
  if (Array.isArray(A.fileIds) && A.fileIds.length > 0) {
    const i = function(s, r) {
      const n = Math.floor(Date.now() / 1e3), g = r.filename || "", o = [n.toString(), g, s.toString()];
      let I = o.reduce((c, B) => c + B.length, 0);
      for (const c of Object.values(r.info))
        o.push(c), I += c.length;
      const C = new Uint8Array(I);
      let h = 0;
      for (const c of o)
        hh(c, h, C), h += c.length;
      return Mt(ii(C));
    }(t, A);
    e.set("ID", [A.fileIds[0], i]);
  }
}
async function c5({ originalData: t, xrefInfo: A, changes: e, xref: i = null, hasXfa: a = !1, xfaDatasetsRef: s = null, hasXfaDatasetsEntry: r = !1, needAppearances: n, acroFormRef: g = null, acroForm: o = null, xfaData: I = null, useXrefStream: C = !1 }) {
  await async function({ xref: p, acroForm: m, acroFormRef: y, hasXfa: b, hasXfaDatasetsEntry: D, xfaDatasetsRef: R, needAppearances: k, changes: Y }) {
    if (!b || D || R || G("XFA - Cannot save it"), !k && (!b || !R || D)) return;
    const V = m.clone();
    if (b && !D) {
      const eA = m.get("XFA").slice();
      eA.splice(2, 0, "datasets"), eA.splice(3, 0, R), V.set("XFA", eA);
    }
    k && V.set("NeedAppearances", !0), Y.put(y, { data: V });
  }({ xref: i, acroForm: o, acroFormRef: g, hasXfa: a, hasXfaDatasetsEntry: r, xfaDatasetsRef: s, needAppearances: n, changes: e }), a && I5({ xfaData: I, xfaDatasetsRef: s, changes: e, xref: i });
  const h = function(p, m, y) {
    const b = new U(null);
    b.set("Prev", p.startXRef);
    const D = p.newRef;
    return y ? (m.put(D, { data: "" }), b.set("Size", D.num + 1), b.set("Type", T.get("XRef"))) : b.set("Size", D.num), p.rootRef !== null && b.set("Root", p.rootRef), p.infoRef !== null && b.set("Info", p.infoRef), p.encryptRef !== null && b.set("Encrypt", p.encryptRef), b;
  }(A, e, C), c = [], B = await async function(p, m, y = []) {
    const b = [];
    for (const [D, { data: R }] of p.items()) R !== null && typeof R != "string" ? (await b0(D, R, y, m), b.push({ ref: D, data: y.join("") }), y.length = 0) : b.push({ ref: D, data: R });
    return b.sort((D, R) => D.ref.num - R.ref.num);
  }(e, i, c);
  let l = t.length;
  const Q = t.at(-1);
  Q !== 10 && Q !== 13 && (c.push(`
`), l += 1);
  for (const { data: d } of B) d !== null && c.push(d);
  await (C ? async function(p, m, y, b, D) {
    const R = [];
    let k = 0, Y = 0;
    for (const { ref: v, data: W } of y) {
      let K;
      k = Math.max(k, m), W !== null ? (K = Math.min(v.gen, 65535), R.push([1, m, K]), m += W.length) : (K = Math.min(v.gen + 1, 65535), R.push([0, 0, K])), Y = Math.max(Y, K);
    }
    b.set("Index", k0(y));
    const V = [1, $I(k), $I(Y)];
    b.set("W", V), F0(m, p, b);
    const eA = V.reduce((v, W) => v + W, 0), AA = new Uint8Array(eA * R.length), O = new At(AA);
    O.dict = b;
    let L = 0;
    for (const [v, W, K] of R)
      L = Hg(v, V[0], L, AA), L = Hg(W, V[1], L, AA), L = Hg(K, V[2], L, AA);
    await b0(p.newRef, O, D, {}), D.push(`startxref
`, m.toString(), `
%%EOF
`);
  }(A, l, B, h, c) : async function(p, m, y, b, D) {
    D.push(`xref
`);
    const R = k0(y);
    let k = 0;
    for (const { ref: Y, data: V } of y)
      Y.num === R[k] && (D.push(`${R[k]} ${R[k + 1]}
`), k += 2), V !== null ? (D.push(`${m.toString().padStart(10, "0")} ${Math.min(Y.gen, 65535).toString().padStart(5, "0")} n\r
`), m += V.length) : D.push(`0000000000 ${Math.min(Y.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
    F0(m, p, b), D.push(`trailer
`), await rg(b, D), D.push(`
startxref
`, m.toString(), `
%%EOF
`);
  }(A, l, B, h, c));
  const E = c.reduce((d, p) => d + p.length, t.length), u = new Uint8Array(E);
  u.set(t);
  let f = t.length;
  for (const d of c)
    hh(d, f, u), f += d.length;
  return u;
}
const S0 = 1, R0 = 2, G0 = 1, Yg = 2, N0 = 3, x0 = 4, U0 = 5, M0 = 6, xn = 7, vg = 8;
function L0() {
}
function _t(t) {
  switch (t instanceof Error || typeof t == "object" && t !== null || xA('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), t.name) {
    case "AbortException":
      return new pt(t.message);
    case "MissingPDFException":
      return new I1(t.message);
    case "PasswordException":
      return new cr(t.message, t.code);
    case "UnexpectedResponseException":
      return new c1(t.message, t.status);
    case "UnknownErrorException":
      return new Cr(t.message, t.details);
    default:
      return new Cr(t.message, t.toString());
  }
}
var Sa, se, Bh, lh, Qh, Ar;
class J0 {
  constructor(A, e, i) {
    MA(this, se);
    MA(this, Sa, new AbortController());
    this.sourceName = A, this.targetName = e, this.comObj = i, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i.addEventListener("message", CA(this, se, Bh).bind(this), { signal: NA(this, Sa).signal });
  }
  on(A, e) {
    const i = this.actionHandler;
    if (i[A]) throw new Error(`There is already an actionName called "${A}"`);
    i[A] = e;
  }
  send(A, e, i) {
    this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: A, data: e }, i);
  }
  sendWithPromise(A, e, i) {
    const a = this.callbackId++, s = Promise.withResolvers();
    this.callbackCapabilities[a] = s;
    try {
      this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: A, callbackId: a, data: e }, i);
    } catch (r) {
      s.reject(r);
    }
    return s.promise;
  }
  sendWithStream(A, e, i, a) {
    const s = this.streamId++, r = this.sourceName, n = this.targetName, g = this.comObj;
    return new ReadableStream({ start: (o) => {
      const I = Promise.withResolvers();
      return this.streamControllers[s] = { controller: o, startCall: I, pullCall: null, cancelCall: null, isClosed: !1 }, g.postMessage({ sourceName: r, targetName: n, action: A, streamId: s, data: e, desiredSize: o.desiredSize }, a), I.promise;
    }, pull: (o) => {
      const I = Promise.withResolvers();
      return this.streamControllers[s].pullCall = I, g.postMessage({ sourceName: r, targetName: n, stream: M0, streamId: s, desiredSize: o.desiredSize }), I.promise;
    }, cancel: (o) => {
      Rt(o instanceof Error, "cancel must have a valid reason");
      const I = Promise.withResolvers();
      return this.streamControllers[s].cancelCall = I, this.streamControllers[s].isClosed = !0, g.postMessage({ sourceName: r, targetName: n, stream: G0, streamId: s, reason: _t(o) }), I.promise;
    } }, i);
  }
  destroy() {
    var A;
    (A = NA(this, Sa)) == null || A.abort(), Vt(this, Sa, null);
  }
}
Sa = new WeakMap(), se = new WeakSet(), Bh = function({ data: A }) {
  if (A.targetName !== this.sourceName) return;
  if (A.stream) {
    CA(this, se, Qh).call(this, A);
    return;
  }
  if (A.callback) {
    const i = A.callbackId, a = this.callbackCapabilities[i];
    if (!a) throw new Error(`Cannot resolve callback ${i}`);
    if (delete this.callbackCapabilities[i], A.callback === S0) a.resolve(A.data);
    else {
      if (A.callback !== R0) throw new Error("Unexpected callback case");
      a.reject(_t(A.reason));
    }
    return;
  }
  const e = this.actionHandler[A.action];
  if (!e) throw new Error(`Unknown action from worker: ${A.action}`);
  if (A.callbackId) {
    const i = this.sourceName, a = A.sourceName, s = this.comObj;
    Promise.try(e, A.data).then(function(r) {
      s.postMessage({ sourceName: i, targetName: a, callback: S0, callbackId: A.callbackId, data: r });
    }, function(r) {
      s.postMessage({ sourceName: i, targetName: a, callback: R0, callbackId: A.callbackId, reason: _t(r) });
    });
  } else A.streamId ? CA(this, se, lh).call(this, A) : e(A.data);
}, lh = function(A) {
  const e = A.streamId, i = this.sourceName, a = A.sourceName, s = this.comObj, r = this, n = this.actionHandler[A.action], g = { enqueue(o, I = 1, C) {
    if (this.isCancelled) return;
    const h = this.desiredSize;
    this.desiredSize -= I, h > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), s.postMessage({ sourceName: i, targetName: a, stream: x0, streamId: e, chunk: o }, C);
  }, close() {
    this.isCancelled || (this.isCancelled = !0, s.postMessage({ sourceName: i, targetName: a, stream: N0, streamId: e }), delete r.streamSinks[e]);
  }, error(o) {
    Rt(o instanceof Error, "error must have a valid reason"), this.isCancelled || (this.isCancelled = !0, s.postMessage({ sourceName: i, targetName: a, stream: U0, streamId: e, reason: _t(o) }));
  }, sinkCapability: Promise.withResolvers(), onPull: null, onCancel: null, isCancelled: !1, desiredSize: A.desiredSize, ready: null };
  g.sinkCapability.resolve(), g.ready = g.sinkCapability.promise, this.streamSinks[e] = g, Promise.try(n, A.data, g).then(function() {
    s.postMessage({ sourceName: i, targetName: a, stream: vg, streamId: e, success: !0 });
  }, function(o) {
    s.postMessage({ sourceName: i, targetName: a, stream: vg, streamId: e, reason: _t(o) });
  });
}, Qh = function(A) {
  const e = A.streamId, i = this.sourceName, a = A.sourceName, s = this.comObj, r = this.streamControllers[e], n = this.streamSinks[e];
  switch (A.stream) {
    case vg:
      A.success ? r.startCall.resolve() : r.startCall.reject(_t(A.reason));
      break;
    case xn:
      A.success ? r.pullCall.resolve() : r.pullCall.reject(_t(A.reason));
      break;
    case M0:
      if (!n) {
        s.postMessage({ sourceName: i, targetName: a, stream: xn, streamId: e, success: !0 });
        break;
      }
      n.desiredSize <= 0 && A.desiredSize > 0 && n.sinkCapability.resolve(), n.desiredSize = A.desiredSize, Promise.try(n.onPull || L0).then(function() {
        s.postMessage({ sourceName: i, targetName: a, stream: xn, streamId: e, success: !0 });
      }, function(o) {
        s.postMessage({ sourceName: i, targetName: a, stream: xn, streamId: e, reason: _t(o) });
      });
      break;
    case x0:
      if (Rt(r, "enqueue should have stream controller"), r.isClosed) break;
      r.controller.enqueue(A.chunk);
      break;
    case N0:
      if (Rt(r, "close should have stream controller"), r.isClosed) break;
      r.isClosed = !0, r.controller.close(), CA(this, se, Ar).call(this, r, e);
      break;
    case U0:
      Rt(r, "error should have stream controller"), r.controller.error(_t(A.reason)), CA(this, se, Ar).call(this, r, e);
      break;
    case Yg:
      A.success ? r.cancelCall.resolve() : r.cancelCall.reject(_t(A.reason)), CA(this, se, Ar).call(this, r, e);
      break;
    case G0:
      if (!n) break;
      const g = _t(A.reason);
      Promise.try(n.onCancel || L0, g).then(function() {
        s.postMessage({ sourceName: i, targetName: a, stream: Yg, streamId: e, success: !0 });
      }, function(o) {
        s.postMessage({ sourceName: i, targetName: a, stream: Yg, streamId: e, reason: _t(o) });
      }), n.sinkCapability.reject(g), n.isCancelled = !0, delete this.streamSinks[e];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, Ar = async function(A, e) {
  var i, a, s;
  await Promise.allSettled([(i = A.startCall) == null ? void 0 : i.promise, (a = A.pullCall) == null ? void 0 : a.promise, (s = A.cancelCall) == null ? void 0 : s.promise]), delete this.streamControllers[e];
};
class C5 {
  constructor(A) {
    this._msgHandler = A, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  getFullReader() {
    return Rt(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new h5(this._msgHandler), this._fullRequestReader;
  }
  getRangeReader(A, e) {
    const i = new B5(A, e, this._msgHandler);
    return this._rangeRequestReaders.push(i), i;
  }
  cancelAllRequests(A) {
    var e;
    (e = this._fullRequestReader) == null || e.cancel(A);
    for (const i of this._rangeRequestReaders.slice(0)) i.cancel(A);
  }
}
class h5 {
  constructor(A) {
    this._msgHandler = A, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
    const e = this._msgHandler.sendWithStream("GetReader");
    this._reader = e.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((i) => {
      this._isStreamingSupported = i.isStreamingSupported, this._isRangeSupported = i.isRangeSupported, this._contentLength = i.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const { value: A, done: e } = await this._reader.read();
    return e ? { value: void 0, done: !0 } : { value: A.buffer, done: !1 };
  }
  cancel(A) {
    this._reader.cancel(A);
  }
}
class B5 {
  constructor(A, e, i) {
    this._msgHandler = i, this.onProgress = null;
    const a = this._msgHandler.sendWithStream("GetRangeReader", { begin: A, end: e });
    this._reader = a.getReader();
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    const { value: A, done: e } = await this._reader.read();
    return e ? { value: void 0, done: !0 } : { value: A.buffer, done: !1 };
  }
  cancel(A) {
    this._reader.cancel(A);
  }
}
class ki {
  constructor(A) {
    this.name = A, this.terminated = !1, this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = !0;
  }
  ensureNotTerminated() {
    if (this.terminated) throw new Error("Worker task was terminated");
  }
}
const SI = class SI {
  static setup(A, e) {
    let i = !1;
    A.on("test", (a) => {
      i || (i = !0, A.send("test", a instanceof Uint8Array));
    }), A.on("configure", (a) => {
      (function(r) {
        Number.isInteger(r) && (Pr = r);
      })(a.verbosity);
    }), A.on("GetDocRequest", (a) => this.createDocumentHandler(a, e));
  }
  static createDocumentHandler(A, e) {
    let i, a = !1, s = null;
    const r = /* @__PURE__ */ new Set(), n = HB(), { docId: g, apiVersion: o } = A, I = "4.9.155";
    if (o !== I) throw new Error(`The API version "${o}" does not match the Worker version "${I}".`);
    const C = [];
    for (const f in []) C.push(f);
    if (C.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    const h = g + "_worker";
    let c = new J0(h, g, e);
    function B() {
      if (a) throw new Error("Worker was terminated");
    }
    function l(f) {
      r.add(f);
    }
    function Q(f) {
      f.finish(), r.delete(f);
    }
    async function E(f) {
      await i.ensureDoc("checkHeader"), await i.ensureDoc("parseStartXRef"), await i.ensureDoc("parse", [f]), await i.ensureDoc("checkFirstPage", [f]), await i.ensureDoc("checkLastPage", [f]);
      const d = await i.ensureDoc("isPureXfa");
      if (d) {
        const y = new ki("loadXfaFonts");
        l(y), await Promise.all([i.loadXfaFonts(c, y).catch((b) => {
        }).then(() => Q(y)), i.loadXfaImages()]);
      }
      const [p, m] = await Promise.all([i.ensureDoc("numPages"), i.ensureDoc("fingerprints")]);
      return { numPages: p, fingerprints: m, htmlForXfa: d ? await i.ensureDoc("htmlForXfa") : null };
    }
    function u(f) {
      function d(y) {
        B(), c.send("GetDoc", { pdfInfo: y });
      }
      function p(y) {
        if (B(), y instanceof cr) {
          const b = new ki(`PasswordException: response ${y.code}`);
          l(b), c.sendWithPromise("PasswordRequest", y).then(function({ password: D }) {
            Q(b), i.updatePassword(D), m();
          }).catch(function() {
            Q(b), c.send("DocException", y);
          });
        } else y instanceof hr || y instanceof I1 || y instanceof c1 || y instanceof Cr ? c.send("DocException", y) : c.send("DocException", new Cr(y.message, y.toString()));
      }
      function m() {
        B(), E(!1).then(d, function(y) {
          B(), y instanceof fa ? i.requestLoadedStream().then(function() {
            B(), E(!0).then(d, p);
          }) : p(y);
        });
      }
      B(), async function({ data: b, password: D, disableAutoFetch: R, rangeChunkSize: k, length: Y, docBaseUrl: V, enableXfa: eA, evaluatorOptions: AA }) {
        const O = { source: null, disableAutoFetch: R, docBaseUrl: V, docId: g, enableXfa: eA, evaluatorOptions: AA, handler: c, length: Y, password: D, rangeChunkSize: k };
        if (b)
          return O.source = b, new D0(O);
        const L = new C5(c), v = L.getFullReader(), W = Promise.withResolvers();
        let K, q = [], N = 0;
        return v.headersReady.then(function() {
          if (v.isRangeSupported) {
            O.source = L, O.length = v.contentLength, O.disableAutoFetch || (O.disableAutoFetch = v.isStreamingSupported), K = new o5(O);
            for (const F of q) K.sendProgressiveData(F);
            q = [], W.resolve(K), s = null;
          }
        }).catch(function(F) {
          W.reject(F), s = null;
        }), new Promise(function(F, w) {
          const x = function({ value: J, done: M }) {
            try {
              if (B(), M) {
                if (!K) {
                  const H = d1(q);
                  q = [], Y && H.length !== Y && G("reported HTTP length is different from actual"), O.source = H, K = new D0(O), W.resolve(K);
                }
                s = null;
                return;
              }
              N += J.byteLength, v.isStreamingSupported || c.send("DocProgress", { loaded: N, total: Math.max(N, v.contentLength || 0) }), K ? K.sendProgressiveData(J) : q.push(J), v.read().then(x, w);
            } catch (H) {
              w(H);
            }
          };
          v.read().then(x, w);
        }).catch(function(F) {
          W.reject(F), s = null;
        }), s = (F) => {
          L.cancelAllRequests(F);
        }, W.promise;
      }(f).then(function(y) {
        if (a)
          throw y.terminate(new pt("Worker was terminated.")), new Error("Worker was terminated");
        i = y, i.requestLoadedStream(!0).then((b) => {
          c.send("DataLoaded", { length: b.bytes.byteLength });
        });
      }).then(m, p);
    }
    return c.on("GetPage", function(f) {
      return i.getPage(f.pageIndex).then(function(d) {
        return Promise.all([i.ensure(d, "rotate"), i.ensure(d, "ref"), i.ensure(d, "userUnit"), i.ensure(d, "view")]).then(function([p, m, y, b]) {
          return { rotate: p, ref: m, refStr: (m == null ? void 0 : m.toString()) ?? null, userUnit: y, view: b };
        });
      });
    }), c.on("GetPageIndex", function(f) {
      const d = rA.get(f.num, f.gen);
      return i.ensureCatalog("getPageIndex", [d]);
    }), c.on("GetDestinations", function(f) {
      return i.ensureCatalog("destinations");
    }), c.on("GetDestination", function(f) {
      return i.ensureCatalog("getDestination", [f.id]);
    }), c.on("GetPageLabels", function(f) {
      return i.ensureCatalog("pageLabels");
    }), c.on("GetPageLayout", function(f) {
      return i.ensureCatalog("pageLayout");
    }), c.on("GetPageMode", function(f) {
      return i.ensureCatalog("pageMode");
    }), c.on("GetViewerPreferences", function(f) {
      return i.ensureCatalog("viewerPreferences");
    }), c.on("GetOpenAction", function(f) {
      return i.ensureCatalog("openAction");
    }), c.on("GetAttachments", function(f) {
      return i.ensureCatalog("attachments");
    }), c.on("GetDocJSActions", function(f) {
      return i.ensureCatalog("jsActions");
    }), c.on("GetPageJSActions", function({ pageIndex: f }) {
      return i.getPage(f).then(function(d) {
        return i.ensure(d, "jsActions");
      });
    }), c.on("GetOutline", function(f) {
      return i.ensureCatalog("documentOutline");
    }), c.on("GetOptionalContentConfig", function(f) {
      return i.ensureCatalog("optionalContentConfig");
    }), c.on("GetPermissions", function(f) {
      return i.ensureCatalog("permissions");
    }), c.on("GetMetadata", function(f) {
      return Promise.all([i.ensureDoc("documentInfo"), i.ensureCatalog("metadata")]);
    }), c.on("GetMarkInfo", function(f) {
      return i.ensureCatalog("markInfo");
    }), c.on("GetData", function(f) {
      return i.requestLoadedStream().then(function(d) {
        return d.bytes;
      });
    }), c.on("GetAnnotations", function({ pageIndex: f, intent: d }) {
      return i.getPage(f).then(function(p) {
        const m = new ki(`GetAnnotations: page ${f}`);
        return l(m), p.getAnnotationsData(c, m, d).then((y) => (Q(m), y), (y) => {
          throw Q(m), y;
        });
      });
    }), c.on("GetFieldObjects", function(f) {
      return i.ensureDoc("fieldObjects").then((d) => (d == null ? void 0 : d.allFields) || null);
    }), c.on("HasJSActions", function(f) {
      return i.ensureDoc("hasJSActions");
    }), c.on("GetCalculationOrderIds", function(f) {
      return i.ensureDoc("calculationOrderIds");
    }), c.on("SaveDocument", async function({ isPureXfa: f, numPages: d, annotationStorage: p, filename: m }) {
      const y = [i.requestLoadedStream(), i.ensureCatalog("acroForm"), i.ensureCatalog("acroFormRef"), i.ensureDoc("startXRef"), i.ensureDoc("xref"), i.ensureDoc("linearization"), i.ensureCatalog("structTreeRoot")], b = new xt(), D = [], R = f ? null : m1(p), [k, Y, V, eA, AA, O, L] = await Promise.all(y), v = AA.trailer.getRaw("Root") || null;
      let W;
      if (R) {
        L ? await L.canUpdateStructTree({ pdfManager: i, xref: AA, newAnnotationsByPage: R }) && (W = L) : await Ns.canCreateStructureTree({ catalogRef: v, pdfManager: i, newAnnotationsByPage: R }) && (W = null);
        const M = ri.generateImages(p.values(), AA, i.evaluatorOptions.isOffscreenCanvasSupported), H = W === void 0 ? D : [];
        for (const [z, aA] of R) H.push(i.getPage(z).then((tA) => {
          const hA = new ki(`Save (editor): page ${z}`);
          return tA.saveNewAnnotations(c, hA, aA, M, b).finally(function() {
            Q(hA);
          });
        }));
        W === null ? D.push(Promise.all(H).then(async () => {
          await Ns.createStructureTree({ newAnnotationsByPage: R, xref: AA, catalogRef: v, pdfManager: i, changes: b });
        })) : W && D.push(Promise.all(H).then(async () => {
          await W.updateStructureTree({ newAnnotationsByPage: R, pdfManager: i, changes: b });
        }));
      }
      if (f) D.push(i.serializeXfaData(p));
      else for (let M = 0; M < d; M++) D.push(i.getPage(M).then(function(H) {
        const z = new ki(`Save: page ${M}`);
        return H.save(c, z, p, b).finally(function() {
          Q(z);
        });
      }));
      const K = await Promise.all(D);
      let q = null;
      if (f) {
        if (q = K[0], !q) return k.bytes;
      } else if (b.size === 0) return k.bytes;
      const N = V && Y instanceof U && b.values().some((M) => M.needAppearances), F = Y instanceof U && Y.get("XFA") || null;
      let w = null, x = !1;
      if (Array.isArray(F)) {
        for (let M = 0, H = F.length; M < H; M += 2) F[M] === "datasets" && (w = F[M + 1], x = !0);
        w === null && (w = AA.getNewTemporaryRef());
      } else F && G("Unsupported XFA type.");
      let J = /* @__PURE__ */ Object.create(null);
      if (AA.trailer) {
        const M = /* @__PURE__ */ Object.create(null), H = AA.trailer.get("Info") || null;
        if (H instanceof U) for (const [z, aA] of H) typeof aA == "string" && (M[z] = LA(aA));
        J = { rootRef: v, encryptRef: AA.trailer.getRaw("Encrypt") || null, newRef: AA.getNewTemporaryRef(), infoRef: AA.trailer.getRaw("Info") || null, info: M, fileIds: AA.trailer.get("ID") || null, startXRef: O ? eA : AA.lastXRefStreamPos ?? eA, filename: m };
      }
      return c5({ originalData: k.bytes, xrefInfo: J, changes: b, xref: AA, hasXfa: !!F, xfaDatasetsRef: w, hasXfaDatasetsEntry: x, needAppearances: N, acroFormRef: V, acroForm: Y, xfaData: q, useXrefStream: E1(AA.topDict, "XRef") }).finally(() => {
        AA.resetNewTemporaryRef();
      });
    }), c.on("GetOperatorList", function(f, d) {
      const p = f.pageIndex;
      i.getPage(p).then(function(m) {
        const y = new ki(`GetOperatorList: page ${p}`);
        l(y);
        const b = n >= fs.INFOS ? Date.now() : 0;
        m.getOperatorList({ handler: c, sink: d, task: y, intent: f.intent, cacheKey: f.cacheKey, annotationStorage: f.annotationStorage, modifiedIds: f.modifiedIds }).then(function(D) {
          Q(y), b && RA(`page=${p + 1} - getOperatorList: time=${Date.now() - b}ms, len=${D.length}`), d.close();
        }, function(D) {
          Q(y), y.terminated || d.error(D);
        });
      });
    }), c.on("GetTextContent", function(f, d) {
      const { pageIndex: p, includeMarkedContent: m, disableNormalization: y } = f;
      i.getPage(p).then(function(b) {
        const D = new ki("GetTextContent: page " + p);
        l(D);
        const R = n >= fs.INFOS ? Date.now() : 0;
        b.extractTextContent({ handler: c, task: D, sink: d, includeMarkedContent: m, disableNormalization: y }).then(function() {
          Q(D), R && RA(`page=${p + 1} - getTextContent: time=` + (Date.now() - R) + "ms"), d.close();
        }, function(k) {
          Q(D), D.terminated || d.error(k);
        });
      });
    }), c.on("GetStructTree", function(f) {
      return i.getPage(f.pageIndex).then(function(d) {
        return i.ensure(d, "getStructTree");
      });
    }), c.on("FontFallback", function(f) {
      return i.fontFallback(f.id, c);
    }), c.on("Cleanup", function(f) {
      return i.cleanup(!0);
    }), c.on("Terminate", function(f) {
      a = !0;
      const d = [];
      if (i) {
        i.terminate(new pt("Worker was terminated."));
        const p = i.cleanup();
        d.push(p), i = null;
      } else cI();
      s == null || s(new pt("Worker was terminated."));
      for (const p of r)
        d.push(p.finished), p.terminate();
      return Promise.all(d).then(function() {
        c.destroy(), c = null;
      });
    }), c.on("Ready", function(f) {
      u(A), A = null;
    }), h;
  }
  static initializeFromPort(A) {
    const e = new J0("worker", "main", A);
    this.setup(e, A), e.send("ready", null);
  }
};
typeof window > "u" && !ph && typeof self < "u" && typeof self.postMessage == "function" && "onmessage" in self && SI.initializeFromPort(self);
let Po = SI;
var Q5 = Y0.WorkerMessageHandler;
Promise.withResolvers ?? (Promise.withResolvers = function() {
  let t, A;
  return { promise: new Promise((i, a) => {
    t = i, A = a;
  }), resolve: t, reject: A };
});
export {
  Q5 as WorkerMessageHandler
};
