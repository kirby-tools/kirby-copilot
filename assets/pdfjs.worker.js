var Gh = Object.defineProperty;
var So = (e) => {
  throw TypeError(e);
};
var Nh = (e, A, t) => A in e ? Gh(e, A, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[A] = t;
var Me = (e, A, t) => Nh(e, typeof A != "symbol" ? A + "" : A, t), fr = (e, A, t) => A.has(e) || So("Cannot " + t);
var PA = (e, A, t) => (fr(e, A, "read from private field"), t ? t.call(e) : A.get(e)), ZA = (e, A, t) => A.has(e) ? So("Cannot add the same private member more than once") : A instanceof WeakSet ? A.add(e) : A.set(e, t), wt = (e, A, t, i) => (fr(e, A, "write to private field"), i ? i.call(e, t) : A.set(e, t), t), BA = (e, A, t) => (fr(e, A, "access private method"), t);
var Us = {};
Us.d = (e, A) => {
  for (var t in A)
    Us.o(A, t) && !Us.o(e, t) && Object.defineProperty(e, t, { enumerable: !0, get: A[t] });
};
Us.o = (e, A) => Object.prototype.hasOwnProperty.call(e, A);
var lc = globalThis.pdfjsWorker = {};
Us.d(lc, {
  WorkerMessageHandler: () => (
    /* reexport */
    Tg
  )
});
const Mh = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), Wt = [1, 0, 0, 1, 0, 0], o0 = [1e-3, 0, 0, 1e-3, 0, 0], Uh = 1e7, Qi = 1.35, xn = 0.35, Fo = xn / Qi, it = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, hc = "pdfjs_internal_editor_", wi = {
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, Ro = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, Cc = {
  FILL: 0,
  ADD_TO_PATH_FLAG: 4
}, Ue = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Je = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  WIDGET: 20
}, Or = {
  GROUP: "Group",
  REPLY: "R"
}, ke = {
  INVISIBLE: 1,
  HIDDEN: 2,
  PRINT: 4,
  NOROTATE: 16,
  NOVIEW: 32,
  LOCKED: 128,
  LOCKEDCONTENTS: 512
}, Pe = {
  READONLY: 1,
  REQUIRED: 2,
  MULTILINE: 4096,
  PASSWORD: 8192,
  RADIO: 32768,
  PUSHBUTTON: 65536,
  COMBO: 131072,
  FILESELECT: 1048576,
  MULTISELECT: 2097152,
  DONOTSCROLL: 8388608,
  COMB: 16777216
}, x0 = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, Bc = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
}, Lh = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
}, Hh = {
  O: "PageOpen",
  C: "PageClose"
}, Ps = {
  WARNINGS: 1,
  INFOS: 5
}, w = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93
}, Go = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let zn = Ps.WARNINGS;
function Jh(e) {
  Number.isInteger(e) && (zn = e);
}
function Yh() {
  return zn;
}
function vA(e) {
  zn >= Ps.INFOS && console.log(`Info: ${e}`);
}
function k(e) {
  zn >= Ps.WARNINGS && console.log(`Warning: ${e}`);
}
function WA(e) {
  throw new Error(e);
}
function _e(e, A) {
  e || WA(A);
}
function Kh(e) {
  switch (e == null ? void 0 : e.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function mn(e, A = null, t = null) {
  if (!e)
    return null;
  try {
    if (t && typeof e == "string") {
      if (t.addDefaultProtocol && e.startsWith("www.")) {
        const s = e.match(/\./g);
        (s == null ? void 0 : s.length) >= 2 && (e = `http://${e}`);
      }
      if (t.tryConvertEncoding)
        try {
          e = Vs(e);
        } catch {
        }
    }
    const i = A ? new URL(e, A) : new URL(e);
    if (Kh(i))
      return i;
  } catch {
  }
  return null;
}
function iA(e, A, t, i = !1) {
  return Object.defineProperty(e, A, {
    value: t,
    enumerable: !i,
    configurable: !0,
    writable: !1
  }), t;
}
const At = function() {
  function A(t, i) {
    this.message = t, this.name = i;
  }
  return A.prototype = new Error(), A.constructor = A, A;
}();
class Ws extends At {
  constructor(A, t) {
    super(A, "PasswordException"), this.code = t;
  }
}
class ur extends At {
  constructor(A, t) {
    super(A, "UnknownErrorException"), this.details = t;
  }
}
class Os extends At {
  constructor(A) {
    super(A, "InvalidPDFException");
  }
}
class No extends At {
  constructor(A) {
    super(A, "MissingPDFException");
  }
}
class Mo extends At {
  constructor(A, t) {
    super(A, "UnexpectedResponseException"), this.status = t;
  }
}
class v extends At {
  constructor(A) {
    super(A, "FormatError");
  }
}
class Te extends At {
  constructor(A) {
    super(A, "AbortException");
  }
}
function ct(e) {
  (typeof e != "object" || (e == null ? void 0 : e.length) === void 0) && WA("Invalid argument for bytesToString");
  const A = e.length, t = 8192;
  if (A < t)
    return String.fromCharCode.apply(null, e);
  const i = [];
  for (let s = 0; s < A; s += t) {
    const a = Math.min(s + t, A), n = e.subarray(s, a);
    i.push(String.fromCharCode.apply(null, n));
  }
  return i.join("");
}
function We(e) {
  typeof e != "string" && WA("Invalid argument for stringToBytes");
  const A = e.length, t = new Uint8Array(A);
  for (let i = 0; i < A; ++i)
    t[i] = e.charCodeAt(i) & 255;
  return t;
}
function qe(e) {
  return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255);
}
function Qc(e) {
  return Object.keys(e).length;
}
function vh() {
  const e = new Uint8Array(4);
  return e[0] = 1, new Uint32Array(e.buffer, 0, 1)[0] === 1;
}
function Th() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class ht {
  static get isLittleEndian() {
    return iA(this, "isLittleEndian", vh());
  }
  static get isEvalSupported() {
    return iA(this, "isEvalSupported", Th());
  }
  static get isOffscreenCanvasSupported() {
    return iA(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get isImageDecoderSupported() {
    return iA(this, "isImageDecoderSupported", typeof ImageDecoder < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? iA(this, "platform", {
      isMac: navigator.platform.includes("Mac"),
      isWindows: navigator.platform.includes("Win"),
      isFirefox: typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && navigator.userAgent.includes("Firefox")
    }) : iA(this, "platform", {
      isMac: !1,
      isWindows: !1,
      isFirefox: !1
    });
  }
  static get isCSSRoundSupported() {
    var A, t;
    return iA(this, "isCSSRoundSupported", (t = (A = globalThis.CSS) == null ? void 0 : A.supports) == null ? void 0 : t.call(A, "width: round(1.5px, 1px)"));
  }
}
const q0 = Array.from(Array(256).keys(), (e) => e.toString(16).padStart(2, "0"));
var di, nn, Vr;
class de {
  static makeHexColor(A, t, i) {
    return `#${q0[A]}${q0[t]}${q0[i]}`;
  }
  static scaleMinMax(A, t) {
    let i;
    A[0] ? (A[0] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= A[0], t[2] *= A[0], A[3] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= A[3], t[3] *= A[3]) : (i = t[0], t[0] = t[1], t[1] = i, i = t[2], t[2] = t[3], t[3] = i, A[1] < 0 && (i = t[1], t[1] = t[3], t[3] = i), t[1] *= A[1], t[3] *= A[1], A[2] < 0 && (i = t[0], t[0] = t[2], t[2] = i), t[0] *= A[2], t[2] *= A[2]), t[0] += A[4], t[1] += A[5], t[2] += A[4], t[3] += A[5];
  }
  static transform(A, t) {
    return [A[0] * t[0] + A[2] * t[1], A[1] * t[0] + A[3] * t[1], A[0] * t[2] + A[2] * t[3], A[1] * t[2] + A[3] * t[3], A[0] * t[4] + A[2] * t[5] + A[4], A[1] * t[4] + A[3] * t[5] + A[5]];
  }
  static applyTransform(A, t) {
    const i = A[0] * t[0] + A[1] * t[2] + t[4], s = A[0] * t[1] + A[1] * t[3] + t[5];
    return [i, s];
  }
  static applyInverseTransform(A, t) {
    const i = t[0] * t[3] - t[1] * t[2], s = (A[0] * t[3] - A[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / i, a = (-A[0] * t[1] + A[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / i;
    return [s, a];
  }
  static getAxialAlignedBoundingBox(A, t) {
    const i = this.applyTransform(A, t), s = this.applyTransform(A.slice(2, 4), t), a = this.applyTransform([A[0], A[3]], t), n = this.applyTransform([A[2], A[1]], t);
    return [Math.min(i[0], s[0], a[0], n[0]), Math.min(i[1], s[1], a[1], n[1]), Math.max(i[0], s[0], a[0], n[0]), Math.max(i[1], s[1], a[1], n[1])];
  }
  static inverseTransform(A) {
    const t = A[0] * A[3] - A[1] * A[2];
    return [A[3] / t, -A[1] / t, -A[2] / t, A[0] / t, (A[2] * A[5] - A[4] * A[3]) / t, (A[4] * A[1] - A[5] * A[0]) / t];
  }
  static singularValueDecompose2dScale(A) {
    const t = [A[0], A[2], A[1], A[3]], i = A[0] * t[0] + A[1] * t[2], s = A[0] * t[1] + A[1] * t[3], a = A[2] * t[0] + A[3] * t[2], n = A[2] * t[1] + A[3] * t[3], r = (i + n) / 2, g = Math.sqrt((i + n) ** 2 - 4 * (i * n - a * s)) / 2, o = r + g || 1, I = r - g || 1;
    return [Math.sqrt(o), Math.sqrt(I)];
  }
  static normalizeRect(A) {
    const t = A.slice(0);
    return A[0] > A[2] && (t[0] = A[2], t[2] = A[0]), A[1] > A[3] && (t[1] = A[3], t[3] = A[1]), t;
  }
  static intersect(A, t) {
    const i = Math.max(Math.min(A[0], A[2]), Math.min(t[0], t[2])), s = Math.min(Math.max(A[0], A[2]), Math.max(t[0], t[2]));
    if (i > s)
      return null;
    const a = Math.max(Math.min(A[1], A[3]), Math.min(t[1], t[3])), n = Math.min(Math.max(A[1], A[3]), Math.max(t[1], t[3]));
    return a > n ? null : [i, a, s, n];
  }
  static bezierBoundingBox(A, t, i, s, a, n, r, g, o) {
    return o ? (o[0] = Math.min(o[0], A, r), o[1] = Math.min(o[1], t, g), o[2] = Math.max(o[2], A, r), o[3] = Math.max(o[3], t, g)) : o = [Math.min(A, r), Math.min(t, g), Math.max(A, r), Math.max(t, g)], BA(this, di, Vr).call(this, A, i, a, r, t, s, n, g, 3 * (-A + 3 * (i - a) + r), 6 * (A - 2 * i + a), 3 * (i - A), o), BA(this, di, Vr).call(this, A, i, a, r, t, s, n, g, 3 * (-t + 3 * (s - n) + g), 6 * (t - 2 * s + n), 3 * (s - t), o), o;
  }
}
di = new WeakSet(), nn = function(A, t, i, s, a, n, r, g, o, I) {
  if (o <= 0 || o >= 1)
    return;
  const c = 1 - o, l = o * o, h = l * o, C = c * (c * (c * A + 3 * o * t) + 3 * l * i) + h * s, B = c * (c * (c * a + 3 * o * n) + 3 * l * r) + h * g;
  I[0] = Math.min(I[0], C), I[1] = Math.min(I[1], B), I[2] = Math.max(I[2], C), I[3] = Math.max(I[3], B);
}, Vr = function(A, t, i, s, a, n, r, g, o, I, c, l) {
  if (Math.abs(o) < 1e-12) {
    Math.abs(I) >= 1e-12 && BA(this, di, nn).call(this, A, t, i, s, a, n, r, g, -c / I, l);
    return;
  }
  const h = I ** 2 - 4 * c * o;
  if (h < 0)
    return;
  const C = Math.sqrt(h), B = 2 * o;
  BA(this, di, nn).call(this, A, t, i, s, a, n, r, g, (-I + C) / B, l), BA(this, di, nn).call(this, A, t, i, s, a, n, r, g, (-I - C) / B, l);
}, ZA(de, di);
const qh = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
function jA(e) {
  if (e[0] >= "ï") {
    let t;
    if (e[0] === "þ" && e[1] === "ÿ" ? (t = "utf-16be", e.length % 2 === 1 && (e = e.slice(0, -1))) : e[0] === "ÿ" && e[1] === "þ" ? (t = "utf-16le", e.length % 2 === 1 && (e = e.slice(0, -1))) : e[0] === "ï" && e[1] === "»" && e[2] === "¿" && (t = "utf-8"), t)
      try {
        const i = new TextDecoder(t, {
          fatal: !0
        }), s = We(e), a = i.decode(s);
        return a.includes("\x1B") ? a.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : a;
      } catch (i) {
        k(`stringToPDFString: "${i}".`);
      }
  }
  const A = [];
  for (let t = 0, i = e.length; t < i; t++) {
    const s = e.charCodeAt(t);
    if (s === 27) {
      for (; ++t < i && e.charCodeAt(t) !== 27; )
        ;
      continue;
    }
    const a = qh[s];
    A.push(a ? String.fromCharCode(a) : e.charAt(t));
  }
  return A.join("");
}
function Vs(e) {
  return decodeURIComponent(escape(e));
}
function Zr(e) {
  return unescape(encodeURIComponent(e));
}
function B0(e, A) {
  if (e.length !== A.length)
    return !1;
  for (let t = 0, i = e.length; t < i; t++)
    if (e[t] !== A[t])
      return !1;
  return !0;
}
function xi(e = /* @__PURE__ */ new Date()) {
  return [e.getUTCFullYear().toString(), (e.getUTCMonth() + 1).toString().padStart(2, "0"), e.getUTCDate().toString().padStart(2, "0"), e.getUTCHours().toString().padStart(2, "0"), e.getUTCMinutes().toString().padStart(2, "0"), e.getUTCSeconds().toString().padStart(2, "0")].join("");
}
let dr = null, Uo = null;
function Ph(e) {
  return dr || (dr = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Uo = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), e.replaceAll(dr, (A, t, i) => t ? t.normalize("NFKC") : Uo.get(i));
}
const Wh = "pdfjs_internal_id_";
function Lo(e) {
  return Uint8Array.prototype.toHex ? e.toHex() : Array.from(e, (A) => q0[A]).join("");
}
function Oh(e) {
  return Uint8Array.fromBase64 ? Uint8Array.fromBase64(e) : We(atob(e));
}
typeof Promise.try != "function" && (Promise.try = function(e, ...A) {
  return new Promise((t) => {
    t(e(...A));
  });
});
const Vh = Symbol("CIRCULAR_REF"), Le = Symbol("EOF");
let rn = /* @__PURE__ */ Object.create(null), gn = /* @__PURE__ */ Object.create(null), k0 = /* @__PURE__ */ Object.create(null);
function Zh() {
  rn = /* @__PURE__ */ Object.create(null), gn = /* @__PURE__ */ Object.create(null), k0 = /* @__PURE__ */ Object.create(null);
}
class L {
  constructor(A) {
    this.name = A;
  }
  static get(A) {
    return gn[A] || (gn[A] = new L(A));
  }
}
class be {
  constructor(A) {
    this.cmd = A;
  }
  static get(A) {
    return rn[A] || (rn[A] = new be(A));
  }
}
const Ec = function() {
  return Ec;
};
class R {
  constructor(A = null) {
    this._map = /* @__PURE__ */ new Map(), this.xref = A, this.objId = null, this.suppressEncryption = !1, this.__nonSerializable__ = Ec;
  }
  assignXref(A) {
    this.xref = A;
  }
  get size() {
    return this._map.size;
  }
  get(A, t, i) {
    let s = this._map.get(A);
    return s === void 0 && t !== void 0 && (s = this._map.get(t), s === void 0 && i !== void 0 && (s = this._map.get(i))), s instanceof nA && this.xref ? this.xref.fetch(s, this.suppressEncryption) : s;
  }
  async getAsync(A, t, i) {
    let s = this._map.get(A);
    return s === void 0 && t !== void 0 && (s = this._map.get(t), s === void 0 && i !== void 0 && (s = this._map.get(i))), s instanceof nA && this.xref ? this.xref.fetchAsync(s, this.suppressEncryption) : s;
  }
  getArray(A, t, i) {
    let s = this._map.get(A);
    if (s === void 0 && t !== void 0 && (s = this._map.get(t), s === void 0 && i !== void 0 && (s = this._map.get(i))), s instanceof nA && this.xref && (s = this.xref.fetch(s, this.suppressEncryption)), Array.isArray(s)) {
      s = s.slice();
      for (let a = 0, n = s.length; a < n; a++)
        s[a] instanceof nA && this.xref && (s[a] = this.xref.fetch(s[a], this.suppressEncryption));
    }
    return s;
  }
  getRaw(A) {
    return this._map.get(A);
  }
  getKeys() {
    return [...this._map.keys()];
  }
  getRawValues() {
    return [...this._map.values()];
  }
  set(A, t) {
    this._map.set(A, t);
  }
  has(A) {
    return this._map.has(A);
  }
  *[Symbol.iterator]() {
    for (const [A, t] of this._map)
      yield [A, t instanceof nA && this.xref ? this.xref.fetch(t, this.suppressEncryption) : t];
  }
  static get empty() {
    const A = new R(null);
    return A.set = (t, i) => {
      WA("Should not call `set` on the empty dictionary.");
    }, iA(this, "empty", A);
  }
  static merge({
    xref: A,
    dictArray: t,
    mergeSubDicts: i = !1
  }) {
    const s = new R(A), a = /* @__PURE__ */ new Map();
    for (const n of t)
      if (n instanceof R)
        for (const [r, g] of n._map) {
          let o = a.get(r);
          if (o === void 0)
            o = [], a.set(r, o);
          else if (!i || !(g instanceof R))
            continue;
          o.push(g);
        }
    for (const [n, r] of a) {
      if (r.length === 1 || !(r[0] instanceof R)) {
        s._map.set(n, r[0]);
        continue;
      }
      const g = new R(A);
      for (const o of r)
        for (const [I, c] of o._map)
          g._map.has(I) || g._map.set(I, c);
      g.size > 0 && s._map.set(n, g);
    }
    return a.clear(), s.size > 0 ? s : R.empty;
  }
  clone() {
    const A = new R(this.xref);
    for (const t of this.getKeys())
      A.set(t, this.getRaw(t));
    return A;
  }
  delete(A) {
    delete this._map[A];
  }
}
class nA {
  constructor(A, t) {
    this.num = A, this.gen = t;
  }
  toString() {
    return this.gen === 0 ? `${this.num}R` : `${this.num}R${this.gen}`;
  }
  static fromString(A) {
    const t = k0[A];
    if (t)
      return t;
    const i = /^(\d+)R(\d*)$/.exec(A);
    return !i || i[1] === "0" ? null : k0[A] = new nA(parseInt(i[1]), i[2] ? parseInt(i[2]) : 0);
  }
  static get(A, t) {
    const i = t === 0 ? `${A}R` : `${A}R${t}`;
    return k0[i] || (k0[i] = new nA(A, t));
  }
}
class Ne {
  constructor(A = null) {
    this._set = new Set(A == null ? void 0 : A._set);
  }
  has(A) {
    return this._set.has(A.toString());
  }
  put(A) {
    this._set.add(A.toString());
  }
  remove(A) {
    this._set.delete(A.toString());
  }
  [Symbol.iterator]() {
    return this._set.values();
  }
  clear() {
    this._set.clear();
  }
}
class ot {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._map.size;
  }
  get(A) {
    return this._map.get(A.toString());
  }
  has(A) {
    return this._map.has(A.toString());
  }
  put(A, t) {
    this._map.set(A.toString(), t);
  }
  putAlias(A, t) {
    this._map.set(A.toString(), this.get(t));
  }
  [Symbol.iterator]() {
    return this._map.values();
  }
  clear() {
    this._map.clear();
  }
  *values() {
    yield* this._map.values();
  }
  *items() {
    for (const [A, t] of this._map)
      yield [nA.fromString(A), t];
  }
}
function xe(e, A) {
  return e instanceof L && (A === void 0 || e.name === A);
}
function Ge(e, A) {
  return e instanceof be && (A === void 0 || e.cmd === A);
}
function fc(e, A) {
  return e instanceof R && (A === void 0 || xe(e.get("Type"), A));
}
function pn(e, A) {
  return e.num === A.num && e.gen === A.gen;
}
class JA {
  get length() {
    WA("Abstract getter `length` accessed");
  }
  get isEmpty() {
    WA("Abstract getter `isEmpty` accessed");
  }
  get isDataLoaded() {
    return iA(this, "isDataLoaded", !0);
  }
  getByte() {
    WA("Abstract method `getByte` called");
  }
  getBytes(A) {
    WA("Abstract method `getBytes` called");
  }
  async getImageData(A, t) {
    return this.getBytes(A, t);
  }
  async asyncGetBytes() {
    WA("Abstract method `asyncGetBytes` called");
  }
  get isAsync() {
    return !1;
  }
  get canAsyncDecodeImageFromBuffer() {
    return !1;
  }
  async getTransferableImage() {
    return null;
  }
  peekByte() {
    const A = this.getByte();
    return A !== -1 && this.pos--, A;
  }
  peekBytes(A) {
    const t = this.getBytes(A);
    return this.pos -= t.length, t;
  }
  getUint16() {
    const A = this.getByte(), t = this.getByte();
    return A === -1 || t === -1 ? -1 : (A << 8) + t;
  }
  getInt32() {
    const A = this.getByte(), t = this.getByte(), i = this.getByte(), s = this.getByte();
    return (A << 24) + (t << 16) + (i << 8) + s;
  }
  getByteRange(A, t) {
    WA("Abstract method `getByteRange` called");
  }
  getString(A) {
    return ct(this.getBytes(A));
  }
  skip(A) {
    this.pos += A || 1;
  }
  reset() {
    WA("Abstract method `reset` called");
  }
  moveStart() {
    WA("Abstract method `moveStart` called");
  }
  makeSubStream(A, t, i = null) {
    WA("Abstract method `makeSubStream` called");
  }
  getBaseStreams() {
    return null;
  }
}
const uc = /^[1-9]\.\d$/, jr = 2 ** 31 - 1, jh = -2147483648;
function le(e) {
  let A;
  return function() {
    return e && (A = /* @__PURE__ */ Object.create(null), e(A), e = null), A;
  };
}
class oe extends At {
  constructor(A, t) {
    super(`Missing data [${A}, ${t})`, "MissingDataException"), this.begin = A, this.end = t;
  }
}
class Xr extends At {
  constructor(A) {
    super(A, "ParserEOFException");
  }
}
class Hi extends At {
  constructor(A) {
    super(A, "XRefEntryException");
  }
}
class P0 extends At {
  constructor(A) {
    super(A, "XRefParseException");
  }
}
function dc(e) {
  const A = e.length;
  if (A === 0)
    return new Uint8Array(0);
  if (A === 1)
    return new Uint8Array(e[0]);
  let t = 0;
  for (let a = 0; a < A; a++)
    t += e[a].byteLength;
  const i = new Uint8Array(t);
  let s = 0;
  for (let a = 0; a < A; a++) {
    const n = new Uint8Array(e[a]);
    i.set(n, s), s += n.byteLength;
  }
  return i;
}
function Gt({
  dict: e,
  key: A,
  getArray: t = !1,
  stopWhenFound: i = !0
}) {
  let s;
  const a = new Ne();
  for (; e instanceof R && !(e.objId && a.has(e.objId)); ) {
    e.objId && a.put(e.objId);
    const n = t ? e.getArray(A) : e.get(A);
    if (n !== void 0) {
      if (i)
        return n;
      (s || (s = [])).push(n);
    }
    e = e.get("Parent");
  }
  return s;
}
function Xh(e, A, t) {
  const i = new Ne(), s = e, a = {
    dict: null,
    ref: null
  };
  for (; e instanceof R && !i.has(A) && (i.put(A), !e.has("T")); ) {
    if (A = e.getRaw("Parent"), !(A instanceof nA))
      return a;
    e = t.fetch(A);
  }
  return e instanceof R && e !== s && (a.dict = e, a.ref = A), a;
}
const xr = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
function _h(e, A = !1) {
  _e(Number.isInteger(e) && e > 0, "The number should be a positive integer.");
  const t = "M".repeat(e / 1e3 | 0) + xr[e % 1e3 / 100 | 0] + xr[10 + (e % 100 / 10 | 0)] + xr[20 + e % 10];
  return A ? t.toLowerCase() : t;
}
function qg(e) {
  return e > 0 ? Math.ceil(Math.log2(e)) : 0;
}
function bi(e, A) {
  return e[A] << 24 >> 24;
}
function Ie(e, A) {
  return e[A] << 8 | e[A + 1];
}
function ce(e, A) {
  return (e[A] << 24 | e[A + 1] << 16 | e[A + 2] << 8 | e[A + 3]) >>> 0;
}
function mt(e) {
  return e === 32 || e === 9 || e === 13 || e === 10;
}
function zh(e, A) {
  return Array.isArray(e) && e.length === A && e.every((t) => typeof t == "boolean");
}
function at(e, A) {
  return Array.isArray(e) ? (A === null || e.length === A) && e.every((t) => typeof t == "number") : ArrayBuffer.isView(e) && (e.length === 0 || typeof e[0] == "number") && (A === null || e.length === A);
}
function Ji(e, A) {
  return at(e, 6) ? e : A;
}
function _r(e, A) {
  return at(e, 4) ? e : A;
}
function ii(e, A) {
  return at(e, 4) ? de.normalizeRect(e) : A;
}
function xc(e) {
  const A = /(.+)\[(\d+)\]$/;
  return e.split(".").map((t) => {
    const i = t.match(A);
    return i ? {
      name: i[1],
      pos: parseInt(i[2], 10)
    } : {
      name: t,
      pos: 0
    };
  });
}
function Pg(e) {
  const A = [];
  let t = 0;
  for (let i = 0, s = e.length; i < s; i++) {
    const a = e.charCodeAt(i);
    (a < 33 || a > 126 || a === 35 || a === 40 || a === 41 || a === 60 || a === 62 || a === 91 || a === 93 || a === 123 || a === 125 || a === 47 || a === 37) && (t < i && A.push(e.substring(t, i)), A.push(`#${a.toString(16)}`), t = i + 1);
  }
  return A.length === 0 ? e : (t < e.length && A.push(e.substring(t, e.length)), A.join(""));
}
function es(e) {
  return e.replaceAll(/([()\\\n\r])/g, (A) => A === `
` ? "\\n" : A === "\r" ? "\\r" : `\\${A}`);
}
function yn(e, A, t, i) {
  if (!e)
    return;
  let s = null;
  if (e instanceof nA) {
    if (i.has(e))
      return;
    s = e, i.put(s), e = A.fetch(e);
  }
  if (Array.isArray(e))
    for (const a of e)
      yn(a, A, t, i);
  else if (e instanceof R) {
    if (xe(e.get("S"), "JavaScript")) {
      const a = e.get("JS");
      let n;
      a instanceof JA ? n = a.getString() : typeof a == "string" && (n = a), n && (n = jA(n).replaceAll("\0", "")), n && t.push(n);
    }
    yn(e.getRaw("Next"), A, t, i);
  }
  s && i.remove(s);
}
function $n(e, A, t) {
  const i = /* @__PURE__ */ Object.create(null), s = Gt({
    dict: A,
    key: "AA",
    stopWhenFound: !1
  });
  if (s)
    for (let a = s.length - 1; a >= 0; a--) {
      const n = s[a];
      if (n instanceof R)
        for (const r of n.getKeys()) {
          const g = t[r];
          if (!g)
            continue;
          const o = n.getRaw(r), I = new Ne(), c = [];
          yn(o, e, c, I), c.length > 0 && (i[g] = c);
        }
    }
  if (A.has("A")) {
    const a = A.get("A"), n = new Ne(), r = [];
    yn(a, e, r, n), r.length > 0 && (i.Action = r);
  }
  return Qc(i) > 0 ? i : null;
}
const $h = {
  60: "&lt;",
  62: "&gt;",
  38: "&amp;",
  34: "&quot;",
  39: "&apos;"
};
function* AC(e) {
  for (let A = 0, t = e.length; A < t; A++) {
    const i = e.codePointAt(A);
    i > 55295 && (i < 57344 || i > 65533) && A++, yield i;
  }
}
function W0(e) {
  const A = [];
  let t = 0;
  for (let i = 0, s = e.length; i < s; i++) {
    const a = e.codePointAt(i);
    if (32 <= a && a <= 126) {
      const n = $h[a];
      n && (t < i && A.push(e.substring(t, i)), A.push(n), t = i + 1);
    } else
      t < i && A.push(e.substring(t, i)), A.push(`&#x${a.toString(16).toUpperCase()};`), a > 55295 && (a < 57344 || a > 65533) && i++, t = i + 1;
  }
  return A.length === 0 ? e : (t < e.length && A.push(e.substring(t, e.length)), A.join(""));
}
function zr(e, A = !1) {
  const t = /^("|').*("|')$/.exec(e);
  if (t && t[1] === t[2]) {
    if (new RegExp(`[^\\\\]${t[1]}`).test(e.slice(1, -1)))
      return A && k(`FontFamily contains unescaped ${t[1]}: ${e}.`), !1;
  } else
    for (const i of e.split(/[ \t]+/))
      if (/^(\d|(-(\d|-)))/.test(i) || !/^[\w-\\]+$/.test(i))
        return A && k(`FontFamily contains invalid <custom-ident>: ${e}.`), !1;
  return !0;
}
function eC(e) {
  const A = "14", t = "400", i = /* @__PURE__ */ new Set(["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "normal", "bold", "bolder", "lighter"]), {
    fontFamily: s,
    fontWeight: a,
    italicAngle: n
  } = e;
  if (!zr(s, !0))
    return !1;
  const r = a ? a.toString() : "";
  e.fontWeight = i.has(r) ? r : t;
  const g = parseFloat(n);
  return e.italicAngle = isNaN(g) || g < -90 || g > 90 ? A : n.toString(), !0;
}
function mc(e) {
  const A = ["app.launchURL", "window.open", "xfa.host.gotoURL"], i = new RegExp("^\\s*(" + A.join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e);
  return i != null && i[2] ? {
    url: i[2],
    newWindow: i[1] === "app.launchURL" && i[3] === "true"
  } : null;
}
function $A(e) {
  if (Number.isInteger(e))
    return e.toString();
  const A = Math.round(e * 100);
  return A % 100 === 0 ? (A / 100).toString() : A % 10 === 0 ? e.toFixed(1) : e.toFixed(2);
}
function pc(e) {
  if (!e)
    return null;
  const A = /* @__PURE__ */ new Map();
  for (const [t, i] of e) {
    if (!t.startsWith(hc))
      continue;
    let s = A.get(i.pageIndex);
    s || (s = [], A.set(i.pageIndex, s)), s.push(i);
  }
  return A.size > 0 ? A : null;
}
function Nt(e) {
  return tC(e) ? e : yc(e, !0);
}
function tC(e) {
  return /^[\x00-\x7F]*$/.test(e);
}
function iC(e) {
  const A = [];
  for (let t = 0, i = e.length; t < i; t++) {
    const s = e.charCodeAt(t);
    A.push(q0[s >> 8 & 255], q0[s & 255]);
  }
  return A.join("");
}
function yc(e, A = !1) {
  const t = [];
  A && t.push("þÿ");
  for (let i = 0, s = e.length; i < s; i++) {
    const a = e.charCodeAt(i);
    t.push(String.fromCharCode(a >> 8 & 255), String.fromCharCode(a & 255));
  }
  return t.join("");
}
function wn(e, A, t) {
  switch (e) {
    case 90:
      return [0, 1, -1, 0, A, 0];
    case 180:
      return [-1, 0, 0, -1, A, t];
    case 270:
      return [0, -1, 1, 0, 0, t];
    default:
      throw new Error("Invalid rotation");
  }
}
function Ho(e) {
  return Math.ceil(Math.ceil(Math.log2(1 + e)) / 8);
}
class Qe extends JA {
  constructor(A, t, i, s) {
    super(), this.bytes = A instanceof Uint8Array ? A : new Uint8Array(A), this.start = t || 0, this.pos = this.start, this.end = t + i || this.bytes.length, this.dict = s;
  }
  get length() {
    return this.end - this.start;
  }
  get isEmpty() {
    return this.length === 0;
  }
  getByte() {
    return this.pos >= this.end ? -1 : this.bytes[this.pos++];
  }
  getBytes(A) {
    const t = this.bytes, i = this.pos, s = this.end;
    if (!A)
      return t.subarray(i, s);
    let a = i + A;
    return a > s && (a = s), this.pos = a, t.subarray(i, a);
  }
  getByteRange(A, t) {
    return A < 0 && (A = 0), t > this.end && (t = this.end), this.bytes.subarray(A, t);
  }
  reset() {
    this.pos = this.start;
  }
  moveStart() {
    this.start = this.pos;
  }
  makeSubStream(A, t, i = null) {
    return new Qe(this.bytes.buffer, A, t, i);
  }
}
class Ct extends Qe {
  constructor(A) {
    super(We(A));
  }
}
class $r extends Qe {
  constructor() {
    super(new Uint8Array(0));
  }
}
class sC extends Qe {
  constructor(A, t, i) {
    super(new Uint8Array(A), 0, A, null), this.chunkSize = t, this._loadedChunks = /* @__PURE__ */ new Set(), this.numChunks = Math.ceil(A / t), this.manager = i, this.progressiveDataLength = 0, this.lastSuccessfulEnsureByteChunk = -1;
  }
  getMissingChunks() {
    const A = [];
    for (let t = 0, i = this.numChunks; t < i; ++t)
      this._loadedChunks.has(t) || A.push(t);
    return A;
  }
  get numChunksLoaded() {
    return this._loadedChunks.size;
  }
  get isDataLoaded() {
    return this.numChunksLoaded === this.numChunks;
  }
  onReceiveData(A, t) {
    const i = this.chunkSize;
    if (A % i !== 0)
      throw new Error(`Bad begin offset: ${A}`);
    const s = A + t.byteLength;
    if (s % i !== 0 && s !== this.bytes.length)
      throw new Error(`Bad end offset: ${s}`);
    this.bytes.set(new Uint8Array(t), A);
    const a = Math.floor(A / i), n = Math.floor((s - 1) / i) + 1;
    for (let r = a; r < n; ++r)
      this._loadedChunks.add(r);
  }
  onReceiveProgressiveData(A) {
    let t = this.progressiveDataLength;
    const i = Math.floor(t / this.chunkSize);
    this.bytes.set(new Uint8Array(A), t), t += A.byteLength, this.progressiveDataLength = t;
    const s = t >= this.end ? this.numChunks : Math.floor(t / this.chunkSize);
    for (let a = i; a < s; ++a)
      this._loadedChunks.add(a);
  }
  ensureByte(A) {
    if (A < this.progressiveDataLength)
      return;
    const t = Math.floor(A / this.chunkSize);
    if (!(t > this.numChunks) && t !== this.lastSuccessfulEnsureByteChunk) {
      if (!this._loadedChunks.has(t))
        throw new oe(A, A + 1);
      this.lastSuccessfulEnsureByteChunk = t;
    }
  }
  ensureRange(A, t) {
    if (A >= t || t <= this.progressiveDataLength)
      return;
    const i = Math.floor(A / this.chunkSize);
    if (i > this.numChunks)
      return;
    const s = Math.min(Math.floor((t - 1) / this.chunkSize) + 1, this.numChunks);
    for (let a = i; a < s; ++a)
      if (!this._loadedChunks.has(a))
        throw new oe(A, t);
  }
  nextEmptyChunk(A) {
    const t = this.numChunks;
    for (let i = 0; i < t; ++i) {
      const s = (A + i) % t;
      if (!this._loadedChunks.has(s))
        return s;
    }
    return null;
  }
  hasChunk(A) {
    return this._loadedChunks.has(A);
  }
  getByte() {
    const A = this.pos;
    return A >= this.end ? -1 : (A >= this.progressiveDataLength && this.ensureByte(A), this.bytes[this.pos++]);
  }
  getBytes(A) {
    const t = this.bytes, i = this.pos, s = this.end;
    if (!A)
      return s > this.progressiveDataLength && this.ensureRange(i, s), t.subarray(i, s);
    let a = i + A;
    return a > s && (a = s), a > this.progressiveDataLength && this.ensureRange(i, a), this.pos = a, t.subarray(i, a);
  }
  getByteRange(A, t) {
    return A < 0 && (A = 0), t > this.end && (t = this.end), t > this.progressiveDataLength && this.ensureRange(A, t), this.bytes.subarray(A, t);
  }
  makeSubStream(A, t, i = null) {
    t ? A + t > this.progressiveDataLength && this.ensureRange(A, A + t) : A >= this.progressiveDataLength && this.ensureByte(A);
    function s() {
    }
    s.prototype = Object.create(this), s.prototype.getMissingChunks = function() {
      const n = this.chunkSize, r = Math.floor(this.start / n), g = Math.floor((this.end - 1) / n) + 1, o = [];
      for (let I = r; I < g; ++I)
        this._loadedChunks.has(I) || o.push(I);
      return o;
    }, Object.defineProperty(s.prototype, "isDataLoaded", {
      get() {
        return this.numChunksLoaded === this.numChunks ? !0 : this.getMissingChunks().length === 0;
      },
      configurable: !0
    });
    const a = new s();
    return a.pos = a.start = A, a.end = A + t || this.end, a.dict = i, a;
  }
  getBaseStreams() {
    return [this];
  }
}
class aC {
  constructor(A, t) {
    this.length = t.length, this.chunkSize = t.rangeChunkSize, this.stream = new sC(this.length, this.chunkSize, this), this.pdfNetworkStream = A, this.disableAutoFetch = t.disableAutoFetch, this.msgHandler = t.msgHandler, this.currRequestId = 0, this._chunksNeededByRequest = /* @__PURE__ */ new Map(), this._requestsByChunk = /* @__PURE__ */ new Map(), this._promisesByRequest = /* @__PURE__ */ new Map(), this.progressiveDataLength = 0, this.aborted = !1, this._loadedStreamCapability = Promise.withResolvers();
  }
  sendRequest(A, t) {
    const i = this.pdfNetworkStream.getRangeReader(A, t);
    i.isStreamingSupported || (i.onProgress = this.onProgress.bind(this));
    let s = [], a = 0;
    return new Promise((n, r) => {
      const g = ({
        value: o,
        done: I
      }) => {
        try {
          if (I) {
            const c = dc(s);
            s = null, n(c);
            return;
          }
          a += o.byteLength, i.isStreamingSupported && this.onProgress({
            loaded: a
          }), s.push(o), i.read().then(g, r);
        } catch (c) {
          r(c);
        }
      };
      i.read().then(g, r);
    }).then((n) => {
      this.aborted || this.onReceiveData({
        chunk: n,
        begin: A
      });
    });
  }
  requestAllChunks(A = !1) {
    if (!A) {
      const t = this.stream.getMissingChunks();
      this._requestChunks(t);
    }
    return this._loadedStreamCapability.promise;
  }
  _requestChunks(A) {
    const t = this.currRequestId++, i = /* @__PURE__ */ new Set();
    this._chunksNeededByRequest.set(t, i);
    for (const n of A)
      this.stream.hasChunk(n) || i.add(n);
    if (i.size === 0)
      return Promise.resolve();
    const s = Promise.withResolvers();
    this._promisesByRequest.set(t, s);
    const a = [];
    for (const n of i) {
      let r = this._requestsByChunk.get(n);
      r || (r = [], this._requestsByChunk.set(n, r), a.push(n)), r.push(t);
    }
    if (a.length > 0) {
      const n = this.groupChunks(a);
      for (const r of n) {
        const g = r.beginChunk * this.chunkSize, o = Math.min(r.endChunk * this.chunkSize, this.length);
        this.sendRequest(g, o).catch(s.reject);
      }
    }
    return s.promise.catch((n) => {
      if (!this.aborted)
        throw n;
    });
  }
  getStream() {
    return this.stream;
  }
  requestRange(A, t) {
    t = Math.min(t, this.length);
    const i = this.getBeginChunk(A), s = this.getEndChunk(t), a = [];
    for (let n = i; n < s; ++n)
      a.push(n);
    return this._requestChunks(a);
  }
  requestRanges(A = []) {
    const t = [];
    for (const i of A) {
      const s = this.getBeginChunk(i.begin), a = this.getEndChunk(i.end);
      for (let n = s; n < a; ++n)
        t.includes(n) || t.push(n);
    }
    return t.sort(function(i, s) {
      return i - s;
    }), this._requestChunks(t);
  }
  groupChunks(A) {
    const t = [];
    let i = -1, s = -1;
    for (let a = 0, n = A.length; a < n; ++a) {
      const r = A[a];
      i < 0 && (i = r), s >= 0 && s + 1 !== r && (t.push({
        beginChunk: i,
        endChunk: s + 1
      }), i = r), a + 1 === A.length && t.push({
        beginChunk: i,
        endChunk: r + 1
      }), s = r;
    }
    return t;
  }
  onProgress(A) {
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize + A.loaded,
      total: this.length
    });
  }
  onReceiveData(A) {
    const t = A.chunk, i = A.begin === void 0, s = i ? this.progressiveDataLength : A.begin, a = s + t.byteLength, n = Math.floor(s / this.chunkSize), r = a < this.length ? Math.floor(a / this.chunkSize) : Math.ceil(a / this.chunkSize);
    i ? (this.stream.onReceiveProgressiveData(t), this.progressiveDataLength = a) : this.stream.onReceiveData(s, t), this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
    const g = [];
    for (let o = n; o < r; ++o) {
      const I = this._requestsByChunk.get(o);
      if (I) {
        this._requestsByChunk.delete(o);
        for (const c of I) {
          const l = this._chunksNeededByRequest.get(c);
          l.has(o) && l.delete(o), !(l.size > 0) && g.push(c);
        }
      }
    }
    if (!this.disableAutoFetch && this._requestsByChunk.size === 0) {
      let o;
      if (this.stream.numChunksLoaded === 1) {
        const I = this.stream.numChunks - 1;
        this.stream.hasChunk(I) || (o = I);
      } else
        o = this.stream.nextEmptyChunk(r);
      Number.isInteger(o) && this._requestChunks([o]);
    }
    for (const o of g) {
      const I = this._promisesByRequest.get(o);
      this._promisesByRequest.delete(o), I.resolve();
    }
    this.msgHandler.send("DocProgress", {
      loaded: this.stream.numChunksLoaded * this.chunkSize,
      total: this.length
    });
  }
  onError(A) {
    this._loadedStreamCapability.reject(A);
  }
  getBeginChunk(A) {
    return Math.floor(A / this.chunkSize);
  }
  getEndChunk(A) {
    return Math.floor((A - 1) / this.chunkSize) + 1;
  }
  abort(A) {
    var t;
    this.aborted = !0, (t = this.pdfNetworkStream) == null || t.cancelAllRequests(A);
    for (const i of this._promisesByRequest.values())
      i.reject(A);
  }
}
function nC(e, A, t, i, s, a, n) {
  n = n !== 1 ? 0 : n;
  const g = t / s, o = i / a;
  let I = 0, c;
  const l = new Uint16Array(s), h = t * 3;
  for (let C = 0; C < s; C++)
    l[C] = Math.floor(C * g) * 3;
  for (let C = 0; C < a; C++) {
    const B = Math.floor(C * o) * h;
    for (let Q = 0; Q < s; Q++)
      c = B + l[Q], A[I++] = e[c++], A[I++] = e[c++], A[I++] = e[c++], I += n;
  }
}
function rC(e, A, t, i, s, a, n) {
  const r = t / s, g = i / a;
  let o = 0;
  const I = new Uint16Array(s);
  if (n === 1) {
    for (let C = 0; C < s; C++)
      I[C] = Math.floor(C * r);
    const c = new Uint32Array(e.buffer), l = new Uint32Array(A.buffer), h = ht.isLittleEndian ? 16777215 : 4294967040;
    for (let C = 0; C < a; C++) {
      const B = c.subarray(Math.floor(C * g) * t);
      for (let Q = 0; Q < s; Q++)
        l[o++] |= B[I[Q]] & h;
    }
  } else {
    const l = t * 4;
    for (let h = 0; h < s; h++)
      I[h] = Math.floor(h * r) * 4;
    for (let h = 0; h < a; h++) {
      const C = e.subarray(Math.floor(h * g) * l);
      for (let B = 0; B < s; B++) {
        const Q = I[B];
        A[o++] = C[Q], A[o++] = C[Q + 1], A[o++] = C[Q + 2];
      }
    }
  }
}
function gC(e, A, t) {
  if (t === 1) {
    const i = new Uint32Array(e.buffer), s = new Uint32Array(A.buffer), a = ht.isLittleEndian ? 16777215 : 4294967040;
    for (let n = 0, r = i.length; n < r; n++)
      s[n] |= i[n] & a;
  } else {
    let i = 0;
    for (let s = 0, a = e.length; s < a; s += 4)
      A[i++] = e[s], A[i++] = e[s + 1], A[i++] = e[s + 2];
  }
}
class LA {
  constructor(A, t) {
    this.name = A, this.numComps = t;
  }
  getRgb(A, t) {
    const i = new Uint8ClampedArray(3);
    return this.getRgbItem(A, t, i, 0), i;
  }
  getRgbItem(A, t, i, s) {
    WA("Should not call ColorSpace.getRgbItem");
  }
  getRgbBuffer(A, t, i, s, a, n, r) {
    WA("Should not call ColorSpace.getRgbBuffer");
  }
  getOutputLength(A, t) {
    WA("Should not call ColorSpace.getOutputLength");
  }
  isPassthrough(A) {
    return !1;
  }
  isDefaultDecode(A, t) {
    return LA.isDefaultDecode(A, this.numComps);
  }
  fillRgb(A, t, i, s, a, n, r, g, o) {
    const I = t * i;
    let c = null;
    const l = 1 << r, h = i !== a || t !== s;
    if (this.isPassthrough(r))
      c = g;
    else if (this.numComps === 1 && I > l && this.name !== "DeviceGray" && this.name !== "DeviceRGB") {
      const C = r <= 8 ? new Uint8Array(l) : new Uint16Array(l);
      for (let Q = 0; Q < l; Q++)
        C[Q] = Q;
      const B = new Uint8ClampedArray(l * 3);
      if (this.getRgbBuffer(C, 0, l, B, 0, r, 0), h) {
        c = new Uint8Array(I * 3);
        let Q = 0;
        for (let E = 0; E < I; ++E) {
          const f = g[E] * 3;
          c[Q++] = B[f], c[Q++] = B[f + 1], c[Q++] = B[f + 2];
        }
      } else {
        let Q = 0;
        for (let E = 0; E < I; ++E) {
          const f = g[E] * 3;
          A[Q++] = B[f], A[Q++] = B[f + 1], A[Q++] = B[f + 2], Q += o;
        }
      }
    } else h ? (c = new Uint8ClampedArray(I * 3), this.getRgbBuffer(g, 0, I, c, 0, r, 0)) : this.getRgbBuffer(g, 0, s * n, A, 0, r, o);
    if (c)
      if (h)
        nC(c, A, t, i, s, a, o);
      else {
        let C = 0, B = 0;
        for (let Q = 0, E = s * n; Q < E; Q++)
          A[C++] = c[B++], A[C++] = c[B++], A[C++] = c[B++], C += o;
      }
  }
  get usesZeroToOneRange() {
    return iA(this, "usesZeroToOneRange", !0);
  }
  static _cache(A, t, i, s) {
    if (!i)
      throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
    if (!s)
      throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
    let a, n;
    A instanceof nA && (n = A, A = t.fetch(A)), A instanceof L && (a = A.name), (a || n) && i.set(a, n, s);
  }
  static getCached(A, t, i) {
    if (!i)
      throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
    if (A instanceof nA) {
      const s = i.getByRef(A);
      if (s)
        return s;
      try {
        A = t.fetch(A);
      } catch (a) {
        if (a instanceof oe)
          throw a;
      }
    }
    if (A instanceof L) {
      const s = i.getByName(A.name);
      if (s)
        return s;
    }
    return null;
  }
  static async parseAsync({
    cs: A,
    xref: t,
    resources: i = null,
    pdfFunctionFactory: s,
    localColorSpaceCache: a
  }) {
    const n = this._parse(A, t, i, s);
    return this._cache(A, t, a, n), n;
  }
  static parse({
    cs: A,
    xref: t,
    resources: i = null,
    pdfFunctionFactory: s,
    localColorSpaceCache: a
  }) {
    const n = this.getCached(A, t, a);
    if (n)
      return n;
    const r = this._parse(A, t, i, s);
    return this._cache(A, t, a, r), r;
  }
  static _parse(A, t, i = null, s) {
    if (A = t.fetchIfRef(A), A instanceof L)
      switch (A.name) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "DeviceRGBA":
          return this.singletons.rgba;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "Pattern":
          return new Jo(null);
        default:
          if (i instanceof R) {
            const a = i.get("ColorSpace");
            if (a instanceof R) {
              const n = a.get(A.name);
              if (n) {
                if (n instanceof L)
                  return this._parse(n, t, i, s);
                A = n;
                break;
              }
            }
          }
          return k(`Unrecognized ColorSpace: ${A.name}`), this.singletons.gray;
      }
    if (Array.isArray(A)) {
      const a = t.fetchIfRef(A[0]).name;
      let n, r, g, o, I, c;
      switch (a) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "CalGray":
          return n = t.fetchIfRef(A[1]), o = n.getArray("WhitePoint"), I = n.getArray("BlackPoint"), c = n.get("Gamma"), new BC(o, I, c);
        case "CalRGB":
          n = t.fetchIfRef(A[1]), o = n.getArray("WhitePoint"), I = n.getArray("BlackPoint"), c = n.getArray("Gamma");
          const l = n.getArray("Matrix");
          return new tg(o, I, c, l);
        case "ICCBased":
          const C = t.fetchIfRef(A[1]).dict;
          r = C.get("N");
          const B = C.get("Alternate");
          if (B) {
            const x = this._parse(B, t, i, s);
            if (x.numComps === r)
              return x;
            k("ICCBased color space: Ignoring incorrect /Alternate entry.");
          }
          if (r === 1)
            return this.singletons.gray;
          if (r === 3)
            return this.singletons.rgb;
          if (r === 4)
            return this.singletons.cmyk;
          break;
        case "Pattern":
          return g = A[1] || null, g && (g = this._parse(g, t, i, s)), new Jo(g);
        case "I":
        case "Indexed":
          g = this._parse(A[1], t, i, s);
          const Q = Math.max(0, Math.min(t.fetchIfRef(A[2]), 255)), E = t.fetchIfRef(A[3]);
          return new IC(g, Q, E);
        case "Separation":
        case "DeviceN":
          const f = t.fetchIfRef(A[1]);
          r = Array.isArray(f) ? f.length : 1, g = this._parse(A[2], t, i, s);
          const d = s.create(A[3]);
          return new oC(r, g, d);
        case "Lab":
          n = t.fetchIfRef(A[1]), o = n.getArray("WhitePoint"), I = n.getArray("BlackPoint");
          const u = n.getArray("Range");
          return new QC(o, I, u);
        default:
          return k(`Unimplemented ColorSpace object: ${a}`), this.singletons.gray;
      }
    }
    return k(`Unrecognized ColorSpace object: ${A}`), this.singletons.gray;
  }
  static isDefaultDecode(A, t) {
    if (!Array.isArray(A))
      return !0;
    if (t * 2 !== A.length)
      return k("The decode map is not the correct length"), !0;
    for (let i = 0, s = A.length; i < s; i += 2)
      if (A[i] !== 0 || A[i + 1] !== 1)
        return !1;
    return !0;
  }
  static get singletons() {
    return iA(this, "singletons", {
      get gray() {
        return iA(this, "gray", new cC());
      },
      get rgb() {
        return iA(this, "rgb", new lC());
      },
      get rgba() {
        return iA(this, "rgba", new hC());
      },
      get cmyk() {
        return iA(this, "cmyk", new CC());
      }
    });
  }
}
class oC extends LA {
  constructor(A, t, i) {
    super("Alternate", A), this.base = t, this.tintFn = i, this.tmpBuf = new Float32Array(t.numComps);
  }
  getRgbItem(A, t, i, s) {
    const a = this.tmpBuf;
    this.tintFn(A, t, a, 0), this.base.getRgbItem(a, 0, i, s);
  }
  getRgbBuffer(A, t, i, s, a, n, r) {
    const g = this.tintFn, o = this.base, I = 1 / ((1 << n) - 1), c = o.numComps, l = o.usesZeroToOneRange, h = (o.isPassthrough(8) || !l) && r === 0;
    let C = h ? a : 0;
    const B = h ? s : new Uint8ClampedArray(c * i), Q = this.numComps, E = new Float32Array(Q), f = new Float32Array(c);
    let d, u;
    for (d = 0; d < i; d++) {
      for (u = 0; u < Q; u++)
        E[u] = A[t++] * I;
      if (g(E, 0, f, 0), l)
        for (u = 0; u < c; u++)
          B[C++] = f[u] * 255;
      else
        o.getRgbItem(f, 0, B, C), C += c;
    }
    h || o.getRgbBuffer(B, 0, i, s, a, 8, r);
  }
  getOutputLength(A, t) {
    return this.base.getOutputLength(A * this.base.numComps / this.numComps, t);
  }
}
class Jo extends LA {
  constructor(A) {
    super("Pattern", null), this.base = A;
  }
  isDefaultDecode(A, t) {
    WA("Should not call PatternCS.isDefaultDecode");
  }
}
class IC extends LA {
  constructor(A, t, i) {
    super("Indexed", 1), this.base = A;
    const s = A.numComps * (t + 1);
    if (this.lookup = new Uint8Array(s), i instanceof JA) {
      const a = i.getBytes(s);
      this.lookup.set(a);
    } else if (typeof i == "string")
      for (let a = 0; a < s; ++a)
        this.lookup[a] = i.charCodeAt(a) & 255;
    else
      throw new v(`IndexedCS - unrecognized lookup table: ${i}`);
  }
  getRgbItem(A, t, i, s) {
    const a = this.base.numComps, n = A[t] * a;
    this.base.getRgbBuffer(this.lookup, n, 1, i, s, 8, 0);
  }
  getRgbBuffer(A, t, i, s, a, n, r) {
    const g = this.base, o = g.numComps, I = g.getOutputLength(o, r), c = this.lookup;
    for (let l = 0; l < i; ++l) {
      const h = A[t++] * o;
      g.getRgbBuffer(c, h, 1, s, a, 8, r), a += I;
    }
  }
  getOutputLength(A, t) {
    return this.base.getOutputLength(A * this.base.numComps, t);
  }
  isDefaultDecode(A, t) {
    return Array.isArray(A) ? A.length !== 2 ? (k("Decode map length is not correct"), !0) : !Number.isInteger(t) || t < 1 ? (k("Bits per component is not correct"), !0) : A[0] === 0 && A[1] === (1 << t) - 1 : !0;
  }
}
class cC extends LA {
  constructor() {
    super("DeviceGray", 1);
  }
  getRgbItem(A, t, i, s) {
    const a = A[t] * 255;
    i[s] = i[s + 1] = i[s + 2] = a;
  }
  getRgbBuffer(A, t, i, s, a, n, r) {
    const g = 255 / ((1 << n) - 1);
    let o = t, I = a;
    for (let c = 0; c < i; ++c) {
      const l = g * A[o++];
      s[I++] = l, s[I++] = l, s[I++] = l, I += r;
    }
  }
  getOutputLength(A, t) {
    return A * (3 + t);
  }
}
class lC extends LA {
  constructor() {
    super("DeviceRGB", 3);
  }
  getRgbItem(A, t, i, s) {
    i[s] = A[t] * 255, i[s + 1] = A[t + 1] * 255, i[s + 2] = A[t + 2] * 255;
  }
  getRgbBuffer(A, t, i, s, a, n, r) {
    if (n === 8 && r === 0) {
      s.set(A.subarray(t, t + i * 3), a);
      return;
    }
    const g = 255 / ((1 << n) - 1);
    let o = t, I = a;
    for (let c = 0; c < i; ++c)
      s[I++] = g * A[o++], s[I++] = g * A[o++], s[I++] = g * A[o++], I += r;
  }
  getOutputLength(A, t) {
    return A * (3 + t) / 3 | 0;
  }
  isPassthrough(A) {
    return A === 8;
  }
}
class hC extends LA {
  constructor() {
    super("DeviceRGBA", 4);
  }
  getOutputLength(A, t) {
    return A * 4;
  }
  isPassthrough(A) {
    return A === 8;
  }
  fillRgb(A, t, i, s, a, n, r, g, o) {
    i !== a || t !== s ? rC(g, A, t, i, s, a, o) : gC(g, A, o);
  }
}
var oa, Ag;
class CC extends LA {
  constructor() {
    super("DeviceCMYK", 4);
    ZA(this, oa);
  }
  getRgbItem(t, i, s, a) {
    BA(this, oa, Ag).call(this, t, i, 1, s, a);
  }
  getRgbBuffer(t, i, s, a, n, r, g) {
    const o = 1 / ((1 << r) - 1);
    for (let I = 0; I < s; I++)
      BA(this, oa, Ag).call(this, t, i, o, a, n), i += 4, n += 3 + g;
  }
  getOutputLength(t, i) {
    return t / 4 * (3 + i) | 0;
  }
}
oa = new WeakSet(), Ag = function(t, i, s, a, n) {
  const r = t[i] * s, g = t[i + 1] * s, o = t[i + 2] * s, I = t[i + 3] * s;
  a[n] = 255 + r * (-4.387332384609988 * r + 54.48615194189176 * g + 18.82290502165302 * o + 212.25662451639585 * I + -285.2331026137004) + g * (1.7149763477362134 * g - 5.6096736904047315 * o + -17.873870861415444 * I - 5.497006427196366) + o * (-2.5217340131683033 * o - 21.248923337353073 * I + 17.5119270841813) + I * (-21.86122147463605 * I - 189.48180835922747), a[n + 1] = 255 + r * (8.841041422036149 * r + 60.118027045597366 * g + 6.871425592049007 * o + 31.159100130055922 * I + -79.2970844816548) + g * (-15.310361306967817 * g + 17.575251261109482 * o + 131.35250912493976 * I - 190.9453302588951) + o * (4.444339102852739 * o + 9.8632861493405 * I - 24.86741582555878) + I * (-20.737325471181034 * I - 187.80453709719578), a[n + 2] = 255 + r * (0.8842522430003296 * r + 8.078677503112928 * g + 30.89978309703729 * o - 0.23883238689178934 * I + -14.183576799673286) + g * (10.49593273432072 * g + 63.02378494754052 * o + 50.606957656360734 * I - 112.23884253719248) + o * (0.03296041114873217 * o + 115.60384449646641 * I + -193.58209356861505) + I * (-22.33816807309886 * I - 180.12613974708367);
};
var Ia, eg;
class BC extends LA {
  constructor(t, i, s) {
    super("CalGray", 1);
    ZA(this, Ia);
    if (!t)
      throw new v("WhitePoint missing - required for color space CalGray");
    if ([this.XW, this.YW, this.ZW] = t, [this.XB, this.YB, this.ZB] = i || [0, 0, 0], this.G = s || 1, this.XW < 0 || this.ZW < 0 || this.YW !== 1)
      throw new v(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (vA(`Invalid BlackPoint for ${this.name}, falling back to default.`), this.XB = this.YB = this.ZB = 0), (this.XB !== 0 || this.YB !== 0 || this.ZB !== 0) && k(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`), this.G < 1 && (vA(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`), this.G = 1);
  }
  getRgbItem(t, i, s, a) {
    BA(this, Ia, eg).call(this, t, i, s, a, 1);
  }
  getRgbBuffer(t, i, s, a, n, r, g) {
    const o = 1 / ((1 << r) - 1);
    for (let I = 0; I < s; ++I)
      BA(this, Ia, eg).call(this, t, i, a, n, o), i += 1, n += 3 + g;
  }
  getOutputLength(t, i) {
    return t * (3 + i);
  }
}
Ia = new WeakSet(), eg = function(t, i, s, a, n) {
  const g = (t[i] * n) ** this.G, o = this.YW * g, I = Math.max(295.8 * o ** 0.3333333333333333 - 40.8, 0);
  s[a] = I, s[a + 1] = I, s[a + 2] = I;
};
var ca, la, qn, Pn, ha, X0, Ca, Wn, zA, S0, wc, bc, on, F0, R0, Dc, kc, Sc, ig;
const he = class he extends LA {
  constructor(t, i, s, a) {
    super("CalRGB", 3);
    ZA(this, zA);
    if (!t)
      throw new v("WhitePoint missing - required for color space CalRGB");
    const [n, r, g] = this.whitePoint = t, [o, I, c] = this.blackPoint = i || new Float32Array(3);
    if ([this.GR, this.GG, this.GB] = s || new Float32Array([1, 1, 1]), [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a || new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), n < 0 || g < 0 || r !== 1)
      throw new v(`Invalid WhitePoint components for ${this.name}, no fallback available`);
    (o < 0 || I < 0 || c < 0) && (vA(`Invalid BlackPoint for ${this.name} [${o}, ${I}, ${c}], falling back to default.`), this.blackPoint = new Float32Array(3)), (this.GR < 0 || this.GG < 0 || this.GB < 0) && (vA(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`), this.GR = this.GG = this.GB = 1);
  }
  getRgbItem(t, i, s, a) {
    BA(this, zA, ig).call(this, t, i, s, a, 1);
  }
  getRgbBuffer(t, i, s, a, n, r, g) {
    const o = 1 / ((1 << r) - 1);
    for (let I = 0; I < s; ++I)
      BA(this, zA, ig).call(this, t, i, a, n, o), i += 3, n += 3 + g;
  }
  getOutputLength(t, i) {
    return t * (3 + i) / 3 | 0;
  }
};
ca = new WeakMap(), la = new WeakMap(), qn = new WeakMap(), Pn = new WeakMap(), ha = new WeakMap(), X0 = new WeakMap(), Ca = new WeakMap(), Wn = new WeakMap(), zA = new WeakSet(), S0 = function(t, i, s) {
  s[0] = t[0] * i[0] + t[1] * i[1] + t[2] * i[2], s[1] = t[3] * i[0] + t[4] * i[1] + t[5] * i[2], s[2] = t[6] * i[0] + t[7] * i[1] + t[8] * i[2];
}, wc = function(t, i, s) {
  s[0] = i[0] * 1 / t[0], s[1] = i[1] * 1 / t[1], s[2] = i[2] * 1 / t[2];
}, bc = function(t, i, s) {
  s[0] = i[0] * 0.95047 / t[0], s[1] = i[1] * 1 / t[1], s[2] = i[2] * 1.08883 / t[2];
}, on = function(t) {
  return t <= 31308e-7 ? BA(this, zA, F0).call(this, 0, 1, 12.92 * t) : t >= 0.99554525 ? 1 : BA(this, zA, F0).call(this, 0, 1, (1 + 0.055) * t ** (1 / 2.4) - 0.055);
}, F0 = function(t, i, s) {
  return Math.max(t, Math.min(i, s));
}, R0 = function(t) {
  return t < 0 ? -BA(this, zA, R0).call(this, -t) : t > 8 ? ((t + 16) / 116) ** 3 : t * PA(he, Wn);
}, Dc = function(t, i, s) {
  if (t[0] === 0 && t[1] === 0 && t[2] === 0) {
    s[0] = i[0], s[1] = i[1], s[2] = i[2];
    return;
  }
  const a = BA(this, zA, R0).call(this, 0), n = a, r = BA(this, zA, R0).call(this, t[0]), g = a, o = BA(this, zA, R0).call(this, t[1]), I = a, c = BA(this, zA, R0).call(this, t[2]), l = (1 - n) / (1 - r), h = 1 - l, C = (1 - g) / (1 - o), B = 1 - C, Q = (1 - I) / (1 - c), E = 1 - Q;
  s[0] = i[0] * l + h, s[1] = i[1] * C + B, s[2] = i[2] * Q + E;
}, kc = function(t, i, s) {
  if (t[0] === 1 && t[2] === 1) {
    s[0] = i[0], s[1] = i[1], s[2] = i[2];
    return;
  }
  const a = s;
  BA(this, zA, S0).call(this, PA(he, ca), i, a);
  const n = PA(he, ha);
  BA(this, zA, wc).call(this, t, a, n), BA(this, zA, S0).call(this, PA(he, la), n, s);
}, Sc = function(t, i, s) {
  const a = s;
  BA(this, zA, S0).call(this, PA(he, ca), i, a);
  const n = PA(he, ha);
  BA(this, zA, bc).call(this, t, a, n), BA(this, zA, S0).call(this, PA(he, la), n, s);
}, ig = function(t, i, s, a, n) {
  const r = BA(this, zA, F0).call(this, 0, 1, t[i] * n), g = BA(this, zA, F0).call(this, 0, 1, t[i + 1] * n), o = BA(this, zA, F0).call(this, 0, 1, t[i + 2] * n), I = r === 1 ? 1 : r ** this.GR, c = g === 1 ? 1 : g ** this.GG, l = o === 1 ? 1 : o ** this.GB, h = this.MXA * I + this.MXB * c + this.MXC * l, C = this.MYA * I + this.MYB * c + this.MYC * l, B = this.MZA * I + this.MZB * c + this.MZC * l, Q = PA(he, X0);
  Q[0] = h, Q[1] = C, Q[2] = B;
  const E = PA(he, Ca);
  BA(this, zA, kc).call(this, this.whitePoint, Q, E);
  const f = PA(he, X0);
  BA(this, zA, Dc).call(this, this.blackPoint, E, f);
  const d = PA(he, Ca);
  BA(this, zA, Sc).call(this, PA(he, Pn), f, d);
  const u = PA(he, X0);
  BA(this, zA, S0).call(this, PA(he, qn), d, u), s[a] = BA(this, zA, on).call(this, u[0]) * 255, s[a + 1] = BA(this, zA, on).call(this, u[1]) * 255, s[a + 2] = BA(this, zA, on).call(this, u[2]) * 255;
}, ZA(he, ca, new Float32Array([0.8951, 0.2664, -0.1614, -0.7502, 1.7135, 0.0367, 0.0389, -0.0685, 1.0296])), ZA(he, la, new Float32Array([0.9869929, -0.1470543, 0.1599627, 0.4323053, 0.5183603, 0.0492912, -85287e-7, 0.0400428, 0.9684867])), ZA(he, qn, new Float32Array([3.2404542, -1.5371385, -0.4985314, -0.969266, 1.8760108, 0.041556, 0.0556434, -0.2040259, 1.0572252])), ZA(he, Pn, new Float32Array([1, 1, 1])), ZA(he, ha, new Float32Array(3)), ZA(he, X0, new Float32Array(3)), ZA(he, Ca, new Float32Array(3)), ZA(he, Wn, (24 / 116) ** 3 / 8);
let tg = he;
var pt, In, cn, sg;
class QC extends LA {
  constructor(t, i, s) {
    super("Lab", 3);
    ZA(this, pt);
    if (!t)
      throw new v("WhitePoint missing - required for color space Lab");
    if ([this.XW, this.YW, this.ZW] = t, [this.amin, this.amax, this.bmin, this.bmax] = s || [-100, 100, -100, 100], [this.XB, this.YB, this.ZB] = i || [0, 0, 0], this.XW < 0 || this.ZW < 0 || this.YW !== 1)
      throw new v("Invalid WhitePoint components, no fallback available");
    (this.XB < 0 || this.YB < 0 || this.ZB < 0) && (vA("Invalid BlackPoint, falling back to default"), this.XB = this.YB = this.ZB = 0), (this.amin > this.amax || this.bmin > this.bmax) && (vA("Invalid Range, falling back to defaults"), this.amin = -100, this.amax = 100, this.bmin = -100, this.bmax = 100);
  }
  getRgbItem(t, i, s, a) {
    BA(this, pt, sg).call(this, t, i, !1, s, a);
  }
  getRgbBuffer(t, i, s, a, n, r, g) {
    const o = (1 << r) - 1;
    for (let I = 0; I < s; I++)
      BA(this, pt, sg).call(this, t, i, o, a, n), i += 3, n += 3 + g;
  }
  getOutputLength(t, i) {
    return t * (3 + i) / 3 | 0;
  }
  isDefaultDecode(t, i) {
    return !0;
  }
  get usesZeroToOneRange() {
    return iA(this, "usesZeroToOneRange", !1);
  }
}
pt = new WeakSet(), In = function(t) {
  return t >= 6 / 29 ? t ** 3 : 108 / 841 * (t - 4 / 29);
}, cn = function(t, i, s, a) {
  return s + t * (a - s) / i;
}, sg = function(t, i, s, a, n) {
  let r = t[i], g = t[i + 1], o = t[i + 2];
  s !== !1 && (r = BA(this, pt, cn).call(this, r, s, 0, 100), g = BA(this, pt, cn).call(this, g, s, this.amin, this.amax), o = BA(this, pt, cn).call(this, o, s, this.bmin, this.bmax)), g > this.amax ? g = this.amax : g < this.amin && (g = this.amin), o > this.bmax ? o = this.bmax : o < this.bmin && (o = this.bmin);
  const I = (r + 16) / 116, c = I + g / 500, l = I - o / 200, h = this.XW * BA(this, pt, In).call(this, c), C = this.YW * BA(this, pt, In).call(this, I), B = this.ZW * BA(this, pt, In).call(this, l);
  let Q, E, f;
  this.ZW < 1 ? (Q = h * 3.1339 + C * -1.617 + B * -0.4906, E = h * -0.9785 + C * 1.916 + B * 0.0333, f = h * 0.072 + C * -0.229 + B * 1.4057) : (Q = h * 3.2406 + C * -1.5372 + B * -0.4986, E = h * -0.9689 + C * 1.8758 + B * 0.0415, f = h * 0.0557 + C * -0.204 + B * 1.057), a[n] = Math.sqrt(Q) * 255, a[n + 1] = Math.sqrt(E) * 255, a[n + 2] = Math.sqrt(f) * 255;
};
function Ze(e, A) {
  let t = 0;
  for (let i = 0; i <= A; i++)
    t = t << 8 | e[i];
  return t >>> 0;
}
function Ua(e, A) {
  return A === 1 ? String.fromCharCode(e[0], e[1]) : A === 3 ? String.fromCharCode(e[0], e[1], e[2], e[3]) : String.fromCharCode(...e.subarray(0, A + 1));
}
function et(e, A, t) {
  let i = 0;
  for (let s = t; s >= 0; s--)
    i += e[s] + A[s], e[s] = i & 255, i >>= 8;
}
function Vi(e, A) {
  let t = 1;
  for (let i = A; i >= 0 && t > 0; i--)
    t += e[i], e[i] = t & 255, t >>= 8;
}
const m0 = 16, EC = 19;
class fC {
  constructor(A) {
    this.buffer = A, this.pos = 0, this.end = A.length, this.tmpBuf = new Uint8Array(EC);
  }
  readByte() {
    return this.pos >= this.end ? -1 : this.buffer[this.pos++];
  }
  readNumber() {
    let A = 0, t;
    do {
      const i = this.readByte();
      if (i < 0)
        throw new v("unexpected EOF in bcmap");
      t = !(i & 128), A = A << 7 | i & 127;
    } while (!t);
    return A;
  }
  readSigned() {
    const A = this.readNumber();
    return A & 1 ? ~(A >>> 1) : A >>> 1;
  }
  readHex(A, t) {
    A.set(this.buffer.subarray(this.pos, this.pos + t + 1)), this.pos += t + 1;
  }
  readHexNumber(A, t) {
    let i;
    const s = this.tmpBuf;
    let a = 0;
    do {
      const o = this.readByte();
      if (o < 0)
        throw new v("unexpected EOF in bcmap");
      i = !(o & 128), s[a++] = o & 127;
    } while (!i);
    let n = t, r = 0, g = 0;
    for (; n >= 0; ) {
      for (; g < 8 && s.length > 0; )
        r |= s[--a] << g, g += 7;
      A[n] = r & 255, n--, r >>= 8, g -= 8;
    }
  }
  readHexSigned(A, t) {
    this.readHexNumber(A, t);
    const i = A[t] & 1 ? 255 : 0;
    let s = 0;
    for (let a = 0; a <= t; a++)
      s = (s & 1) << 8 | A[a], A[a] = s >> 1 ^ i;
  }
  readString() {
    const A = this.readNumber(), t = new Array(A);
    for (let i = 0; i < A; i++)
      t[i] = this.readNumber();
    return String.fromCharCode(...t);
  }
}
class uC {
  async process(A, t, i) {
    const s = new fC(A), a = s.readByte();
    t.vertical = !!(a & 1);
    let n = null;
    const r = new Uint8Array(m0), g = new Uint8Array(m0), o = new Uint8Array(m0), I = new Uint8Array(m0), c = new Uint8Array(m0);
    let l, h;
    for (; (h = s.readByte()) >= 0; ) {
      const C = h >> 5;
      if (C === 7) {
        switch (h & 31) {
          case 0:
            s.readString();
            break;
          case 1:
            n = s.readString();
            break;
        }
        continue;
      }
      const B = !!(h & 16), Q = h & 15;
      if (Q + 1 > m0)
        throw new Error("BinaryCMapReader.process: Invalid dataSize.");
      const E = 1, f = s.readNumber();
      switch (C) {
        case 0:
          s.readHex(r, Q), s.readHexNumber(g, Q), et(g, r, Q), t.addCodespaceRange(Q + 1, Ze(r, Q), Ze(g, Q));
          for (let d = 1; d < f; d++)
            Vi(g, Q), s.readHexNumber(r, Q), et(r, g, Q), s.readHexNumber(g, Q), et(g, r, Q), t.addCodespaceRange(Q + 1, Ze(r, Q), Ze(g, Q));
          break;
        case 1:
          s.readHex(r, Q), s.readHexNumber(g, Q), et(g, r, Q), s.readNumber();
          for (let d = 1; d < f; d++)
            Vi(g, Q), s.readHexNumber(r, Q), et(r, g, Q), s.readHexNumber(g, Q), et(g, r, Q), s.readNumber();
          break;
        case 2:
          s.readHex(o, Q), l = s.readNumber(), t.mapOne(Ze(o, Q), l);
          for (let d = 1; d < f; d++)
            Vi(o, Q), B || (s.readHexNumber(c, Q), et(o, c, Q)), l = s.readSigned() + (l + 1), t.mapOne(Ze(o, Q), l);
          break;
        case 3:
          s.readHex(r, Q), s.readHexNumber(g, Q), et(g, r, Q), l = s.readNumber(), t.mapCidRange(Ze(r, Q), Ze(g, Q), l);
          for (let d = 1; d < f; d++)
            Vi(g, Q), B ? r.set(g) : (s.readHexNumber(r, Q), et(r, g, Q)), s.readHexNumber(g, Q), et(g, r, Q), l = s.readNumber(), t.mapCidRange(Ze(r, Q), Ze(g, Q), l);
          break;
        case 4:
          s.readHex(o, E), s.readHex(I, Q), t.mapOne(Ze(o, E), Ua(I, Q));
          for (let d = 1; d < f; d++)
            Vi(o, E), B || (s.readHexNumber(c, E), et(o, c, E)), Vi(I, Q), s.readHexSigned(c, Q), et(I, c, Q), t.mapOne(Ze(o, E), Ua(I, Q));
          break;
        case 5:
          s.readHex(r, E), s.readHexNumber(g, E), et(g, r, E), s.readHex(I, Q), t.mapBfRange(Ze(r, E), Ze(g, E), Ua(I, Q));
          for (let d = 1; d < f; d++)
            Vi(g, E), B ? r.set(g) : (s.readHexNumber(r, E), et(r, g, E)), s.readHexNumber(g, E), et(g, r, E), s.readHex(I, Q), t.mapBfRange(Ze(r, E), Ze(g, E), Ua(I, Q));
          break;
        default:
          throw new Error(`BinaryCMapReader.process - unknown type: ${C}`);
      }
    }
    return n ? i(n) : t;
  }
}
const dC = new Uint8Array(0);
class $e extends JA {
  constructor(A) {
    if (super(), this._rawMinBufferLength = A || 0, this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = dC, this.minBufferLength = 512, A)
      for (; this.minBufferLength < A; )
        this.minBufferLength *= 2;
  }
  get isEmpty() {
    for (; !this.eof && this.bufferLength === 0; )
      this.readBlock();
    return this.bufferLength === 0;
  }
  ensureBuffer(A) {
    const t = this.buffer;
    if (A <= t.byteLength)
      return t;
    let i = this.minBufferLength;
    for (; i < A; )
      i *= 2;
    const s = new Uint8Array(i);
    return s.set(t), this.buffer = s;
  }
  getByte() {
    const A = this.pos;
    for (; this.bufferLength <= A; ) {
      if (this.eof)
        return -1;
      this.readBlock();
    }
    return this.buffer[this.pos++];
  }
  getBytes(A, t = null) {
    const i = this.pos;
    let s;
    if (A) {
      for (this.ensureBuffer(i + A), s = i + A; !this.eof && this.bufferLength < s; )
        this.readBlock(t);
      const a = this.bufferLength;
      s > a && (s = a);
    } else {
      for (; !this.eof; )
        this.readBlock(t);
      s = this.bufferLength;
    }
    return this.pos = s, this.buffer.subarray(i, s);
  }
  async getImageData(A, t = null) {
    if (!this.canAsyncDecodeImageFromBuffer)
      return this.getBytes(A, t);
    const i = await this.stream.asyncGetBytes();
    return this.decodeImage(i, t);
  }
  reset() {
    this.pos = 0;
  }
  makeSubStream(A, t, i = null) {
    if (t === void 0)
      for (; !this.eof; )
        this.readBlock();
    else {
      const s = A + t;
      for (; this.bufferLength <= s && !this.eof; )
        this.readBlock();
    }
    return new Qe(this.buffer, A, t, i);
  }
  getBaseStreams() {
    return this.str ? this.str.getBaseStreams() : null;
  }
}
class xC extends $e {
  constructor(A, t = null) {
    A = A.filter((s) => s instanceof JA);
    let i = 0;
    for (const s of A)
      i += s instanceof $e ? s._rawMinBufferLength : s.length;
    super(i), this.streams = A, this._onError = t;
  }
  readBlock() {
    var r;
    const A = this.streams;
    if (A.length === 0) {
      this.eof = !0;
      return;
    }
    const t = A.shift();
    let i;
    try {
      i = t.getBytes();
    } catch (g) {
      if (this._onError) {
        this._onError(g, (r = t.dict) == null ? void 0 : r.objId);
        return;
      }
      throw g;
    }
    const s = this.bufferLength, a = s + i.length;
    this.ensureBuffer(a).set(i, s), this.bufferLength = a;
  }
  getBaseStreams() {
    const A = [];
    for (const t of this.streams) {
      const i = t.getBaseStreams();
      i && A.push(...i);
    }
    return A.length > 0 ? A : null;
  }
}
class mC extends $e {
  constructor(A, t) {
    t && (t *= 0.8), super(t), this.str = A, this.dict = A.dict, this.input = new Uint8Array(5);
  }
  readBlock() {
    const s = this.str;
    let a = s.getByte();
    for (; mt(a); )
      a = s.getByte();
    if (a === -1 || a === 126) {
      this.eof = !0;
      return;
    }
    const n = this.bufferLength;
    let r, g;
    if (a === 122) {
      for (r = this.ensureBuffer(n + 4), g = 0; g < 4; ++g)
        r[n + g] = 0;
      this.bufferLength += 4;
    } else {
      const o = this.input;
      for (o[0] = a, g = 1; g < 5; ++g) {
        for (a = s.getByte(); mt(a); )
          a = s.getByte();
        if (o[g] = a, a === -1 || a === 126)
          break;
      }
      if (r = this.ensureBuffer(n + g - 1), this.bufferLength += g - 1, g < 5) {
        for (; g < 5; ++g)
          o[g] = 117;
        this.eof = !0;
      }
      let I = 0;
      for (g = 0; g < 5; ++g)
        I = I * 85 + (o[g] - 33);
      for (g = 3; g >= 0; --g)
        r[n + g] = I & 255, I >>= 8;
    }
  }
}
class pC extends $e {
  constructor(A, t) {
    t && (t *= 0.5), super(t), this.str = A, this.dict = A.dict, this.firstDigit = -1;
  }
  readBlock() {
    const t = this.str.getBytes(8e3);
    if (!t.length) {
      this.eof = !0;
      return;
    }
    const i = t.length + 1 >> 1, s = this.ensureBuffer(this.bufferLength + i);
    let a = this.bufferLength, n = this.firstDigit;
    for (const r of t) {
      let g;
      if (r >= 48 && r <= 57)
        g = r & 15;
      else if (r >= 65 && r <= 70 || r >= 97 && r <= 102)
        g = (r & 15) + 9;
      else if (r === 62) {
        this.eof = !0;
        break;
      } else
        continue;
      n < 0 ? n = g : (s[a++] = n << 4 | g, n = -1);
    }
    n >= 0 && this.eof && (s[a++] = n << 4, n = -1), this.firstDigit = n, this.bufferLength = a;
  }
}
const ag = -2, gi = -1, Ii = 0, Ye = 1, kA = 2, Ke = 3, ve = 4, ng = 5, rg = 6, Fc = 7, Rc = 8, Yo = [[-1, -1], [-1, -1], [7, Rc], [7, Fc], [6, rg], [6, rg], [6, ng], [6, ng], [4, Ii], [4, Ii], [4, Ii], [4, Ii], [4, Ii], [4, Ii], [4, Ii], [4, Ii], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, Ye], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, ve], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [3, Ke], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA], [1, kA]], Ko = [[-1, -1], [12, ag], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [12, 1984], [12, 2048], [12, 2112], [12, 2176], [12, 2240], [12, 2304], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [12, 2368], [12, 2432], [12, 2496], [12, 2560]], vo = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [8, 29], [8, 29], [8, 30], [8, 30], [8, 45], [8, 45], [8, 46], [8, 46], [7, 22], [7, 22], [7, 22], [7, 22], [7, 23], [7, 23], [7, 23], [7, 23], [8, 47], [8, 47], [8, 48], [8, 48], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [6, 13], [7, 20], [7, 20], [7, 20], [7, 20], [8, 33], [8, 33], [8, 34], [8, 34], [8, 35], [8, 35], [8, 36], [8, 36], [8, 37], [8, 37], [8, 38], [8, 38], [7, 19], [7, 19], [7, 19], [7, 19], [8, 31], [8, 31], [8, 32], [8, 32], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 1], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [8, 53], [8, 53], [8, 54], [8, 54], [7, 26], [7, 26], [7, 26], [7, 26], [8, 39], [8, 39], [8, 40], [8, 40], [8, 41], [8, 41], [8, 42], [8, 42], [8, 43], [8, 43], [8, 44], [8, 44], [7, 21], [7, 21], [7, 21], [7, 21], [7, 28], [7, 28], [7, 28], [7, 28], [8, 61], [8, 61], [8, 62], [8, 62], [8, 63], [8, 63], [8, 0], [8, 0], [8, 320], [8, 320], [8, 384], [8, 384], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 10], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [5, 11], [7, 27], [7, 27], [7, 27], [7, 27], [8, 59], [8, 59], [8, 60], [8, 60], [9, 1472], [9, 1536], [9, 1600], [9, 1728], [7, 18], [7, 18], [7, 18], [7, 18], [7, 24], [7, 24], [7, 24], [7, 24], [8, 49], [8, 49], [8, 50], [8, 50], [8, 51], [8, 51], [8, 52], [8, 52], [7, 25], [7, 25], [7, 25], [7, 25], [8, 55], [8, 55], [8, 56], [8, 56], [8, 57], [8, 57], [8, 58], [8, 58], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 192], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [6, 1664], [8, 448], [8, 448], [8, 512], [8, 512], [9, 704], [9, 768], [8, 640], [8, 640], [8, 576], [8, 576], [9, 832], [9, 896], [9, 960], [9, 1024], [9, 1088], [9, 1152], [9, 1216], [9, 1280], [9, 1344], [9, 1408], [7, 256], [7, 256], [7, 256], [7, 256], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 128], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 8], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 16], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [6, 17], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 4], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [4, 5], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 14], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [6, 15], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [5, 64], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 6], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7], [4, 7]], To = [[-1, -1], [-1, -1], [12, ag], [12, ag], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [-1, -1], [11, 1792], [11, 1792], [11, 1792], [11, 1792], [12, 1984], [12, 1984], [12, 2048], [12, 2048], [12, 2112], [12, 2112], [12, 2176], [12, 2176], [12, 2240], [12, 2240], [12, 2304], [12, 2304], [11, 1856], [11, 1856], [11, 1856], [11, 1856], [11, 1920], [11, 1920], [11, 1920], [11, 1920], [12, 2368], [12, 2368], [12, 2432], [12, 2432], [12, 2496], [12, 2496], [12, 2560], [12, 2560], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [10, 18], [12, 52], [12, 52], [13, 640], [13, 704], [13, 768], [13, 832], [12, 55], [12, 55], [12, 56], [12, 56], [13, 1280], [13, 1344], [13, 1408], [13, 1472], [12, 59], [12, 59], [12, 60], [12, 60], [13, 1536], [13, 1600], [11, 24], [11, 24], [11, 24], [11, 24], [11, 25], [11, 25], [11, 25], [11, 25], [13, 1664], [13, 1728], [12, 320], [12, 320], [12, 384], [12, 384], [12, 448], [12, 448], [13, 512], [13, 576], [12, 53], [12, 53], [12, 54], [12, 54], [13, 896], [13, 960], [13, 1024], [13, 1088], [13, 1152], [13, 1216], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64], [10, 64]], qo = [[8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [8, 13], [11, 23], [11, 23], [12, 50], [12, 51], [12, 44], [12, 45], [12, 46], [12, 47], [12, 57], [12, 58], [12, 61], [12, 256], [10, 16], [10, 16], [10, 16], [10, 16], [10, 17], [10, 17], [10, 17], [10, 17], [12, 48], [12, 49], [12, 62], [12, 63], [12, 30], [12, 31], [12, 32], [12, 33], [12, 40], [12, 41], [11, 22], [11, 22], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 10], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [7, 11], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [9, 15], [12, 128], [12, 192], [12, 26], [12, 27], [12, 28], [12, 29], [11, 19], [11, 19], [11, 20], [11, 20], [12, 34], [12, 35], [12, 36], [12, 37], [12, 38], [12, 39], [11, 21], [11, 21], [12, 42], [12, 43], [10, 0], [10, 0], [10, 0], [10, 0], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12], [7, 12]], Po = [[-1, -1], [-1, -1], [-1, -1], [-1, -1], [6, 9], [6, 8], [5, 7], [5, 7], [4, 6], [4, 6], [4, 6], [4, 6], [4, 5], [4, 5], [4, 5], [4, 5], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 1], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]];
class Gc {
  constructor(A, t = {}) {
    if (typeof (A == null ? void 0 : A.next) != "function")
      throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
    this.source = A, this.eof = !1, this.encoding = t.K || 0, this.eoline = t.EndOfLine || !1, this.byteAlign = t.EncodedByteAlign || !1, this.columns = t.Columns || 1728, this.rows = t.Rows || 0, this.eoblock = t.EndOfBlock ?? !0, this.black = t.BlackIs1 || !1, this.codingLine = new Uint32Array(this.columns + 1), this.refLine = new Uint32Array(this.columns + 2), this.codingLine[0] = this.columns, this.codingPos = 0, this.row = 0, this.nextLine2D = this.encoding < 0, this.inputBits = 0, this.inputBuf = 0, this.outputBits = 0, this.rowsDone = !1;
    let i;
    for (; (i = this._lookBits(12)) === 0; )
      this._eatBits(1);
    i === 1 && this._eatBits(12), this.encoding > 0 && (this.nextLine2D = !this._lookBits(1), this._eatBits(1));
  }
  readNextChar() {
    if (this.eof)
      return -1;
    const A = this.refLine, t = this.codingLine, i = this.columns;
    let s, a, n, r;
    if (this.outputBits === 0) {
      if (this.rowsDone && (this.eof = !0), this.eof)
        return -1;
      this.err = !1;
      let o, I, c;
      if (this.nextLine2D) {
        for (r = 0; t[r] < i; ++r)
          A[r] = t[r];
        for (A[r++] = i, A[r] = i, t[0] = 0, this.codingPos = 0, s = 0, a = 0; t[this.codingPos] < i; )
          switch (o = this._getTwoDimCode(), o) {
            case Ii:
              this._addPixels(A[s + 1], a), A[s + 1] < i && (s += 2);
              break;
            case Ye:
              if (o = I = 0, a) {
                do
                  o += c = this._getBlackCode();
                while (c >= 64);
                do
                  I += c = this._getWhiteCode();
                while (c >= 64);
              } else {
                do
                  o += c = this._getWhiteCode();
                while (c >= 64);
                do
                  I += c = this._getBlackCode();
                while (c >= 64);
              }
              for (this._addPixels(t[this.codingPos] + o, a), t[this.codingPos] < i && this._addPixels(t[this.codingPos] + I, a ^ 1); A[s] <= t[this.codingPos] && A[s] < i; )
                s += 2;
              break;
            case Fc:
              if (this._addPixels(A[s] + 3, a), a ^= 1, t[this.codingPos] < i)
                for (++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case ng:
              if (this._addPixels(A[s] + 2, a), a ^= 1, t[this.codingPos] < i)
                for (++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case Ke:
              if (this._addPixels(A[s] + 1, a), a ^= 1, t[this.codingPos] < i)
                for (++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case kA:
              if (this._addPixels(A[s], a), a ^= 1, t[this.codingPos] < i)
                for (++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case Rc:
              if (this._addPixelsNeg(A[s] - 3, a), a ^= 1, t[this.codingPos] < i)
                for (s > 0 ? --s : ++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case rg:
              if (this._addPixelsNeg(A[s] - 2, a), a ^= 1, t[this.codingPos] < i)
                for (s > 0 ? --s : ++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case ve:
              if (this._addPixelsNeg(A[s] - 1, a), a ^= 1, t[this.codingPos] < i)
                for (s > 0 ? --s : ++s; A[s] <= t[this.codingPos] && A[s] < i; )
                  s += 2;
              break;
            case gi:
              this._addPixels(i, 0), this.eof = !0;
              break;
            default:
              vA("bad 2d code"), this._addPixels(i, 0), this.err = !0;
          }
      } else
        for (t[0] = 0, this.codingPos = 0, a = 0; t[this.codingPos] < i; ) {
          if (o = 0, a)
            do
              o += c = this._getBlackCode();
            while (c >= 64);
          else
            do
              o += c = this._getWhiteCode();
            while (c >= 64);
          this._addPixels(t[this.codingPos] + o, a), a ^= 1;
        }
      let l = !1;
      if (this.byteAlign && (this.inputBits &= -8), !this.eoblock && this.row === this.rows - 1)
        this.rowsDone = !0;
      else {
        if (o = this._lookBits(12), this.eoline)
          for (; o !== gi && o !== 1; )
            this._eatBits(1), o = this._lookBits(12);
        else
          for (; o === 0; )
            this._eatBits(1), o = this._lookBits(12);
        o === 1 ? (this._eatBits(12), l = !0) : o === gi && (this.eof = !0);
      }
      if (!this.eof && this.encoding > 0 && !this.rowsDone && (this.nextLine2D = !this._lookBits(1), this._eatBits(1)), this.eoblock && l && this.byteAlign) {
        if (o = this._lookBits(12), o === 1) {
          if (this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1)), this.encoding >= 0)
            for (r = 0; r < 4; ++r)
              o = this._lookBits(12), o !== 1 && vA("bad rtc code: " + o), this._eatBits(12), this.encoding > 0 && (this._lookBits(1), this._eatBits(1));
          this.eof = !0;
        }
      } else if (this.err && this.eoline) {
        for (; ; ) {
          if (o = this._lookBits(13), o === gi)
            return this.eof = !0, -1;
          if (o >> 1 === 1)
            break;
          this._eatBits(1);
        }
        this._eatBits(12), this.encoding > 0 && (this._eatBits(1), this.nextLine2D = !(o & 1));
      }
      this.outputBits = t[0] > 0 ? t[this.codingPos = 0] : t[this.codingPos = 1], this.row++;
    }
    let g;
    if (this.outputBits >= 8)
      g = this.codingPos & 1 ? 0 : 255, this.outputBits -= 8, this.outputBits === 0 && t[this.codingPos] < i && (this.codingPos++, this.outputBits = t[this.codingPos] - t[this.codingPos - 1]);
    else {
      n = 8, g = 0;
      do {
        if (typeof this.outputBits != "number")
          throw new v('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
        this.outputBits > n ? (g <<= n, this.codingPos & 1 || (g |= 255 >> 8 - n), this.outputBits -= n, n = 0) : (g <<= this.outputBits, this.codingPos & 1 || (g |= 255 >> 8 - this.outputBits), n -= this.outputBits, this.outputBits = 0, t[this.codingPos] < i ? (this.codingPos++, this.outputBits = t[this.codingPos] - t[this.codingPos - 1]) : n > 0 && (g <<= n, n = 0));
      } while (n);
    }
    return this.black && (g ^= 255), g;
  }
  _addPixels(A, t) {
    const i = this.codingLine;
    let s = this.codingPos;
    A > i[s] && (A > this.columns && (vA("row is wrong length"), this.err = !0, A = this.columns), s & 1 ^ t && ++s, i[s] = A), this.codingPos = s;
  }
  _addPixelsNeg(A, t) {
    const i = this.codingLine;
    let s = this.codingPos;
    if (A > i[s])
      A > this.columns && (vA("row is wrong length"), this.err = !0, A = this.columns), s & 1 ^ t && ++s, i[s] = A;
    else if (A < i[s]) {
      for (A < 0 && (vA("invalid code"), this.err = !0, A = 0); s > 0 && A < i[s - 1]; )
        --s;
      i[s] = A;
    }
    this.codingPos = s;
  }
  _findTableCode(A, t, i, s) {
    const a = s || 0;
    for (let n = A; n <= t; ++n) {
      let r = this._lookBits(n);
      if (r === gi)
        return [!0, 1, !1];
      if (n < t && (r <<= t - n), !a || r >= a) {
        const g = i[r - a];
        if (g[0] === n)
          return this._eatBits(n), [!0, g[1], !0];
      }
    }
    return [!1, 0, !1];
  }
  _getTwoDimCode() {
    let A = 0, t;
    if (this.eoblock) {
      if (A = this._lookBits(7), t = Yo[A], (t == null ? void 0 : t[0]) > 0)
        return this._eatBits(t[0]), t[1];
    } else {
      const i = this._findTableCode(1, 7, Yo);
      if (i[0] && i[2])
        return i[1];
    }
    return vA("Bad two dim code"), gi;
  }
  _getWhiteCode() {
    let A = 0, t;
    if (this.eoblock) {
      if (A = this._lookBits(12), A === gi)
        return 1;
      if (t = A >> 5 ? vo[A >> 3] : Ko[A], t[0] > 0)
        return this._eatBits(t[0]), t[1];
    } else {
      let i = this._findTableCode(1, 9, vo);
      if (i[0] || (i = this._findTableCode(11, 12, Ko), i[0]))
        return i[1];
    }
    return vA("bad white code"), this._eatBits(1), 1;
  }
  _getBlackCode() {
    let A, t;
    if (this.eoblock) {
      if (A = this._lookBits(13), A === gi)
        return 1;
      if (A >> 7 ? !(A >> 9) && A >> 7 ? t = qo[(A >> 1) - 64] : t = Po[A >> 7] : t = To[A], t[0] > 0)
        return this._eatBits(t[0]), t[1];
    } else {
      let i = this._findTableCode(2, 6, Po);
      if (i[0] || (i = this._findTableCode(7, 12, qo, 64), i[0]) || (i = this._findTableCode(10, 13, To), i[0]))
        return i[1];
    }
    return vA("bad black code"), this._eatBits(1), 1;
  }
  _lookBits(A) {
    let t;
    for (; this.inputBits < A; ) {
      if ((t = this.source.next()) === -1)
        return this.inputBits === 0 ? gi : this.inputBuf << A - this.inputBits & 65535 >> 16 - A;
      this.inputBuf = this.inputBuf << 8 | t, this.inputBits += 8;
    }
    return this.inputBuf >> this.inputBits - A & 65535 >> 16 - A;
  }
  _eatBits(A) {
    (this.inputBits -= A) < 0 && (this.inputBits = 0);
  }
}
class yC extends $e {
  constructor(A, t, i) {
    super(t), this.str = A, this.dict = A.dict, i instanceof R || (i = R.empty);
    const s = {
      next() {
        return A.getByte();
      }
    };
    this.ccittFaxDecoder = new Gc(s, {
      K: i.get("K"),
      EndOfLine: i.get("EndOfLine"),
      EncodedByteAlign: i.get("EncodedByteAlign"),
      Columns: i.get("Columns"),
      Rows: i.get("Rows"),
      EndOfBlock: i.get("EndOfBlock"),
      BlackIs1: i.get("BlackIs1")
    });
  }
  readBlock() {
    for (; !this.eof; ) {
      const A = this.ccittFaxDecoder.readNextChar();
      if (A === -1) {
        this.eof = !0;
        return;
      }
      this.ensureBuffer(this.bufferLength + 1), this.buffer[this.bufferLength++] = A;
    }
  }
}
const Wo = new Int32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), wC = new Int32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), bC = new Int32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]), DC = [new Int32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], kC = [new Int32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
var Li, G0;
class Oo extends $e {
  constructor(t, i) {
    super(i);
    ZA(this, Li);
    this.str = t, this.dict = t.dict;
    const s = t.getByte(), a = t.getByte();
    if (s === -1 || a === -1)
      throw new v(`Invalid header in flate stream: ${s}, ${a}`);
    if ((s & 15) !== 8)
      throw new v(`Unknown compression method in flate stream: ${s}, ${a}`);
    if (((s << 8) + a) % 31 !== 0)
      throw new v(`Bad FCHECK in flate stream: ${s}, ${a}`);
    if (a & 32)
      throw new v(`FDICT bit set in flate stream: ${s}, ${a}`);
    this.codeSize = 0, this.codeBuf = 0;
  }
  async getImageData(t, i) {
    const s = await this.asyncGetBytes();
    return (s == null ? void 0 : s.subarray(0, t)) || this.getBytes(t);
  }
  async asyncGetBytes() {
    this.str.reset();
    const t = this.str.getBytes();
    try {
      const {
        readable: i,
        writable: s
      } = new DecompressionStream("deflate"), a = s.getWriter();
      await a.ready, a.write(t).then(async () => {
        await a.ready, await a.close();
      }).catch(() => {
      });
      const n = [];
      let r = 0;
      for await (const I of i)
        n.push(I), r += I.byteLength;
      const g = new Uint8Array(r);
      let o = 0;
      for (const I of n)
        g.set(I, o), o += I.byteLength;
      return g;
    } catch {
      return this.str = new Qe(t, 2, t.length, this.str.dict), this.reset(), null;
    }
  }
  get isAsync() {
    return !0;
  }
  getBits(t) {
    const i = this.str;
    let s = this.codeSize, a = this.codeBuf, n;
    for (; s < t; ) {
      if ((n = i.getByte()) === -1)
        throw new v("Bad encoding in flate stream");
      a |= n << s, s += 8;
    }
    return n = a & (1 << t) - 1, this.codeBuf = a >> t, this.codeSize = s -= t, n;
  }
  getCode(t) {
    const i = this.str, s = t[0], a = t[1];
    let n = this.codeSize, r = this.codeBuf, g;
    for (; n < a && (g = i.getByte()) !== -1; )
      r |= g << n, n += 8;
    const o = s[r & (1 << a) - 1], I = o >> 16, c = o & 65535;
    if (I < 1 || n < I)
      throw new v("Bad encoding in flate stream");
    return this.codeBuf = r >> I, this.codeSize = n - I, c;
  }
  generateHuffmanTable(t) {
    const i = t.length;
    let s = 0, a;
    for (a = 0; a < i; ++a)
      t[a] > s && (s = t[a]);
    const n = 1 << s, r = new Int32Array(n);
    for (let g = 1, o = 0, I = 2; g <= s; ++g, o <<= 1, I <<= 1)
      for (let c = 0; c < i; ++c)
        if (t[c] === g) {
          let l = 0, h = o;
          for (a = 0; a < g; ++a)
            l = l << 1 | h & 1, h >>= 1;
          for (a = l; a < n; a += I)
            r[a] = g << 16 | c;
          ++o;
        }
    return [r, s];
  }
  readBlock() {
    let t, i, s;
    const a = this.str;
    try {
      i = this.getBits(3);
    } catch (I) {
      BA(this, Li, G0).call(this, I.message);
      return;
    }
    if (i & 1 && (this.eof = !0), i >>= 1, i === 0) {
      let I;
      if ((I = a.getByte()) === -1) {
        BA(this, Li, G0).call(this, "Bad block header in flate stream");
        return;
      }
      let c = I;
      if ((I = a.getByte()) === -1) {
        BA(this, Li, G0).call(this, "Bad block header in flate stream");
        return;
      }
      if (c |= I << 8, (I = a.getByte()) === -1) {
        BA(this, Li, G0).call(this, "Bad block header in flate stream");
        return;
      }
      let l = I;
      if ((I = a.getByte()) === -1) {
        BA(this, Li, G0).call(this, "Bad block header in flate stream");
        return;
      }
      if (l |= I << 8, l !== (~c & 65535) && (c !== 0 || l !== 0))
        throw new v("Bad uncompressed block length in flate stream");
      this.codeBuf = 0, this.codeSize = 0;
      const h = this.bufferLength, C = h + c;
      if (t = this.ensureBuffer(C), this.bufferLength = C, c === 0)
        a.peekByte() === -1 && (this.eof = !0);
      else {
        const B = a.getBytes(c);
        t.set(B, h), B.length < c && (this.eof = !0);
      }
      return;
    }
    let n, r;
    if (i === 1)
      n = DC, r = kC;
    else if (i === 2) {
      const I = this.getBits(5) + 257, c = this.getBits(5) + 1, l = this.getBits(4) + 4, h = new Uint8Array(Wo.length);
      let C;
      for (C = 0; C < l; ++C)
        h[Wo[C]] = this.getBits(3);
      const B = this.generateHuffmanTable(h);
      s = 0, C = 0;
      const Q = I + c, E = new Uint8Array(Q);
      let f, d, u;
      for (; C < Q; ) {
        const x = this.getCode(B);
        if (x === 16)
          f = 2, d = 3, u = s;
        else if (x === 17)
          f = 3, d = 3, u = s = 0;
        else if (x === 18)
          f = 7, d = 11, u = s = 0;
        else {
          E[C++] = s = x;
          continue;
        }
        let m = this.getBits(f) + d;
        for (; m-- > 0; )
          E[C++] = u;
      }
      n = this.generateHuffmanTable(E.subarray(0, I)), r = this.generateHuffmanTable(E.subarray(I, Q));
    } else
      throw new v("Unknown block type in flate stream");
    t = this.buffer;
    let g = t ? t.length : 0, o = this.bufferLength;
    for (; ; ) {
      let I = this.getCode(n);
      if (I < 256) {
        o + 1 >= g && (t = this.ensureBuffer(o + 1), g = t.length), t[o++] = I;
        continue;
      }
      if (I === 256) {
        this.bufferLength = o;
        return;
      }
      I -= 257, I = wC[I];
      let c = I >> 16;
      c > 0 && (c = this.getBits(c)), s = (I & 65535) + c, I = this.getCode(r), I = bC[I], c = I >> 16, c > 0 && (c = this.getBits(c));
      const l = (I & 65535) + c;
      o + s >= g && (t = this.ensureBuffer(o + s), g = t.length);
      for (let h = 0; h < s; ++h, ++o)
        t[o] = t[o - l];
    }
  }
}
Li = new WeakSet(), G0 = function(t) {
  vA(t), this.eof = !0;
};
const SC = [{
  qe: 22017,
  nmps: 1,
  nlps: 1,
  switchFlag: 1
}, {
  qe: 13313,
  nmps: 2,
  nlps: 6,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 3,
  nlps: 9,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 4,
  nlps: 12,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 5,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 38,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 7,
  nlps: 6,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 8,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 9,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 10,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 11,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 12,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 13,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 29,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 15,
  nlps: 14,
  switchFlag: 1
}, {
  qe: 21505,
  nmps: 16,
  nlps: 14,
  switchFlag: 0
}, {
  qe: 20737,
  nmps: 17,
  nlps: 15,
  switchFlag: 0
}, {
  qe: 18433,
  nmps: 18,
  nlps: 16,
  switchFlag: 0
}, {
  qe: 14337,
  nmps: 19,
  nlps: 17,
  switchFlag: 0
}, {
  qe: 13313,
  nmps: 20,
  nlps: 18,
  switchFlag: 0
}, {
  qe: 12289,
  nmps: 21,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 10241,
  nmps: 22,
  nlps: 19,
  switchFlag: 0
}, {
  qe: 9217,
  nmps: 23,
  nlps: 20,
  switchFlag: 0
}, {
  qe: 8705,
  nmps: 24,
  nlps: 21,
  switchFlag: 0
}, {
  qe: 7169,
  nmps: 25,
  nlps: 22,
  switchFlag: 0
}, {
  qe: 6145,
  nmps: 26,
  nlps: 23,
  switchFlag: 0
}, {
  qe: 5633,
  nmps: 27,
  nlps: 24,
  switchFlag: 0
}, {
  qe: 5121,
  nmps: 28,
  nlps: 25,
  switchFlag: 0
}, {
  qe: 4609,
  nmps: 29,
  nlps: 26,
  switchFlag: 0
}, {
  qe: 4353,
  nmps: 30,
  nlps: 27,
  switchFlag: 0
}, {
  qe: 2753,
  nmps: 31,
  nlps: 28,
  switchFlag: 0
}, {
  qe: 2497,
  nmps: 32,
  nlps: 29,
  switchFlag: 0
}, {
  qe: 2209,
  nmps: 33,
  nlps: 30,
  switchFlag: 0
}, {
  qe: 1313,
  nmps: 34,
  nlps: 31,
  switchFlag: 0
}, {
  qe: 1089,
  nmps: 35,
  nlps: 32,
  switchFlag: 0
}, {
  qe: 673,
  nmps: 36,
  nlps: 33,
  switchFlag: 0
}, {
  qe: 545,
  nmps: 37,
  nlps: 34,
  switchFlag: 0
}, {
  qe: 321,
  nmps: 38,
  nlps: 35,
  switchFlag: 0
}, {
  qe: 273,
  nmps: 39,
  nlps: 36,
  switchFlag: 0
}, {
  qe: 133,
  nmps: 40,
  nlps: 37,
  switchFlag: 0
}, {
  qe: 73,
  nmps: 41,
  nlps: 38,
  switchFlag: 0
}, {
  qe: 37,
  nmps: 42,
  nlps: 39,
  switchFlag: 0
}, {
  qe: 21,
  nmps: 43,
  nlps: 40,
  switchFlag: 0
}, {
  qe: 9,
  nmps: 44,
  nlps: 41,
  switchFlag: 0
}, {
  qe: 5,
  nmps: 45,
  nlps: 42,
  switchFlag: 0
}, {
  qe: 1,
  nmps: 45,
  nlps: 43,
  switchFlag: 0
}, {
  qe: 22017,
  nmps: 46,
  nlps: 46,
  switchFlag: 0
}];
class FC {
  constructor(A, t, i) {
    this.data = A, this.bp = t, this.dataEnd = i, this.chigh = A[t], this.clow = 0, this.byteIn(), this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127, this.clow = this.clow << 7 & 65535, this.ct -= 7, this.a = 32768;
  }
  byteIn() {
    const A = this.data;
    let t = this.bp;
    A[t] === 255 ? A[t + 1] > 143 ? (this.clow += 65280, this.ct = 8) : (t++, this.clow += A[t] << 9, this.ct = 7, this.bp = t) : (t++, this.clow += t < this.dataEnd ? A[t] << 8 : 65280, this.ct = 8, this.bp = t), this.clow > 65535 && (this.chigh += this.clow >> 16, this.clow &= 65535);
  }
  readBit(A, t) {
    let i = A[t] >> 1, s = A[t] & 1;
    const a = SC[i], n = a.qe;
    let r, g = this.a - n;
    if (this.chigh < n)
      g < n ? (g = n, r = s, i = a.nmps) : (g = n, r = 1 ^ s, a.switchFlag === 1 && (s = r), i = a.nlps);
    else {
      if (this.chigh -= n, g & 32768)
        return this.a = g, s;
      g < n ? (r = 1 ^ s, a.switchFlag === 1 && (s = r), i = a.nlps) : (r = s, i = a.nmps);
    }
    do
      this.ct === 0 && this.byteIn(), g <<= 1, this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1, this.clow = this.clow << 1 & 65535, this.ct--;
    while (!(g & 32768));
    return this.a = g, A[t] = i << 1 | s, r;
  }
}
class Ce extends At {
  constructor(A) {
    super(A, "Jbig2Error");
  }
}
class RC {
  getContexts(A) {
    return A in this ? this[A] : this[A] = new Int8Array(65536);
  }
}
class Bs {
  constructor(A, t, i) {
    this.data = A, this.start = t, this.end = i;
  }
  get decoder() {
    const A = new FC(this.data, this.start, this.end);
    return iA(this, "decoder", A);
  }
  get contextCache() {
    const A = new RC();
    return iA(this, "contextCache", A);
  }
}
function je(e, A, t) {
  const i = e.getContexts(A);
  let s = 1;
  function a(o) {
    let I = 0;
    for (let c = 0; c < o; c++) {
      const l = t.readBit(i, s);
      s = s < 256 ? s << 1 | l : (s << 1 | l) & 511 | 256, I = I << 1 | l;
    }
    return I >>> 0;
  }
  const n = a(1), r = a(1) ? a(1) ? a(1) ? a(1) ? a(1) ? a(32) + 4436 : a(12) + 340 : a(8) + 84 : a(6) + 20 : a(4) + 4 : a(2);
  let g;
  return n === 0 ? g = r : r > 0 && (g = -r), g >= jh && g <= jr ? g : null;
}
function Nc(e, A, t) {
  const i = e.getContexts("IAID");
  let s = 1;
  for (let a = 0; a < t; a++) {
    const n = A.readBit(i, s);
    s = s << 1 | n;
  }
  return t < 31 ? s & (1 << t) - 1 : s & 2147483647;
}
const Vo = ["SymbolDictionary", null, null, null, "IntermediateTextRegion", null, "ImmediateTextRegion", "ImmediateLosslessTextRegion", null, null, null, null, null, null, null, null, "PatternDictionary", null, null, null, "IntermediateHalftoneRegion", null, "ImmediateHalftoneRegion", "ImmediateLosslessHalftoneRegion", null, null, null, null, null, null, null, null, null, null, null, null, "IntermediateGenericRegion", null, "ImmediateGenericRegion", "ImmediateLosslessGenericRegion", "IntermediateGenericRefinementRegion", null, "ImmediateGenericRefinementRegion", "ImmediateLosslessGenericRefinementRegion", null, null, null, null, "PageInformation", "EndOfPage", "EndOfStripe", "EndOfFile", "Profiles", "Tables", null, null, null, null, null, null, null, null, "Extension"], GC = [[{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: 2,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: 2,
  y: -1
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -1,
  y: -2
}, {
  x: 0,
  y: -2
}, {
  x: 1,
  y: -2
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}], [{
  x: -3,
  y: -1
}, {
  x: -2,
  y: -1
}, {
  x: -1,
  y: -1
}, {
  x: 0,
  y: -1
}, {
  x: 1,
  y: -1
}, {
  x: -4,
  y: 0
}, {
  x: -3,
  y: 0
}, {
  x: -2,
  y: 0
}, {
  x: -1,
  y: 0
}]], Zo = [{
  coding: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: -1,
    y: 1
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}, {
  coding: [{
    x: -1,
    y: -1
  }, {
    x: 0,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: -1,
    y: 0
  }],
  reference: [{
    x: 0,
    y: -1
  }, {
    x: -1,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 1,
    y: 0
  }, {
    x: 0,
    y: 1
  }, {
    x: 1,
    y: 1
  }]
}], NC = [39717, 1941, 229, 405];
function MC(e, A, t) {
  const i = t.decoder, s = t.contextCache.getContexts("GB"), a = [];
  let n, r, g, o, I, c, l;
  const h = 31735;
  for (r = 0; r < A; r++)
    for (I = a[r] = new Uint8Array(e), c = r < 1 ? I : a[r - 1], l = r < 2 ? I : a[r - 2], n = l[0] << 13 | l[1] << 12 | l[2] << 11 | c[0] << 7 | c[1] << 6 | c[2] << 5 | c[3] << 4, g = 0; g < e; g++)
      I[g] = o = i.readBit(s, n), n = (n & h) << 1 | (g + 3 < e ? l[g + 3] << 11 : 0) | (g + 4 < e ? c[g + 4] << 4 : 0) | o;
  return a;
}
function Ar(e, A, t, i, s, a, n, r) {
  if (e) {
    const pA = new Zs(r.data, r.start, r.end);
    return Wg(pA, A, t, !1);
  }
  if (i === 0 && !s && n.length === 4 && n[0].x === 3 && n[0].y === -1 && n[1].x === -3 && n[1].y === -1 && n[2].x === 2 && n[2].y === -2 && n[3].x === -2 && n[3].y === -2)
    return MC(A, t, r);
  const g = GC[i].concat(n);
  g.sort(function(pA, DA) {
    return pA.y - DA.y || pA.x - DA.x;
  });
  const o = g.length, I = new Int8Array(o), c = new Int8Array(o), l = [];
  let h = 0, C = 0, B = 0, Q = 0, E, f;
  for (f = 0; f < o; f++)
    I[f] = g[f].x, c[f] = g[f].y, C = Math.min(C, g[f].x), B = Math.max(B, g[f].x), Q = Math.min(Q, g[f].y), f < o - 1 && g[f].y === g[f + 1].y && g[f].x === g[f + 1].x - 1 ? h |= 1 << o - 1 - f : l.push(f);
  const d = l.length, u = new Int8Array(d), x = new Int8Array(d), m = new Uint16Array(d);
  for (E = 0; E < d; E++)
    f = l[E], u[E] = g[f].x, x[E] = g[f].y, m[E] = 1 << o - 1 - f;
  const p = -C, D = -Q, F = A - B, y = NC[i];
  let H = new Uint8Array(A);
  const N = [], T = r.decoder, _ = r.contextCache.getContexts("GB");
  let oA = 0, G, S, tA, $ = 0, hA, yA;
  for (let pA = 0; pA < t; pA++) {
    if (s) {
      const DA = T.readBit(_, y);
      if (oA ^= DA, oA) {
        N.push(H);
        continue;
      }
    }
    for (H = new Uint8Array(H), N.push(H), G = 0; G < A; G++) {
      if (G >= p && G < F && pA >= D)
        for ($ = $ << 1 & h, f = 0; f < d; f++)
          S = pA + x[f], tA = G + u[f], hA = N[S][tA], hA && (hA = m[f], $ |= hA);
      else
        for ($ = 0, yA = o - 1, f = 0; f < o; f++, yA--)
          tA = G + I[f], tA >= 0 && tA < A && (S = pA + c[f], S >= 0 && (hA = N[S][tA], hA && ($ |= hA << yA)));
      const DA = T.readBit(_, $);
      H[G] = DA;
    }
  }
  return N;
}
function Mc(e, A, t, i, s, a, n, r, g) {
  let o = Zo[t].coding;
  t === 0 && (o = o.concat([r[0]]));
  const I = o.length, c = new Int32Array(I), l = new Int32Array(I);
  let h;
  for (h = 0; h < I; h++)
    c[h] = o[h].x, l[h] = o[h].y;
  let C = Zo[t].reference;
  t === 0 && (C = C.concat([r[1]]));
  const B = C.length, Q = new Int32Array(B), E = new Int32Array(B);
  for (h = 0; h < B; h++)
    Q[h] = C[h].x, E[h] = C[h].y;
  const f = i[0].length, d = i.length, u = [], x = g.decoder, m = g.contextCache.getContexts("GR");
  for (let p = 0; p < A; p++) {
    const D = new Uint8Array(e);
    u.push(D);
    for (let F = 0; F < e; F++) {
      let y, H, N = 0;
      for (h = 0; h < I; h++)
        y = p + l[h], H = F + c[h], y < 0 || H < 0 || H >= e ? N <<= 1 : N = N << 1 | u[y][H];
      for (h = 0; h < B; h++)
        y = p + E[h] - a, H = F + Q[h] - s, y < 0 || y >= d || H < 0 || H >= f ? N <<= 1 : N = N << 1 | i[y][H];
      const T = x.readBit(m, N);
      D[F] = T;
    }
  }
  return u;
}
function UC(e, A, t, i, s, a, n, r, g, o, I, c) {
  if (e && A)
    throw new Ce("symbol refinement with Huffman is not supported");
  const l = [];
  let h = 0, C = qg(t.length + i);
  const B = I.decoder, Q = I.contextCache;
  let E, f;
  for (e && (E = Ki(1), f = [], C = Math.max(C, 1)); l.length < i; ) {
    const F = e ? a.tableDeltaHeight.decode(c) : je(Q, "IADH", B);
    h += F;
    let y = 0, H = 0;
    const N = e ? f.length : 0;
    for (; ; ) {
      const T = e ? a.tableDeltaWidth.decode(c) : je(Q, "IADW", B);
      if (T === null)
        break;
      y += T, H += y;
      let _;
      if (A) {
        const oA = je(Q, "IAAI", B);
        if (oA > 1)
          _ = Uc(e, A, y, h, 0, oA, 1, t.concat(l), C, 0, 0, 1, 0, a, g, o, I, 0, c);
        else {
          const G = Nc(Q, B, C), S = je(Q, "IARDX", B), tA = je(Q, "IARDY", B), $ = G < t.length ? t[G] : l[G - t.length];
          _ = Mc(y, h, g, $, S, tA, !1, o, I);
        }
        l.push(_);
      } else e ? f.push(y) : (_ = Ar(!1, y, h, n, !1, null, r, I), l.push(_));
    }
    if (e && !A) {
      const T = a.tableBitmapSize.decode(c);
      c.byteAlign();
      let _;
      if (T === 0)
        _ = VC(c, H, h);
      else {
        const G = c.end, S = c.position + T;
        c.end = S, _ = Wg(c, H, h, !1), c.end = G, c.position = S;
      }
      const oA = f.length;
      if (N === oA - 1)
        l.push(_);
      else {
        let G, S, tA = 0, $, hA, yA;
        for (G = N; G < oA; G++) {
          for (hA = f[G], $ = tA + hA, yA = [], S = 0; S < h; S++)
            yA.push(_[S].subarray(tA, $));
          l.push(yA), tA = $;
        }
      }
    }
  }
  const d = [], u = [];
  let x = !1, m, p;
  const D = t.length + i;
  for (; u.length < D; ) {
    let F = e ? E.decode(c) : je(Q, "IAEX", B);
    for (; F--; )
      u.push(x);
    x = !x;
  }
  for (m = 0, p = t.length; m < p; m++)
    u[m] && d.push(t[m]);
  for (let F = 0; F < i; m++, F++)
    u[m] && d.push(l[F]);
  return d;
}
function Uc(e, A, t, i, s, a, n, r, g, o, I, c, l, h, C, B, Q, E, f) {
  if (e && A)
    throw new Ce("refinement with Huffman is not supported");
  const d = [];
  let u, x;
  for (u = 0; u < i; u++) {
    if (x = new Uint8Array(t), s)
      for (let y = 0; y < t; y++)
        x[y] = s;
    d.push(x);
  }
  const m = Q.decoder, p = Q.contextCache;
  let D = e ? -h.tableDeltaT.decode(f) : -je(p, "IADT", m), F = 0;
  for (u = 0; u < a; ) {
    const y = e ? h.tableDeltaT.decode(f) : je(p, "IADT", m);
    D += y;
    const H = e ? h.tableFirstS.decode(f) : je(p, "IAFS", m);
    F += H;
    let N = F;
    do {
      let T = 0;
      n > 1 && (T = e ? f.readBits(E) : je(p, "IAIT", m));
      const _ = n * D + T, oA = e ? h.symbolIDTable.decode(f) : Nc(p, m, g), G = A && (e ? f.readBit() : je(p, "IARI", m));
      let S = r[oA], tA = S[0].length, $ = S.length;
      if (G) {
        const U = je(p, "IARDW", m), J = je(p, "IARDH", m), q = je(p, "IARDX", m), Z = je(p, "IARDY", m);
        tA += U, $ += J, S = Mc(tA, $, C, S, (U >> 1) + q, (J >> 1) + Z, !1, B, Q);
      }
      let hA = 0;
      o ? c & 1 ? hA = $ - 1 : N += $ - 1 : c > 1 ? N += tA - 1 : hA = tA - 1;
      const yA = _ - (c & 1 ? 0 : $ - 1), pA = N - (c & 2 ? tA - 1 : 0);
      let DA, X, qA;
      if (o)
        for (DA = 0; DA < $; DA++) {
          if (x = d[pA + DA], !x)
            continue;
          qA = S[DA];
          const U = Math.min(t - yA, tA);
          switch (l) {
            case 0:
              for (X = 0; X < U; X++)
                x[yA + X] |= qA[X];
              break;
            case 2:
              for (X = 0; X < U; X++)
                x[yA + X] ^= qA[X];
              break;
            default:
              throw new Ce(`operator ${l} is not supported`);
          }
        }
      else
        for (X = 0; X < $; X++)
          if (x = d[yA + X], !!x)
            switch (qA = S[X], l) {
              case 0:
                for (DA = 0; DA < tA; DA++)
                  x[pA + DA] |= qA[DA];
                break;
              case 2:
                for (DA = 0; DA < tA; DA++)
                  x[pA + DA] ^= qA[DA];
                break;
              default:
                throw new Ce(`operator ${l} is not supported`);
            }
      u++;
      const IA = e ? h.tableDeltaS.decode(f) : je(p, "IADS", m);
      if (IA === null)
        break;
      N += hA + IA + I;
    } while (!0);
  }
  return d;
}
function LC(e, A, t, i, s, a) {
  const n = [];
  e || (n.push({
    x: -A,
    y: 0
  }), s === 0 && n.push({
    x: -3,
    y: -1
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -2
  }));
  const r = (i + 1) * A, g = Ar(e, r, t, s, !1, null, n, a), o = [];
  for (let I = 0; I <= i; I++) {
    const c = [], l = A * I, h = l + A;
    for (let C = 0; C < t; C++)
      c.push(g[C].subarray(l, h));
    o.push(c);
  }
  return o;
}
function HC(e, A, t, i, s, a, n, r, g, o, I, c, l, h, C) {
  if (n)
    throw new Ce("skip is not supported");
  if (r !== 0)
    throw new Ce(`operator "${r}" is not supported in halftone region`);
  const Q = [];
  let E, f, d;
  for (E = 0; E < s; E++) {
    if (d = new Uint8Array(i), a)
      for (f = 0; f < i; f++)
        d[f] = a;
    Q.push(d);
  }
  const u = A.length, x = A[0], m = x[0].length, p = x.length, D = qg(u), F = [];
  e || (F.push({
    x: t <= 1 ? 3 : 2,
    y: -1
  }), t === 0 && F.push({
    x: -3,
    y: -1
  }, {
    x: 2,
    y: -2
  }, {
    x: -2,
    y: -2
  }));
  const y = [];
  let H, N;
  for (e && (H = new Zs(C.data, C.start, C.end)), E = D - 1; E >= 0; E--)
    e ? N = Wg(H, g, o, !0) : N = Ar(!1, g, o, t, !1, null, F, C), y[E] = N;
  let T, _, oA, G, S, tA, $, hA, yA;
  for (T = 0; T < o; T++)
    for (_ = 0; _ < g; _++) {
      for (oA = 0, G = 0, f = D - 1; f >= 0; f--)
        oA ^= y[f][T][_], G |= oA << f;
      if (S = A[G], tA = I + T * h + _ * l >> 8, $ = c + T * l - _ * h >> 8, tA >= 0 && tA + m <= i && $ >= 0 && $ + p <= s)
        for (E = 0; E < p; E++)
          for (yA = Q[$ + E], hA = S[E], f = 0; f < m; f++)
            yA[tA + f] |= hA[f];
      else {
        let pA, DA;
        for (E = 0; E < p; E++)
          if (DA = $ + E, !(DA < 0 || DA >= s))
            for (yA = Q[DA], hA = S[E], f = 0; f < m; f++)
              pA = tA + f, pA >= 0 && pA < i && (yA[pA] |= hA[f]);
      }
    }
  return Q;
}
function JC(e, A) {
  const t = {};
  t.number = ce(e, A);
  const i = e[A + 4], s = i & 63;
  if (!Vo[s])
    throw new Ce("invalid segment type: " + s);
  t.type = s, t.typeName = Vo[s], t.deferredNonRetain = !!(i & 128);
  const a = !!(i & 64), n = e[A + 5];
  let r = n >> 5 & 7;
  const g = [n & 31];
  let o = A + 6;
  if (n === 7) {
    r = ce(e, o - 1) & 536870911, o += 3;
    let C = r + 7 >> 3;
    for (g[0] = e[o++]; --C > 0; )
      g.push(e[o++]);
  } else if (n === 5 || n === 6)
    throw new Ce("invalid referred-to flags");
  t.retainBits = g;
  let I = 4;
  t.number <= 256 ? I = 1 : t.number <= 65536 && (I = 2);
  const c = [];
  let l, h;
  for (l = 0; l < r; l++) {
    let C;
    I === 1 ? C = e[o] : I === 2 ? C = Ie(e, o) : C = ce(e, o), c.push(C), o += I;
  }
  if (t.referredTo = c, a ? (t.pageAssociation = ce(e, o), o += 4) : t.pageAssociation = e[o++], t.length = ce(e, o), o += 4, t.length === 4294967295)
    if (s === 38) {
      const C = ln(e, o), Q = !!(e[o + hn] & 1), E = 6, f = new Uint8Array(E);
      for (Q || (f[0] = 255, f[1] = 172), f[2] = C.height >>> 24 & 255, f[3] = C.height >> 16 & 255, f[4] = C.height >> 8 & 255, f[5] = C.height & 255, l = o, h = e.length; l < h; l++) {
        let d = 0;
        for (; d < E && f[d] === e[l + d]; )
          d++;
        if (d === E) {
          t.length = l + E;
          break;
        }
      }
      if (t.length === 4294967295)
        throw new Ce("segment end was not found");
    } else
      throw new Ce("invalid unknown segment length");
  return t.headerEnd = o, t;
}
function YC(e, A, t, i) {
  const s = [];
  let a = t;
  for (; a < i; ) {
    const n = JC(A, a);
    a = n.headerEnd;
    const r = {
      header: n,
      data: A
    };
    if (e.randomAccess || (r.start = a, a += n.length, r.end = a), s.push(r), n.type === 51)
      break;
  }
  if (e.randomAccess)
    for (let n = 0, r = s.length; n < r; n++)
      s[n].start = a, a += s[n].header.length, s[n].end = a;
  return s;
}
function ln(e, A) {
  return {
    width: ce(e, A),
    height: ce(e, A + 4),
    x: ce(e, A + 8),
    y: ce(e, A + 12),
    combinationOperator: e[A + 16] & 7
  };
}
const hn = 17;
function KC(e, A) {
  const t = e.header, i = e.data, s = e.end;
  let a = e.start, n, r, g, o;
  switch (t.type) {
    case 0:
      const c = {}, l = Ie(i, a);
      if (c.huffman = !!(l & 1), c.refinement = !!(l & 2), c.huffmanDHSelector = l >> 2 & 3, c.huffmanDWSelector = l >> 4 & 3, c.bitmapSizeSelector = l >> 6 & 1, c.aggregationInstancesSelector = l >> 7 & 1, c.bitmapCodingContextUsed = !!(l & 256), c.bitmapCodingContextRetained = !!(l & 512), c.template = l >> 10 & 3, c.refinementTemplate = l >> 12 & 1, a += 2, !c.huffman) {
        for (o = c.template === 0 ? 4 : 1, r = [], g = 0; g < o; g++)
          r.push({
            x: bi(i, a),
            y: bi(i, a + 1)
          }), a += 2;
        c.at = r;
      }
      if (c.refinement && !c.refinementTemplate) {
        for (r = [], g = 0; g < 2; g++)
          r.push({
            x: bi(i, a),
            y: bi(i, a + 1)
          }), a += 2;
        c.refinementAt = r;
      }
      c.numberOfExportedSymbols = ce(i, a), a += 4, c.numberOfNewSymbols = ce(i, a), a += 4, n = [c, t.number, t.referredTo, i, a, s];
      break;
    case 6:
    case 7:
      const h = {};
      h.info = ln(i, a), a += hn;
      const C = Ie(i, a);
      if (a += 2, h.huffman = !!(C & 1), h.refinement = !!(C & 2), h.logStripSize = C >> 2 & 3, h.stripSize = 1 << h.logStripSize, h.referenceCorner = C >> 4 & 3, h.transposed = !!(C & 64), h.combinationOperator = C >> 7 & 3, h.defaultPixelValue = C >> 9 & 1, h.dsOffset = C << 17 >> 27, h.refinementTemplate = C >> 15 & 1, h.huffman) {
        const p = Ie(i, a);
        a += 2, h.huffmanFS = p & 3, h.huffmanDS = p >> 2 & 3, h.huffmanDT = p >> 4 & 3, h.huffmanRefinementDW = p >> 6 & 3, h.huffmanRefinementDH = p >> 8 & 3, h.huffmanRefinementDX = p >> 10 & 3, h.huffmanRefinementDY = p >> 12 & 3, h.huffmanRefinementSizeSelector = !!(p & 16384);
      }
      if (h.refinement && !h.refinementTemplate) {
        for (r = [], g = 0; g < 2; g++)
          r.push({
            x: bi(i, a),
            y: bi(i, a + 1)
          }), a += 2;
        h.refinementAt = r;
      }
      h.numberOfSymbolInstances = ce(i, a), a += 4, n = [h, t.referredTo, i, a, s];
      break;
    case 16:
      const B = {}, Q = i[a++];
      B.mmr = !!(Q & 1), B.template = Q >> 1 & 3, B.patternWidth = i[a++], B.patternHeight = i[a++], B.maxPatternIndex = ce(i, a), a += 4, n = [B, t.number, i, a, s];
      break;
    case 22:
    case 23:
      const E = {};
      E.info = ln(i, a), a += hn;
      const f = i[a++];
      E.mmr = !!(f & 1), E.template = f >> 1 & 3, E.enableSkip = !!(f & 8), E.combinationOperator = f >> 4 & 7, E.defaultPixelValue = f >> 7 & 1, E.gridWidth = ce(i, a), a += 4, E.gridHeight = ce(i, a), a += 4, E.gridOffsetX = ce(i, a) & 4294967295, a += 4, E.gridOffsetY = ce(i, a) & 4294967295, a += 4, E.gridVectorX = Ie(i, a), a += 2, E.gridVectorY = Ie(i, a), a += 2, n = [E, t.referredTo, i, a, s];
      break;
    case 38:
    case 39:
      const d = {};
      d.info = ln(i, a), a += hn;
      const u = i[a++];
      if (d.mmr = !!(u & 1), d.template = u >> 1 & 3, d.prediction = !!(u & 8), !d.mmr) {
        for (o = d.template === 0 ? 4 : 1, r = [], g = 0; g < o; g++)
          r.push({
            x: bi(i, a),
            y: bi(i, a + 1)
          }), a += 2;
        d.at = r;
      }
      n = [d, i, a, s];
      break;
    case 48:
      const x = {
        width: ce(i, a),
        height: ce(i, a + 4),
        resolutionX: ce(i, a + 8),
        resolutionY: ce(i, a + 12)
      };
      x.height === 4294967295 && delete x.height;
      const m = i[a + 16];
      Ie(i, a + 17), x.lossless = !!(m & 1), x.refinement = !!(m & 2), x.defaultPixelValue = m >> 2 & 1, x.combinationOperator = m >> 3 & 3, x.requiresBuffer = !!(m & 32), x.combinationOperatorOverride = !!(m & 64), n = [x];
      break;
    case 49:
      break;
    case 50:
      break;
    case 51:
      break;
    case 53:
      n = [t.number, i, a, s];
      break;
    case 62:
      break;
    default:
      throw new Ce(`segment type ${t.typeName}(${t.type}) is not implemented`);
  }
  const I = "on" + t.typeName;
  I in A && A[I].apply(A, n);
}
function vC(e, A) {
  for (let t = 0, i = e.length; t < i; t++)
    KC(e[t], A);
}
function TC(e) {
  const A = new qC();
  for (let t = 0, i = e.length; t < i; t++) {
    const s = e[t], a = YC({}, s.data, s.start, s.end);
    vC(a, A);
  }
  return A.buffer;
}
class qC {
  onPageInformation(A) {
    this.currentPageInfo = A;
    const t = A.width + 7 >> 3, i = new Uint8ClampedArray(t * A.height);
    A.defaultPixelValue && i.fill(255), this.buffer = i;
  }
  drawBitmap(A, t) {
    const i = this.currentPageInfo, s = A.width, a = A.height, n = i.width + 7 >> 3, r = i.combinationOperatorOverride ? A.combinationOperator : i.combinationOperator, g = this.buffer, o = 128 >> (A.x & 7);
    let I = A.y * n + (A.x >> 3), c, l, h, C;
    switch (r) {
      case 0:
        for (c = 0; c < a; c++) {
          for (h = o, C = I, l = 0; l < s; l++)
            t[c][l] && (g[C] |= h), h >>= 1, h || (h = 128, C++);
          I += n;
        }
        break;
      case 2:
        for (c = 0; c < a; c++) {
          for (h = o, C = I, l = 0; l < s; l++)
            t[c][l] && (g[C] ^= h), h >>= 1, h || (h = 128, C++);
          I += n;
        }
        break;
      default:
        throw new Ce(`operator ${r} is not supported`);
    }
  }
  onImmediateGenericRegion(A, t, i, s) {
    const a = A.info, n = new Bs(t, i, s), r = Ar(A.mmr, a.width, a.height, A.template, A.prediction, null, A.at, n);
    this.drawBitmap(a, r);
  }
  onImmediateLosslessGenericRegion() {
    this.onImmediateGenericRegion(...arguments);
  }
  onSymbolDictionary(A, t, i, s, a, n) {
    let r, g;
    A.huffman && (r = OC(A, i, this.customTables), g = new Zs(s, a, n));
    let o = this.symbols;
    o || (this.symbols = o = {});
    const I = [];
    for (const l of i) {
      const h = o[l];
      h && I.push(...h);
    }
    const c = new Bs(s, a, n);
    o[t] = UC(A.huffman, A.refinement, I, A.numberOfNewSymbols, A.numberOfExportedSymbols, r, A.template, A.at, A.refinementTemplate, A.refinementAt, c, g);
  }
  onImmediateTextRegion(A, t, i, s, a) {
    const n = A.info;
    let r, g;
    const o = this.symbols, I = [];
    for (const C of t) {
      const B = o[C];
      B && I.push(...B);
    }
    const c = qg(I.length);
    A.huffman && (g = new Zs(i, s, a), r = WC(A, t, this.customTables, I.length, g));
    const l = new Bs(i, s, a), h = Uc(A.huffman, A.refinement, n.width, n.height, A.defaultPixelValue, A.numberOfSymbolInstances, A.stripSize, I, c, A.transposed, A.dsOffset, A.referenceCorner, A.combinationOperator, r, A.refinementTemplate, A.refinementAt, l, A.logStripSize, g);
    this.drawBitmap(n, h);
  }
  onImmediateLosslessTextRegion() {
    this.onImmediateTextRegion(...arguments);
  }
  onPatternDictionary(A, t, i, s, a) {
    let n = this.patterns;
    n || (this.patterns = n = {});
    const r = new Bs(i, s, a);
    n[t] = LC(A.mmr, A.patternWidth, A.patternHeight, A.maxPatternIndex, A.template, r);
  }
  onImmediateHalftoneRegion(A, t, i, s, a) {
    const n = this.patterns[t[0]], r = A.info, g = new Bs(i, s, a), o = HC(A.mmr, n, A.template, r.width, r.height, A.defaultPixelValue, A.enableSkip, A.combinationOperator, A.gridWidth, A.gridHeight, A.gridOffsetX, A.gridOffsetY, A.gridVectorX, A.gridVectorY, g);
    this.drawBitmap(r, o);
  }
  onImmediateLosslessHalftoneRegion() {
    this.onImmediateHalftoneRegion(...arguments);
  }
  onTables(A, t, i, s) {
    let a = this.customTables;
    a || (this.customTables = a = {}), a[A] = PC(t, i, s);
  }
}
class Yi {
  constructor(A) {
    A.length === 2 ? (this.isOOB = !0, this.rangeLow = 0, this.prefixLength = A[0], this.rangeLength = 0, this.prefixCode = A[1], this.isLowerRange = !1) : (this.isOOB = !1, this.rangeLow = A[0], this.prefixLength = A[1], this.rangeLength = A[2], this.prefixCode = A[3], this.isLowerRange = A[4] === "lower");
  }
}
class bn {
  constructor(A) {
    this.children = [], A ? (this.isLeaf = !0, this.rangeLength = A.rangeLength, this.rangeLow = A.rangeLow, this.isLowerRange = A.isLowerRange, this.isOOB = A.isOOB) : this.isLeaf = !1;
  }
  buildTree(A, t) {
    const i = A.prefixCode >> t & 1;
    if (t <= 0)
      this.children[i] = new bn(A);
    else {
      let s = this.children[i];
      s || (this.children[i] = s = new bn(null)), s.buildTree(A, t - 1);
    }
  }
  decodeNode(A) {
    if (this.isLeaf) {
      if (this.isOOB)
        return null;
      const i = A.readBits(this.rangeLength);
      return this.rangeLow + (this.isLowerRange ? -i : i);
    }
    const t = this.children[A.readBit()];
    if (!t)
      throw new Ce("invalid Huffman data");
    return t.decodeNode(A);
  }
}
class Dn {
  constructor(A, t) {
    t || this.assignPrefixCodes(A), this.rootNode = new bn(null);
    for (let i = 0, s = A.length; i < s; i++) {
      const a = A[i];
      a.prefixLength > 0 && this.rootNode.buildTree(a, a.prefixLength - 1);
    }
  }
  decode(A) {
    return this.rootNode.decodeNode(A);
  }
  assignPrefixCodes(A) {
    const t = A.length;
    let i = 0;
    for (let I = 0; I < t; I++)
      i = Math.max(i, A[I].prefixLength);
    const s = new Uint32Array(i + 1);
    for (let I = 0; I < t; I++)
      s[A[I].prefixLength]++;
    let a = 1, n = 0, r, g, o;
    for (s[0] = 0; a <= i; ) {
      for (n = n + s[a - 1] << 1, r = n, g = 0; g < t; )
        o = A[g], o.prefixLength === a && (o.prefixCode = r, r++), g++;
      a++;
    }
  }
}
function PC(e, A, t) {
  const i = e[A], s = ce(e, A + 1) & 4294967295, a = ce(e, A + 5) & 4294967295, n = new Zs(e, A + 9, t), r = (i >> 1 & 7) + 1, g = (i >> 4 & 7) + 1, o = [];
  let I, c, l = s;
  do
    I = n.readBits(r), c = n.readBits(g), o.push(new Yi([l, I, c, 0])), l += 1 << c;
  while (l < a);
  return I = n.readBits(r), o.push(new Yi([s - 1, I, 32, 0, "lower"])), I = n.readBits(r), o.push(new Yi([a, I, 32, 0])), i & 1 && (I = n.readBits(r), o.push(new Yi([I, 0]))), new Dn(o, !1);
}
const jo = {};
function Ki(e) {
  let A = jo[e];
  if (A)
    return A;
  let t;
  switch (e) {
    case 1:
      t = [[0, 1, 4, 0], [16, 2, 8, 2], [272, 3, 16, 6], [65808, 3, 32, 7]];
      break;
    case 2:
      t = [[0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [75, 6, 32, 62], [6, 63]];
      break;
    case 3:
      t = [[-256, 8, 8, 254], [0, 1, 0, 0], [1, 2, 0, 2], [2, 3, 0, 6], [3, 4, 3, 14], [11, 5, 6, 30], [-257, 8, 32, 255, "lower"], [75, 7, 32, 126], [6, 62]];
      break;
    case 4:
      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [76, 5, 32, 31]];
      break;
    case 5:
      t = [[-255, 7, 8, 126], [1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 0, 6], [4, 4, 3, 14], [12, 5, 6, 30], [-256, 7, 32, 127, "lower"], [76, 6, 32, 62]];
      break;
    case 6:
      t = [[-2048, 5, 10, 28], [-1024, 4, 9, 8], [-512, 4, 8, 9], [-256, 4, 7, 10], [-128, 5, 6, 29], [-64, 5, 5, 30], [-32, 4, 5, 11], [0, 2, 7, 0], [128, 3, 7, 2], [256, 3, 8, 3], [512, 4, 9, 12], [1024, 4, 10, 13], [-2049, 6, 32, 62, "lower"], [2048, 6, 32, 63]];
      break;
    case 7:
      t = [[-1024, 4, 9, 8], [-512, 3, 8, 0], [-256, 4, 7, 9], [-128, 5, 6, 26], [-64, 5, 5, 27], [-32, 4, 5, 10], [0, 4, 5, 11], [32, 5, 5, 28], [64, 5, 6, 29], [128, 4, 7, 12], [256, 3, 8, 1], [512, 3, 9, 2], [1024, 3, 10, 3], [-1025, 5, 32, 30, "lower"], [2048, 5, 32, 31]];
      break;
    case 8:
      t = [[-15, 8, 3, 252], [-7, 9, 1, 508], [-5, 8, 1, 253], [-3, 9, 0, 509], [-2, 7, 0, 124], [-1, 4, 0, 10], [0, 2, 1, 0], [2, 5, 0, 26], [3, 6, 0, 58], [4, 3, 4, 4], [20, 6, 1, 59], [22, 4, 4, 11], [38, 4, 5, 12], [70, 5, 6, 27], [134, 5, 7, 28], [262, 6, 7, 60], [390, 7, 8, 125], [646, 6, 10, 61], [-16, 9, 32, 510, "lower"], [1670, 9, 32, 511], [2, 1]];
      break;
    case 9:
      t = [[-31, 8, 4, 252], [-15, 9, 2, 508], [-11, 8, 2, 253], [-7, 9, 1, 509], [-5, 7, 1, 124], [-3, 4, 1, 10], [-1, 3, 1, 2], [1, 3, 1, 3], [3, 5, 1, 26], [5, 6, 1, 58], [7, 3, 5, 4], [39, 6, 2, 59], [43, 4, 5, 11], [75, 4, 6, 12], [139, 5, 7, 27], [267, 5, 8, 28], [523, 6, 8, 60], [779, 7, 9, 125], [1291, 6, 11, 61], [-32, 9, 32, 510, "lower"], [3339, 9, 32, 511], [2, 0]];
      break;
    case 10:
      t = [[-21, 7, 4, 122], [-5, 8, 0, 252], [-4, 7, 0, 123], [-3, 5, 0, 24], [-2, 2, 2, 0], [2, 5, 0, 25], [3, 6, 0, 54], [4, 7, 0, 124], [5, 8, 0, 253], [6, 2, 6, 1], [70, 5, 5, 26], [102, 6, 5, 55], [134, 6, 6, 56], [198, 6, 7, 57], [326, 6, 8, 58], [582, 6, 9, 59], [1094, 6, 10, 60], [2118, 7, 11, 125], [-22, 8, 32, 254, "lower"], [4166, 8, 32, 255], [2, 2]];
      break;
    case 11:
      t = [[1, 1, 0, 0], [2, 2, 1, 2], [4, 4, 0, 12], [5, 4, 1, 13], [7, 5, 1, 28], [9, 5, 2, 29], [13, 6, 2, 60], [17, 7, 2, 122], [21, 7, 3, 123], [29, 7, 4, 124], [45, 7, 5, 125], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 12:
      t = [[1, 1, 0, 0], [2, 2, 0, 2], [3, 3, 1, 6], [5, 5, 0, 28], [6, 5, 1, 29], [8, 6, 1, 60], [10, 7, 0, 122], [11, 7, 1, 123], [13, 7, 2, 124], [17, 7, 3, 125], [25, 7, 4, 126], [41, 8, 5, 254], [73, 8, 32, 255]];
      break;
    case 13:
      t = [[1, 1, 0, 0], [2, 3, 0, 4], [3, 4, 0, 12], [4, 5, 0, 28], [5, 4, 1, 13], [7, 3, 3, 5], [15, 6, 1, 58], [17, 6, 2, 59], [21, 6, 3, 60], [29, 6, 4, 61], [45, 6, 5, 62], [77, 7, 6, 126], [141, 7, 32, 127]];
      break;
    case 14:
      t = [[-2, 3, 0, 4], [-1, 3, 0, 5], [0, 1, 0, 0], [1, 3, 0, 6], [2, 3, 0, 7]];
      break;
    case 15:
      t = [[-24, 7, 4, 124], [-8, 6, 2, 60], [-4, 5, 1, 28], [-2, 4, 0, 12], [-1, 3, 0, 4], [0, 1, 0, 0], [1, 3, 0, 5], [2, 4, 0, 13], [3, 5, 1, 29], [5, 6, 2, 61], [9, 7, 4, 125], [-25, 7, 32, 126, "lower"], [25, 7, 32, 127]];
      break;
    default:
      throw new Ce(`standard table B.${e} does not exist`);
  }
  for (let i = 0, s = t.length; i < s; i++)
    t[i] = new Yi(t[i]);
  return A = new Dn(t, !0), jo[e] = A, A;
}
class Zs {
  constructor(A, t, i) {
    this.data = A, this.start = t, this.end = i, this.position = t, this.shift = -1, this.currentByte = 0;
  }
  readBit() {
    if (this.shift < 0) {
      if (this.position >= this.end)
        throw new Ce("end of data while reading bit");
      this.currentByte = this.data[this.position++], this.shift = 7;
    }
    const A = this.currentByte >> this.shift & 1;
    return this.shift--, A;
  }
  readBits(A) {
    let t = 0, i;
    for (i = A - 1; i >= 0; i--)
      t |= this.readBit() << i;
    return t;
  }
  byteAlign() {
    this.shift = -1;
  }
  next() {
    return this.position >= this.end ? -1 : this.data[this.position++];
  }
}
function r0(e, A, t) {
  let i = 0;
  for (let s = 0, a = A.length; s < a; s++) {
    const n = t[A[s]];
    if (n) {
      if (e === i)
        return n;
      i++;
    }
  }
  throw new Ce("can't find custom Huffman table");
}
function WC(e, A, t, i, s) {
  const a = [];
  for (let l = 0; l <= 34; l++) {
    const h = s.readBits(4);
    a.push(new Yi([l, h, 0, 0]));
  }
  const n = new Dn(a, !1);
  a.length = 0;
  for (let l = 0; l < i; ) {
    const h = n.decode(s);
    if (h >= 32) {
      let C, B, Q;
      switch (h) {
        case 32:
          if (l === 0)
            throw new Ce("no previous value in symbol ID table");
          B = s.readBits(2) + 3, C = a[l - 1].prefixLength;
          break;
        case 33:
          B = s.readBits(3) + 3, C = 0;
          break;
        case 34:
          B = s.readBits(7) + 11, C = 0;
          break;
        default:
          throw new Ce("invalid code length in symbol ID table");
      }
      for (Q = 0; Q < B; Q++)
        a.push(new Yi([l, C, 0, 0])), l++;
    } else
      a.push(new Yi([l, h, 0, 0])), l++;
  }
  s.byteAlign();
  const r = new Dn(a, !1);
  let g = 0, o, I, c;
  switch (e.huffmanFS) {
    case 0:
    case 1:
      o = Ki(e.huffmanFS + 6);
      break;
    case 3:
      o = r0(g, A, t), g++;
      break;
    default:
      throw new Ce("invalid Huffman FS selector");
  }
  switch (e.huffmanDS) {
    case 0:
    case 1:
    case 2:
      I = Ki(e.huffmanDS + 8);
      break;
    case 3:
      I = r0(g, A, t), g++;
      break;
    default:
      throw new Ce("invalid Huffman DS selector");
  }
  switch (e.huffmanDT) {
    case 0:
    case 1:
    case 2:
      c = Ki(e.huffmanDT + 11);
      break;
    case 3:
      c = r0(g, A, t), g++;
      break;
    default:
      throw new Ce("invalid Huffman DT selector");
  }
  if (e.refinement)
    throw new Ce("refinement with Huffman is not supported");
  return {
    symbolIDTable: r,
    tableFirstS: o,
    tableDeltaS: I,
    tableDeltaT: c
  };
}
function OC(e, A, t) {
  let i = 0, s, a;
  switch (e.huffmanDHSelector) {
    case 0:
    case 1:
      s = Ki(e.huffmanDHSelector + 4);
      break;
    case 3:
      s = r0(i, A, t), i++;
      break;
    default:
      throw new Ce("invalid Huffman DH selector");
  }
  switch (e.huffmanDWSelector) {
    case 0:
    case 1:
      a = Ki(e.huffmanDWSelector + 2);
      break;
    case 3:
      a = r0(i, A, t), i++;
      break;
    default:
      throw new Ce("invalid Huffman DW selector");
  }
  let n, r;
  return e.bitmapSizeSelector ? (n = r0(i, A, t), i++) : n = Ki(1), e.aggregationInstancesSelector ? r = r0(i, A, t) : r = Ki(1), {
    tableDeltaHeight: s,
    tableDeltaWidth: a,
    tableBitmapSize: n,
    tableAggregateInstances: r
  };
}
function VC(e, A, t) {
  const i = [];
  for (let s = 0; s < t; s++) {
    const a = new Uint8Array(A);
    i.push(a);
    for (let n = 0; n < A; n++)
      a[n] = e.readBit();
    e.byteAlign();
  }
  return i;
}
function Wg(e, A, t, i) {
  const s = {
    K: -1,
    Columns: A,
    Rows: t,
    BlackIs1: !0,
    EndOfBlock: i
  }, a = new Gc(e, s), n = [];
  let r, g = !1;
  for (let o = 0; o < t; o++) {
    const I = new Uint8Array(A);
    n.push(I);
    let c = -1;
    for (let l = 0; l < A; l++)
      c < 0 && (r = a.readNextChar(), r === -1 && (r = 0, g = !0), c = 7), I[l] = r >> c & 1, c--;
  }
  if (i && !g)
    for (let I = 0; I < 5 && a.readNextChar() !== -1; I++)
      ;
  return n;
}
class ZC {
  parseChunks(A) {
    return TC(A);
  }
  parse(A) {
    throw new Error("Not implemented: Jbig2Image.parse");
  }
}
class jC extends $e {
  constructor(A, t, i) {
    super(t), this.stream = A, this.dict = A.dict, this.maybeLength = t, this.params = i;
  }
  get bytes() {
    return iA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(A) {
  }
  readBlock() {
    this.decodeImage();
  }
  decodeImage(A) {
    if (this.eof)
      return this.buffer;
    A || (A = this.bytes);
    const t = new ZC(), i = [];
    if (this.params instanceof R) {
      const n = this.params.get("JBIG2Globals");
      if (n instanceof JA) {
        const r = n.getBytes();
        i.push({
          data: r,
          start: 0,
          end: r.length
        });
      }
    }
    i.push({
      data: A,
      start: 0,
      end: A.length
    });
    const s = t.parseChunks(i), a = s.length;
    for (let n = 0; n < a; n++)
      s[n] ^= 255;
    return this.buffer = s, this.bufferLength = a, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
function Lc(e) {
  switch (e.kind) {
    case Ue.GRAYSCALE_1BPP:
      return gg(e);
    case Ue.RGB_24BPP:
      return XC(e);
  }
  return null;
}
function gg({
  src: e,
  srcPos: A = 0,
  dest: t,
  width: i,
  height: s,
  nonBlackColor: a = 4294967295,
  inverseDecode: n = !1
}) {
  const r = ht.isLittleEndian ? 4278190080 : 255, [g, o] = n ? [a, r] : [r, a], I = i >> 3, c = i & 7, l = e.length;
  t = new Uint32Array(t.buffer);
  let h = 0;
  for (let C = 0; C < s; C++) {
    for (const Q = A + I; A < Q; A++) {
      const E = A < l ? e[A] : 255;
      t[h++] = E & 128 ? o : g, t[h++] = E & 64 ? o : g, t[h++] = E & 32 ? o : g, t[h++] = E & 16 ? o : g, t[h++] = E & 8 ? o : g, t[h++] = E & 4 ? o : g, t[h++] = E & 2 ? o : g, t[h++] = E & 1 ? o : g;
    }
    if (c === 0)
      continue;
    const B = A < l ? e[A++] : 255;
    for (let Q = 0; Q < c; Q++)
      t[h++] = B & 1 << 7 - Q ? o : g;
  }
  return {
    srcPos: A,
    destPos: h
  };
}
function XC({
  src: e,
  srcPos: A = 0,
  dest: t,
  destPos: i = 0,
  width: s,
  height: a
}) {
  let n = 0;
  const r = s * a * 3, g = r >> 2, o = new Uint32Array(e.buffer, A, g);
  if (ht.isLittleEndian) {
    for (; n < g - 2; n += 3, i += 4) {
      const I = o[n], c = o[n + 1], l = o[n + 2];
      t[i] = I | 4278190080, t[i + 1] = I >>> 24 | c << 8 | 4278190080, t[i + 2] = c >>> 16 | l << 16 | 4278190080, t[i + 3] = l >>> 8 | 4278190080;
    }
    for (let I = n * 4, c = A + r; I < c; I += 3)
      t[i++] = e[I] | e[I + 1] << 8 | e[I + 2] << 16 | 4278190080;
  } else {
    for (; n < g - 2; n += 3, i += 4) {
      const I = o[n], c = o[n + 1], l = o[n + 2];
      t[i] = I | 255, t[i + 1] = I << 24 | c >>> 8 | 255, t[i + 2] = c << 16 | l >>> 16 | 255, t[i + 3] = l << 8 | 255;
    }
    for (let I = n * 4, c = A + r; I < c; I += 3)
      t[i++] = e[I] << 24 | e[I + 1] << 16 | e[I + 2] << 8 | 255;
  }
  return {
    srcPos: A + r,
    destPos: i
  };
}
function _C(e, A) {
  if (ht.isLittleEndian)
    for (let t = 0, i = e.length; t < i; t++)
      A[t] = e[t] * 65793 | 4278190080;
  else
    for (let t = 0, i = e.length; t < i; t++)
      A[t] = e[t] * 16843008 | 255;
}
class Kt extends At {
  constructor(A) {
    super(A, "JpegError");
  }
}
class og extends At {
  constructor(A, t) {
    super(A, "DNLMarkerError"), this.scanLines = t;
  }
}
class Hc extends At {
  constructor(A) {
    super(A, "EOIMarkerError");
  }
}
const Ls = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), La = 4017, Ha = 799, Ja = 3406, Ya = 2276, Ka = 1567, va = 3784, p0 = 5793, Ta = 2896;
function zC(e, A) {
  let t = 0, i, s, a = 16;
  for (; a > 0 && !e[a - 1]; )
    a--;
  const n = [{
    children: [],
    index: 0
  }];
  let r = n[0], g;
  for (i = 0; i < a; i++) {
    for (s = 0; s < e[i]; s++) {
      for (r = n.pop(), r.children[r.index] = A[t]; r.index > 0; )
        r = n.pop();
      for (r.index++, n.push(r); n.length <= i; )
        n.push(g = {
          children: [],
          index: 0
        }), r.children[r.index] = g.children, r = g;
      t++;
    }
    i + 1 < a && (n.push(g = {
      children: [],
      index: 0
    }), r.children[r.index] = g.children, r = g);
  }
  return n[0].children;
}
function Ig(e, A, t) {
  return 64 * ((e.blocksPerLine + 1) * A + t);
}
function $C(e, A, t, i, s, a, n, r, g, o = !1) {
  const I = t.mcusPerLine, c = t.progressive, l = A;
  let h = 0, C = 0;
  function B() {
    if (C > 0)
      return C--, h >> C & 1;
    if (h = e[A++], h === 255) {
      const IA = e[A++];
      if (IA) {
        if (IA === 220 && o) {
          A += 2;
          const U = Ie(e, A);
          if (A += 2, U > 0 && U !== t.scanLines)
            throw new og("Found DNL marker (0xFFDC) while parsing scan data", U);
        } else if (IA === 217) {
          if (o) {
            const U = H * (t.precision === 8 ? 8 : 0);
            if (U > 0 && Math.round(t.scanLines / U) >= 5)
              throw new og("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", U);
          }
          throw new Hc("Found EOI marker (0xFFD9) while parsing scan data");
        }
        throw new Kt(`unexpected marker ${(h << 8 | IA).toString(16)}`);
      }
    }
    return C = 7, h >>> 7;
  }
  function Q(IA) {
    let U = IA;
    for (; ; ) {
      switch (U = U[B()], typeof U) {
        case "number":
          return U;
        case "object":
          continue;
      }
      throw new Kt("invalid huffman sequence");
    }
  }
  function E(IA) {
    let U = 0;
    for (; IA > 0; )
      U = U << 1 | B(), IA--;
    return U;
  }
  function f(IA) {
    if (IA === 1)
      return B() === 1 ? 1 : -1;
    const U = E(IA);
    return U >= 1 << IA - 1 ? U : U + (-1 << IA) + 1;
  }
  function d(IA, U) {
    const J = Q(IA.huffmanTableDC), q = J === 0 ? 0 : f(J);
    IA.blockData[U] = IA.pred += q;
    let Z = 1;
    for (; Z < 64; ) {
      const sA = Q(IA.huffmanTableAC), z = sA & 15, W = sA >> 4;
      if (z === 0) {
        if (W < 15)
          break;
        Z += 16;
        continue;
      }
      Z += W;
      const M = Ls[Z];
      IA.blockData[U + M] = f(z), Z++;
    }
  }
  function u(IA, U) {
    const J = Q(IA.huffmanTableDC), q = J === 0 ? 0 : f(J) << g;
    IA.blockData[U] = IA.pred += q;
  }
  function x(IA, U) {
    IA.blockData[U] |= B() << g;
  }
  let m = 0;
  function p(IA, U) {
    if (m > 0) {
      m--;
      return;
    }
    let J = a;
    const q = n;
    for (; J <= q; ) {
      const Z = Q(IA.huffmanTableAC), sA = Z & 15, z = Z >> 4;
      if (sA === 0) {
        if (z < 15) {
          m = E(z) + (1 << z) - 1;
          break;
        }
        J += 16;
        continue;
      }
      J += z;
      const W = Ls[J];
      IA.blockData[U + W] = f(sA) * (1 << g), J++;
    }
  }
  let D = 0, F;
  function y(IA, U) {
    let J = a;
    const q = n;
    let Z = 0, sA, z;
    for (; J <= q; ) {
      const W = U + Ls[J], M = IA.blockData[W] < 0 ? -1 : 1;
      switch (D) {
        case 0:
          if (z = Q(IA.huffmanTableAC), sA = z & 15, Z = z >> 4, sA === 0)
            Z < 15 ? (m = E(Z) + (1 << Z), D = 4) : (Z = 16, D = 1);
          else {
            if (sA !== 1)
              throw new Kt("invalid ACn encoding");
            F = f(sA), D = Z ? 2 : 3;
          }
          continue;
        case 1:
        case 2:
          IA.blockData[W] ? IA.blockData[W] += M * (B() << g) : (Z--, Z === 0 && (D = D === 2 ? 3 : 0));
          break;
        case 3:
          IA.blockData[W] ? IA.blockData[W] += M * (B() << g) : (IA.blockData[W] = F << g, D = 0);
          break;
        case 4:
          IA.blockData[W] && (IA.blockData[W] += M * (B() << g));
          break;
      }
      J++;
    }
    D === 4 && (m--, m === 0 && (D = 0));
  }
  let H = 0;
  function N(IA, U, J, q, Z) {
    const sA = J / I | 0, z = J % I;
    H = sA * IA.v + q;
    const W = z * IA.h + Z, M = Ig(IA, H, W);
    U(IA, M);
  }
  function T(IA, U, J) {
    H = J / IA.blocksPerLine | 0;
    const q = J % IA.blocksPerLine, Z = Ig(IA, H, q);
    U(IA, Z);
  }
  const _ = i.length;
  let oA, G, S, tA, $, hA;
  c ? a === 0 ? hA = r === 0 ? u : x : hA = r === 0 ? p : y : hA = d;
  let yA = 0, pA;
  const DA = _ === 1 ? i[0].blocksPerLine * i[0].blocksPerColumn : I * t.mcusPerColumn;
  let X, qA;
  for (; yA <= DA; ) {
    const IA = s ? Math.min(DA - yA, s) : DA;
    if (IA > 0) {
      for (G = 0; G < _; G++)
        i[G].pred = 0;
      if (m = 0, _ === 1)
        for (oA = i[0], $ = 0; $ < IA; $++)
          T(oA, hA, yA), yA++;
      else
        for ($ = 0; $ < IA; $++) {
          for (G = 0; G < _; G++)
            for (oA = i[G], X = oA.h, qA = oA.v, S = 0; S < qA; S++)
              for (tA = 0; tA < X; tA++)
                N(oA, hA, yA, S, tA);
          yA++;
        }
    }
    if (C = 0, pA = er(e, A), !pA)
      break;
    if (pA.invalid) {
      const U = IA > 0 ? "unexpected" : "excessive";
      k(`decodeScan - ${U} MCU data, current marker is: ${pA.invalid}`), A = pA.offset;
    }
    if (pA.marker >= 65488 && pA.marker <= 65495)
      A += 2;
    else
      break;
  }
  return A - l;
}
function AB(e, A, t) {
  const i = e.quantizationTable, s = e.blockData;
  let a, n, r, g, o, I, c, l, h, C, B, Q, E, f, d, u, x;
  if (!i)
    throw new Kt("missing required Quantization Table.");
  for (let m = 0; m < 64; m += 8) {
    if (h = s[A + m], C = s[A + m + 1], B = s[A + m + 2], Q = s[A + m + 3], E = s[A + m + 4], f = s[A + m + 5], d = s[A + m + 6], u = s[A + m + 7], h *= i[m], !(C | B | Q | E | f | d | u)) {
      x = p0 * h + 512 >> 10, t[m] = x, t[m + 1] = x, t[m + 2] = x, t[m + 3] = x, t[m + 4] = x, t[m + 5] = x, t[m + 6] = x, t[m + 7] = x;
      continue;
    }
    C *= i[m + 1], B *= i[m + 2], Q *= i[m + 3], E *= i[m + 4], f *= i[m + 5], d *= i[m + 6], u *= i[m + 7], a = p0 * h + 128 >> 8, n = p0 * E + 128 >> 8, r = B, g = d, o = Ta * (C - u) + 128 >> 8, l = Ta * (C + u) + 128 >> 8, I = Q << 4, c = f << 4, a = a + n + 1 >> 1, n = a - n, x = r * va + g * Ka + 128 >> 8, r = r * Ka - g * va + 128 >> 8, g = x, o = o + c + 1 >> 1, c = o - c, l = l + I + 1 >> 1, I = l - I, a = a + g + 1 >> 1, g = a - g, n = n + r + 1 >> 1, r = n - r, x = o * Ya + l * Ja + 2048 >> 12, o = o * Ja - l * Ya + 2048 >> 12, l = x, x = I * Ha + c * La + 2048 >> 12, I = I * La - c * Ha + 2048 >> 12, c = x, t[m] = a + l, t[m + 7] = a - l, t[m + 1] = n + c, t[m + 6] = n - c, t[m + 2] = r + I, t[m + 5] = r - I, t[m + 3] = g + o, t[m + 4] = g - o;
  }
  for (let m = 0; m < 8; ++m) {
    if (h = t[m], C = t[m + 8], B = t[m + 16], Q = t[m + 24], E = t[m + 32], f = t[m + 40], d = t[m + 48], u = t[m + 56], !(C | B | Q | E | f | d | u)) {
      x = p0 * h + 8192 >> 14, x < -2040 ? x = 0 : x >= 2024 ? x = 255 : x = x + 2056 >> 4, s[A + m] = x, s[A + m + 8] = x, s[A + m + 16] = x, s[A + m + 24] = x, s[A + m + 32] = x, s[A + m + 40] = x, s[A + m + 48] = x, s[A + m + 56] = x;
      continue;
    }
    a = p0 * h + 2048 >> 12, n = p0 * E + 2048 >> 12, r = B, g = d, o = Ta * (C - u) + 2048 >> 12, l = Ta * (C + u) + 2048 >> 12, I = Q, c = f, a = (a + n + 1 >> 1) + 4112, n = a - n, x = r * va + g * Ka + 2048 >> 12, r = r * Ka - g * va + 2048 >> 12, g = x, o = o + c + 1 >> 1, c = o - c, l = l + I + 1 >> 1, I = l - I, a = a + g + 1 >> 1, g = a - g, n = n + r + 1 >> 1, r = n - r, x = o * Ya + l * Ja + 2048 >> 12, o = o * Ja - l * Ya + 2048 >> 12, l = x, x = I * Ha + c * La + 2048 >> 12, I = I * La - c * Ha + 2048 >> 12, c = x, h = a + l, u = a - l, C = n + c, d = n - c, B = r + I, f = r - I, Q = g + o, E = g - o, h < 16 ? h = 0 : h >= 4080 ? h = 255 : h >>= 4, C < 16 ? C = 0 : C >= 4080 ? C = 255 : C >>= 4, B < 16 ? B = 0 : B >= 4080 ? B = 255 : B >>= 4, Q < 16 ? Q = 0 : Q >= 4080 ? Q = 255 : Q >>= 4, E < 16 ? E = 0 : E >= 4080 ? E = 255 : E >>= 4, f < 16 ? f = 0 : f >= 4080 ? f = 255 : f >>= 4, d < 16 ? d = 0 : d >= 4080 ? d = 255 : d >>= 4, u < 16 ? u = 0 : u >= 4080 ? u = 255 : u >>= 4, s[A + m] = h, s[A + m + 8] = C, s[A + m + 16] = B, s[A + m + 24] = Q, s[A + m + 32] = E, s[A + m + 40] = f, s[A + m + 48] = d, s[A + m + 56] = u;
  }
}
function eB(e, A) {
  const t = A.blocksPerLine, i = A.blocksPerColumn, s = new Int16Array(64);
  for (let a = 0; a < i; a++)
    for (let n = 0; n < t; n++) {
      const r = Ig(A, a, n);
      AB(A, r, s);
    }
  return A.blockData;
}
function er(e, A, t = A) {
  const i = e.length - 1;
  let s = t < A ? t : A;
  if (A >= i)
    return null;
  const a = Ie(e, A);
  if (a >= 65472 && a <= 65534)
    return {
      invalid: null,
      marker: a,
      offset: A
    };
  let n = Ie(e, s);
  for (; !(n >= 65472 && n <= 65534); ) {
    if (++s >= i)
      return null;
    n = Ie(e, s);
  }
  return {
    invalid: a.toString(16),
    marker: n,
    offset: s
  };
}
function tB(e) {
  const A = Math.ceil(e.samplesPerLine / 8 / e.maxH), t = Math.ceil(e.scanLines / 8 / e.maxV);
  for (const i of e.components) {
    const s = Math.ceil(Math.ceil(e.samplesPerLine / 8) * i.h / e.maxH), a = Math.ceil(Math.ceil(e.scanLines / 8) * i.v / e.maxV), n = A * i.h, g = 64 * (t * i.v) * (n + 1);
    i.blockData = new Int16Array(g), i.blocksPerLine = s, i.blocksPerColumn = a;
  }
  e.mcusPerLine = A, e.mcusPerColumn = t;
}
function iB(e, A) {
  const t = Ie(e, A);
  A += 2;
  let i = A + t - 2;
  const s = er(e, i, A);
  s != null && s.invalid && (k("readDataBlock - incorrect length, current marker is: " + s.invalid), i = s.offset);
  const a = e.subarray(A, i);
  return A += a.length, {
    appData: a,
    newOffset: A
  };
}
function sB(e, A) {
  const t = Ie(e, A);
  A += 2;
  const i = A + t - 2, s = er(e, i, A);
  return s != null && s.invalid ? s.offset : i;
}
class Xo {
  constructor({
    decodeTransform: A = null,
    colorTransform: t = -1
  } = {}) {
    this._decodeTransform = A, this._colorTransform = t;
  }
  static canUseImageDecoder(A, t = -1) {
    let i = 0, s = null, a = Ie(A, i);
    if (i += 2, a !== 65496)
      throw new Kt("SOI not found");
    a = Ie(A, i), i += 2;
    A: for (; a !== 65497; ) {
      switch (a) {
        case 65472:
        case 65473:
        case 65474:
          s = A[i + 7];
          break A;
        case 65535:
          A[i] !== 255 && i--;
          break;
      }
      i = sB(A, i), a = Ie(A, i), i += 2;
    }
    return !(s === 4 || s === 3 && t === 0);
  }
  parse(A, {
    dnlScanLines: t = null
  } = {}) {
    let i = 0, s = null, a = null, n, r, g = 0;
    const o = [], I = [], c = [];
    let l = Ie(A, i);
    if (i += 2, l !== 65496)
      throw new Kt("SOI not found");
    l = Ie(A, i), i += 2;
    A: for (; l !== 65497; ) {
      let h, C, B;
      switch (l) {
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          const {
            appData: Q,
            newOffset: E
          } = iB(A, i);
          i = E, l === 65504 && Q[0] === 74 && Q[1] === 70 && Q[2] === 73 && Q[3] === 70 && Q[4] === 0 && (s = {
            version: {
              major: Q[5],
              minor: Q[6]
            },
            densityUnits: Q[7],
            xDensity: Q[8] << 8 | Q[9],
            yDensity: Q[10] << 8 | Q[11],
            thumbWidth: Q[12],
            thumbHeight: Q[13],
            thumbData: Q.subarray(14, 14 + 3 * Q[12] * Q[13])
          }), l === 65518 && Q[0] === 65 && Q[1] === 100 && Q[2] === 111 && Q[3] === 98 && Q[4] === 101 && (a = {
            version: Q[5] << 8 | Q[6],
            flags0: Q[7] << 8 | Q[8],
            flags1: Q[9] << 8 | Q[10],
            transformCode: Q[11]
          });
          break;
        case 65499:
          const f = Ie(A, i);
          i += 2;
          const d = f + i - 2;
          let u;
          for (; i < d; ) {
            const S = A[i++], tA = new Uint16Array(64);
            if (S >> 4)
              if (S >> 4 === 1)
                for (C = 0; C < 64; C++)
                  u = Ls[C], tA[u] = Ie(A, i), i += 2;
              else
                throw new Kt("DQT - invalid table spec");
            else for (C = 0; C < 64; C++)
              u = Ls[C], tA[u] = A[i++];
            o[S & 15] = tA;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          if (n)
            throw new Kt("Only single frame JPEGs supported");
          i += 2, n = {}, n.extended = l === 65473, n.progressive = l === 65474, n.precision = A[i++];
          const x = Ie(A, i);
          i += 2, n.scanLines = t || x, n.samplesPerLine = Ie(A, i), i += 2, n.components = [], n.componentIds = {};
          const m = A[i++];
          let p = 0, D = 0;
          for (h = 0; h < m; h++) {
            const S = A[i], tA = A[i + 1] >> 4, $ = A[i + 1] & 15;
            p < tA && (p = tA), D < $ && (D = $);
            const hA = A[i + 2];
            B = n.components.push({
              h: tA,
              v: $,
              quantizationId: hA,
              quantizationTable: null
            }), n.componentIds[S] = B - 1, i += 3;
          }
          n.maxH = p, n.maxV = D, tB(n);
          break;
        case 65476:
          const F = Ie(A, i);
          for (i += 2, h = 2; h < F; ) {
            const S = A[i++], tA = new Uint8Array(16);
            let $ = 0;
            for (C = 0; C < 16; C++, i++)
              $ += tA[C] = A[i];
            const hA = new Uint8Array($);
            for (C = 0; C < $; C++, i++)
              hA[C] = A[i];
            h += 17 + $, (S >> 4 ? I : c)[S & 15] = zC(tA, hA);
          }
          break;
        case 65501:
          i += 2, r = Ie(A, i), i += 2;
          break;
        case 65498:
          const y = ++g === 1 && !t;
          i += 2;
          const H = A[i++], N = [];
          for (h = 0; h < H; h++) {
            const S = A[i++], tA = n.componentIds[S], $ = n.components[tA];
            $.index = S;
            const hA = A[i++];
            $.huffmanTableDC = c[hA >> 4], $.huffmanTableAC = I[hA & 15], N.push($);
          }
          const T = A[i++], _ = A[i++], oA = A[i++];
          try {
            const S = $C(A, i, n, N, r, T, _, oA >> 4, oA & 15, y);
            i += S;
          } catch (S) {
            if (S instanceof og)
              return k(`${S.message} -- attempting to re-parse the JPEG image.`), this.parse(A, {
                dnlScanLines: S.scanLines
              });
            if (S instanceof Hc) {
              k(`${S.message} -- ignoring the rest of the image data.`);
              break A;
            }
            throw S;
          }
          break;
        case 65500:
          i += 4;
          break;
        case 65535:
          A[i] !== 255 && i--;
          break;
        default:
          const G = er(A, i - 2, i - 3);
          if (G != null && G.invalid) {
            k("JpegImage.parse - unexpected data, current marker is: " + G.invalid), i = G.offset;
            break;
          }
          if (!G || i >= A.length - 1) {
            k("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
            break A;
          }
          throw new Kt("JpegImage.parse - unknown marker: " + l.toString(16));
      }
      l = Ie(A, i), i += 2;
    }
    if (!n)
      throw new Kt("JpegImage.parse - no frame data found.");
    this.width = n.samplesPerLine, this.height = n.scanLines, this.jfif = s, this.adobe = a, this.components = [];
    for (const h of n.components) {
      const C = o[h.quantizationId];
      C && (h.quantizationTable = C), this.components.push({
        index: h.index,
        output: eB(n, h),
        scaleX: h.h / n.maxH,
        scaleY: h.v / n.maxV,
        blocksPerLine: h.blocksPerLine,
        blocksPerColumn: h.blocksPerColumn
      });
    }
    this.numComponents = this.components.length;
  }
  _getLinearizedBlockData(A, t, i = !1) {
    const s = this.width / A, a = this.height / t;
    let n, r, g, o, I, c, l, h, C, B, Q = 0, E;
    const f = this.components.length, d = A * t * f, u = new Uint8ClampedArray(d), x = new Uint32Array(A), m = 4294967288;
    let p;
    for (l = 0; l < f; l++) {
      if (n = this.components[l], r = n.scaleX * s, g = n.scaleY * a, Q = l, E = n.output, o = n.blocksPerLine + 1 << 3, r !== p) {
        for (I = 0; I < A; I++)
          h = 0 | I * r, x[I] = (h & m) << 3 | h & 7;
        p = r;
      }
      for (c = 0; c < t; c++)
        for (h = 0 | c * g, B = o * (h & m) | (h & 7) << 3, I = 0; I < A; I++)
          u[Q] = E[B + x[I]], Q += f;
    }
    let D = this._decodeTransform;
    if (!i && f === 4 && !D && (D = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), D)
      for (l = 0; l < d; )
        for (h = 0, C = 0; h < f; h++, l++, C += 2)
          u[l] = (u[l] * D[C] >> 8) + D[C + 1];
    return u;
  }
  get _isColorConversionNeeded() {
    return this.adobe ? !!this.adobe.transformCode : this.numComponents === 3 ? this._colorTransform === 0 ? !1 : !(this.components[0].index === 82 && this.components[1].index === 71 && this.components[2].index === 66) : this._colorTransform === 1;
  }
  _convertYccToRgb(A) {
    let t, i, s;
    for (let a = 0, n = A.length; a < n; a += 3)
      t = A[a], i = A[a + 1], s = A[a + 2], A[a] = t - 179.456 + 1.402 * s, A[a + 1] = t + 135.459 - 0.344 * i - 0.714 * s, A[a + 2] = t - 226.816 + 1.772 * i;
    return A;
  }
  _convertYccToRgba(A, t) {
    for (let i = 0, s = 0, a = A.length; i < a; i += 3, s += 4) {
      const n = A[i], r = A[i + 1], g = A[i + 2];
      t[s] = n - 179.456 + 1.402 * g, t[s + 1] = n + 135.459 - 0.344 * r - 0.714 * g, t[s + 2] = n - 226.816 + 1.772 * r, t[s + 3] = 255;
    }
    return t;
  }
  _convertYcckToRgb(A) {
    let t, i, s, a, n = 0;
    for (let r = 0, g = A.length; r < g; r += 4)
      t = A[r], i = A[r + 1], s = A[r + 2], a = A[r + 3], A[n++] = -122.67195406894 + i * (-660635669420364e-19 * i + 437130475926232e-18 * s - 54080610064599e-18 * t + 48449797120281e-17 * a - 0.154362151871126) + s * (-957964378445773e-18 * s + 817076911346625e-18 * t - 0.00477271405408747 * a + 1.53380253221734) + t * (961250184130688e-18 * t - 0.00266257332283933 * a + 0.48357088451265) + a * (-336197177618394e-18 * a + 0.484791561490776), A[n++] = 107.268039397724 + i * (219927104525741e-19 * i - 640992018297945e-18 * s + 659397001245577e-18 * t + 426105652938837e-18 * a - 0.176491792462875) + s * (-778269941513683e-18 * s + 0.00130872261408275 * t + 770482631801132e-18 * a - 0.151051492775562) + t * (0.00126935368114843 * t - 0.00265090189010898 * a + 0.25802910206845) + a * (-318913117588328e-18 * a - 0.213742400323665), A[n++] = -20.810012546947 + i * (-570115196973677e-18 * i - 263409051004589e-19 * s + 0.0020741088115012 * t - 0.00288260236853442 * a + 0.814272968359295) + s * (-153496057440975e-19 * s - 132689043961446e-18 * t + 560833691242812e-18 * a - 0.195152027534049) + t * (0.00174418132927582 * t - 0.00255243321439347 * a + 0.116935020465145) + a * (-343531996510555e-18 * a + 0.24165260232407);
    return A.subarray(0, n);
  }
  _convertYcckToRgba(A) {
    for (let t = 0, i = A.length; t < i; t += 4) {
      const s = A[t], a = A[t + 1], n = A[t + 2], r = A[t + 3];
      A[t] = -122.67195406894 + a * (-660635669420364e-19 * a + 437130475926232e-18 * n - 54080610064599e-18 * s + 48449797120281e-17 * r - 0.154362151871126) + n * (-957964378445773e-18 * n + 817076911346625e-18 * s - 0.00477271405408747 * r + 1.53380253221734) + s * (961250184130688e-18 * s - 0.00266257332283933 * r + 0.48357088451265) + r * (-336197177618394e-18 * r + 0.484791561490776), A[t + 1] = 107.268039397724 + a * (219927104525741e-19 * a - 640992018297945e-18 * n + 659397001245577e-18 * s + 426105652938837e-18 * r - 0.176491792462875) + n * (-778269941513683e-18 * n + 0.00130872261408275 * s + 770482631801132e-18 * r - 0.151051492775562) + s * (0.00126935368114843 * s - 0.00265090189010898 * r + 0.25802910206845) + r * (-318913117588328e-18 * r - 0.213742400323665), A[t + 2] = -20.810012546947 + a * (-570115196973677e-18 * a - 263409051004589e-19 * n + 0.0020741088115012 * s - 0.00288260236853442 * r + 0.814272968359295) + n * (-153496057440975e-19 * n - 132689043961446e-18 * s + 560833691242812e-18 * r - 0.195152027534049) + s * (0.00174418132927582 * s - 0.00255243321439347 * r + 0.116935020465145) + r * (-343531996510555e-18 * r + 0.24165260232407), A[t + 3] = 255;
    }
    return A;
  }
  _convertYcckToCmyk(A) {
    let t, i, s;
    for (let a = 0, n = A.length; a < n; a += 4)
      t = A[a], i = A[a + 1], s = A[a + 2], A[a] = 434.456 - t - 1.402 * s, A[a + 1] = 119.541 - t + 0.344 * i + 0.714 * s, A[a + 2] = 481.816 - t - 1.772 * i;
    return A;
  }
  _convertCmykToRgb(A) {
    let t, i, s, a, n = 0;
    for (let r = 0, g = A.length; r < g; r += 4)
      t = A[r], i = A[r + 1], s = A[r + 2], a = A[r + 3], A[n++] = 255 + t * (-6747147073602441e-20 * t + 8379262121013727e-19 * i + 2894718188643294e-19 * s + 0.003264231057537806 * a - 1.1185611867203937) + i * (26374107616089405e-21 * i - 8626949158638572e-20 * s - 2748769067499491e-19 * a - 0.02155688794978967) + s * (-3878099212869363e-20 * s - 3267808279485286e-19 * a + 0.0686742238595345) - a * (3361971776183937e-19 * a + 0.7430659151342254), A[n++] = 255 + t * (13596372813588848e-20 * t + 924537132573585e-18 * i + 10567359618683593e-20 * s + 4791864687436512e-19 * a - 0.3109689587515875) + i * (-23545346108370344e-20 * i + 2702845253534714e-19 * s + 0.0020200308977307156 * a - 0.7488052167015494) + s * (6834815998235662e-20 * s + 15168452363460973e-20 * a - 0.09751927774728933) - a * (3189131175883281e-19 * a + 0.7364883807733168), A[n++] = 255 + t * (13598650411385307e-21 * t + 12423956175490851e-20 * i + 4751985097583589e-19 * s - 36729317476630422e-22 * a - 0.05562186980264034) + i * (16141380598724676e-20 * i + 9692239130725186e-19 * s + 7782692450036253e-19 * a - 0.44015232367526463) + s * (5068882914068769e-22 * s + 0.0017778369011375071 * a - 0.7591454649749609) - a * (3435319965105553e-19 * a + 0.7063770186160144);
    return A.subarray(0, n);
  }
  _convertCmykToRgba(A) {
    for (let t = 0, i = A.length; t < i; t += 4) {
      const s = A[t], a = A[t + 1], n = A[t + 2], r = A[t + 3];
      A[t] = 255 + s * (-6747147073602441e-20 * s + 8379262121013727e-19 * a + 2894718188643294e-19 * n + 0.003264231057537806 * r - 1.1185611867203937) + a * (26374107616089405e-21 * a - 8626949158638572e-20 * n - 2748769067499491e-19 * r - 0.02155688794978967) + n * (-3878099212869363e-20 * n - 3267808279485286e-19 * r + 0.0686742238595345) - r * (3361971776183937e-19 * r + 0.7430659151342254), A[t + 1] = 255 + s * (13596372813588848e-20 * s + 924537132573585e-18 * a + 10567359618683593e-20 * n + 4791864687436512e-19 * r - 0.3109689587515875) + a * (-23545346108370344e-20 * a + 2702845253534714e-19 * n + 0.0020200308977307156 * r - 0.7488052167015494) + n * (6834815998235662e-20 * n + 15168452363460973e-20 * r - 0.09751927774728933) - r * (3189131175883281e-19 * r + 0.7364883807733168), A[t + 2] = 255 + s * (13598650411385307e-21 * s + 12423956175490851e-20 * a + 4751985097583589e-19 * n - 36729317476630422e-22 * r - 0.05562186980264034) + a * (16141380598724676e-20 * a + 9692239130725186e-19 * n + 7782692450036253e-19 * r - 0.44015232367526463) + n * (5068882914068769e-22 * n + 0.0017778369011375071 * r - 0.7591454649749609) - r * (3435319965105553e-19 * r + 0.7063770186160144), A[t + 3] = 255;
    }
    return A;
  }
  getData({
    width: A,
    height: t,
    forceRGBA: i = !1,
    forceRGB: s = !1,
    isSourcePDF: a = !1
  }) {
    if (this.numComponents > 4)
      throw new Kt("Unsupported color mode");
    const n = this._getLinearizedBlockData(A, t, a);
    if (this.numComponents === 1 && (i || s)) {
      const r = n.length * (i ? 4 : 3), g = new Uint8ClampedArray(r);
      let o = 0;
      if (i)
        _C(n, new Uint32Array(g.buffer));
      else
        for (const I of n)
          g[o++] = I, g[o++] = I, g[o++] = I;
      return g;
    } else if (this.numComponents === 3 && this._isColorConversionNeeded) {
      if (i) {
        const r = new Uint8ClampedArray(n.length / 3 * 4);
        return this._convertYccToRgba(n, r);
      }
      return this._convertYccToRgb(n);
    } else if (this.numComponents === 4) {
      if (this._isColorConversionNeeded)
        return i ? this._convertYcckToRgba(n) : s ? this._convertYcckToRgb(n) : this._convertYcckToCmyk(n);
      if (i)
        return this._convertCmykToRgba(n);
      if (s)
        return this._convertCmykToRgb(n);
    }
    return n;
  }
}
var Ba, Qa, cg;
const On = class On extends $e {
  constructor(t, i, s) {
    super(i);
    ZA(this, Qa);
    this.stream = t, this.dict = t.dict, this.maybeLength = i, this.params = s;
  }
  static get canUseImageDecoder() {
    return iA(this, "canUseImageDecoder", PA(this, Ba) ? ImageDecoder.isTypeSupported("image/jpeg") : Promise.resolve(!1));
  }
  static setOptions({
    isImageDecoderSupported: t = !1
  }) {
    wt(this, Ba, t);
  }
  get bytes() {
    return iA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(t) {
  }
  readBlock() {
    this.decodeImage();
  }
  get jpegOptions() {
    const t = {
      decodeTransform: void 0,
      colorTransform: void 0
    }, i = this.dict.getArray("D", "Decode");
    if ((this.forceRGBA || this.forceRGB) && Array.isArray(i)) {
      const s = this.dict.get("BPC", "BitsPerComponent") || 8, a = i.length, n = new Int32Array(a);
      let r = !1;
      const g = (1 << s) - 1;
      for (let o = 0; o < a; o += 2)
        n[o] = (i[o + 1] - i[o]) * 256 | 0, n[o + 1] = i[o] * g | 0, (n[o] !== 256 || n[o + 1] !== 0) && (r = !0);
      r && (t.decodeTransform = n);
    }
    if (this.params instanceof R) {
      const s = this.params.get("ColorTransform");
      Number.isInteger(s) && (t.colorTransform = s);
    }
    return iA(this, "jpegOptions", t);
  }
  decodeImage(t) {
    if (this.eof)
      return this.buffer;
    t = BA(this, Qa, cg).call(this, t || this.bytes);
    const i = new Xo(this.jpegOptions);
    i.parse(t);
    const s = i.getData({
      width: this.drawWidth,
      height: this.drawHeight,
      forceRGBA: this.forceRGBA,
      forceRGB: this.forceRGB,
      isSourcePDF: !0
    });
    return this.buffer = s, this.bufferLength = s.length, this.eof = !0, this.buffer;
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
  async getTransferableImage() {
    if (!await On.canUseImageDecoder)
      return null;
    const t = this.jpegOptions;
    if (t.decodeTransform)
      return null;
    let i;
    try {
      const s = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
      if (!s)
        return null;
      const a = BA(this, Qa, cg).call(this, s);
      return Xo.canUseImageDecoder(a, t.colorTransform) ? (i = new ImageDecoder({
        data: a,
        type: "image/jpeg",
        preferAnimation: !1
      }), (await i.decode()).image) : null;
    } catch (s) {
      return k(`getTransferableImage - failed: "${s}".`), null;
    } finally {
      i == null || i.close();
    }
  }
};
Ba = new WeakMap(), Qa = new WeakSet(), cg = function(t) {
  for (let i = 0, s = t.length - 1; i < s; i++)
    if (t[i] === 255 && t[i + 1] === 216) {
      i > 0 && (t = t.subarray(i));
      break;
    }
  return t;
}, ZA(On, Ba, ht.isImageDecoderSupported);
let ts = On;
var aB = (() => {
  var A;
  var e = typeof document < "u" ? (A = document.currentScript) == null ? void 0 : A.src : void 0;
  return function(t = {}) {
    var i, s = t, a, n;
    new Promise((V, AA) => {
      a = V, n = AA;
    }), s.decode = function(V, {
      numComponents: AA = 4,
      isIndexedColormap: fA = !1,
      smaskInData: GA = !1
    }) {
      const HA = V.length, ge = s._malloc(HA);
      s.HEAPU8.set(V, ge);
      const ie = s._jp2_decode(ge, HA, AA > 0 ? AA : 0, !!fA, !!GA);
      if (s._free(ge), ie) {
        const {
          errorMessages: ne
        } = s;
        return ne ? (delete s.errorMessages, ne) : "Unknown error";
      }
      const {
        imageData: rt
      } = s;
      return s.imageData = null, rt;
    };
    var r = Object.assign({}, s), g = "./this.program", o = (V, AA) => {
      throw AA;
    }, I = "";
    typeof document < "u" && document.currentScript && (I = document.currentScript.src), e && (I = e), I.startsWith("blob:") ? I = "" : I = I.substr(0, I.replace(/[?#].*/, "").lastIndexOf("/") + 1);
    var c = s.print || console.log.bind(console), l = s.printErr || console.error.bind(console);
    Object.assign(s, r), r = null, s.arguments && s.arguments, s.thisProgram && (g = s.thisProgram);
    var h = s.wasmBinary;
    function C(V) {
      for (var AA = atob(V), fA = new Uint8Array(AA.length), GA = 0; GA < AA.length; ++GA)
        fA[GA] = AA.charCodeAt(GA);
      return fA;
    }
    function B(V) {
      if (pA(V))
        return C(V.slice(yA.length));
    }
    var Q, E = !1, f, d, u, x;
    function m() {
      var V = Q.buffer;
      s.HEAP8 = d = new Int8Array(V), s.HEAP16 = new Int16Array(V), s.HEAPU8 = u = new Uint8Array(V), s.HEAPU16 = new Uint16Array(V), s.HEAP32 = new Int32Array(V), s.HEAPU32 = x = new Uint32Array(V), s.HEAPF32 = new Float32Array(V), s.HEAPF64 = new Float64Array(V);
    }
    var p = [], D = [], F = [];
    function y() {
      if (s.preRun)
        for (typeof s.preRun == "function" && (s.preRun = [s.preRun]); s.preRun.length; )
          T(s.preRun.shift());
      Z(p);
    }
    function H() {
      Z(D);
    }
    function N() {
      if (s.postRun)
        for (typeof s.postRun == "function" && (s.postRun = [s.postRun]); s.postRun.length; )
          oA(s.postRun.shift());
      Z(F);
    }
    function T(V) {
      p.unshift(V);
    }
    function _(V) {
      D.unshift(V);
    }
    function oA(V) {
      F.unshift(V);
    }
    var G = 0, S = null;
    function tA(V) {
      var AA;
      G++, (AA = s.monitorRunDependencies) == null || AA.call(s, G);
    }
    function $(V) {
      var fA;
      if (G--, (fA = s.monitorRunDependencies) == null || fA.call(s, G), G == 0 && S) {
        var AA = S;
        S = null, AA();
      }
    }
    function hA(V) {
      var fA;
      (fA = s.onAbort) == null || fA.call(s, V), V = "Aborted(" + V + ")", l(V), E = !0, V += ". Build with -sASSERTIONS for more info.";
      var AA = new WebAssembly.RuntimeError(V);
      throw n(AA), AA;
    }
    var yA = "data:application/octet-stream;base64,", pA = (V) => V.startsWith(yA);
    function DA() {
      var V = "data:application/octet-stream;base64,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A3FFBEACQCAAQQNxRQRAIAAhAgwBCyACRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCyADQXxxIQQCQCADQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0EEayIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECkiAARAIABBACABEBkaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECkL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEHUgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUEQEEIIAEQKQwBCyABRQRAIAAQFEEADAELAkAgAUFHSw0AIAACf0EIIAFBA2pBfHEgAUEITRsiB0EIaiEBAkACfwJAIABBBGsiCiIEKAIAIgUgBGoiAigCACIJIAIgCWoiCEEEaygCAEcEQCAIIAEgBGoiA0EQak8EQCACKAIEIgUgAigCCCICNgIIIAIgBTYCBCADIAggA2siAjYCACADIAJBfHFqQQRrIAJBAXI2AgAgAwJ/IAMoAgBBCGsiAkH/AE0EQCACQQN2QQFrDAELIAJBHSACZyIFa3ZBBHMgBUECdGtB7gBqIAJB/x9NDQAaQT8gAkEeIAVrdkECcyAFQQF0a0HHAGoiAiACQT9PGwsiAkEEdCIFQeDNAWo2AgQgAyAFQejNAWoiBSgCADYCCCAFIAM2AgAgAygCCCADNgIEQejVAUHo1QEpAwBCASACrYaENwMAIAQgATYCAAwECyADIAhLDQEgAigCBCIBIAIoAggiAzYCCCADIAE2AgQgBCAFIAlqIgE2AgAMAwsgBSABQRBqTwRAIAQgATYCACAEIAFBfHFqQQRrIAE2AgAgASAEaiIDIAUgAWsiATYCACADIAFBfHFqQQRrIAFBAXI2AgAgAwJ/IAMoAgBBCGsiAUH/AE0EQCABQQN2QQFrDAELIAFBHSABZyIEa3ZBBHMgBEECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIARrdkECcyAEQQF0a0HHAGoiASABQT9PGwsiAUEEdCIEQeDNAWo2AgQgAyAEQejNAWoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQejVAUHo1QEpAwBCASABrYaENwMAQQEMBAtBASABIAVNDQEaC0EACwwBCyAEIAFBfHFqQQRrIAE2AgBBAQsNARpBCCAHECkiAUUNACABIAAgByAKKAIAQQhrIgYgBiAHSxsQFhogABAUIAEhBgsgBgsLMwEBfyMAQRBrIgEkACAABH8gAUEMakEQIAAQeSEAQQAgASgCDCAAGwVBAAsgAUEQaiQAC7wEAQV/IAIgACgCMCIFTQRAIAEgACgCJCACEBYaIAAgACgCJCACajYCJCAAIAAoAjAgAms2AjAgACAAKQM4IAKtfDcDOCACDwsgAC0AREEEcQRAIAEgACgCJCAFEBYaIAAoAjAhASAAQQA2AjAgACABIAAoAiRqNgIkIAAgACkDOCABrXw3AzggBUF/IAUbDwsCQCAFBEAgASAAKAIkIAUQFiEEIAAgACgCICIHNgIkIAAoAjAhASAAQQA2AjAgACAAKQM4IAGtfDcDOCACIAFrIQIgASAEaiEBDAELIAAgACgCICIHNgIkCwJAAkADQAJAIAAoAgAhBCAAKAIQIQYCQCAAKAJAIgggAksEQCAAIAcgCCAEIAYRAAAiBjYCMCAGQX9GBEAMBgsgAiAGTQ0CIAEgACgCJCAGEBYaIAAgACgCICIHNgIkIAAoAjAhBAwBCyAAIAEgAiAEIAYRAAAiBDYCMCAEQX9GBEAMBQsgAiAETQ0DIAAgACgCICIHNgIkIAQhBgsgAEEANgIwIAAgACkDOCAErXw3AzggASAEaiEBIAIgBGshAiAFIAZqIQUMAQsLIAEgACgCJCACEBYaIAAgACgCJCACajYCJCAAIAAoAjAgAms2AjAgACAAKQM4IAKtfDcDOCACIAVqDwsgAEEANgIwIAAgACgCIDYCJCAAIAApAzggBK18NwM4IAQgBWoPCyADQQRB6fkAQQAQEyAAQQA2AjAgACAAKAJEQQRyNgJEIAVBfyAFGwsXACAALQAAQSBxRQRAIAEgAiAAEEYaCwuDBwILfwF+IAAoAhAiB0EgTwRAIAApAwinDwsCQCAAKAIYIgJBBE4EQCAAKAIAIgEoAgAhBCAAIAJBBGsiBTYCGCAAIAFBBGo2AgAMAQtBf0EAIAAoAhwbIQQgAkEATARAIAIhBQwBCyACQQFxIAAoAgAhAQJAIAJBAUYEQCABIQYMAQsgAkH+////B3EhCgNAIAAgAUEBajYCACABLQAAIQkgACABQQJqIgY2AgAgACACQQFrNgIYIAEtAAEhASAAIAJBAmsiAjYCGCAEQf8BIAN0QX9zcSAJIAN0ckGA/gMgA3RBf3NxIAEgA0EIcnRyIQQgA0EQaiEDIAYhASAFQQJqIgUgCkcNAAsLQQAhBUUNACAAIAZBAWo2AgAgBi0AACEBIAAgAkEBazYCGCAEQf8BIAN0QX9zcSABIAN0ciEECyAAKAIUIQEgACAEQRh2IgpB/wFGNgIUIABBB0EIIAEbIgFBB0EIIARB/wFxIgZB/wFGG2oiAkEHQQggBEEIdkH/AXEiA0H/AUYbaiIJQQdBCCAEQRB2Qf8BcSIEQf8BRhsgB2pqIgg2AhAgACAAKQMIIAMgAXQgBCACdHIgCiAJdHIgBnKtIAethoQiDDcDCCAIQR9NBEACQCAFQQROBEAgACgCACIBKAIAIQIgACAFQQRrNgIYIAAgAUEEajYCAAwBC0EAIQNBf0EAIAAoAhwbIQIgBUEATA0AIAVBAXEgACgCACEBAkAgBUEBRgRAIAEhBAwBCyAFQf7///8HcSEJQQAhBgNAIAAgAUEBajYCACABLQAAIQsgACABQQJqIgQ2AgAgACAFQQFrNgIYIAEtAAEhASAAIAVBAmsiBTYCGCACQf8BIAN0QX9zcSALIAN0ckGA/gMgA3RBf3NxIAEgA0EIcnRyIQIgA0EQaiEDIAQhASAGQQJqIgYgCUcNAAsLRQ0AIAAgBEEBajYCACAELQAAIQEgACAFQQFrNgIYIAJB/wEgA3RBf3NxIAEgA3RyIQILIAAgAkEYdiIBQf8BRjYCFCAAQQdBCCAKQf8BRhsiBEEHQQggAkH/AXEiBkH/AUYbaiIFQQdBCCACQQh2Qf8BcSIDQf8BRhtqIgdBB0EIIAJBEHZB/wFxIgJB/wFGGyAIamo2AhAgACADIAR0IAIgBXRyIAEgB3RyIAZyrSAIrYYgDIQiDDcDCAsgDKcLawEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siA0GAAiADQYACSSIBGxAZGiABRQRAA0AgACAFQYACEB4gA0GAAmsiA0H/AUsNAAsLIAAgBSADEB4LIAVBgAJqJAALMQAgAQJ/IAIoAkxBAEgEQCAAIAEgAhBGDAELIAAgASACEEYLIgBGBEAPCyAAIAFuGgsXACAAIAEgAiADIAQgBSAGIAdBARAqGguhAQEEfyABQQBMBEBBAA8LIAAoAgwhAiAAKAIQIQMDQCABIQUCQCADDQAgACACQQh0QYD+A3EiAjYCDCAAQQdBCCACQYD+A0YbIgM2AhAgACgCCCIBIAAoAgRPDQAgACABQQFqNgIIIAAgAiABLQAAciICNgIMCyAAIANBAWsiAzYCECACIAN2QQFxIAVBAWsiAXQgBHIhBCAFQQFLDQALIAQLHgAgACgCDARAIABBADYCKANAIAAoAhhBAEoNAAsLC2oBA38gAARAIAAoAhgiAQRAIAAoAhAiAgR/QQAhAQNAIAAoAhggAUE0bGooAiwiAwRAIAMQFCAAKAIQIQILIAFBAWoiASACSQ0ACyAAKAIYBSABCxAUCyAAKAIcIgEEQCABEBQLIAAQFAsLkhUBD38CQAJAIAAoAgxFBEBBASEPIAAoAgRBAEoNASAAKAIIQQFKDQEMAgtBASENIAAoAghBAEoNACAAKAIEQQJIDQELIAAoAgAiCCANQQV0aiEEAkAgACgCECIHIAAoAhQiCk8NACAEIAdBBnRqIQECQCAKIAdrQQNxIgZFBEAgByECDAELIAchAgNAIAEgAf0ABAD9DFh2nT9Ydp0/WHadP1h2nT/95gH9CwQAIAEgAf0ABBD9DFh2nT9Ydp0/WHadP1h2nT/95gH9CwQQIAFBQGshASACQQFqIQIgA0EBaiIDIAZHDQALCyAHIAprQXxLDQADQCABIAH9AAQA/QxYdp0/WHadP1h2nT9Ydp0//eYB/QsEACABIAH9AAQQ/QxYdp0/WHadP1h2nT9Ydp0//eYB/QsEECABIAH9AARA/QxYdp0/WHadP1h2nT9Ydp0//eYB/QsEQCABIAH9AARQ/QxYdp0/WHadP1h2nT9Ydp0//eYB/QsEUCABIAH9AASAAf0MWHadP1h2nT9Ydp0/WHadP/3mAf0LBIABIAEgAf0ABJAB/QxYdp0/WHadP1h2nT9Ydp0//eYB/QsEkAEgASAB/QAEwAH9DFh2nT9Ydp0/WHadP1h2nT/95gH9CwTAASABIAH9AATQAf0MWHadP1h2nT9Ydp0/WHadP/3mAf0LBNABIAFBgAJqIQEgAkEEaiICIApHDQALCyAIIA9BBXRqIQUCQCAAKAIYIgYgACgCHCILTw0AIAUgBkEGdGohAQJAIAsgBmtBA3EiCEUEQCAGIQIMAQtBACEDIAYhAgNAIAEgAf0ABAD9DAAY0D8AGNA/ABjQPwAY0D/95gH9CwQAIAEgAf0ABBD9DAAY0D8AGNA/ABjQPwAY0D/95gH9CwQQIAFBQGshASACQQFqIQIgA0EBaiIDIAhHDQALCyAGIAtrQXxLDQADQCABIAH9AAQA/QwAGNA/ABjQPwAY0D8AGNA//eYB/QsEACABIAH9AAQQ/QwAGNA/ABjQPwAY0D8AGNA//eYB/QsEECABIAH9AARA/QwAGNA/ABjQPwAY0D8AGNA//eYB/QsEQCABIAH9AARQ/QwAGNA/ABjQPwAY0D8AGNA//eYB/QsEUCABIAH9AASAAf0MABjQPwAY0D8AGNA/ABjQP/3mAf0LBIABIAEgAf0ABJAB/QwAGNA/ABjQPwAY0D8AGNA//eYB/QsEkAEgASAB/QAEwAH9DAAY0D8AGNA/ABjQPwAY0D/95gH9CwTAASABIAH9AATQAf0MABjQPwAY0D8AGNA/ABjQP/3mAf0LBNABIAFBgAJqIQEgAkEEaiICIAtHDQALCyAKIAAoAggiCSAAKAIEIg4gDWsiACAAIAlKGyIIIAggCksbIQwgBEEgaiEBAn8gB0UEQCAMRQRAQQAhAyABDAILIAQgBP0ABAAgBf0ABAAgBP0ABCD95AH9DFUT4z5VE+M+VRPjPlUT4z795gH95QH9CwQAIAQgBP0ABBAgBf0ABBAgBP0ABDD95AH9DFUT4z5VE+M+VRPjPlUT4z795gH95QH9CwQQQQEhAyAEQeAAagwBCyABIAciA0EGdGoLIQIgAyAMSQRAA0AgAkEgayIAIAD9AAQAIAJBQGr9AAQAIAL9AAQA/eQB/QxVE+M+VRPjPlUT4z5VE+M+/eYB/eUB/QsEACACQRBrIgAgAP0ABAAgAkEwa/0ABAAgAv0ABBD95AH9DFUT4z5VE+M+VRPjPlUT4z795gH95QH9CwQAIAJBQGshAiADQQFqIgMgDEcNAAsLIAggCk8iDUUEQCACQSBrIgAgAP0ABAAgAkFAav0ABAD9DFUTYz9VE2M/VRNjP1UTYz/95gH95QH9CwQAIAJBEGsiACAA/QAEACACQTBr/QAEAP0MVRNjP1UTYz9VE2M/VRNjP/3mAf3lAf0LBAALIAsgDiAJIA9rIgAgACAOShsiDiALIA5JGyEJIAVBIGohAiAJAn8gBkUEQCAJRQRAIAIhA0EADAILIAUgBf0ABAAgBP0ABAAgBf0ABCD95AH9DHYGYj92BmI/dgZiP3YGYj/95gH95QH9CwQAIAUgBf0ABBAgBP0ABBAgBf0ABDD95AH9DHYGYj92BmI/dgZiP3YGYj/95gH95QH9CwQQIAVB4ABqIQNBAQwBCyACIAZBBnRqIQMgBgsiAEsEQANAIANBIGsiCCAI/QAEACADQUBq/QAEACAD/QAEAP3kAf0MdgZiP3YGYj92BmI/dgZiP/3mAf3lAf0LBAAgA0EQayIIIAj9AAQAIANBMGv9AAQAIAP9AAQQ/eQB/Qx2BmI/dgZiP3YGYj92BmI//eYB/eUB/QsEACADQUBrIQMgAEEBaiIAIAlHDQALCyALIA5NIghFBEAgA0EgayIAIAD9AAQAIANBQGr9AAQA/Qx2BuI/dgbiP3YG4j92BuI//eYB/eUB/QsEACADQRBrIgAgAP0ABAAgA0Ewa/0ABAD9DHYG4j92BuI/dgbiP3YG4j/95gH95QH9CwQACwJAIAdFBEAgDEUEQEEAIQcMAgsgBCAE/QAEACAF/QAEACAE/QAEIP3kAf0MrgFZPa4BWT2uAVk9rgFZPf3mAf3kAf0LBAAgBCAE/QAEECAF/QAEECAE/QAEMP3kAf0MrgFZPa4BWT2uAVk9rgFZPf3mAf3kAf0LBBAgBEHgAGohAUEBIQcMAQsgASAHQQZ0aiEBCyAHIAxJBEADQCABQSBrIgAgAP0ABAAgAUFAav0ABAAgAf0ABAD95AH9DK4BWT2uAVk9rgFZPa4BWT395gH95AH9CwQAIAFBEGsiACAA/QAEACABQTBr/QAEACAB/QAEEP3kAf0MrgFZPa4BWT2uAVk9rgFZPf3mAf3kAf0LBAAgAUFAayEBIAdBAWoiByAMRw0ACwsgDUUEQCABQSBrIgAgAP0ABAAgAUFAav0ABAD9DK4B2T2uAdk9rgHZPa4B2T395gH95AH9CwQAIAFBEGsiACAA/QAEACABQTBr/QAEAP0MrgHZPa4B2T2uAdk9rgHZPf3mAf3kAf0LBAALAkAgBkUEQCAJRQRAQQAhBgwCCyAFIAX9AAQAIAT9AAQAIAX9AAQg/eQB/QxzBss/cwbLP3MGyz9zBss//eYB/eQB/QsEACAFIAX9AAQQIAT9AAQQIAX9AAQw/eQB/QxzBss/cwbLP3MGyz9zBss//eYB/eQB/QsEECAFQeAAaiECQQEhBgwBCyACIAZBBnRqIQILIAYgCUkEQANAIAJBIGsiACAA/QAEACACQUBq/QAEACAC/QAEAP3kAf0McwbLP3MGyz9zBss/cwbLP/3mAf3kAf0LBAAgAkEQayIAIAD9AAQAIAJBMGv9AAQAIAL9AAQQ/eQB/QxzBss/cwbLP3MGyz9zBss//eYB/eQB/QsEACACQUBrIQIgBkEBaiIGIAlHDQALCyAIDQAgAkEgayIAIAD9AAQAIAJBQGr9AAQA/QxzBktAcwZLQHMGS0BzBktA/eYB/eQB/QsEACACQRBrIgAgAP0ABAAgAkEwa/0ABAD9DHMGS0BzBktAcwZLQHMGS0D95gH95AH9CwQACwtdAQR/IAAEQCAAKAIUIgEgACgCECICbARAA0AgACgCGCADQQJ0aigCACIEBEAgBBAUIAAoAhAhAiAAKAIUIQELIANBAWoiAyABIAJsSQ0ACwsgACgCGBAUIAAQFAsLhQEBAn8CQAJAIAAoAgQiAyAAKAIAIgRHBEAgACgCCCEDDAELIAAgA0EKaiIENgIEIAAoAgggBEECdBAbIgNFDQEgACADNgIIIAAoAgAhBAsgAyAEQQJ0aiABNgIAIAAgBEEBajYCAEEBDwsgACgCCBAUIABCADcCACACQQFBxi9BABATQQALkwQCBn8CfgJAAkADQCAAIABBAWtxDQEgAUFHSw0BIABBCCAAQQhLIgcbIQBB6NUBKQMAIggCf0EIIAFBA2pBfHEgAUEITRsiAUH/AE0EQCABQQN2QQFrDAELIAFnIQMgAUEdIANrdkEEcyADQQJ0a0HuAGogAUH/H00NABpBPyABQR4gA2t2QQJzIANBAXRrQccAaiIDIANBP08bCyIDrYgiCUIAUgRAA0AgCSAJeiIIiCEJAn4gAyAIp2oiA0EEdCIEQejNAWooAgAiAiAEQeDNAWoiBUcEQCACIAAgARBFIgQNBiACKAIEIgQgAigCCCIGNgIIIAYgBDYCBCACIAU2AgggAiAFKAIENgIEIAUgAjYCBCACKAIEIAI2AgggA0EBaiEDIAlCAYgMAQtB6NUBQejVASkDAEJ+IAOtiYM3AwAgCUIBhQsiCUIAUg0AC0Ho1QEpAwAhCAtBPyAIeadrIQUCQCAIUARAQQAhAgwBCyAFQQR0IgRB6M0BaigCACECIAhCgICAgARUDQBB4wAhAyACIARB4M0BaiIGRg0AA0AgA0UNASACIAAgARBFIgQNBCADQQFrIQMgAigCCCICIAZHDQALCyABIABBMGpBMCAHG2oQeg0ACyACRQ0AIAIgBUEEdEHgzQFqIgNGDQADQCACIAAgARBFIgQNAiACKAIIIgIgA0cNAAsLQQAhBAsgBAuWIwInfwN7AkAgAyAAKAIAIglLDQAgASADTw0AIAEgCU8NACAEIAAoAgQiCUsNACACIARPDQAgAiAJTw0AIAVBHGshJyAAKAIIIhlBAnQhESAHQQJ0IQ8gBkECdCEfIAVBBGshKCACIAAoAgxuIR4gGSAZIAEgGW4iKWwgAWtqISogBkEIRyEjIAIhHQNAIAAoAgwiCSEKIAIgHUYEQCAJIAIgCXBrIQoLIAogBCAdayIMIAogDEkbIhNBfHEhGyATQQNxIRYgE0F4cSErIBNBB3EhJCATQQFrIRogGSAJQQJ0IApBAnRrQQRqbCEgIAZBAkYgE0EBRnEhLCAJIAprIBlsISUgJyAPIB0gAmsiDGwiCWohJiAJIChqIS0gBSAJaiEuIAUgByAMbEECdGohHCApISEgASEYA0AgKiAZIAEgGEYbIgwgAyAYayIJIAkgDEsbIRAgGSAMayEJICFBAnQiDSAAKAIYIAAoAhAgHmxBAnRqaigCACESAkACQCAIBEACQAJAAkACQAJAIBIEQCASICVBAnRqIAlBAnRqIQogGCABayENIAZBAUYNBCAcIAYgDWxBAnRqIQsgEEEBRg0DICwNAiAjDQEgEEEHTQ0BIBNFDQggJiANIB9saiAQQQV0aiEVIBIgICAQQQJ0aiAMQQJ0a2ohIiAQQXxxIQ1BACESDAULIAZBAUcEQCATRQ0IIBBBfHEhDSAQQQNxIQwgHCAYIAFrIAZsQQJ0aiELQQAhEiAQQQFrQQNJIRQDQAJAIBBFDQBBACEJQQAhCkEAIQ4gFEUEQANAIAsgBiAKbEECdGpBADYCACALIApBAXIgBmxBAnRqQQA2AgAgCyAKQQJyIAZsQQJ0akEANgIAIAsgCkEDciAGbEECdGpBADYCACAKQQRqIQogDkEEaiIOIA1HDQALCyAMRQ0AA0AgCyAGIApsQQJ0akEANgIAIApBAWohCiAJQQFqIgkgDEcNAAsLIAsgD2ohCyATIBJBAWoiEkcNAAsMCAsgE0UNByAQQQJ0IQwgHCAYIAFrQQJ0aiELQQAhCSAaQQdPBEADQCALQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qQQAgDBAZIA9qIQsgCUEIaiIJICtHDQALC0EAIQkgJEUNBwNAIAtBACAMEBkgD2ohCyAJQQFqIgkgJEcNAAsMBwsgE0UNBiAQQXxxIRQgEEEDcSESQQAhDSAQQQFrQQNJIRcMBQtBACEJIBBBfHEiDgRAA0AgCyAJQQN0aiAKIAlBAnRqKAIANgIAIAsgCUEBciIUQQN0aiAKIBRBAnRqKAIANgIAIAsgCUECciIUQQN0aiAKIBRBAnRqKAIANgIAIAsgCUEDciIUQQN0aiAKIBRBAnRqKAIANgIAIAlBBGoiCSAOSQ0ACwsgCSAQTw0FAkAgECAJayIUQQ9NDQAgLiANIB9sIg1qIAlBA3RqIBIgIGoiDiAQIAxrQQJ0akkEQCAOIAkgDGtBAnRqIA0gLWogEEEDdGpJDQELIAogCUECdGohDSAJ/RH9DAAAAAABAAAAAgAAAAMAAAD9rgEhMCAJIBRBfHEiDGohCUEAIQ4DQCALIDBBA/2rASIx/RsAaiANIA5BAnRq/QACACIy/VoCAAAgCyAx/RsBaiAy/VoCAAEgCyAx/RsCaiAy/VoCAAIgCyAx/RsDaiAy/VoCAAMgMP0MBAAAAAQAAAAEAAAABAAAAP2uASEwIA5BBGoiDiAMRw0ACyAMIBRGDQYLQQAhDCAJIQ4gECAJa0EDcSINBEADQCALIA5BA3RqIAogDkECdGooAgA2AgAgDkEBaiEOIAxBAWoiDCANRw0ACwsgCSAQa0F8Sw0FA0AgCyAOQQN0aiAKIA5BAnRqKAIANgIAIAsgDkEBaiIJQQN0aiAKIAlBAnRqKAIANgIAIAsgDkECaiIJQQN0aiAKIAlBAnRqKAIANgIAIAsgDkEDaiIJQQN0aiAKIAlBAnRqKAIANgIAIA5BBGoiDiAQRw0ACwwFCyATRQ0EQQAhCSAaQQNPBEADQCALIAooAgA2AgAgCyAPaiIMIAogEWoiDSgCADYCACAMIA9qIgwgDSARaiINKAIANgIAIAwgD2oiDCANIBFqIg0oAgA2AgAgDSARaiEKIAwgD2ohCyAJQQRqIgkgG0cNAAsLQQAhCSAWRQ0EA0AgCyAKKAIANgIAIAogEWohCiALIA9qIQsgCUEBaiIJIBZHDQALDAQLIBwgDUECdGohCyAQQQRHBEAgE0UNBCAQQQJ0IQlBACEOIBpBA08EQANAIAsgCiAJEBYgCiARaiINIBFqIgsgEWoiEiARaiEKIA9qIA0gCRAWIA9qIAsgCRAWIA9qIBIgCRAWIA9qIQsgDkEEaiIOIBtHDQALC0EAIQ4gFkUNBANAIAsgCiAJEBYgCiARaiEKIA9qIQsgDkEBaiIOIBZHDQALDAQLIBNFDQNBACEJIBpBA08EQANAIAsgCv0AAgD9CwIAIAsgD2oiDCAKIBFqIg39AAIA/QsCACAMIA9qIgwgDSARaiIN/QACAP0LAgAgDCAPaiIMIA0gEWoiDf0AAgD9CwIAIA0gEWohCiAMIA9qIQsgCUEEaiIJIBtHDQALC0EAIQkgFkUNAwNAIAsgCv0AAgD9CwIAIAogEWohCiALIA9qIQsgCUEBaiIJIBZHDQALDAMLA0BBACEJIA0EQANAIAsgCUEFdGogCiAJQQJ0aigCADYCACALIAlBAXIiDEEFdGogCiAMQQJ0aigCADYCACALIAlBAnIiDEEFdGogCiAMQQJ0aigCADYCACALIAlBA3IiDEEFdGogCiAMQQJ0aigCADYCACAJQQRqIgkgDUkNAAsLAkAgCSAQTw0AAkACQCAQIAlrIhRBB00NACALIAlBBXRqICIgESASbGpJBEAgCiAJQQJ0aiAVIA8gEmxqSQ0BCyAJ/RH9DAAAAAABAAAAAgAAAAMAAAD9rgEhMCAJIBRBfHEiF2ohDEEAIQ4DQCALIDBBBf2rASIx/RsAaiAKIAkgDmpBAnRq/QACACIy/VoCAAAgCyAx/RsBaiAy/VoCAAEgCyAx/RsCaiAy/VoCAAIgCyAx/RsDaiAy/VoCAAMgMP0MBAAAAAQAAAAEAAAABAAAAP2uASEwIA5BBGoiDiAXRw0ACyAUIBdHDQEMAgsgCSEMC0EAIQ4gECAMIglrQQNxIhQEQANAIAsgCUEFdGogCiAJQQJ0aigCADYCACAJQQFqIQkgDkEBaiIOIBRHDQALCyAMIBBrQXxLDQADQCALIAlBBXRqIAogCUECdGooAgA2AgAgCyAJQQFqIgxBBXRqIAogDEECdGooAgA2AgAgCyAJQQJqIgxBBXRqIAogDEECdGooAgA2AgAgCyAJQQNqIgxBBXRqIAogDEECdGooAgA2AgAgCUEEaiIJIBBHDQALCyAKIBFqIQogCyAPaiELIBMgEkEBaiISRw0ACwwCCyASRQRAQQEgACgCCCAAKAIMbEECdBAXIhJFBEBBAA8LIAAoAhggACgCECAebEECdGogDWogEjYCAAsgEiAlQQJ0aiAJQQJ0aiELIBggAWshCQJAIAZBAUcEQCAcIAYgCWxBAnRqIQogEEEBRwRAAkAgIw0AIBBBB00NACATRQ0FICYgCSAfbGogEEEFdGohIiAgIBBBAnRqIAxBAnRrIS8gEEF8cSEUQQAhDANAQQAhCSAUBEADQCALIAlBAnRqIAogCUEFdGooAgA2AgAgCyAJQQFyIg1BAnRqIAogDUEFdGooAgA2AgAgCyAJQQJyIg1BAnRqIAogDUEFdGooAgA2AgAgCyAJQQNyIg1BAnRqIAogDUEFdGooAgA2AgAgCUEEaiIJIBRJDQALCwJAIAkgEE8NAAJAAkAgECAJayIXQQdNDQAgCyAJQQJ0aiAiIAwgD2xqSQRAIAogCUEFdGogEiAvIAwgEWxqakkNAQsgCf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BITAgCSAXQXxxIhVqIQ1BACEOA0AgCyAJIA5qQQJ0aiAKIDBBBf2rASIx/RsDaiAKIDH9GwJqIAogMf0bAWogCiAx/RsAav1cAgD9VgIAAf1WAgAC/VYCAAP9CwIAIDD9DAQAAAAEAAAABAAAAAQAAAD9rgEhMCAOQQRqIg4gFUcNAAsgFSAXRw0BDAILIAkhDQtBACEOIBAgDSIJa0EDcSIXBEADQCALIAlBAnRqIAogCUEFdGooAgA2AgAgCUEBaiEJIA5BAWoiDiAXRw0ACwsgDSAQa0F8Sw0AA0AgCyAJQQJ0aiAKIAlBBXRqKAIANgIAIAsgCUEBaiINQQJ0aiAKIA1BBXRqKAIANgIAIAsgCUECaiINQQJ0aiAKIA1BBXRqKAIANgIAIAsgCUEDaiINQQJ0aiAKIA1BBXRqKAIANgIAIAlBBGoiCSAQRw0ACwsgCyARaiELIAogD2ohCiATIAxBAWoiDEcNAAsMBQsgE0UNBCAQQXxxIRQgEEEDcSESQQAhDSAQQQFrQQNJIRcMAgsgE0UNA0EAIQkgGkEDTwRAA0AgCyAKKAIANgIAIAsgEWoiDCAKIA9qIg0oAgA2AgAgDCARaiIMIA0gD2oiDSgCADYCACAMIBFqIgwgDSAPaiINKAIANgIAIAwgEWohCyANIA9qIQogCUEEaiIJIBtHDQALC0EAIQkgFkUNAwNAIAsgCigCADYCACALIBFqIQsgCiAPaiEKIAlBAWoiCSAWRw0ACwwDCyAcIAlBAnRqIQogEEEERwRAIBNFDQMgEEECdCEJQQAhDiAaQQNPBEADQCALIAogCRAWIAogD2oiDSAPaiILIA9qIhIgD2ohCiARaiANIAkQFiARaiALIAkQFiARaiASIAkQFiARaiELIA5BBGoiDiAbRw0ACwtBACEOIBZFDQMDQCALIAogCRAWIAogD2ohCiARaiELIA5BAWoiDiAWRw0ACwwDCyATRQ0CQQAhCSAaQQNPBEADQCALIAr9AAIA/QsCACALIBFqIgwgCiAPaiIN/QACAP0LAgAgDCARaiIMIA0gD2oiDf0AAgD9CwIAIAwgEWoiDCANIA9qIg39AAIA/QsCACANIA9qIQogDCARaiELIAlBBGoiCSAbRw0ACwtBACEJIBZFDQIDQCALIAr9AAIA/QsCACAKIA9qIQogCyARaiELIAlBAWoiCSAWRw0ACwwCCwNAAkAgEEUNAEEAIQ5BACEJQQAhDCAXRQRAA0AgCyAJQQJ0aiAKIAYgCWxBAnRqKAIANgIAIAsgCUEBciIVQQJ0aiAKIAYgFWxBAnRqKAIANgIAIAsgCUECciIVQQJ0aiAKIAYgFWxBAnRqKAIANgIAIAsgCUEDciIVQQJ0aiAKIAYgFWxBAnRqKAIANgIAIAlBBGohCSAMQQRqIgwgFEcNAAsLIBJFDQADQCALIAlBAnRqIAogBiAJbEECdGooAgA2AgAgCUEBaiEJIA5BAWoiDiASRw0ACwsgCyARaiELIAogD2ohCiATIA1BAWoiDUcNAAsMAQsDQAJAIBBFDQBBACEOQQAhCUEAIQwgF0UEQANAIAsgBiAJbEECdGogCiAJQQJ0aigCADYCACALIAlBAXIiFSAGbEECdGogCiAVQQJ0aigCADYCACALIAlBAnIiFSAGbEECdGogCiAVQQJ0aigCADYCACALIAlBA3IiFSAGbEECdGogCiAVQQJ0aigCADYCACAJQQRqIQkgDEEEaiIMIBRHDQALCyASRQ0AA0AgCyAGIAlsQQJ0aiAKIAlBAnRqKAIANgIAIAlBAWohCSAOQQFqIg4gEkcNAAsLIAogEWohCiALIA9qIQsgDUEBaiINIBNHDQALCyAhQQFqISEgECAYaiIYIANJDQALIB5BAWohHiATIB1qIh0gBEkNAAsLQQELGQECfiAAKQMAIgIgASkDACIDVSACIANTawu0NgUnfw9+AXsBfQF8IwBB0ABrIg8kACAPQZD/AzYCKCAAKAKEASAAKAKAAWwhGAJ/AkACQAJAIAAoAggiC0EIRwRAQQAgC0GAAkcNBBogD0HZ/wM2AigMAQsgAC0AXEEBcQ0AIBhBfHEhDSAPQc0AaiEoIA9BzABqISkgD0HIAGohMEGQ/wMhCwJAAkADQAJAAkACQAJAAkACQAJAAkAgACgCVCIMRQ0AIAwgACgCUCIOTQ0AIAAoAlggDkEDdGopAwAhMiAAIA5BAWo2AlAgCSAyIAoQMEUEQCAKQQFBmypBABATQQAMDwsgCSAAKAIQQQIgChAdQQJHBEAgCkEBQYMTQQAQE0EADA8LIAAoAhAgD0EoakECEBUgDygCKEGQ/wNGDQEgCkEBQcQfQQAQE0EADA4LIAtBk/8DRg0BCwNAIAkpAwgiMlAEfkIABSAyIAkpAzh9C1AEQCAAQcAANgIIDAILIAkgACgCEEECIAoQHUECRwRAIApBAUGDE0EAEBNBAAwOCyAAKAIQIA9BJGpBAhAVIA8oAiRBAU0EQCAKQQFB+y5BABATQQAMDgsCQCAPKAIoQYCBAkcNACAJKQMIIjJQBH5CAAUgMiAJKQM4fQtCAFINACAAQcAANgIIDAILAkAgACgCCCITQRBxRQRAIA8oAiQhCwwBCyAPKAIkIQsgACgCGCIORQ0AIAtBAmoiDCAOSwRAIApBAUGNwQBBABATQQAMDwsgACAOIAxrNgIYCyAPIAtBAmsiEDYCJEGgwgEhDCAPKAIoIQ4DQCAMIgsoAgAiGwRAIAtBDGohDCAOIBtHDQELCyALKAIEIBNxRQRAIApBAUHwKUEAEBNBAAwOCwJAIAAoAhQgEE8EQCAAKAIQIQwMAQsgCSkDCCIyUAR+QgAFIDIgCSkDOH0LIBCtUwRAIApBAUGALUEAEBNBAAwPCyAAKAIQIA8oAiQQGyIMRQRAIAAoAhAQFCAAQgA3AxAgCkEBQcgmQQAQE0EADA8LIAAgDDYCECAAIA8oAiQiEDYCFAsgCSAMIBAgChAdIgwgDygCJEcEQCAKQQFBgxNBABATQQAMDgsgCygCCCILRQRAIApBAUGo2wBBABATQQAMDgsgACAAKAIQIAwgCiALEQEARQRAIA8gDygCKDYCICAKQQFB4uwAIA9BIGoQE0EADA4LIAkpAzghMiAPKAIkIRIgACgC4AEiEygCKCIQIAAoAuQBIgxBKGwiDmoiFSgCFCIeQQFqIhwgFSgCHCILSwRAIBUCfyALs0MAAMhCkiJCQwAAgE9dIEJDAAAAAGBxBEAgQqkMAQtBAAsiCzYCHCAVKAIYIAtBGGwQGyELIBMoAigiECAOaiEVIAtFDQMgFSALNgIYIBUoAhQiHkEBaiEcCyAOIBBqIhMoAhggHkEYbGoiCyASQQRqNgIQIAsgMqcgEmtBBGsiDqw3AwggCyAbOwEAIBMgHDYCFAJAIBtBkP8DRw0AAkAgEygCECIMRQ0AIBMoAgwiCyATKAIETw0AIAwgC0EYbGogDq03AwALIAkpAzinIA8oAiRrQQRrrSIyIAApAzBXDQAgACAyNwMwCyAALQBcQQRxBEAgCSAANQIYIAogCSgCKBEIACAANQIYUgRAIApBAUGDE0EAEBNBAAwPCyAPQZP/AzYCKAwCCyAJIAAoAhBBAiAKEB1BAkcEQCAKQQFBgxNBABATQQAMDgsgACgCECAPQShqQQIQFSAPKAIoQZP/A0cNAAsLAkAgCSkDCCIyUAR+QgAFIDIgCSkDOH0LUARAIAAoAghBwABGDQELIAAtAFwiC0EEcUUEQCAAKALkAUGMLGwhDCAAKAK0AQJAAkAgACgCOARAIAkpAwgiMlAEfkIABSAyIAkpAzh9C6chEAwBCyAAKAIYIhBBAkkNAQsgACAQQQJrIhA2AhgLIAxqIRYgEEUNAyAJKQMIIjJQBH5CAAUgMiAJKQM4fQsgEK1TBEAgACgC0AEEQCAKQQFBrS1BABATQQAMDwsgCkECQa0tQQAQEwsgACgCGCIOQX5PBEAgCkEBQaMLQQAQE0EADA4LAkAgFigC3CsiDARAIBYoAuArIgtBfSAOa0sEQCAKQQFBlglBABATQQAMEAsgDCALIA5qQQJqEBsiCwRAIBYgCzYC3CsMBgsgFigC3CsQFCAWQQA2AtwrDAELIBYgDkECahAYIgs2AtwrIAsNBAsgCkEBQfsvQQAQE0EADA0LIABBCDYCCCAAIAtB+gFxOgBcDAMLIA8oAighCwwECyAVKAIYEBQgEygCKCAMQShsaiIAQQA2AhwgAEIANwIUIApBAUHyHUEAEBNBAAwKCyAAKALgASIbKAIoIhUgACgC5AEiE0EobCISaiIMKAIQIAwoAgxBGGxqIgsgCSkDOCIzQgJ9IjI3AwggCyAzIAA1Ahh8NwMQIAAoAhghDgJAIAwoAhQiHkEBaiIcIAwoAhwiC00EQCAMKAIYIQwMAQsgDAJ/IAuzQwAAyEKSIkJDAACAT10gQkMAAAAAYHEEQCBCqQwBC0EACyILNgIcIAwoAhggC0EYbBAbIQwgGygCKCIVIBJqIQsgDEUNBSALIAw2AhggCygCFCIeQQFqIRwLIAwgHkEYbGoiCyAOQQJqNgIQIAsgMsQ3AwggC0GT/wM7AQAgEiAVaiAcNgIUIAACfyAQBEBBCCAJIBYoAtwrIBYoAuAraiAAKAIYIAoQHSIQIAAoAhhGDQEaQcAAIBBBf0cNARogCkEBQYMTQQAQE0EADAsLQQAhEEHAAEEIIAAoAhgbCzYCCCAWIBYoAuArIBBqNgLgKwJAIAAtAFxBAXENACAAKAIsIgtBAEgNACAAKALkASIMIAtHDQAgACgCTA0AIAkoAhxBAkYNACAAKAK0ASAMQYwsbGoiCygC2CsiDiAAKALgASgCKCAMQShsaiIMKAIERw0AIA4gCygC1CtBAWoiC00NAAJAIAwoAhAgC0EYbGopAwAiMiAJKQM4UQ0AIAkgMiAKEDANACAKQQFBmypBABATQQAMCwsgCSAAKAIQQQIgChAdQQJHBEAgCkEBQYMTQQAQE0EADAsLIAAoAhAgD0EoakECEBUgDygCKEGQ/wNGDQIgCkEBQcQfQQAQE0EADAoLIAAtAFwiC0EJcUEBRw0AIAAgC0EIcjoAXCAAKAK0ASAAKALkASIOQYwsbGooAtgrQQFGDQAgCSgCHEECRg0AIAkpAzgiMkJ/UQ0AAkADQEEBIQwgCSAPQcYAaiILQQIgChAdQQJHDQEgCyAPQUBrQQIQFSAPKAJAQZD/A0cNAUGDEyEQIAkgC0ECIAoQHUECRw0JIAsgD0E8akECEBUgDygCPEEKRwRAQfsuIRAMCgsgD0EINgI8IAkgD0HGAGpBCCAKEB0iCyAPKAI8Rw0JIAtBCEcEQEGqHyEQDAoLIA9BxgBqIA9BOGpBAhAVIDAgD0E0akEEEBUgKSAPQTBqQQEQFSAoIA9BLGpBARAVIA4gDygCOEcEQCAPKAI0IgtBDkkNAiAPIAtBDGsiCzYCNCAJIAutIAogCSgCKBEIACAPNQI0UQ0BDAILCyAPKAIwIA8oAixHIQwLIAkgMiAKIAkoAiwRDABFDQggDA0AIAAgAC0AXEHuAXFBEHI6AFwCQCAYRQ0AIAAoArQBIRZBACELIBhBBE8EQANAIBYgC0GMLGxqIh4oAtgrIhz9ESAWIAtBAXJBjCxsaiIbKALYKyIV/RwBIBYgC0ECckGMLGxqIhIoAtgrIhP9HAIgFiALQQNyQYwsbGoiDigC2CsiDP0cA/0MAAAAAAAAAAAAAAAAAAAAAP04IkH9GwBBAXEEQCAeQdgraiAcQQFqNgIACyBB/RsBQQFxBEAgG0HYK2ogFUEBajYCAAsgQf0bAkEBcQRAIBJB2CtqIBNBAWo2AgALIEH9GwNBAXEEQCAOQdgraiAMQQFqNgIACyALQQRqIgsgDUcNAAsgGCANIgtGDQELA0AgFiALQYwsbGoiDigC2CsiDARAIA5B2CtqIAxBAWo2AgALIAtBAWoiCyAYRw0ACwsgCkECQabGAEEAEBMLIAAtAFxBAXENACAJIAAoAhBBAiAKEB1BAkcEQAJAIAAoAuQBQQFqIBhHDQAgGEUNACAAKAK0ASENQQAhCwNAIA0gC0GMLGxqIgkoAtQrRQRAIAkoAtgrRQ0ICyALQQFqIgsgGEcNAAsLIApBAUGDE0EAEBNBAAwJCyAAKAIQIA9BKGpBAhAVCyAPKAIoIQsgAC0AXEEBcQ0AIAtB2f8DRw0BCwsgC0HZ/wNHDQIgACgCCEGAAkYNAiAAQYACNgIIIABBADYC5AEMAgsgCygCGBAUIBsoAiggE0EobGoiAEEANgIcIABCADcCFCAKQQFB8h1BABATQQAMBAsgDyALNgIQIApBBEHX1QAgD0EQahATIAAgCzYC5AEgD0HZ/wM2AiggAEGAAjYCCAsgACgC5AEhCyAAKAK0ASEJAkACQCAALQBcQQFxDQACQAJAIAsgGE8NACAJIAtBjCxsaiEQA0AgECgC3CsNASAAIAtBAWoiCzYC5AEgEEGMLGohECALIBhHDQALDAELIAsgGEcNAQsgCEEANgIADAELAkACQCAKQQEgCSALQYwsbGoiEigCtCgEf0GQNQUgEi0AiCxBAnFFDQICQCASKAKoKCIORQRAQQAhDAwBCyASKAKsKCEJQQAhDEEAIQsgDkEETwRAIA5BfHEhC/0MAAAAAAAAAAAAAAAAAAAAACFBQQAhEANAIAkgEEEDdGoiDUEcaiANQRRqIA1BDGogDf1cAgT9VgIAAf1WAgAC/VYCAAMgQf2uASFBIBBBBGoiECALRw0ACyBBIEEgQf0NCAkKCwwNDg8AAQIDAAECA/2uASJBIEEgQf0NBAUGBwABAgMAAQIDAAECA/2uAf0bACEMIAsgDkYNAQsDQCAJIAtBA3RqKAIEIAxqIQwgC0EBaiILIA5HDQALCyASIAwQGCIJNgK0KCAJDQFBhB8LQQAQEyAKQQFB1j5BABATQQAMBQsgEiAMNgK8KCASKAKsKCEJIBIoAqgoIgwEQEEAIRBBACELA0AgCSALQQN0IhNqIg4oAgAiDQRAIBIoArQoIBBqIA0gDigCBBAWGiASKAKsKCATaiIJKAIEIAkoAgAQFCASKAKsKCIJIBNqQgA3AgAgEGohECASKAKoKCEMCyALQQFqIgsgDEkNAAsLIBJBADYCqCggCRAUIBJBADYCrCggEiASKAK0KDYCsCggEiASKAK8KDYCuCgLAn8gACgC6AEiCygCHCIiKAJMIAAoAuQBIglBjCxsaigC0CshGiALKAIYIhMoAhghIyALKAIUKAIAIh0gIigCBCAiKAIMIgsgCSAJICIoAhgiCW4iDSAJbGtsaiIOIBMoAgAiCSAJIA5JGyIMNgIAIB1BfyALIA5qIgkgCSAOSRsiCyATKAIIIgkgCSALSxsiCTYCCAJAIAkgDEogDEEATnFFBEAgCkEBQfUzQQAQEwwBCyAdKAIUIREgHSAiKAIIIA0gIigCECILbGoiDCATKAIEIgkgCSAMSRsiDTYCBCAdQX8gCyAMaiIJIAkgDEkbIgsgEygCDCIJIAkgC0sbIgk2AgwgCSANSiANQQBOcUUEQCAKQQFBzzNBABATDAELAkAgGigCBARAIB0oAhANAUEBDAMLIApBAUHJKUEAEBMMAQsCQAJAA0AgI0EANgIkIBEgIzQCACI2QgF9IjIgHTQCAHwgNn8+AgAgESAjNAIEIjVCAX0iMyAdNAIEfCA1fz4CBCARIDIgHTQCCHwgNn8+AgggHTQCDCEyIBEgMTYCECARIDIgM3wgNX8+AgwgESAaKAIEIgs2AhQgEUEBIAsgIigCUCIJayAJIAtLGzYCGCARKAI0EBQgEUEANgJEIBH9DAAAAAAAAAAAAAAAAAAAAAD9CwI0IAtBmAFsIQ0CQCARKAIcIglFBEAgESANEBgiCTYCHCAJRQ0FIBEgDTYCICAJQQAgDRAZGgwBCyANIBEoAiBNDQAgCSANEBsiC0UEQCAKQQFB7RdBABATIBEoAhwQFCARQgA3AhwMBQsgESALNgIcIAsgESgCICIJakEAIA0gCWsQGRogESANNgIgCyARKAIUIgsEQCAaQbAHaiEwIBpBrAZqIR4gGkEcaiEqIBEoAhwhGUEAISQDQCAZQn8gC0EBayIJrSI0hkJ/hSIzIBE0AgB8IDSHpyIVNgIAIBkgMyARNAIEfCA0h6ciEjYCBCAZIDMgETQCCHwgNIciMqciEzYCCCAZIDMgETQCDHwgNIciNaciDjYCDCAyxEIBIB4gJEECdCINaigCACIfrSIyhnxCAX0gMoenIB90IgxBAEgNBCA1xEJ/IA0gMGooAgAiIK0iMoZCf4V8IDKHpyAgdCINQQBIDQQgGSANQX8gIHQgEnEiK2sgIHVBACAOIBJHGyINNgIUIBkgDEF/IB90IBVxIixrIB91QQAgEyAVRxsiDDYCEAJAIAxFDQAgDK0gDa1+QiCIUA0ADAQLIAwgDWwiLUHnzJkzTw0DIC1BKGwhISAZICQEfyAgQQFrISAgH0EBayEfICusQgF8QgGIpyErICysQgF8QgGIpyEsQQMFQQELNgIYIBlBHGohFCArQQEgIHRqIRwgLEEBIB90aiEbQgEgC60iN4YhOEJ/IBooAgwiCyAgIAsgIEkbIiWtIj2GQn+FIT5CfyAaKAIIIgsgHyALIB9JGyImrSI/hkJ/hSFAQQAhEANAAn4gJEUEQCAzIBE0AgR8IDSHITkgMyARNAIAfCA0hyE6QQAhCyAzIjIhOyA0DAELIDggEEEBaiILQQF2rSA0hkJ/hXwiOyARNAIEfCA3hyE5IDggC0EBca0gNIZCf4V8IjIgETQCAHwgN4chOiA3CyE8IBE0AgghNiARNAIMITUgFCA5PgIEIBQgOj4CACAUIAs2AhAgFCA1IDt8IDyHPgIMIBQgMiA2fCA8hz4CCEEAIQ0CQCAaKAIURQ0AIAtFDQBBAkEBIAtBA0YbIQ0LRAAAAAAAAPA/IUMCQCAjKAIYIA1qICooAgAiDWsiC0GACE4EQEQAAAAAAADgfyFDIAtB/w9JBEAgC0H/B2shCwwCC0QAAAAAAADwfyFDQf0XIAsgC0H9F08bQf4PayELDAELIAtBgXhKDQBEAAAAAAAAYAMhQyALQbhwSwRAIAtByQdqIQsMAQtEAAAAAAAAAAAhQ0HwaCALIAtB8GhNG0GSD2ohCwsgFCAqKAIEt0QAAAAAAABAP6JEAAAAAAAA8D+gIEMgC0H/B2qtQjSGv6KitjgCICAUIA0gGigCpAZqQQFrNgIcIBQoAhQhCwJAAkACQCAtRQ0AIAsNACAUICEQGCILNgIUIAtFBEAgCkEBQYEWQQAQEwwKCyALQQAgIRAZGiAUICE2AhgMAQsgISAUKAIYSwRAIAsgIRAbIg1FBEAgCkEBQYEWQQAQEyAUKAIUEBQgFEIANwIUDAoLIBQgDTYCFCANIBQoAhgiC2pBACAhIAtrEBkaIBQgITYCGAsgLUUNAQsgFCgCFCELQQAhLgNAIAsgLiAuIBkoAhAiDW4iEyANbGsgH3QiDiAsaiIMIBQoAgAiDSAMIA1KGyIVNgIAIAsgEyAgdCISICtqIgwgFCgCBCINIAwgDUobIhM2AgQgCyAOIBtqIgwgFCgCCCINIAwgDUgbIg42AgggCyASIBxqIgwgFCgCDCINIAwgDUgbIg02AgwgCyBAIA6sfCA/h6cgFSAmdSIoayAmdCAmdSIMNgIQIAsgPiANrHwgPYenIBMgJXUiKWsgJXQgJXUiDTYCFCAMIA1sIi+tQsQAfkIgiEIAUgRAIApBAUHSFkEAEBMMCQsgL0HEAGwhDgJAAkACQCALKAIYIg0NACAvRQ0AIAsgDhAYIg02AhggDUUNCyANQQAgDhAZGgwBCyAOIAsoAhxNDQEgDSAOEBsiDEUEQCALKAIYEBQgC0IANwIYIApBAUHQE0EAEBMMCwsgCyAMNgIYIAwgCygCHCINakEAIA4gDWsQGRoLIAsgDjYCHAsgCygCFCEOIAsoAhAhDCALAn8gCygCICINRQRAIAwgDiAKEGwMAQsgDSAMIA4gChBqCzYCICALKAIUIQ4gCygCECEMIAsCfyALKAIkIg1FBEAgDCAOIAoQbAwBCyANIAwgDiAKEGoLNgIkIC8EQCApQQFqIRIgKEEBaiETQQAhJwNAICcgCygCECIObiEYAkAgCygCGCAnQcQAbGoiFygCACIVBEAgFygCOCEMIBcoAgQhDSAXKAIwIRYgFygCPBAUIBf9DAAAAAAAAAAAAAAAAAAAAAD9CwIoIBdBQGtBADYCACAXQgA3AjggF/0MAAAAAAAAAAAAAAAAAAAAAP0LAhggF/0MAAAAAAAAAAAAAAAAAAAAAP0LAgggFyAVNgIAIBcgFjYCMCAWBEAgFUEAIBZBGGwQGRoLIBcgDDYCOCAXIA02AgQMAQsgF0EKQRgQFyINNgIAIA1FDQsgF0EKNgIwCyAXICcgDiAYbGsiDiAoaiAmdCIMIAsoAgAiDSAMIA1KGzYCCCAXIBggKWogJXQiDCALKAIEIg0gDCANShs2AgwgFyAOIBNqICZ0IgwgCygCCCINIAwgDUgbNgIQIBcgEiAYaiAldCIMIAsoAgwiDSAMIA1IGzYCFCAnQQFqIicgL0cNAAsLIAtBKGohCyAuQQFqIi4gLUcNAAsLICpBCGohKiAUQSRqIRQgEEEBaiIQIBkoAhhJDQALIBlBmAFqIRkgCSELICRBAWoiJCARKAIUSQ0ACwsgI0E0aiEjIBFBzABqIREgGkG4CGohGiAxQQFqIjEgHSgCEEkNAAtBAQwDCyAKQQFBgRdBABATDAELIApBAUGgEkEAEBMLQQALRQRAIApBAUGvHEEAEBNBAAwECyAAKALkASEJIA8gACgCgAEgACgChAFsNgIEIA8gCUEBajYCACAKQQRBjNwAIA8QEyABIAAoAuQBNgIAIAhBATYCACACBEAgAiAAKALoAUEAEF0iATYCAEEAIAFBf0YNBBoLIAMgACgC6AEoAhQoAgAiASgCADYCACAEIAEoAgQ2AgAgBSABKAIINgIAIAYgASgCDDYCACAHIAEoAhA2AgAgACAAKAIIQYABcjYCCAtBAQwCCyAKQQEgEEEAEBMLIApBAUHRHEEAEBNBAAsgD0HQAGokAAvuEAIMfwJ+AkAgACgCICICDQACQCAAKAIQIglBBUoEQCAJIQIMAQsCQAJAIAAoAhQiBkEFTgRAIAAoAgAiASgCACECIAAgAUEEajYCACAGQQRrIQcMAQsgBkEATARAQX8hAgwCCyAAKAIAIQECfyAGQQFGBEBBfyEFQQAMAQtBfyEFIAZBAWsiBEEBcQJAIAZBAkYEQEEAIQIgBiEEDAELIARBfnEhC0EAIQIgASEDIAYhBANAIAAgA0EBajYCACADLQAAIQwgACADQQJqIgE2AgAgACAEQQFrNgIUIAMtAAEhAyAAIARBAmsiBDYCFCAFQf8BIAJ0QX9zcSAMIAJ0ckGA/gMgAnRBf3NxIAMgAkEIcnRyIQUgAkEQaiECIAEhAyAIQQJqIgggC0cNAAsLBEAgACABQQFqIgM2AgAgAS0AACEBIAAgBEEBazYCFCAFQf8BIAJ0QX9zcSABIAJ0ciEFIAMhAQsgBkEDdEEIawshAiAAIAFBAWo2AgAgBUH/ASACdEF/c3EgAS0AAEEPciACdHIhAgsgACAHNgIUCyAAKAIYIQEgACACQRh2IgRB/wFGNgIYIAAgCSACQRB2Qf8BcSIDQf8BRiIGIAJBCHZB/wFxIgVB/wFGIgcgASACQf8BcSIIQf8BRiIKampqIgFrQSBqIgI2AhAgACAAKQMIIAhBB0EIIAobdCAFckEHQQggBxt0IANyQQdBCCAGG3QgBHKtIAEgCWtBIGqthoQ3AwggAkEGTg0AQQAhAgwBCyAAKAIcIgFBAnRB4KEBaigCACEDAn4gACkDCCINQgBTBEBBDCABQQFqIAFBC04bIQQgAkEBayECQX8gA3RBf3NBAXQhAUIBDAELIAFBAWtBACABQQFKGyEEIA1BPyADa62Ip0F/IAN0QX9zcUEBdEEBciEBIAIgA0EBaiIDayECIAOtCyEOIAAgAjYCECAAIAQ2AhwgACANIA6GNwMIIAAgAawgACkDKEJAg4Q3AyggAkEGSARAQQEhAgwBCyAAKAIcIgFBAnRB4KEBaigCACEDAn4gACkDCCINQgBTBEBBDCABQQFqIAFBC04bIQQgAkEBayECQX8gA3RBf3NBAXQhAUIBDAELIAFBAWtBACABQQFKGyEEIA1BPyADa62Ip0F/IAN0QX9zcUEBdEEBciEBIAIgA0EBaiIDayECIAOtCyEOIAAgAjYCECAAIAQ2AhwgACANIA6GNwMIIAAgACkDKEL/QIMgAaxCB4aENwMoIAJBBkgEQEECIQIMAQsgACgCHCIBQQJ0QeChAWooAgAhAwJ+IAApAwgiDUIAUwRAQQwgAUEBaiABQQtOGyEEIAJBAWshAkF/IAN0QX9zQQF0IQFCAQwBCyABQQFrQQAgAUEBShshBCANQT8gA2utiKdBfyADdEF/c3FBAXRBAXIhASACIANBAWoiA2shAiADrQshDiAAIAI2AhAgACAENgIcIAAgDSAOhjcDCCAAIAApAyhC//9AgyABrEIOhoQ3AyggAkEGSARAQQMhAgwBCyAAKAIcIgFBAnRB4KEBaigCACEDAn4gACkDCCINQgBTBEBBDCABQQFqIAFBC04bIQQgAkEBayECQX8gA3RBf3NBAXQhAUIBDAELIAFBAWtBACABQQFKGyEEIA1BPyADa62Ip0F/IAN0QX9zcUEBdEEBciEBIAIgA0EBaiIDayECIAOtCyEOIAAgAjYCECAAIAQ2AhwgACANIA6GNwMIIAAgACkDKEL///9AgyABrEIVhoQ3AyggAkEGSARAQQQhAgwBCyAAKAIcIgFBAnRB4KEBaigCACEDAn4gACkDCCINQgBTBEBBDCABQQFqIAFBC04bIQQgAkEBayECQX8gA3RBf3NBAXQhAUIBDAELIAFBAWtBACABQQFKGyEEIA1BPyADa62Ip0F/IAN0QX9zcUEBdEEBciEBIAIgA0EBaiIDayECIAOtCyEOIAAgAjYCECAAIAQ2AhwgACANIA6GNwMIIAAgACkDKEL/////QIMgAaxCHIaENwMoIAJBBkgEQEEFIQIMAQsgACgCHCIBQQJ0QeChAWooAgAhBAJ/IAApAwgiDUIAUwRAIAJBAWshA0F/IAR0QX9zQQF0IQVCASEOQQwgAUEBaiABQQtOGwwBCyANQT8gBGutiKdBfyAEdEF/c3FBAXRBAXIhBSACIARBAWoiBGshAyAErSEOIAFBAWtBACABQQFKGwshASAAIAM2AhAgACABNgIcIAAgDSAOhjcDCCAAIAApAyhC//////9AgyAFrUIjhoQ3AyhBBiECIANBBkgNACAAKAIcIgFBAnRB4KEBaigCACEEAn8gACkDCCINQgBTBEAgA0EBayECQX8gBHRBf3NBAXQhBUIBIQ5BDCABQQFqIAFBC04bDAELIA1BPyAEa62Ip0F/IAR0QX9zcUEBdEEBciEFIAMgBEEBaiIEayECIAStIQ4gAUEBa0EAIAFBAUobCyEBIAAgAjYCECAAIAE2AhwgACANIA6GNwMIIAAgACkDKEL///////9AgyAFrUIqhoQ3AyggAkEGSARAQQchAgwBCyAAKAIcIgFBAnRB4KEBaigCACEDAn4gACkDCCINQgBTBEBBDCABQQFqIAFBC04bIQQgAkEBayECQX8gA3RBf3NBAXQhAUIBDAELIAFBAWtBACABQQFKGyEEIA1BPyADa62Ip0F/IAN0QX9zcUEBdEEBciEBIAIgA0EBaiIDayECIAOtCyEOIAAgAjYCECAAIAQ2AhwgACANIA6GNwMIIAAgACkDKEL/////////QIMgAa1CMYaENwMoQQghAgsgACACQQFrNgIgIAAgACkDKCIOQgeINwMoIA6nQf8AcQsiAQF/IAAEQCAAKAIMIgEEQCABEBQgAEEANgIMCyAAEBQLC4IBAgF+A38CQCAAQoCAgIAQVARAIAAhAgwBCwNAIAFBAWsiASAAQgqAIgJC9gF+IAB8p0EwcjoAACAAQv////+fAVYgAiEADQALCyACQgBSBEAgAqchAwNAIAFBAWsiASADQQpuIgRB9gFsIANqQTByOgAAIANBCUsgBCEDDQALCyABC08BAX8gAEEANgIwIAAgACgCIDYCJCABIAAoAgAgACgCHBELACAAKAJEIQJFBEAgACACQQRyNgJEQQAPCyAAIAE3AzggACACQXtxNgJEQQEL3t4BBHB/BnsIfgF9IwBBEGsiTCQAAkAgAC0ACEGAAXFFDQAgASAAKALkAUcNACAAKAK0ASABQYwsbGoiTSgC3CsiF0UEQCBNEDQMAQsgACgC4AEaIAAoAugBIRsgACgCZCIHRQRAIAAoAmAhBwsgBygCACEGIAcoAgQhCyAHKAIIIQkgBygCDCEPIAAoAjwhByAAKAJAIQ4gTSgC4CshCCMAQRBrIj8kACAbIAE2AiQgGygCHCgCTCEMIBtBATYCQCAbIA82AjwgGyAJNgI4IBsgCzYCNCAbIAY2AjAgGyAMIAFBjCxsajYCICAbKAJEEBRBACELIBtBADYCRAJAIAcEQEEEIBsoAhgoAhAQFyILRQRADAILIAdBBE8EQCAHQXxxIQlBACEBA0AgCyAOICJBAnRqIgYoAgBBAnRqQQE2AgAgCyAGKAIEQQJ0akEBNgIAIAsgBigCCEECdGpBATYCACALIAYoAgxBAnRqQQE2AgAgIkEEaiEiIAFBBGoiASAJRw0ACwsgB0EDcSIBBEADQCALIA4gIkECdGooAgBBAnRqQQE2AgAgIkEBaiEiIBlBAWoiGSABRw0ACwsgGyALNgJECwJAAkAgGygCGCIGKAIQIg5FDQBBACEiAkADQAJAIAsEQCALICJBAnRqKAIARQ0BCyAGKAIYICJBNGxqIgE1AgQifEIBfSKAASAbNQI8fCB8gCGBASABNQIAIn1CAX0ifiAbNQI4fCB9gCGCASCAASAbNQI0fCB8gCF8IBsoAhQoAgAoAhQgIkHMAGxqIgEoAhQgASgCGGsiB0EfSw0AAkAgfiAbNQIwfCB9gKciCSABKAIAayIPQQAgCSAPTxsgB3YNACB8pyIJIAEoAgRrIg9BACAJIA9PGyAHdg0AIAEoAggiCSCCAadrIg9BACAJIA9PGyAHdg0AIAEoAgwiASCBAadrIglBACABIAlPGyAHdkUNAQsgG0EANgJADAILICJBAWoiIiAORw0ACyAbKAJARQ0AQQAhGQNAIBsoAhQoAgAoAhQgGUHMAGxqIgEoAhwgASgCGEGYAWxqIgdBlAFrKAIAIQYgB0GMAWsoAgAhCyAHQZgBaygCACEOIAdBkAFrKAIAIQkCQCAbKAJEIgcEQCAHIBlBAnRqKAIARQ0BCyALIAZrIQcgCSAOayEOAkAgBiALRg0AIAetIA6tfkIgiFANAEEAISIgBUEBQYEXQQAQEwwGCyAHIA5sIgdBgICAgARPBEBBACEiIAVBAUGBF0EAEBMMBgsgASAHQQJ0Igc2AiwCQAJAAkAgASgCJCIGBEAgByABKAIwTQ0EIAEoAigNAQsgASAHEBwiBzYCJCAHQQEgASgCLCIHG0UNASABQQE2AiggASAHNgIwDAMLIAYQFCABIAEoAiwQHCIHNgIkIAcNASABQQA2AjAgAUIANwIoC0EAISIgBUEBQYEXQQAQEwwGCyABQQE2AiggASABKAIsNgIwCyAZQQFqIhkgGygCGCIGKAIQSQ0ACwwBCyAGKAIYIRkgGygCFCgCACgCFCENQQAhAQNAAkAgCwRAIAsgAUECdGooAgBFDQELIA0gAUHMAGxqIgcgBygCACIJIBkgAUE0bGoiDzUCACJ8QgF9IoABIBs1AjB8IHyApyIMIAkgDEsbIgk2AjggByAHKAIEIgwgDzUCBCJ9QgF9IoEBIBs1AjR8IH2ApyIPIAwgD0sbIg82AjwgByAHKAIIIgwggAEgGzUCOHwgfICnIgogCiAMSxsiDDYCQCAHIAcoAgwiCiCBASAbNQI8fCB9gKciFSAKIBVJGyIKNgJEIAkgDEsNAyAKIA9JDQMgBygCFCIVRQ0AIAqtQgF9IYEBIAytQgF9IX4gD61CAX0hggEgCa1CAX0hgwEgFa0hfyAHKAIcIQlCACF9A0AgCSB9pyIPQZgBbGoiB0IBIBUgD0F/c2qtInyGIoABIIEBfCB8iD4ClAEgByB+IIABfCB8iD4CkAEgByCAASCCAXwgfIg+AowBIAcggAEggwF8IHyIPgKIASB9QgF8In0gf1INAAsLIAFBAWoiASAORw0ACwtBACEiID9BADYCCCAbKAIcIQFBAUEIEBciIwRAICMgATYCBCAjIAY2AgALICNFDQEgGygCJCEUIBsoAhQoAgAhHyMAQZABayIQJAAgFEGMLGwiASAjKAIEIgkoAkxqIh4oAqQDIS4CfyAjKAIAIighFSAFITNBACEOIwBBIGsiDSQAIAEgCSgCTGoiGCgCpAMhHQJAIBUoAhAiFkGQBGwQGCIPRQ0AAkAgFkECdBAYIgtFBEAgDyELDAELAkACQAJ/IAkoAkwgFEGMLGxqIgooAqQDIhlBAWoiAUHwARAXIgcEQAJAIAEEQCAVKAIQIQwgByEBA0AgASAzNgLsASABIAxBEBAXIgY2AsgBIAZFDQIgASAVKAIQIho2AsQBQQAhBkEAIQwgGgRAA0AgASgCyAEgBkEEdGoiDCAKKALQKyAGQbgIbGoiGigCBEEQEBciJjYCDCAmRQ0EIAwgGigCBDYCCCAGQQFqIgYgFSgCECIMSQ0ACwsgAUHwAWohASATIBlGIBNBAWohE0UNAAsLIAcMAgsgBygCBCIBBEAgARAUIAdBADYCBAsgByEBQQAhCgNAIAEoAsgBIgYEQEEAIQwgASgCxAEiEwR/A0AgBigCDCIaBEAgGhAUIAZBADYCDCABKALEASETCyAGQRBqIQYgDEEBaiIMIBNJDQALIAEoAsgBBSAGCxAUIAFBADYCyAELIAFB8AFqIQEgCiAZRiAKQQFqIQpFDQALIAcQFAtBAAsiBwRAIBZFDQJBACEKIA8hBiAWQQNNDQEgBiAWQXxxIgpBkARsaiEGIA8hAQNAIAsgEUECdGogAf0R/QwAAAAAEAIAACAEAAAwBgAA/a4B/QsCACABQcAQaiEBIBFBBGoiESAKRw0ACyAKIBZHDQEMAgsgDxAUDAILA0AgCyAKQQJ0aiAGNgIAIAZBkARqIQYgCkEBaiIKIBZHDQALCyALIRlBACETIAkoAkwgFEGMLGxqKALQKyEBIBUoAhghCiANIAkoAgQgCSgCDCAUIBQgCSgCGCIGbiILIAZsa2xqIgYgFSgCACIMIAYgDEsbNgIUIA1BfyAGIAkoAgxqIgwgBiAMSxsiBiAVKAIIIgwgBiAMSRs2AhAgDSAJKAIIIAkoAhAgC2xqIgYgFSgCBCILIAYgC0sbNgIMIA1BfyAGIAkoAhBqIgsgBiALSxsiBiAVKAIMIgsgBiALSRs2AgggDUEANgIYIA1BADYCHCANQf////8HNgIEIA1B/////wc2AgAgFSgCEARAA0AgGQR/IBkgE0ECdGooAgAFQQALIQsgCjUCBCJ8QgF9IoABIA01Agh8IHyAIYEBIAo1AgAifUIBfSJ+IA01AhB8IH2AIYIBIIABIA01Agx8IHyAIXwgfiANNQIUfCB9gCF9IAEoAgQiCSANKAIcSwRAIA0gCTYCHCABKAIEIQkLIAkEQCABQbAHaiEaIAFBrAZqISYggQFC/////w+DQgF9IYABIIIBQv////8Pg0IBfSGBASB8Qv////8Pg0IBfSF+IH1C/////w+DQgF9IYIBQQAhFANAIBogFEECdCIMaigCACEGIAwgJmooAgAhDEEAIREgCwRAIAsgBjYCBCALIAw2AgAgC0EIaiERCwJAIAwgCUEBayIJaiILQR9LDQAgCigCACIkQX8gC3ZLDQAgDSANKAIEIiwgJCALdCILIAsgLEsbNgIECwJAIAYgCWoiC0EfSw0AIAooAgQiJEF/IAt2Sw0AIA0gDSgCACIsICQgC3QiCyALICxLGzYCAAtBACELQgEgCa0ifIYifSCAAXwgfIgigwFC/////w+DQgEgBq0if4Z8QgF9IH+IpyB9IH58IHyIpyIkIAZ2a0F/IAZ2cUEAICQggwGnRxshBiB9IIEBfCB8iCKDAUL/////D4NCASAMrSJ/hnxCAX0gf4inIH0gggF8IHyIpyIkIAx2a0F/IAx2cUEAICQggwGnRxshDCARBEAgESAGNgIEIBEgDDYCACARQQhqIQsLIAYgDGwiBiANKAIYSwRAIA0gBjYCGAsgFEEBaiIUIAEoAgRJDQALCyAKQTRqIQogAUG4CGohASATQQFqIhMgFSgCEEkNAAsLIB1BAWohJiANKAIcIRMgDSgCGCEUIAdBADYCBAJAIBgoAghBAWoiAa0gEyAUIBZsIiRsIhqtfkIgiFAEQCAHIAEgGmwiATYCCCAHIAFBAhAXIgE2AgQgAQ0BCyAPEBQgGRAUIAcoAgQiAQRAIAEQFCAHQQA2AgQLICZFBEAgByELDAILQQAhCyAHIQEDQCABKALIASIKBEBBACEGIAEoAsQBIhEEfwNAIAooAgwiCQRAIAkQFCAKQQA2AgwgASgCxAEhEQsgCkEQaiEKIAZBAWoiBiARSQ0ACyABKALIAQUgCgsQFCABQQA2AsgBCyABQfABaiEBIAsgHUYgC0EBaiELRQ0ACyAHIQsMAQsgFSgCGCEMIAcgDSgCFCIsNgLMASAHIA0oAgwiLTYC0AEgByANKAIQIiA2AtQBIAcgDSgCCCI4NgLYASAHIBo2AgwgByAkNgIQIAcgFDYCFEEBIRUgB0EBNgIYIBYEQCAHKALIASEBQQAhCSAMIQsDQCAZIAlBAnRqKAIAIQogASALKAIANgIAIAEgCygCBDYCBAJAIAEoAggiDkUNACABKAIMIQYgDkEBRwRAIA5BfnEhPEEAIREDQCAGIAooAgA2AgAgBiAKKAIENgIEIAYgCigCCDYCCCAGIAooAgw2AgwgBiAKKAIQNgIQIAYgCigCFDYCFCAGIAooAhg2AhggBiAKKAIcNgIcIAZBIGohBiAKQSBqIQogEUECaiIRIDxHDQALCyAOQQFxRQ0AIAYgCigCADYCACAGIAooAgQ2AgQgBiAKKAIINgIIIAYgCigCDDYCDAsgC0E0aiELIAFBEGohASAJQQFqIgkgFkcNAAsLICZBAUsEQCAHIQ4DQCAOIDg2AsgDIA4gIDYCxAMgDiAtNgLAAyAOICw2ArwDIA5BATYCiAIgDiAUNgKEAiAOICQ2AoACIA4gGjYC/AEgFgRAIA4oArgDIQFBACEJIAwhCwNAIBkgCUECdGooAgAhCiABIAsoAgA2AgAgASALKAIENgIEAkAgASgCCCImRQ0AIAEoAgwhBiAmQQFHBEAgJkF+cSE8QQAhEQNAIAYgCigCADYCACAGIAooAgQ2AgQgBiAKKAIINgIIIAYgCigCDDYCDCAGIAooAhA2AhAgBiAKKAIUNgIUIAYgCigCGDYCGCAGIAooAhw2AhwgBkEgaiEGIApBIGohCiARQQJqIhEgPEcNAAsLICZBAXFFDQAgBiAKKAIANgIAIAYgCigCBDYCBCAGIAooAgg2AgggBiAKKAIMNgIMCyALQTRqIQsgAUEQaiEBIAlBAWoiCSAWRw0ACwsgDiAOKQIENwL0ASAVIB1HIA5B8AFqIQ4gFUEBaiEVDQALCyAPEBQgGRAUIBgoAqQDIQsCQCAYLQCILEEEcQRAIAtBf0YNASAYQagDaiEGIBgoAgghAUEAIREgByEKA0AgBigCJCEOIApBATYCLCAKIA42AlQgCiAGKAIANgIwIAYoAgQhDiAKQgA3AkQgCiAONgI0IAogBigCDDYCPCAKIAYoAhA2AkAgBigCCCEOIAogFDYCTCAKIA4gASABIA5LGzYCOCAGQZQBaiEGIApB8AFqIQogCyARRiARQQFqIRFFDQALDAELIAtBf0YNACAYKAIIIQYgGCgCBCEOIAchCiALBEAgC0EBakF+cSEJQQAhAQNAIApCADcCRCAKQQA2AjQgCkIBNwIsIAogDjYCVCAKIBM2AjwgCiAONgLEAiAKIBQ2AkwgCiAGNgI4IApCADcCtAIgCkEANgKkAiAKQgE3ApwCIAogEzYCrAIgCiAGNgKoAiAKIBQ2ArwCIAogCigCxAE2AkAgCiAKKAK0AzYCsAIgCkHgA2ohCiABQQJqIgEgCUcNAAsLIAtBAXENACAKQgA3AkQgCkEANgI0IApCATcCLCAKIA42AlQgCiATNgI8IAogFDYCTCAKIAY2AjggCiAKKALEATYCQAsgByEODAELIAsQFAsgDUEgaiQAAkAgDkUNACAuQQFqISYgFyEZIA4hFQJAAkADQCAVKAJUQX9GDQIgKCgCEEECdBAYIgFFDQIgAUEBICgoAhBBAnQQGSEaIBUQYARAA0AgHygCFCEJAkACQCAVKAIoIB4oAgxPDQAgFSgCICIBIAkgFSgCHEHMAGxqIgcoAhhPDQAgBygCHCABQZgBbGoiBygCGEUNACAHQRxqIQZBACENAkADQCAbIBUoAhwgFSgCICAGIA1BJGxqIgEoAhAgASgCFCAVKAIkQShsaiIBKAIAIAEoAgQgASgCCCABKAIMEEFFBEAgDUEBaiINIAcoAhhJDQEMAgsLIBogFSgCHEECdGpBADYCACAQQQA2AogBICMoAgQgHygCFCAeIBUgEEGMAWogGSAQQYgBaiAIIDMQX0UNBiAVKAIgIQ0gFSgCHCEPIBAoAogBIREgECgCjAEEQCAQQQA2AogBIB8oAhQgD0HMAGxqKAIcIA1BmAFsaiIdKAIYIgkEfyAIIBFrIQYgCCAZaiEkIB1BHGohD0EAIQpBACEYIBEgGWoiLiEUA0ACQCAPKAIIIA8oAgBGDQAgDygCDCAPKAIERg0AIA8oAhQgFSgCJEEobGoiASgCFCABKAIQbCIsRQ0AIAEoAhghCUEAIRMDQCAJKAIkIgsEQAJ/AkAgGEUEQCAJKAJARQ0BCyAJQQA2AjRBASENQcAADAELIAkoAgAhDQJAIAkgCSgCKCIBBH8gDSABQRhsaiINQRRrKAIAIA1BDGsoAgBHBEAgDUEYayENDAILIAFBAWoFQQELNgIoCwJ/AkAgDSgCFCIBIBRBf3NLDQAgDUEUaiEMA0AgASAUaiAkSw0BIAkoAgQhFiAJKAI0IhggCSgCOEcEfyALBSAWIBhBAXRBAXIiAUEDdBAbIhZFBEAgM0EBQYAIQQAQEwwSCyAJIAE2AjggCSAWNgIEIAkoAjQhGCAMKAIAIQEgCSgCJAshByAWIBhBA3RqIgsgATYCBCALIBQ2AgAgCSAYQQFqNgI0IA0gDSgCACABajYCACANIA0oAhAiDCANKAIEaiIWNgIEIAkgByAMayILNgIkIA0gFjYCCCABIBRqIRRBACAHIAxGDQIaIAkgCSgCKEEBajYCKCANQSxqIQwgDSgCLCEBIA1BGGohDSABIBRBf3NNDQALCyAVKAIcIQcgFSgCICELIBUoAiQhDCAjKAIEKAJoBEAgECAHNgJ4IBAgCzYCdCAQIAo2AnAgECAMNgJsIBAgEzYCaCAQIAY2AmQgECABNgJgIDNBAUHA8gAgEEHgAGoQEwwPCyAQIAc2AlggECALNgJUIBAgCjYCUCAQIAw2AkwgECATNgJIIBAgBjYCRCAQIAE2AkAgM0ECQcDyACAQQUBrEBMgCUEANgI0IAlBATYCQEEBCyEYIAkoAighDUEsCyAJaiANNgIACyAJQcQAaiEJIBNBAWoiEyAsRw0ACyAdKAIYIQkLIA9BJGohDyAKQQFqIgogCUkNAAsgFSgCICENIBUoAhwhDyAGIBQgLmsgGBsFQQALIBFqIRELICgoAhggD0E0bGoiASANIAEoAiQiASABIA1JGzYCJAwCCyAfKAIUIQkLIBBBADYCiAEgIygCBCAJIB4gFSAQQYwBaiAZIBBBiAFqIAggMxBfRQ0EIBUoAhwhDyAQKAKIASERIBAoAowBRQ0AIB8oAhQgD0HMAGxqKAIcIBUoAiAiGEGYAWxqIgEoAhgiJEUNACAIIBFrIQYgAUEcaiEWIBUoAiQhDEEAIQ1BACEdAkACQANAAkAgFigCCCAWKAIARg0AIBYoAgwgFigCBEYNACAWKAIUIAxBKGxqIgEoAhQgASgCEGwiLkUNACABKAIYIQtBACEKA0AgCygCJCIBBEAgCygCACEJAkAgCyALKAIoIhMEfyAJIBNBGGxqIglBFGsoAgAgCUEMaygCAEcEQCAJQRhrIQkMAgsgE0EBagVBAQsiEzYCKAsgCSgCFCIUIA1qIg0gFEkNBSAGIA1JDQUDQAJAIAkgCSgCECIUIAkoAgRqNgIEIAEgFGshByABIBRGDQAgCyATQQFqIhM2AiggCSgCLCIUIA1qIg0gFEkNBiAJQRhqIQkgByEBIAYgDU8NAQwGCwsgCyAHNgIkCyALQcQAaiELIApBAWoiCiAuRw0ACwsgFkEkaiEWIB1BAWoiHSAkRw0ACyANIBFqIREMAgsgCyAHNgIkCyAjKAIEKAJoRQRAIBAgDzYCGCAQIBg2AhQgECAdNgIQIBAgDDYCDCAQIAo2AgggECAGNgIEIBAgFDYCACAzQQJB6/EAIBAQEyAVKAIcIQ8gBiARaiERDAELIBAgDzYCOCAQIBg2AjQgECAdNgIwIBAgDDYCLCAQIAo2AiggECAGNgIkIBAgFDYCICAzQQFB6/EAIBBBIGoQEwwECwJAIBogD0ECdGooAgBFDQAgKCgCGCAPQTRsaiIBKAIkDQAgASAfKAIUIA9BzABsaigCGEEBazYCJAsgCCARayEIIBEgGWohGSAVEGANAAsLIBoQFCAVQfABaiEVIBxBAWoiHCAeKAKkA00NAAsgDiAmEEIgPyAZIBdrNgIIQQEMAwsgDiAmEEIgGhAUDAELIA4gJhBCC0EACyAQQZABaiQAICMQMkUNASAbKAIgKALQKyEiIBsoAhQoAgAiECgCFCEOID9BATYCDEEAIRlBACEMIBsoAiAiASgCDCABKAIIRgRAICIoAhBBBHZBAXEhDAsCQCAQKAIQIgpFDQADQAJAIBsoAkQiAQRAIAEgGUECdGooAgBFDQELID9BDGohFEEAIQoCQCAOKAIYIgFFDQAgGygCLCERA0AgDigCHCAKQZgBbGoiDygCGCILBEAgD0EcaiETIA8oAhQhASAPKAIQIRVBACEXA0AgASAVbARAIBMgF0EkbGohDUEAIQkDQCAbIA4oAhAgCiANKAIQIA0oAhQgCUEobGoiBygCACAHKAIEIAcoAgggBygCDBBBIQYgBygCFCILIAcoAhAiCGwhAQJAIAYEQCABRQ0BQQAhCANAAkAgGyAOKAIQIAogDSgCECAHKAIYIAhBxABsaiIGKAIIIAYoAgwgBigCECAGKAIUEEFFBEAgBigCPCIBRQ0BIAEQFCAGQQA2AjwMAQsgGygCQEUEQCAGKAI8DQEgBigCECAGKAIIRg0BIAYoAhQgBigCDEYNAQtBAUEsEBciAUUEQCA/QQA2AgwMCgsgGygCQCELIAFBADYCJCABIBQ2AhwgASAiNgIUIAEgDjYCECABIA02AgwgASAGNgIIIAEgCjYCBCABIAs2AgAgASAMNgIoIAEgMzYCICABIBEoAgRBAUo2AhggEUEOIAEQMyA/KAIMRQ0JCyAIQQFqIgggBygCFCAHKAIQbEkNAAsMAQsgAUUNAEEAIRUDQCAHKAIYIBVBxABsaiIBKAI8IgYEQCAGEBQgAUEANgI8IAcoAhQhCyAHKAIQIQgLIBVBAWoiFSAIIAtsSQ0ACwsgCUEBaiIJIA8oAhQiASAPKAIQIhVsSQ0ACyAPKAIYIQsLIBdBAWoiFyALSQ0ACyAOKAIYIQELIApBAWoiCiABSQ0ACwsgPygCDEUNAiAQKAIQIQoLICJBuAhqISIgDkHMAGohDiAZQQFqIhkgCkkNAAsLQQAhIiAbKAIsECQgPygCDEUNAQJAIBsoAkANACAbKAIYIhkoAhBFDQBBACEOA0AgGygCFCgCACgCFCAOQcwAbGoiASgCHCAZKAIYIA5BNGxqKAIkQZgBbGoiBygCiAEhBiAHKAKQASEIIAcoAowBIQsgBygClAEhByABKAI0EBQgAUEANgI0AkAgGygCRCIJBEAgCSAOQQJ0aigCAEUNAQsgBiAIRg0AIAcgC0YNACAHIAtrIgetIAggBmsiBq1+QiCIQgBSBEAgM0EBQYEXQQAQEwwFCyAGIAdsIgdBgICAgARPBEAgM0EBQYEXQQAQEwwFCyABIAdBAnQQHCIBNgI0IAENACAzQQFBgRdBABATDAQLIA5BAWoiDiAbKAIYIhkoAhBJDQALCyAbKAIgIRkgGygCFCgCACIVKAIQBEAgFSgCFCEOIBkoAtArIRkgGygCGCgCGCEKQQAhCwNAAkAgGygCRCIBBEAgASALQQJ0aigCAEUNAQsgCigCJEEBaiEBIBkoAhRBAUYEQCABIR5BACEIQQAhBv0MAAAAAAAAAAAAAAAAAAAAACF2IwBBIGsiJyQAAkACQCAbKAJABEBBASEHIAFBAUYNAiAOKAIcIgYgDigCGEGYAWxqIgFBkAFrKAIAIg8gAUGYAWsoAgAiEUYNAiAGKAIEIRQgBigCDCEWIAYoAgAhGCAGKAIIIR0gGygCLCIXKAIEIRAgHkEBayINIQwgBiEHAkAgDUEETwRAIA1BA3EhDCAHIA1BfHEiCUGYAWxqIQdBACEBA0AgdiAGIAFBmAFsaiIIQegEaiAIQdADaiAIQbgCaiAI/VwCoAH9VgIAAf1WAgAC/VYCAAMgCEHgBGogCEHIA2ogCEGwAmogCP1cApgB/VYCAAH9VgIAAv1WAgAD/bEB/bkBIAhB7ARqIAhB1ANqIAhBvAJqIAj9XAKkAf1WAgAB/VYCAAL9VgIAAyAIQeQEaiAIQcwDaiAIQbQCaiAI/VwCnAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEhdiABQQRqIgEgCUcNAAsgdiB2IHb9DQgJCgsMDQ4PAAECAwABAgP9uQEidiB2IHb9DQQFBgcAAQIDAAECAwABAgP9uQH9GwAhCCAJIA1GDQELA0AgCCAHKAKgASAHKAKYAWsiASABIAhJGyIBIAcoAqQBIAcoApwBayIIIAEgCEsbIQggB0GYAWohByAMQQFrIgwNAAsLQQAhByAIQf///z9LDQIgJyAIQQV0IhMQNyIMNgIQIAxFDQIgJyAMNgIAIA0EQCAPIBFrIREgFiAUayEJIB0gGGshAQNAIA4oAiQhFCAnIAkiDzYCCCAnIAEiBzYCGCAGKAKcASEIIAYoAqQBIQkgBigCoAEhASAnIAYoApgBIhZBAm82AhwgJyABIBZrIgEgB2s2AhQCQCAQQQJIIh1FIAkgCGsiCUEBS3FFBEBBACEIIAlFDQEDQCAnQRBqIBQgCCARbEECdGoQZiAIQQFqIgggCUcNAAsMAQsgCSAQIAkgEEkbIhZBAWshIyAJIBZuIRhBACEHA0BBJBAYIghFDQUgJ/0AAhAhdiAIIBQ2AhggCCARNgIUIAggATYCECAIIHb9CwIAIAggByAYbDYCHCAHICNGIR8gCCAJIAdBAWoiByAYbCAfGzYCICAIIBMQNyIfNgIAIB9FBEBBACEHIBcQJCAIEBQgDBAUDAcLIBdBCiAIEDMgByAWRw0ACyAXECQLICcgCSAPazYCBCAnIAYoApwBQQJvNgIMAkAgHUUgAUEBS3FFBEBBCCEHQQAhCCABQQhPBEADQCAnIBQgCEECdGogEUEIEDYgByIIQQhqIgcgAU0NAAsLIAEgCE0NASAnIBQgCEECdGogESABIAhrEDYMAQsgASAQIAEgEEkbIg9BAWshGCABIA9uIRZBACEHA0BBJBAYIghFDQUgJ/0AAgAhdiAIIBQ2AhggCCARNgIUIAggCTYCECAIIHb9CwIAIAggByAWbDYCHCAHIBhGIR0gCCABIAdBAWoiByAWbCAdGzYCICAIIBMQNyIdNgIAIB1FBEBBACEHIBcQJCAIEBQgDBAUDAcLIBdBCyAIEDMgByAPRw0ACyAXECQLIAZBmAFqIQYgDUEBayINDQALC0EBIQcgDBAUDAILQQEhByAOKAIcIgkgHkGYAWxqIitBmAFrIl0oAgAgK0GQAWsoAgBGDQEgK0GUAWsiXigCACArQYwBaygCAEYNASAJKAIEIRcgCSgCDCENIAkoAgAhECAJKAIIIREgDigCRCEoIA4oAkAhGiAOKAI8ISYgDigCOCEuIA4gHhBlIjlFBEBBACEHDAILAkACQCAeQQFHBEACQAJAIB5BAWsiD0EESQRAIA8hASAJIQcMAQsgD0EDcSEBIAkgD0F8cSIMQZgBbGohBwNAIHYgCSAGQZgBbGoiCEHoBGogCEHQA2ogCEG4AmogCP1cAqAB/VYCAAH9VgIAAv1WAgADIAhB4ARqIAhByANqIAhBsAJqIAj9XAKYAf1WAgAB/VYCAAL9VgIAA/2xAf25ASAIQewEaiAIQdQDaiAIQbwCaiAI/VwCpAH9VgIAAf1WAgAC/VYCAAMgCEHkBGogCEHMA2ogCEG0AmogCP1cApwB/VYCAAH9VgIAAv1WAgAD/bEB/bkBIXYgBkEEaiIGIAxHDQALIHYgdiB2/Q0ICQoLDA0ODwABAgMAAQID/bkBInYgdiB2/Q0EBQYHAAECAwABAgMAAQID/bkB/RsAIQggDCAPRg0BCwNAIAggBygCoAEgBygCmAFrIgYgBiAISRsiBiAHKAKkASAHKAKcAWsiCCAGIAhLGyEIIAdBmAFqIQcgAUEBayIBDQALCyAIQYCAgIABTw0CIAhBBHQQNyISRQ0CAkAgHkUNACANIBdrIRYgESAQayETIBJBBGshOiASQRxqIU4gEkEYaiE4IBJBFGohPCASQQxrIUEgEkEMaiEpIBJBCGohJSASQRBrIUIgEkEIayFAIBJBBGohISAorSF8IBqtIX0gJq0hgAEgLq0hgQFBASFDA0AgCSgCnAEiAUECbyE3IAkoApgBIgdBAm8hPiAJKAKkASABayIkIBZrIS8gCSgCoAEgB2siLCATayExIC4iBiEHICYiHSEUIBoiASEwICgiCCERAkAgDigCFCIPIENGDQAgDyBDayEPQQAhFEEAIQcgBgRAQn8gD60ifoZCf4UggQF8IH6IpyEHCyAmBEBCfyAPrSJ+hkJ/hSCAAXwgfoinIRQLQQAhCEEAIQEgGgRAQn8gD60ifoZCf4UgfXwgfoinIQELICgEQEJ/IA+tIn6GQn+FIHx8IH6IpyEIC0EAITBBACEGQQEgD0EBa3QiDCAuSQRAIC4gDGutQn8gD60ifoZCf4V8IH6IpyEGCyAMIBpJBEAgGiAMa61CfyAPrSJ+hkJ/hXwgfoinITALQQAhEUEAIR0gDCAmSQRAICYgDGutQn8gD60ifoZCf4V8IH6IpyEdCyAMIChPDQAgKCAMa61CfyAPrSJ+hkJ/hXwgfoinIRELQX8gMCAJKAK0ASIPayIMQQAgDCAwTRsiDEECaiIXIAwgF0sbIgwgMSAMIDFJGyI1QX8gASAJKALYASItayIMQQAgASAMTxsiAUECaiIMIAEgDEsbIgEgEyABIBNJGyI2ID4bQQF0IgEgNiA1ID4bQQF0QQFyIgwgASAMSxsiRiAsSSEYIAYgD2siAUEAIAEgBk0bIgFBAmsiBkEAIAEgBk8bIhAgByAtayIBQQAgASAHTRsiAUECayIGQQAgASAGTxsiDSA+G0EBdCIGIA0gECA+G0EBdEEBciIPSSEgIBQgCSgCuAEiI2siDEEAIAwgFE0bIgxBAmsiF0EAIAwgF08bIgwhHCAdIAkoAtwBIhRrIhdBACAXIB1NGyIXQQJrIh1BACAXIB1PGyIXISpBfyAIICNrIh1BACAIIB1PGyIIQQJqIh0gCCAdSxsiCCAWIAggFkkbIiMhMkF/IBEgFGsiCEEAIAggEU0bIghBAmoiESAIIBFLGyIIIC8gCCAvSRsiHyE7IDcEQCAMISogHyEyICMhOyAXIRwLIEYgLCAYGyFHIAYgDyAgGyEPIBYgH2ohTyAWIBdqIVAgJARAIBIgDUEDdGoiREEEaiA6IDFBA3QiBmoiUSANIDFIIggbIVIgNSATQQFrIBMgNUobISBBACEYIBNBAUogMUEASnIhUyAhID5BAnQiEWsgEEEDdGohVCARIERqIVUgDSA2IDEgMSA2ShsiESAHIC0gByAtSRtqQQIgASABQQJPG2ogB0F/c2oiSEF8cSJFaiE0IA1BAWoiFCBFaiE9IBMgNWohViAQIBNqIVcgDf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIXkgEiAPQQJ0aiFYIEAgE0EDdCIBaiFJIAEgOmohSiAGIEBqIUsgE0UgMUEBRnEhWSASIEdBAnQiAWohWiABIDpqIVsgFP0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIXogOiANIDEgCBtBA3RqIVwDQAJAAkAgGCAjSSAMIBhNcQ0AIBggT0kgGCBQT3ENACAYQQFqIS0MAQsgLCBGSwRAIFtBADYCACBaQQA2AgALIDkgDSAYIDYgGEEBaiItIFVBAkEAECIgOSBXIBggViAtIFRBAkEAECICQAJAAkAgPkUEQCBTRQ0DIA0gNk4NAgJAAkAgDUEASgRAIFwoAgAhBwwBCyAhKAIAIgchASANQQBIDQELIAchASBSKAIAIQcLIEQgRCgCACABIAdqQQJqQQJ1azYCACAUIgcgEU4NAUEAIQcgFCEBIA0hCCB6IXYgeSF4IEhBA0sEQANAIBIgdkEB/asBInf9GwBBAnRqIgEgEiB3/RsDQQJ0aiIGIBIgd/0bAkECdGoiCCASIHf9GwFBAnRqIh0gAf1cAgD9VgIAAf1WAgAC/VYCAAMgEiB4QQH9qwH9DAEAAAABAAAAAQAAAAEAAAD9UCJ7/RsDQQJ0aiASIHv9GwJBAnRqIBIge/0bAUECdGogEiB7/RsAQQJ0av1cAgD9VgIAAf1WAgAC/VYCAAMgEiB3/QwBAAAAAQAAAAEAAAABAAAA/VAid/0bA0ECdGogEiB3/RsCQQJ0aiASIHf9GwFBAnRqIBIgd/0bAEECdGr9XAIA/VYCAAH9VgIAAv1WAgAD/a4B/QwCAAAAAgAAAAIAAAACAAAA/a4BQQL9rAH9sQEid/1aAgAAIB0gd/1aAgABIAggd/1aAgACIAYgd/1aAgADIHj9DAQAAAAEAAAABAAAAAQAAAD9rgEheCB2/QwEAAAABAAAAAQAAAAEAAAA/a4BIXYgB0EEaiIHIEVHDQALID0hASA0IQggESEHIEUgSEYNAgsDQCASIAFBA3RqIgcgBygCACASIAhBA3RqKAIEIAcoAgRqQQJqQQJ1azYCACABIghBAWoiASARRw0ACyARIQcMAQsCQCBZRQRAIA0iByA2Tg0BA0AgEiAHQQN0aiIBKAIEIQYgASAGAn8CQCAHQQBOBEAgASBLIAcgMUgbKAIAITAgB0EBaiEBDAELIBIoAgAhMEEAIQEgEiAHQQFqIgcNARoLIAEgMU4EQCABIQcgSwwBCyASIAEiB0EDdGoLKAIAIDBqQQJqQQJ1azYCBCAHIDZIDQALDAELIBIgEigCAEECbTYCAAwDCyAQIgcgNU4NAgNAIBIgB0EDdCIBaiIGKAIAIQgCfyAHQQBIBEAgISgCACEdICEMAQsgEiAHQQN0akEEaiBKIAcgE0gbKAIAIR0gISAHRQ0AGiBKIAcgE0oNABogASA6agshASAGIAEoAgAgHWpBAXUgCGo2AgAgB0EBaiIHIDVHDQALDAILIAcgNk4NAANAIBIgB0EDdGoiASABKAIAAn8CQCAHQQBKBEAgOiAHIDEgByAxSBtBA3RqKAIAIQgMAQsgISgCACEIICEgB0EASA0BGgsgUSAHIDFODQAaIBIgB0EDdGpBBGoLKAIAIAhqQQJqQQJ1azYCACAHQQFqIgcgNkcNAAsLIBAgNU4NACAgIBAiASIHSgRAA0AgEiAHQQN0aiIBIAEoAgQgEiAHQQFqIgdBA3RqKAIAIAEoAgBqQQF1ajYCBCAHICBHDQALICAhAQsgASA1Tg0AA0ACfwJAIAEiB0EATgRAIBIgAUEDdGogSSABIBNIGygCACEGIAFBAWohCAwBCyASKAIAIQZBACEIIBIgB0EBaiIBDQEaCyAIIBNOBEAgCCEBIEkMAQsgEiAIIgFBA3RqCyEIIBIgB0EDdGoiByAHKAIEIAgoAgAgBmpBAXVqNgIEIAEgNUgNAAsLIDkgDyAYIEcgLSBYQQFBAEEAECpFDQYLIC0iGCAkRw0ACwsgCUGYAWohCSAyQQF0IgEgO0EBdEEBciIHIAEgB0sbIgEgJCABICRJGyE+ICkgDEEFdCIBQRByIgZqIDogL0EFdCIIaiAMIC9IIgcbIUQgBiAlaiAIIEBqIAcbIUUgBiAhaiAIIEFqIAcbIUYgBiASaiAIIEJqIAcbIUggHyAWQQFrIBYgH0obIQ0gL0EASiIQIBZBAUpyIUkgASASaiIdIDdBBHRqIUogKSAWQQN0IgZBCGsiMkEAIBZBAEwbQQJ0IghqIUsgCCAlaiFRIAggIWohUiAIIBJqIVMgKUEAIC9BA3QiCEEIayI7IBAbQQJ0IhBqIVQgECAlaiFVIBAgIWohViAQIBJqIVcgEkEEIDdBAnRrQQJ0aiAXQQV0aiFYICMgLyAjIC9IGyEQIAxBAWohFCASIBxBAXQiESAqQQF0QQFyIhMgESATSRsiWUEEdGohWiABIClqITQgASAlaiEcIAEgIWohLSApIBZBBXQiAWohWyAGQQFrIT0gASAlaiFcIAZBAmshMSABICFqIV8gBkEDayE1IAEgEmohYCAGQQRrITYgCEEFayFhIAhBBmshYiAIQQdrIWMgFkUgL0EBRnEhZCApIDJBAnQiAWohZiABICVqIWcgASAhaiFoIAEgEmohaSApIAhBBGsiakECdCIBaiFrIAEgJWohbCABICFqIW0gASASaiFuIDogDCAvIAcbQQV0IgFqIW8gASBAaiETIAEgQWohGCABIEJqIXAgKSA7QQJ0IgFqIXEgASAlaiFyIAEgIWohcyABIBJqIXQDQAJAAkACfwJAIA8iESBHSQRAIDkgDyAMQQQgRyAPayIBIAFBBE8bIA9qIg8gIyBKQQFBCBAiIDkgESBQIA8gTyBYQQFBCBAiIDdFBEAgSUUNBSAMICNODQQCfyAMQQBKBEAgcCgCACEHIBMhBiAYIQggbwwBCyASKAIQIQcgDEEASA0DIDghBiA8IQggTgsgHSAdKAIAIAcgSCgCAGpBAmpBAnVrNgIAIC0gLSgCACAIKAIAIEYoAgBqQQJqQQJ1azYCACAcIBwoAgAgBigCACBFKAIAakECakECdWs2AgAgRCgCACEHKAIADAMLIGQEQCASIBIoAgBBAm02AgAgEiASKAIEQQJtNgIEICUgJSgCAEECbTYCACApICkoAgBBAm02AgAMBQsgIyAMIgdKBEADQCAHQQN0IQYCQAJAIAdBAEgEQCAHQX9GDQEgEiAGQQJ0aiIBIAH9AAIQIBL9AAIAQQH9qwH9DAIAAAACAAAAAgAAAAIAAAD9rgFBAv2sAf2xAf0LAhAMAgsgEiAGQQJ0aiIBKAIQIQggLyAHQQFqIiBMBEAgASAIIBIgBiA7IAcgL0giCBtBAnRqKAIAIHQoAgBqQQJqQQJ1azYCECABIAEoAhQgEiAGQQFyIGMgCBtBAnRqKAIAIHMoAgBqQQJqQQJ1azYCFCABIAEoAhggEiAGQQJyIGIgCBtBAnRqKAIAIHIoAgBqQQJqQQJ1azYCGCABIAEoAhwgEiAGQQNyIGEgCBtBAnRqKAIAIHEoAgBqQQJqQQJ1azYCHAwCCyABIAFBFGogCP0R/VYCAAEgAUEYav1dAgD9DQABAgMEBQYHEBESExQVFhcgAf0AAgAgEiAgQQV0av0AAgD9rgH9DAIAAAACAAAAAgAAAAIAAAD9rgFBAv2sAf2xAf0LAhAMAQsgQiBCKAIAIBIoAgAgVygCAGpBAmpBAnVrNgIAIEEgQSgCACASKAIEIFYoAgBqQQJqQQJ1azYCACBAIEAoAgAgJSgCACBVKAIAakECakECdWs2AgAgOiA6KAIAICkoAgAgVCgCAGpBAmpBAnVrNgIACyAHQQFqIgcgI0cNAAsLIB8gFyIHTA0EA0AgB0EDdCEGAkAgB0EASARAIBIgBkECdGoiASAS/QACEEEB/asBQQH9rAEgAf0AAgD9rgH9CwIADAELIAcEQCASIAZBAnQiCGoiASABKAIAIGAgASAHIBZKIiAbQRBrKAIAIBIgBkEEciA2IAcgFkgiKhtBAnRqKAIAakEBdWo2AgAgASABKAIEIF8gCCAhaiAgG0EQaygCACASIAZBBXIgNSAqG0ECdGooAgBqQQF1ajYCBCABIAEoAgggXCAIICVqICAbQRBrKAIAIBIgBkEGciAxICobQQJ0aigCAGpBAXVqNgIIIAEgASgCDCBbIAggKWogIBtBEGsoAgAgEiAGQQdyID0gKhtBAnRqKAIAakEBdWo2AgwMAQsgEiASKAIAIBIoAhAgEkEEIDYgByAWSCIBG0ECdGooAgBqQQF1ajYCACASIBIoAgQgEigCFCASQQUgNSABG0ECdGooAgBqQQF1ajYCBCAlICUoAgAgEigCGCASQQYgMSABG0ECdGooAgBqQQF1ajYCACApICkoAgAgEigCHCASQQcgPSABG0ECdGooAgBqQQF1ajYCAAsgB0EBaiIHIB9HDQALDAQLICwhEyAkIRYgQ0EBaiJDIB5HDQUMBgsgHSAdKAIAIAdBAXRBAmpBAnVrNgIAIC0gLSgCACA8KAIAQQF0QQJqQQJ1azYCACAcIBwoAgAgOCgCAEEBdEECakECdWs2AgAgTigCACIHCyEBIDQgNCgCACABIAdqQQJqQQJ1azYCACAMIQYgECAUIgEiB0oEQANAIBIgAUEFdGoiByAH/QACACASIAZBBXRq/QACECAH/QACEP2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEB/QsCACABIgZBAWoiASAQRw0ACyAQIQcLIAcgI04NAANAIAdBA3QiBkEEciEgIAcgL0ghCAJ/IAdBAEwEQCASKAIQISogB0EATgRAIBIgBkECdCIwaiIBIAEoAgAgKiASICAgaiAIG0ECdCIBaigCAGpBAmpBAnVrNgIAICEgMGoiCCAIKAIAIBIoAhQgASAhaigCAGpBAmpBAnVrNgIAICUgMGoiCCAIKAIAIBIoAhggASAlaigCAGpBAmpBAnVrNgIAIBIoAhwgASApaigCAGpBAmoMAgsgEiAGQQJ0IgFqIgggCCgCACAqQQF0QQJqQQJ1azYCACABICFqIgggCCgCACASKAIUQQF0QQJqQQJ1azYCACABICVqIgEgASgCACASKAIYQQF0QQJqQQJ1azYCACASKAIcQQF0QQJqDAELIBIgByAvIAgbQQN0QQRrQQJ0IgFqKAIAISogCEUEQCASIAZBAnQiCGoiICAgKAIAICogbigCAGpBAmpBAnVrNgIAIAggIWoiICAgKAIAIAEgIWooAgAgbSgCAGpBAmpBAnVrNgIAIAggJWoiCCAIKAIAIAEgJWooAgAgbCgCAGpBAmpBAnVrNgIAIAEgKWooAgAgaygCAGpBAmoMAQsgEiAGQQJ0IjBqIgggCCgCACAqIBIgIEECdCIIaigCAGpBAmpBAnVrNgIAICEgMGoiICAgKAIAIAEgIWooAgAgCCAhaigCAGpBAmpBAnVrNgIAICUgMGoiICAgKAIAIAEgJWooAgAgCCAlaigCAGpBAmpBAnVrNgIAIAEgKWooAgAgCCApaigCAGpBAmoLIQEgKSAGQQJ0aiIGIAYoAgAgAUECdWs2AgAgB0EBaiIHICNHDQALCyAXIB9ODQAgDSAXIgEiB0oEQANAIBIgAUEFdGoiByAH/QACICAH/QACAP2uAUEB/awBIAf9AAIQ/a4B/QsCECABQQFqIgEgDUcNAAsgDSEHCyAHIB9ODQADQCApIAdBA3QiAUEEciIGQQJ0aiIqAn8gB0EASARAIBIoAgAhASAHQX9HBEAgEiAGQQJ0IgZqIgggCCgCACABajYCACAGICFqIgEgASgCACAhKAIAajYCACAGICVqIgEgASgCACAlKAIAajYCACApKAIADAILIBIgBkECdCIGaiIIIAgoAgAgUygCACABakEBdWo2AgAgBiAhaiIBIAEoAgAgUigCACAhKAIAakEBdWo2AgAgBiAlaiIBIAEoAgAgUSgCACAlKAIAakEBdWo2AgAgSygCACApKAIAakEBdQwBCyASIAEgMiAHIBZIG0ECdGoiASgCACEIIBYgB0EBaiIwTARAIBIgBkECdCIGaiIgICAoAgAgaSgCACAIakEBdWo2AgAgBiAhaiIIIAgoAgAgaCgCACABKAIEakEBdWo2AgAgBiAlaiIGIAYoAgAgZygCACABKAIIakEBdWo2AgAgZigCACABKAIMakEBdQwBCyASIAZBAnQiIGoiBiAGKAIAIAggEiAwQQV0aiIGKAIAakEBdWo2AgAgICAhaiIIIAgoAgAgBigCBCABKAIEakEBdWo2AgAgICAlaiIIIAgoAgAgBigCCCABKAIIakEBdWo2AgAgBigCDCABKAIMakEBdQsgKigCAGo2AgAgB0EBaiIHIB9HDQALCyA5IBEgWSAPID4gWkEBQQRBABAqDQALCwwCCyASEBRBASEHCyA5ICtBEGsoAgAiASBdKAIAIgZrICtBDGsoAgAgXigCACIIayArQQhrKAIAIgkgBmsgK0EEaygCACAIayAOKAI0QQEgCSABaxAiIDkQJwwDCyA5ECcgEhAUQQAhBwwCCyA5ECdBACEHDAELQQAhByAXECQgDBAUCyAnQSBqJAAgBw0BDAULIAEhB0EAIQz9DAAAAAAAAAAAAAAAAAAAAAAhdiMAQUBqIh4kAAJAAn8CQCAbKAJABEAgDigCHCIXIA4oAhhBmAFsaiIBQZgBaygCACEYIAFBkAFrKAIAIR0gFygCBCENIBcoAgwgFygCACERIBcoAgghFEEBIQYgGygCLCIjKAIEISYgB0EBRg0DQQAhCCAHQQFrIg8hCSAXIQECQCAPQQRPBEAgD0EDcSEJIAEgD0F8cSIMQZgBbGohAUEAIQYDQCB2IBcgBkGYAWxqIgdB6ARqIAdB0ANqIAdBuAJqIAf9XAKgAf1WAgAB/VYCAAL9VgIAAyAHQeAEaiAHQcgDaiAHQbACaiAH/VwCmAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEgB0HsBGogB0HUA2ogB0G8AmogB/1cAqQB/VYCAAH9VgIAAv1WAgADIAdB5ARqIAdBzANqIAdBtAJqIAf9XAKcAf1WAgAB/VYCAAL9VgIAA/2xAf25ASF2IAZBBGoiBiAMRw0ACyB2IHYgdv0NCAkKCwwNDg8AAQIDAAECA/25ASJ2IHYgdv0NBAUGBwABAgMAAQIDAAECA/25Af0bACEIIAwgD0YNAQsDQCAIIAEoAqABIAEoApgBayIHIAcgCEkbIgcgASgCpAEgASgCnAFrIgYgBiAHSRshCCABQZgBaiEBIAlBAWsiCQ0ACwtBACEGIAhB////P0sNAyAeIAhBBXQiRxAcIgE2AiAgAUUNAyAeIAE2AgAgD0UEQEEBIQYgARAUDAQLIA1rIQ0gFCARayEMQQIgJkEBdiIBIAFBAk0bIUQgDigCJCIHIB1BHGwiXSAYQRxsIl5raiEkIAcgHUEYbCJRIBhBGGwiUmtqIS4gByAdQRRsIlMgGEEUbCJUa2ohLCAHIB1BBHQiVSAYQQR0IlZraiEtIAcgHUEMbCJXIBhBDGwiWGtqISAgByAdQQN0IlkgGEEDdCJaa2ohOCAdIBhrIhFBBXQhRSARQQdsIU4gEUEGbCFGIBFBBWwhTyARQQNsIVAgEUEBdCFIIAcgEUECdCJAaiE8IBH9ESF6A0AgHiANNgIIIB4gDCIBNgIoIBcoApwBIR8gFygCpAEhKCAXKAKgASEqIBcoApgBIRogHkEANgI4IB4gATYCNCAeQQA2AjAgHiAaQQJvIhw2AiwgHiAqIBprIgwgAWsiFDYCPCAeIBQ2AiQCQCAmQQJIIltFICggH2siDUEPS3FFBEBBACEGIAchCCANQQhJDQEgLCAHIFEgKkECdCIBaiBSIBpBAnQiCWpraiI+SSAuIAcgASBTaiAJIFRqa2oiQUlxICQgQUkgLCAHIAEgXWogCSBeamtqIkJJcXIhXCA8IAcgASBZaiAJIFpqa2oiSUkgOCAHIB0gKmogGCAaamtBAnRqIkpJcSAgIEpJIDwgByABIFdqIAkgWGpraiJLSXFyIV8gLSBBSSAsIAcgASBVaiAJIFZqa2oiQ0lxIC0gPkkgLiBDSXFyIC0gQkkgJCBDSXFyIWAgLiBCSSAkID5JcSFhIDggS0kgICBJSXEhYiAHIAEgCWtqITIgDEF8cSEJIB4oAiAiFEEMaiE7IBRBCGohNCAUQQRqIT0gFEEcaiESIBRBGGohISAUQRRqISUgFEEQaiEpIBQgDEEFdGoiFkEQayEnIBZBFGshLyAWQRhrITEgFkEcayE5IBZBBGshOiAWQQhrITUgFkEMayE2QQAhHCAMQawBSSFjIAxBLEkhZANAIAYhECAeQSBqIgEgCCARQQgQQyABECYCQCAMRQ0AIBwgRWwhBkEAIQECQAJAIGMNACBiIAggOUkgFCAGIDJqIjdJcSAgIDJJIAggBiBLaiITSXEgCCAGIEpqIitJIDIgPEtxIAggBiBJaiIwSSAyIDhLcXJyciAIIDFJIDcgPUtxciAIIC9JIDQgN0lxciAIICdJIDcgO0txciBfciAUICtJIAYgPGoiNyA5SXFyICsgPUsgMSA3S3FyICsgNEsgLyA3S3FyICsgO0sgJyA3S3Fycg0AIBQgMEkgBiA4aiIrIDlJcQ0AICsgMUkgMCA9S3ENACArIC9JIDAgNEtxDQAgMCA7SyAnICtLcQ0AIAYgIGoiKyA5SSATIBRLcQ0AICsgMUkgEyA9S3ENACArIC9JIBMgNEtxDQAgEyA7SyAnICtLcQ0AA0AgCCABQQJ0aiAUIAFBBXRqIhNB4ABqIBNBQGsgE0EgaiAT/VwCAP1WAgAB/VYCAAL9VgIAA/0LAgAgCCABIBFqQQJ0aiATQeQAaiATQcQAaiATQSRqIBP9XAIE/VYCAAH9VgIAAv1WAgAD/QsCACAIIAEgSGpBAnRqIBNB6ABqIBNByABqIBNBKGogE/1cAgj9VgIAAf1WAgAC/VYCAAP9CwIAIAggASBQakECdGogE0HsAGogE0HMAGogE0EsaiAT/VwCDP1WAgAB/VYCAAL9VgIAA/0LAgAgAUEEaiIBIAlHDQALIAkiASAMRg0BCwNAIAggAUECdGogFCABQQV0aiITKgIAOAIAIAggASARakECdGogEyoCBDgCACAIIAEgSGpBAnRqIBMqAgg4AgAgCCABIFBqQQJ0aiATKgIMOAIAIAFBAWoiASAMRw0ACwtBACEBAkAgZA0AIGEgBiAsaiITIDZJICkgBiBBaiIrSXEgYCAGIC1qIjAgNkkgKSAGIENqIjdJcXIgJSA3SSAwIDVJcXIgISA3SSAwIDpJcXIgEiA3SSAWIDBLcXIgXHJyICUgK0kgEyA1SXFyICEgK0kgEyA6SXFyIBIgK0kgEyAWSXFycg0AIAYgLmoiEyA2SSApIAYgPmoiK0lxDQAgJSArSSATIDVJcQ0AICEgK0kgEyA6SXENACASICtJIBMgFklxDQAgBiAkaiITIDZJICkgBiBCaiIGSXENACATIDVJIAYgJUtxDQAgEyA6SSAGICFLcQ0AIBMgFkkgBiASS3ENAANAIAggASBAakECdGogFCABQQV0aiIGQfAAaiAGQdAAaiAGQTBqIAb9XAIQ/VYCAAH9VgIAAv1WAgAD/QsCACAIIAEgT2pBAnRqIAZB9ABqIAZB1ABqIAZBNGogBv1cAhT9VgIAAf1WAgAC/VYCAAP9CwIAIAggASBGakECdGogBkH4AGogBkHYAGogBkE4aiAG/VwCGP1WAgAB/VYCAAL9VgIAA/0LAgAgCCABIE5qQQJ0aiAGQfwAaiAGQdwAaiAGQTxqIAb9XAIc/VYCAAH9VgIAAv1WAgAD/QsCACABQQRqIgEgCUcNAAsgCSIBIAxGDQELA0AgCCABIEBqQQJ0aiAUIAFBBXRqIgYqAhA4AgAgCCABIE9qQQJ0aiAGKgIUOAIAIAggASBGakECdGogBioCGDgCACAIIAEgTmpBAnRqIAYqAhw4AgAgAUEBaiIBIAxHDQALCyAcQQFqIRwgEEEIaiEGIAggRWohCCAQQQ9qIA1JDQALDAELIA0gDUEDdiIGICYgBiAmSRsiE25BeHEhFiANQXhxIQZBACEJIAchCANAQTAQGCIQRQ0EIBAgRxAcIjI2AgAgMkUEQCAjECQgEBAUQQAMBgsgECAINgIoIBAgETYCJCAQIAw2AiAgECAUNgIcIBBBADYCGCAQIAE2AhQgEEEANgIQIBAgHDYCDCAQIAE2AgggECAUNgIEIBAgBiAJIBZsayAWIAlBAWoiCSATRhsiMjYCLCAjQQwgEBAzIAggESAybEECdGohCCAJIBNHDQALICMQJAsCQCAGIA1PDQAgHkEgaiIBIAggESANIAZrIhQQQyABECYgDEUNACAeKAIgIhYgKkEFdCAoQQJ0aiAGIB9qQQJ0IBpBBXRqa2pBIGshGiAUQXxxIRAgQCAoIAZBf3NqIB9rbCEqQQAhCQNAIBYgCUEFdGohHEEAIQECQAJAIBRBBEkNACAaIAggCUECdCIBaiIGIAggASAqamoiEyAGIBNJG0sEQEEAIQEgFiAGIBMgBiATSxtBBGpJDQELIAn9ESF3/QwAAAAAAQAAAAIAAAADAAAAIXZBACEBA0AgCCB2IHr9tQEgd/2uASJ4/RsAQQJ0aiAcIAFBAnRq/QACACJ5/R8AOAIAIAggeP0bAUECdGogef0fATgCACAIIHj9GwJBAnRqIHn9HwI4AgAgCCB4/RsDQQJ0aiB5/R8DOAIAIHb9DAQAAAAEAAAABAAAAAQAAAD9rgEhdiABQQRqIgEgEEcNAAsgECIBIBRGDQELA0AgCCABIBFsIAlqQQJ0aiAcIAFBAnRqKgIAOAIAIAFBAWoiASAURw0ACwsgCUEBaiIJIAxHDQALCyAeIA0gHigCCCIQayITNgIEIBcoApwBIQEgHiATNgIcIB79DAAAAAAAAAAAAAAAAAAAAAAgAUECbyIq/RwAIBD9HAIidv0LAgwCQCBbRSAMQQ9LcUUEQCAHIQEgDEEISQ0BIA1BfnEhOyANQQFxITQgE0F+cSE9IBNBAXEhEiAQQX5xISEgEEEBcSElICggH0F/c2ohMiAeKAIAIhQgKkEFdCIGaiEWIBQgBmtBIGohHCAQIBFsQQJ0ISkgDCEJA0BBACEIQQAhBgJAAkACQCAQDgICAQALA0AgFiAIQQZ0aiIaIAEgCCARbEECdGoiJ/0AAgD9CwIAIBogJ/0AAhD9CwIQIBYgCEEBciIaQQZ0aiInIAEgESAabEECdGoiGv0AAhD9CwIQICcgGv0AAgD9CwIAIAhBAmohCCAGQQJqIgYgIUcNAAsLICVFDQAgFiAIQQZ0aiIGIAEgCCARbEECdGoiCP0AAgD9CwIAIAYgCP0AAhD9CwIQCwJAIA0gEEYNACABIClqIRpBACEIQQAhBiAQIDJHBEADQCAcIAhBBnRqIicgGiAIIBFsQQJ0aiIv/QACAP0LAgAgJyAv/QACEP0LAhAgHCAIQQFyIidBBnRqIi8gGiARICdsQQJ0aiIn/QACEP0LAhAgLyAn/QACAP0LAgAgCEECaiEIIAZBAmoiBiA9Rw0ACwsgEkUNACAcIAhBBnRqIgYgGiAIIBFsQQJ0aiII/QACAP0LAgAgBiAI/QACEP0LAhALIB4QJgJAIA1FDQBBACEIQQAhBiAyBEADQCABIAggEWxBAnRqIhogFCAIQQV0aiIn/QACAP0LAgAgGiAn/QACEP0LAhAgASAIQQFyIhogEWxBAnRqIicgFCAaQQV0aiIa/QACEP0LAhAgJyAa/QACAP0LAgAgCEECaiEIIAZBAmoiBiA7Rw0ACwsgNEUNACABIAggEWxBAnRqIgYgFCAIQQV0aiII/QACAP0LAgAgBiAI/QACEP0LAhALIAFBIGohASAJQQhrIglBB0sNAAsMAQtBASAMQQN2IgEgRCABIERJGyIJIAlBAU0bIRYgDCAJbkF4cSEUIAxBeHEhHEEAIQYgByEBA0BBMBAYIghFDQQgCCBHEBwiGjYCACAaRQRAICMQJCAIEBRBAAwGCyAIIAE2AiggCCARNgIkIAggDTYCICAIIBM2AhwgCCB2/QsCDCAIIBA2AgggCCATNgIEIAggHCAGIBRsayAUIAZBAWoiBiAJRhsiGjYCLCAjQQ0gCBAzIAEgGkECdGohASAGIBZHDQALICMQJAsCQCAMQQdxIgZFDQAgKkEFdCEaIB4oAgAhCQJAIBBFDQAgCSAaaiEUIAZBAnQhFkEAIQggEEEBRwRAIBBBfnEhKkEAIRwDQCAUIAhBBnRqIAEgCCARbEECdGogFhAWGiAUIAhBAXIiMkEGdGogASARIDJsQQJ0aiAWEBYaIAhBAmohCCAcQQJqIhwgKkcNAAsLIBBBAXFFDQAgFCAIQQZ0aiABIAggEWxBAnRqIBYQFhoLAkAgDSAQRg0AIAkgGmtBIGohFiABIBAgEWxBAnRqIRwgBkECdCEaQQAhCCAQICggH0F/c2pHBEAgE0F+cSEQQQAhFANAIBYgCEEGdGogHCAIIBFsQQJ0aiAaEBYaIBYgCEEBciIqQQZ0aiAcIBEgKmxBAnRqIBoQFhogCEECaiEIIBRBAmoiFCAQRw0ACwsgE0EBcUUNACAWIAhBBnRqIBwgCCARbEECdGogGhAWGgsgHhAmIA1FDQAgBkECdCEQQQAhCCAfQQFqIChHBEAgDUF+cSEUQQAhBgNAIAEgCCARbEECdGogCSAIQQV0aiAQEBYaIAEgCEEBciITIBFsQQJ0aiAJIBNBBXRqIBAQFhogCEECaiEIIAZBAmoiBiAURw0ACwsgDUEBcUUNACABIAggEWxBAnRqIAkgCEEFdGogEBAWGgsgF0GYAWohFyAPQQFrIg8NAAtBAQwCC0EBIQYgDigCHCIXIAdBmAFsaiIaQZgBayI8KAIAIBpBkAFrKAIARg0CIBpBlAFrIiooAgAgGkGMAWsoAgBGDQIgFygCBCENIBcoAgwhECAXKAIAIREgFygCCCEYIA4oAkQhFCAOKAJAIRMgDigCPCEWIA4oAjghHSAOIAcQZSIoRQRAQQAhBgwDCyAHQQFGBEAgKCAaQRBrKAIAIgEgPCgCACIHayAaQQxrKAIAICooAgAiCGsgGkEIaygCACIJIAdrIBpBBGsoAgAgCGsgDigCNEEBIAkgAWsQIiAoECcMAwtBACEIAkACQCAHQQFrIglBBEkEQCAJIQYgFyEBDAELIAlBA3EhBiAXIAlBfHEiD0GYAWxqIQEDQCB2IBcgDEGYAWxqIghB6ARqIAhB0ANqIAhBuAJqIAj9XAKgAf1WAgAB/VYCAAL9VgIAAyAIQeAEaiAIQcgDaiAIQbACaiAI/VwCmAH9VgIAAf1WAgAC/VYCAAP9sQH9uQEgCEHsBGogCEHUA2ogCEG8AmogCP1cAqQB/VYCAAH9VgIAAv1WAgADIAhB5ARqIAhBzANqIAhBtAJqIAj9XAKcAf1WAgAB/VYCAAL9VgIAA/2xAf25ASF2IAxBBGoiDCAPRw0ACyB2IHYgdv0NCAkKCwwNDg8AAQIDAAECA/25ASJ2IHYgdv0NBAUGBwABAgMAAQIDAAECA/25Af0bACEIIAkgD0YNAQsDQCAIIAEoAqABIAEoApgBayIJIAggCUsbIgggASgCpAEgASgCnAFrIgkgCCAJSxshCCABQZgBaiEBIAZBAWsiBg0ACwsCQCAIQYCAgMAATw0AIB4gCEEFdBAcIiY2AiAgJkUNACAeICY2AgACQCAHBEAgECANayENIBggEWshCCAmQSBqITIgB60hfSAUrSGAASATrSGBASAWrSF+IB2tIYIBIA4oAhQiPa0hgwFCASF8A0AgHiANNgIIIB4gCDYCKCAXKAKkASEHIBcoAqABIQYgFygCnAEhASAeIBcoApgBIglBAm8iJDYCLCAeIAFBAm8iOzYCDCAeIAYgCWsiIyAIayIuNgIkIB4gByABayIQIA1rIjQ2AgQgHSIPIQkgFiIBIQwgEyIGIRwgFCIHIRECQCB8IIMBUQ0AID0gfKdrIRhBACEMQQAhCSAPBEBCfyAYrSJ/hkJ/hSCCAXwgf4inIQkLIBYEQEJ/IBitIn+GQn+FIH58IH+IpyEMC0EAIQdBACEGIBMEQEJ/IBitIn+GQn+FIIEBfCB/iKchBgsgFARAQn8gGK0if4ZCf4UggAF8IH+IpyEHC0EAIRxBACEPQQEgGEEBa3QiHyAdSQRAIB0gH2utQn8gGK0if4ZCf4V8IH+IpyEPCyATIB9LBEAgEyAfa61CfyAYrSJ/hkJ/hXwgf4inIRwLQQAhEUEAIQEgFiAfSwRAIBYgH2utQn8gGK0if4ZCf4V8IH+IpyEBCyAUIB9NDQAgFCAfa61CfyAYrSJ/hkJ/hXwgf4inIRELQX8gHCAXKAK0ASIYayIfQQAgHCAfTxsiH0EEaiIcIBwgH0kbIh8gLiAfIC5JGyIgQX8gBiAXKALYASIfayIcQQAgBiAcTxsiBkEEaiIcIAYgHEsbIgYgCCAGIAhJGyI4ICQbQQF0IgYgOCAgICQbQQF0QQFyIhwgBiAcSxsiHCAjSSEuIA8gGGsiBkEAIAYgD00bIgZBBGsiD0EAIAYgD08bIiwgCSAfayIGQQAgBiAJTRsiBkEEayIJQQAgBiAJTxsiLSAkG0EBdCISIC0gLCAkG0EBdEEBciIhSSElIAwgFygCuAEiCWsiBkEAIAYgDE0bIgZBBGsiD0EAIAYgD08bIgYhDyABIBcoAtwBIgxrIhhBACABIBhPGyIBQQRrIhhBACABIBhPGyIBIR9BfyAHIAlrIglBACAHIAlPGyIHQQRqIgkgByAJSxsiByANIAcgDUkbIgkhB0F/IBEgDGsiDEEAIAwgEU0bIgxBBGoiESAMIBFLGyIMIDQgDCA0SRsiGCERIDsEQCABIQ8gBiEfIAkhESAYIQcLIBwgIyAuGyEuIBIgISAlGyEcIB4gIDYCPCAeICw2AjggHiA4NgI0IB4gLTYCMAJAIBBBCEkEQEEHIQhBACEMDAELIDIgJEEFdCIMayAsQQZ0aiE0IAwgJmogLUEGdGohEiAIICBqISAgCCAsaiEsIA0gGGohISABIA1qISUgJiAcQQV0aiEpQQAhDANAAkACQCAJIAxLIAxBB3IiCCAGT3ENACAMICFJIAggJU9xDQAgDEEIaiEMDAELQQggECAMayIIIAhBCE8bISdBACEIA0AgKCAtIAggDGoiJCA4ICRBAWoiLyASIAhBAnQiMWpBEEEAECIgKCAsICQgICAvIDEgNGpBEEEAECIgCEEBaiIIICdHDQALIB5BIGoQJiAoIBwgDCAuIAxBCGoiDCApQQhBAUEAECpFDQULIAxBB3IiCCAQSQ0ACwsCQCAMIBBPDQAgBiAITSAJIAxLcUUEQCAMIA0gGGpPDQEgCCABIA1qSQ0BCyAeQSBqIQhBACEkIBAgDGsiLQRAA0AgKCAIKAIQIiAgDCAkaiIsIAgoAhQgLEEBaiI4ICRBAnQiNCAIKAIAIAgoAgxBBXRqICBBBnRqakEQQQAQIiAoIAgoAhgiICAIKAIIIhJqICwgCCgCHCASaiA4IAgoAgAgCCgCDEEFdGsgIEEGdGogNGpBIGpBEEEAECIgJEEBaiIkIC1HDQALCyAIECYgKCAcIAwgLiAQICYgHEEFdGpBCEEBQQAQKkUNAwsgHiAYNgIcIB4gATYCGCAeIAk2AhQgHiAGNgIQIBwgLkkEQCAHQQF0IgcgEUEBdEEBciIIIAcgCEsbIgcgECAHIBBJGyEHIDIgO0EFdCIIayABQQZ0aiEMIAggJmogBkEGdGohCCANIBhqIREgASANaiENICYgD0EBdCIBIB9BAXRBAXIiDyABIA9JGyIPQQV0aiEYA0AgKCAcIAZBCCAuIBxrIgEgAUEITxsgHGoiASAJIAhBAUEQECIgKCAcIA0gASARIAxBAUEQECIgHhAmICggHCAPIAEgByAYQQFBCEEAECpFDQQgHEEIaiIcIC5JDQALCyAXQZgBaiEXICMhCCAQIQ0gfEIBfCJ8IH1SDQALC0EBIQYgKCAaQRBrKAIAIgEgPCgCACIHayAaQQxrKAIAICooAgAiCGsgGkEIaygCACIJIAdrIBpBBGsoAgAgCGsgDigCNEEBIAkgAWsQIiAoECcgJhAUDAQLICgQJyAmEBRBACEGDAMLICgQJ0EAIQYMAgsgIxAkQQALIQYgHigCIBAUCyAeQUBrJAAgBg0ADAQLIBlBuAhqIRkgCkE0aiEKIA5BzABqIQ4gC0EBaiILIBUoAhBJDQALIBsoAiAhGSAbKAIUKAIAIRULAkAgGSgCECIORQ0AIBsoAkQNACAVKAIUIgooAhwhAQJAAkACQAJAAkAgGygCQCIGBEAgFSgCECILQQNJDQICQCAKKAIYIgcgCigCZEYEQCAHIAooArABRg0BCyAzQQFBxM4AQQAQEwwJCwJAIBsoAhgoAhgiCCgCJCIJIAgoAlhHDQAgCSAIKAKMAUcNACABIAdBmAFsIghqIgFBjAFrKAIAIAFBlAFrKAIAayABQZABaygCACABQZgBaygCAGtsIgEgCigCaCAIaiIHQYwBaygCACAHQZQBaygCAGsgB0GQAWsoAgAgB0GYAWsoAgBrbEcNACAKKAK0ASAIaiIHQYwBaygCACAHQZQBaygCAGsgB0GQAWsoAgAgB0GYAWsoAgBrbCABRg0CCyAzQQFBxM4AQQAQEwwICyAVKAIQIgtBA0kNAQJAIBsoAhgoAhgiBygCJCIIIAcoAlhHDQAgCCAHKAKMASIJRw0AIAEgCEGYAWwiB2oiASgClAEgASgCjAFrIAEoApABIAEoAogBa2wiASAHIAooAmhqIgcoApQBIAcoAowBayAHKAKQASAHKAKIAWtsRw0AIAooArQBIAlBmAFsaiIHKAKUASAHKAKMAWsgBygCkAEgBygCiAFrbCABRg0BCyAzQQFBxM4AQQAQEwwHCyAOQQJGBEAgGSgC6CtFDQUgC0ECdBAYIgtFDQcgFSgCECIJRQ0EIBsoAkAEQEEAIRUgCUELTQ0DIApBJGoiCCALIAlBAnRqSQR/IAogCUHMAGxqQSRrIAtLBUEACw0DIApBiAJqIQ8gCkG8AWohDCAKQfAAaiEXIAogCUF8cSIGQcwAbGohCkEAIQ4DQCALIA5BAnRqIA8gDkHMAGwiB2ogByAMaiAHIBdqIAcgCGr9XAIA/VYCAAH9VgIAAv1WAgAD/QsCACAOQQRqIg4gBkcNAAsgBiAJRw0EDAULQQAhFQJAIAlBDEkEQEEAIQYMAQsgCkE0aiEIAkAgCyAKIAlBzABsakEUa08NACAIIAsgCUECdGpPDQBBACEGDAELIApBmAJqIQ8gCkHMAWohDCAKQYABaiEXIAogCUF8cSIGQcwAbGohCkEAIQ4DQCALIA5BAnRqIA8gDkHMAGwiB2ogByAMaiAHIBdqIAcgCGr9XAIA/VYCAAH9VgIAAv1WAgAD/QsCACAOQQRqIg4gBkcNAAsgBiAJRg0FCwJAIAlBA3EiB0UEQCAGIQ4MAQsgBiEOA0AgCyAOQQJ0aiAKKAI0NgIAIA5BAWohDiAKQcwAaiEKIBVBAWoiFSAHRw0ACwsgBiAJa0F8Sw0EIAtBDGohBiALQQhqIQggC0EEaiEPA0AgCyAOQQJ0IgdqIAooAjQ2AgAgByAPaiAKKAKAATYCACAHIAhqIAooAswBNgIAIAYgB2ogCigCmAI2AgAgCkGwAmohCiAOQQRqIg4gCUcNAAsMBAsgGSgC0CsoAhRBAUYEQCAGBEAgCigCJCAKKAJwIAooArwBIAEQaAwGCyAKKAI0IAooAoABIAooAswBIAEQaAwFCyAGBEAgCigCJCAKKAJwIAooArwBIAEQZwwFCyAKKAI0IAooAoABIAooAswBIAEQZwwECyA/IAs2AgAgM0EBQYHPACA/EBMMAwtBACEGCwJAIAlBA3EiB0UEQCAGIQ4MAQsgBiEOA0AgCyAOQQJ0aiAKKAIkNgIAIA5BAWohDiAKQcwAaiEKIBVBAWoiFSAHRw0ACwsgBiAJa0F8Sw0AIAtBDGohBiALQQhqIQggC0EEaiEPA0AgCyAOQQJ0IgdqIAooAiQ2AgAgByAPaiAKKAJwNgIAIAcgCGogCigCvAE2AgAgBiAHaiAKKAKIAjYCACAKQbACaiEKIA5BBGoiDiAJRw0ACwsgGygCGCgCGCgCIBoCfyAZKALoKyEHQQAhF0EAIAlBA3QQGCIORQ0AGgJAIAFFDQAgCUUNACAOIAlBAnRqIREgCUF8cSENIAlBA3EhGSAJQQFrIRADQEEAIRVBACEIIBBBA08EQANAIA4gFUECdCIGaiAGIAtqKAIAKgIAOAIAIA4gBkEEciIPaiALIA9qKAIAKgIAOAIAIA4gBkEIciIPaiALIA9qKAIAKgIAOAIAIA4gBkEMciIGaiAGIAtqKAIAKgIAOAIAIBVBBGohFSAIQQRqIgggDUcNAAsLQQAhCiAZBEADQCAOIBVBAnQiBmogBiALaigCACoCADgCACAVQQFqIRUgCkEBaiIKIBlHDQALC0EAIQYgByEVA0AgESAGQQJ0IhRqIghBADYCAEMAAAAAIYQBQQAhCkEAIQ8gEEECSwRAA0AgCCAVKgIAIA4gCkECdGoiDCoCAJQghAGSIoQBOAIAIAggFSoCBCAMKgIElCCEAZIihAE4AgAgCCAVKgIIIAwqAgiUIIQBkiKEATgCACAIIBUqAgwgDCoCDJQghAGSIoQBOAIAIApBBGohCiAVQRBqIRUgD0EEaiIPIA1HDQALC0EAIQwgGQRAA0AgCCAVKgIAIA4gCkECdGoqAgCUIIQBkiKEATgCACAKQQFqIQogFUEEaiEVIAxBAWoiDCAZRw0ACwsgCyAUaiIIIAgoAgAiCEEEajYCACAIIIQBOAIAIAZBAWoiBiAJRw0ACyAXQQFqIhcgAUcNAAsLIA4QFEEBCyALEBRFDQILIBsoAhQoAgAiECgCEEUEQEEBISIMAgsgGygCICgC0CsiFUG4CGohFCAVQbQIaiETIBsoAkQhESAQKAIUIQcgGygCGCgCGCEIQQAhFwNAAkAgEQRAIBEgF0ECdGooAgBFDQELIAcoAhwiASAIKAIkQZgBbGohCwJ/IBsoAkBFBEAgCygClAEgCygCjAFrIQYgCygCkAEgCygCiAFrIQFBACEJQTQMAQsgASAHKAIYQZgBbGoiBkGQAWsoAgAgCygCCCALKAIAayIBIAZBmAFrKAIAamshCSALKAIMIAsoAgRrIQZBJAshDyAIKAIYIQsCfyAIKAIgBEBBASALQQFrdCILQQFrIQ5BACALawwBC0F/IAt0QX9zIQ5BAAshDSABRQ0AIAZFDQAgByAPaigCACEiIBUoAhRBAUYEQCAUIBdBuAhsIgtqIRYgCyATaiEYIAFBAXEhMyABQQJ0IR0gAUF8cSIPQQJ0ISMgDv0RIXggDf0RIXZBACEMIAFBBEkhHwNAAkACQAJAIB8NACAYIB0gImpJIBYgIktxDQAgIiAjaiEZIBX9CQK0CCF5QQAhCwNAICIgC0ECdGoiCiB2IHkgCv0AAgD9rgEieiB4/bYBIHogdv05/VL9CwIAIAtBBGoiCyAPRw0ACyAPIgsgAUYNAgwBCyAiIRlBACELCyALQQFyIQogMwRAIBkgDSAVKAK0CCAZKAIAaiILIA4gCyAOSBsgCyANSBs2AgAgGUEEaiEZIAohCwsgASAKRg0AA0AgGSANIBUoArQIIBkoAgBqIgogDiAKIA5IGyAKIA1IGzYCACAZIA0gFSgCtAggGSgCBGoiCiAOIAogDkgbIAogDUgbNgIEIBlBCGohGSALQQJqIgsgAUcNAAsLIBkgCUECdGohIiAMQQFqIgwgBkcNAAsMAQsgDq0hfCANrCGAAUEAIQwDQEEAIQsDQCAiAn8gDiAiKgIAIoQBQwAAAE9eDQAaIA0ghAFDAAAAz10NABogDSAVNAK0CAJ/IIQBkCKEAYtDAAAAT10EQCCEAagMAQtBgICAgHgLrHwifSB8IHwgfVUbpyB9IIABUxsLNgIAICJBBGohIiALQQFqIgsgAUcNAAsgIiAJQQJ0aiEiIAxBAWoiDCAGRw0ACwsgB0HMAGohByAVQbgIaiEVIAhBNGohCEEBISIgF0EBaiIXIBAoAhBJDQALDAELQQAhIiAFQQFBhxpBABATCyA/QRBqJAAgIkUEQCBNEDQgACAAKAIIQYCAAnI2AgggBUEBQZbZAEEAEBMMAQsCQCACRQ0AAn8gAiEHQQAhBgJAIAAoAugBIgpBARBdIgFBf0YNACABIANLDQBBASAKKAIYIgEoAhBFDQEaIAEoAhghDyAKKAIUKAIAKAIUIRcDQCAPKAIYIgFBB3EhAiABQQN2IQMgFygCHCIGIA8oAiRBmAFsaiEBAn8gCigCQARAIAYgFygCGEGYAWxqIgZBkAFrKAIAIAEoAgggASgCAGsiCCAGQZgBaygCAGprIQwgASgCDCABKAIEayEOQSQMAQsgASgClAEgASgCjAFrIQ4gASgCkAEgASgCiAFrIQhBACEMQTQLIBdqKAIAIQECQAJAAkACQAJAQQQgAyACQQBHaiICIAJBA0YbQQFrDgQBAgQABAsgDkUNAyAIIAxqIQYgCEECdCECIA5BBE8EQCAOQXxxIQtBACEIA0AgByABIAIQFiEHIAEgBkECdCIDaiIJIANqIgwgA2oiFSADaiEBIAIgB2ogCSACEBYgAmogDCACEBYgAmogFSACEBYgAmohByAIQQRqIgggC0cNAAsLQQAhCCAOQQNxIgNFDQMDQCAHIAEgAhAWIQcgASAGQQJ0aiEBIAIgB2ohByAIQQFqIgggA0cNAAsMAwsgDkUgCEVyIQIgDygCIEUNASACDQIgCEECdCEVIAhBfHEiA0ECdCEZQQAhCQNAAkACQAJAIAhBBEkNACABIAcgCGpJIAEgFWogB0txDQAgAyAHaiABIBlqIQZBACELA0AgByALaiABIAtBAnRq/QACAP0MAAAAAAAAAAAAAAAAAAAAAP0NAAQIDAAAAAAAAAAAAAAAAP1aAAAAIAtBBGoiCyADRw0ACyEHIAMiAiAIRg0CDAELIAEhBkEAIQILQQAhCyAIIAIiAWtBB3EiDQRAA0AgByAGKAIAOgAAIAFBAWohASAHQQFqIQcgBkEEaiEGIAtBAWoiCyANRw0ACwsgAiAIa0F4Sw0AA0AgByAGKAIAOgAAIAcgBigCBDoAASAHIAYoAgg6AAIgByAGKAIMOgADIAcgBigCEDoABCAHIAYoAhQ6AAUgByAGKAIYOgAGIAcgBigCHDoAByAHQQhqIQcgBkEgaiEGIAFBCGoiASAIRw0ACwsgBiAMQQJ0aiEBIAlBAWoiCSAORw0ACwwCCyAORSAIRXIhAiAPKAIgBEAgAg0CIAhBAnQhFSAIQQF0IRkgCEF8cSIDQQJ0IQ0gA0EBdCEQQQAhCQNAAkACQAJAIAhBBEkNACABIAcgGWpJIAEgFWogB0txDQAgASANaiEGIAcgEGpBACELA0AgByALQQF0aiABIAtBAnRq/QACAP0MAAAAAAAAAAAAAAAAAAAAAP0NAAEEBQgJDA0AAQABAAEAAf1bAQAAIAtBBGoiCyADRw0ACyEHIAMiAiAIRg0CDAELIAEhBkEAIQILQQAhCyAIIAIiAWtBB3EiEQRAA0AgByAGKAIAOwEAIAFBAWohASAHQQJqIQcgBkEEaiEGIAtBAWoiCyARRw0ACwsgAiAIa0F4Sw0AA0AgByAGKAIAOwEAIAcgBigCBDsBAiAHIAYoAgg7AQQgByAGKAIMOwEGIAcgBigCEDsBCCAHIAYoAhQ7AQogByAGKAIYOwEMIAcgBigCHDsBDiAHQRBqIQcgBkEgaiEGIAFBCGoiASAIRw0ACwsgBiAMQQJ0aiEBIAlBAWoiCSAORw0ACwwCCyACDQEgCEECdCEVIAhBAXQhGSAIQXxxIgNBAnQhDSADQQF0IRBBACEJA0ACQAJAAkAgCEEESQ0AIAEgByAZakkgASAVaiAHS3ENACABIA1qIQYgByAQakEAIQsDQCAHIAtBAXRqIAEgC0ECdGr9AAIA/QwAAAAAAAAAAAAAAAAAAAAA/Q0AAQQFCAkMDQABAAEAAQAB/VsBAAAgC0EEaiILIANHDQALIQcgAyICIAhGDQIMAQsgASEGQQAhAgtBACELIAggAiIBa0EHcSIRBEADQCAHIAYoAgA7AQAgAUEBaiEBIAdBAmohByAGQQRqIQYgC0EBaiILIBFHDQALCyACIAhrQXhLDQADQCAHIAYoAgA7AQAgByAGKAIEOwECIAcgBigCCDsBBCAHIAYoAgw7AQYgByAGKAIQOwEIIAcgBigCFDsBCiAHIAYoAhg7AQwgByAGKAIcOwEOIAdBEGohByAGQSBqIQYgAUEIaiIBIAhHDQALCyAGIAxBAnRqIQEgCUEBaiIJIA5HDQALDAELIAINACAIQQJ0IRUgCEF8cSIDQQJ0IRlBACEJA0ACQAJAAkAgCEEESQ0AIAEgByAIakkgASAVaiAHS3ENACADIAdqIAEgGWohBkEAIQsDQCAHIAtqIAEgC0ECdGr9AAIA/QwAAAAAAAAAAAAAAAAAAAAA/Q0ABAgMAAAAAAAAAAAAAAAA/VoAAAAgC0EEaiILIANHDQALIQcgAyICIAhGDQIMAQsgASEGQQAhAgtBACELIAggAiIBa0EHcSINBEADQCAHIAYoAgA6AAAgAUEBaiEBIAdBAWohByAGQQRqIQYgC0EBaiILIA1HDQALCyACIAhrQXhLDQADQCAHIAYoAgA6AAAgByAGKAIEOgABIAcgBigCCDoAAiAHIAYoAgw6AAMgByAGKAIQOgAEIAcgBigCFDoABSAHIAYoAhg6AAYgByAGKAIcOgAHIAdBCGohByAGQSBqIQYgAUEIaiIBIAhHDQALCyAGIAxBAnRqIQEgCUEBaiIJIA5HDQALCyAXQcwAaiEXIA9BNGohD0EBIQYgdUEBaiJ1IAooAhgoAhBJDQALCyAGC0UNASBNKALcKyIBRQ0AIAEQFCBNQgA3AtwrCyAAIAAtAFxB/gFxOgBcIAAgACgCCEH/fnE2AghBASFlIAQpAwgifFAEfkIABSB8IAQpAzh9C1AgACgCCCIBQcAARnENACABQYACRg0AIAQgTEEKakECIAUQHUECRwRAIAVBAUECIAAoAtABG0GDE0EAEBMgACgC0AFFIWUMAQsgTEEKaiBMQQxqQQIQFSBMKAIMIgFBkP8DRg0AIAFB2f8DRgRAIABBgAI2AgggAEEANgLkAQwBCyAEKQMIInxQBH5CAAUgfCAEKQM4fQtQBEAgAEHAADYCCCAFQQJBvsEAQQAQEwwBC0EAIWUgBUEBQc3AAEEAEBMLIExBEGokACBlCwsAIAAEQCAAEBQLC7QBAQF/IAAoAgxFBEAgAiAAKAIkIAERAwAPCwJAQQgQGCIDRQ0AIAMgAjYCBCADIAE2AgBBCBAYIgFFBEAgAxAUDwsgASADNgIAIAAgACgCBEHkAGwiAjYCKANAIAAoAhggAkoNAAsgASAAKAIUNgIEIAAgATYCFCAAIAAoAhhBAWo2AhggACgCHCIBRQ0AIAEoAgBBADYCCCAAIAEoAgQ2AhwgACAAKAIgQQFrNgIgIAEQFAsL+gIBBH8CQCAARQ0AIAAoAqwoIgEEQCAAKAKoKCICBEBBACEBA0AgACgCrCggAUEDdGooAgAiAwRAIAMQFCAAKAKoKCECCyABQQFqIgEgAkkNAAsgACgCrCghAQsgAEEANgKoKCABEBQgAEEANgKsKAsgACgCtCgiAQRAIAEQFCAAQQA2ArQoCyAAKALQKyIBBEAgARAUIABBADYC0CsLIAAoAuwrIgEEQCABEBQgAEEANgLsKwsgACgC6CsiAQRAIAEQFCAAQQA2AugrCyAAKAL8KyIBBEAgARAUIABBADYChCwgAEIANwL8KwsgACgC8CsiAQRAIAAoAvQrIgMEf0EAIQIDQCABKAIMIgQEQCAEEBQgAUEANgIMIAAoAvQrIQMLIAFBFGohASACQQFqIgIgA0kNAAsgACgC8CsFIAELEBQgAEEANgLwKwsgACgC5CsiAQRAIAEQFCAAQQA2AuQrCyAAKALcKyIBRQ0AIAEQFCAAQgA3AtwrCwuwBwILfwF+IAAoAhAiCEEgTwRAIAApAwinDwsCQCAAKAIUIgNBBE4EQCAAKAIAIgJBA2soAgAhASAAIANBBGsiAzYCFCAAIAJBBGs2AgAMAQsgA0EATARADAELIANBAXEgACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEBayIGNgIAIAItAAAgACACQQJrIgI2AgAgACADQQFrNgIUIAYtAAAhBiAAIANBAmsiAzYCFCAEdCABciAGIARBCGt0ciEBIARBEGshBCAFQQJqIgUgCUcNAAsLBEAgACACQQFrNgIAIAItAAAgACADQQFrNgIUIAR0IAFyIQELQQAhAwsgACgCGCECIAAgAUH/AXEiCUGPAUs2AhggAEEHQQggAUGAgID4B3FBgICA+AdGG0EIIAIbIgJBCEEHQQggAUGAgPwDcUGAgPwDRhsgAUH/////eE0baiIEQQhBB0EIIAFBgP4BcUGA/gFGGyABQRB2Qf8BcSIFQY8BTRtqIgZBCEEHQQggAUH/AHFB/wBGGyABQQh2Qf8BcSIHQY8BTRsgCGpqIgo2AhAgACAAKQMIIAUgAnQgAUEYdnIgByAEdHIgCSAGdHKtIAithoQiDDcDCCAKQR9NBEACQCADQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrNgIUIAAgAkEEazYCAAwBCyADQQBMBEBBACEBDAELIANBAXEgACgCACECAkAgA0EBRgRAQRghBEEAIQEMAQsgA0H+////B3EhBkEYIQRBACEBQQAhBQNAIAAgAkEBayIHNgIAIAItAAAgACACQQJrIgI2AgAgACADQQFrNgIUIActAAAhByAAIANBAmsiAzYCFCAEdCABciAHIARBCGt0ciEBIARBEGshBCAFQQJqIgUgBkcNAAsLRQ0AIAAgAkEBazYCACACLQAAIAAgA0EBazYCFCAEdCABciEBCyAAIAFB/wFxIgJBjwFLNgIYIABBCEEHQQggAUGAgID4B3FBgICA+AdGGyAJQY8BTRsiA0EIQQdBCCABQYCA/ANxQYCA/ANGGyABQf////94TRtqIgRBCEEHQQggAUGA/gFxQYD+AUYbIAFBEHZB/wFxIgVBjwFNG2oiCEEIQQdBCCABQf8AcUH/AEYbIAFBCHZB/wFxIglBjwFNGyAKamo2AhAgACAFIAN0IAFBGHZyIAkgBHRyIAIgCHRyrSAKrYYgDIQiDDcDCAsgDKcLwRQCG38GeyAAKAIIIgogACgCBGohCAJAIAAoAgxFBEAgCEECSA0BIANBAEwNASAAKAIAIgUgCEEEayIGQQF2IgxBAnQiCSABIApBAnRqIgcgA0ECdCIEampBBGpJIAUgDEEDdGpBCGoiACAHQQRqS3EgBSABIARqIAlqQQRqSSABQQRqIABJcXIhEiAIQQRJIhQgAkEBR3IhFSACQQFGIAZBBUtxIRYgCEH8////B3EhEyAIQQFxIRcgCkEBaiEPIAhBA3EhESABIAVrIRggBSAIQQJ0aiEZIAUgCEEBayIAQQJ0aiEaIAxBAWoiG0F8cSIQQQF0IQsgAiAKbEECdCEcIABBAXYgAmxBAnQhHQNAIAEoAgAgASAcaigCACIJQQFqQQF1ayEHAkAgFARAIAkhBEEAIQYMAQtBACEGAkACf0EAIBZFDQAaQQAgEg0AGiAJ/REhICAH/REhH/0MAAAAAAIAAAAEAAAABgAAACEjQQAhAANAIAEgAEECdGr9AAIEISIgASAAIA9qQQJ0av0AAgAhISAFIABBA3RqIgQgH/1aAgADIARBCGogIiAhICAgIf0NDA0ODxAREhMUFRYXGBkaGyIi/a4B/QwCAAAAAgAAAAIAAAACAAAA/a4BQQL9rAH9sQEiIP1aAgAAIARBEGogIP1aAgABIARBGGogIP1aAgACIAUgI/0MAQAAAAEAAAABAAAAAQAAAP1QIiT9GwBBAnRqICAgHyAg/Q0MDQ4PEBESExQVFhcYGRob/a4BQQH9rAEgIv2uASIf/VoCAAAgBSAk/RsBQQJ0aiAf/VoCAAEgBSAk/RsCQQJ0aiAf/VoCAAIgBSAk/RsDQQJ0aiAf/VoCAAMgI/0MCAAAAAgAAAAIAAAACAAAAP2uASEjICAhHyAhISAgAEEEaiIAIBBHDQALICD9GwMhBCAf/RsDIQcgECAbRg0BIAshBiAEIQkgEAshAANAIAEgAEEBaiIKIAJsQQJ0aigCACEeIAEgACAPaiACbEECdGooAgAhBCAFIAZBAnRqIg4gBzYCACAOIAcgHiAEIAlqQQJqQQJ1ayIHakEBdSAJajYCBCAGQQJqIQYgACAMRyAEIQkgCiEADQALDAELIAshBgsgBSAGQQJ0aiAHNgIAQXwhACAXBH8gGiABIB1qKAIAIARBAWpBAXVrIgA2AgAgACAHakEBdSEHQXgFQXwLIBlqIAQgB2o2AgBBACEGQQAhAEEAIQQCQCAVIBggDUECdGpBEElyRQRAA0AgASAAQQJ0IgRqIAQgBWr9AAIA/QsCACAAQQRqIgAgE0cNAAsgEyIEIAhGDQELIAQhACARBEADQCABIAAgAmxBAnRqIAUgAEECdGooAgA2AgAgAEEBaiEAIAZBAWoiBiARRw0ACwsgBCAIa0F8Sw0AA0AgASAAIAJsQQJ0aiAFIABBAnRqKAIANgIAIAEgAEEBaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEECaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIAEgAEEDaiIEIAJsQQJ0aiAFIARBAnRqKAIANgIAIABBBGoiACAIRw0ACwsgAUEEaiEBIA1BAWoiDSADRw0ACwwBCwJAAkACQCAIQQFrDgIAAQILIANBAEwNAkEAIQICQCADQQRJBEAgASEADAELIAEgA0H8////B3EiAkECdGohAANAIAEgBkECdGoiBCAE/QACACIf/RsAQQJt/REgH/0bAUECbf0cASAf/RsCQQJt/RwCIB/9GwNBAm39HAP9CwIAIAZBBGoiBiACRw0ACyACIANGDQMLA0AgACAAKAIAQQJtNgIAIABBBGohACACQQFqIgIgA0cNAAsMAgsgA0EATA0BIAAoAgAhCSACIApsQQJ0IQcDQCAJIAEoAgAgASAHaiIEKAIAQQFqQQF1ayIANgIEIAkgACAEKAIAaiIANgIAIAEgADYCACABIAJBAnRqIAkoAgQ2AgAgAUEEaiEBIAZBAWoiBiADRw0ACwwBCyAIQQNIDQAgA0EATA0AIAAoAgAiBSAIIAhBAXEiFEUiBmtBBGsiCUEBdiILQQJ0IgcgASADQQJ0IgBqakkgBSALQQN0akEMaiIEIAFBBGpLcSAFQQRqIAAgASAKQQJ0aiIAaiAHakEIakkgAEEIaiAESXFyIRUgAkEBRyAIQQRJciEWIAJBAUYgCUEFS3EhFyAIQfz///8HcSEQIAhBA3EhESABIAVrIRggBSAIQQJ0akEEayEZIAUgCEECayIAQQJ0aiEaIAtBAWoiEkF8cSIMQQFyIRMgDEEBdEEBciELIAIgCmxBAnQhGyAAIAZrQQJJIRwgCEEBdkEBayACbEECdCEdA0AgBSABKAIAIAEgG2oiDyACQQJ0aigCACIJIA8oAgAiAGpBAmpBAnVrIgcgAGo2AgBBASEEAkAgHARAIAkhBgwBCwJAAn9BASAXRQ0AGkEBIBUNABogCf0RIR8gB/0RISBBACEAA0AgBSAAQQN0aiIHIAEgAEECdCIEav0AAgQgHyAEIA9q/QACCCIf/Q0MDQ4PEBESExQVFhcYGRobIiIgH/2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIiEgISAgICH9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAi/a4BIiL9DQQFBgcYGRobCAkKCxwdHh/9CwIUIAcgICAi/Q0MDQ4PEBESEwABAgMUFRYXICH9DQABAgMEBQYHEBESEwwNDg/9CwIEICEhICAAQQRqIgAgDEcNAAsgH/0bAyEGICD9GwMhByAMIBJGDQEgCyEEIAYhCSATCyEAA0AgASAAIAJsQQJ0aigCACEeIA8gAEEBaiIKIAJsQQJ0aigCACEGIAUgBEECdGoiDiAHNgIAIA4gByAeIAYgCWpBAmpBAnVrIgdqQQF1IAlqNgIEIARBAmohBCAAIBJHIAohACAGIQkNAAsMAQsgCyEECyAYIA1BAnRqIQkgBSAEQQJ0aiAHNgIAAkAgFEUEQCAaIAEgHWooAgAgBkEBakEBdWsiACAHakEBdSAGajYCAAwBCyAGIAdqIQALIBkgADYCAEEAIQZBACEAQQAhBAJAIBYgCUEQSXJFBEADQCABIABBAnQiBGogBCAFav0AAgD9CwIAIABBBGoiACAQRw0ACyAQIgQgCEYNAQsgBCEAIBEEQANAIAEgACACbEECdGogBSAAQQJ0aigCADYCACAAQQFqIQAgBkEBaiIGIBFHDQALCyAEIAhrQXxLDQADQCABIAAgAmxBAnRqIAUgAEECdGooAgA2AgAgASAAQQFqIgQgAmxBAnRqIAUgBEECdGooAgA2AgAgASAAQQJqIgQgAmxBAnRqIAUgBEECdGooAgA2AgAgASAAQQNqIgQgAmxBAnRqIAUgBEECdGooAgA2AgAgAEEEaiIAIAhHDQALCyABQQRqIQEgDUEBaiINIANHDQALCwszAQF/IwBBEGsiASQAIAAEfyABQQxqQSAgABB5IQBBACABKAIMIAAbBUEACyABQRBqJAALGwEBfyAABEAgACgCCCIBBEAgARAUCyAAEBQLCzEBAn9BAUEMEBciAARAIABBCjYCBCAAQQpBBBAXIgE2AgggAQRAIAAPCyAAEBQLQQALSAECfwJ/IAFBH00EQCAAKAIAIQIgAEEEagwBCyABQSBrIQEgAAsoAgAhAyAAIAIgAXQ2AgAgACADIAF0IAJBICABa3ZyNgIEC68CAQZ/IwBB8AFrIgYkACAGIAI2AuwBIAYgATYC6AEgBiAANgIAIARFIQkCQAJAAkACQCABQQFHBEAgACEHQQEhCAwBCyAAIQdBASEIIAINACAAIQQMAQsDQCAHIAUgA0ECdGoiCigCAGsiBCAAECtBAEwEQCAHIQQMAgsgCUF/cyELQQEhCQJAIAsgA0ECSHJBAXFFBEAgCkEIaygCACEKIAdBCGsiCyAEECtBAE4NASALIAprIAQQK0EATg0BCyAGIAhBAnRqIAQ2AgAgBkHoAWogASACEHciARA8IAhBAWohCCABIANqIQMgBigC7AEhAiAEIQcgBigC6AEiAUEBRw0BIAINAQwDCwsgByEEDAELIAlFDQELIAYgCBB2IAQgAyAFEEQLIAZB8AFqJAALSwECfyAAKAIEIQIgAAJ/IAFBH00EQCAAKAIAIQMgAgwBCyABQSBrIQEgAiEDQQALIgIgAXY2AgQgACACQSAgAWt0IAMgAXZyNgIACy8BAX8gAARAIAAoAgQiAQRAIAAoAgAgARECAAsgACgCIBAUIABBADYCICAAEBQLCyoAIAAEQCAAKAIwIABBFEEQIAAoAkwbaigCABECACAAQQA2AjAgABAUCwuGAwIFfwp+IwBBIGsiAyQAAkAgACgCECIFRQRAQQEhAgwBCwJAIAA0AgAiB0IAUw0AIAA0AgQiCEIAUw0AIAA0AggiCUIAUw0AIAA0AgwiCkIAUw0AIAAoAhghACAHQgF9IQwgCEIBfSENIAlCAX0hCSAKQgF9IQoDQCAAIAwgACgCACICrSIHfCAHgCILPgIQIAAgDSAAKAIEIgatIgd8IAeAIg4+AhRCASAANQIoIgeGIg9CAX0iCCAJIAKsIhB8IBB/xHwgB4enIAggC8R8IAeHp2siAkEASARAIAMgAjYCBCADIAQ2AgAgAUEBQaHpACADEBNBACECDAMLIAAgAjYCCCAIIAogBqwiC3wgC3/EfCAHh6cgDsQgD3xCAX0gB4enayICQQBIBEAgAyACNgIUIAMgBDYCECABQQFB5ukAIANBEGoQE0EAIQIMAwsgACACNgIMIABBNGohAEEBIQIgBEEBaiIEIAVHDQALDAELIAFBAUGbNEEAEBMLIANBIGokACACC/0GAQZ/IAAEQAJAIAAoAgAEQCAAKAIMIgEEQCABEDQgACgCDBAUIABBADYCDAsgACgCECIBBEAgARAUIABCADcDEAsgACgCQBAUIABCADcCPCAAKAJIEBQgAEEANgJIIAAoAlgQFCAAQQA2AlgMAQsgACgCLCIBBEAgARAUIABBADYCLAsgACgCICIBBEAgARAUIABCADcDIAsgACgCNCIBRQ0AIAEQFCAAQgA3AjQLIAAoAugBEF4gACgCtAEiAQRAIAAoAoABIAAoAoQBbCIDBH8DQCABEDQgAUGMLGohASACQQFqIgIgA0cNAAsgACgCtAEFIAELEBQgAEEANgK0AQsgACgCjAEiAQRAIAAoAogBIgIEQEEAIQEDQCAAKAKMASABQQN0aigCACIDBEAgAxAUIAAoAogBIQILIAFBAWoiASACSQ0ACyAAKAKMASEBCyAAQQA2AogBIAEQFCAAQQA2AowBCyAAKAKgARAUIABBADYCkAEgAEEANgKgASAAKAJ8EBQgAEEANgJ8IAAtANQBQQJxRQRAIAAoAsABEBQLIABB6ABqQQBB8AAQGRogACgC2AEQOCAAQQA2AtgBIAAoAtwBEDggAEEANgLYASAAKALgASIBBEAgASgCHCICBEAgAhAUIAFBADYCHAsgASgCKCICBEAgASgCJARAA0AgAiAFQShsIgNqKAIkIgQEQCAEEBQgASgCKCICIANqQQA2AiQLIAIgA2ooAhAiBARAIAQQFCABKAIoIgIgA2pBADYCEAsgAiADaigCGCIEBEAgBBAUIAEoAigiAiADakEANgIYCyAFQQFqIgUgASgCJEkNAAsLIAIQFCABQQA2AigLIAEQFAsgAEEANgLgASAAKAJgECUgAEEANgJgIAAoAmQQJSAAQQA2AmQgACgC7AEiAwRAAkAgAygCCEUNACADKAIMBEAgA0EANgIoA0AgAygCGEEASg0ACwsgA0EBNgIQIAMoAgAQFCADKAIcIgJFDQADQCACKAIEIQEgAhAUIAMgATYCHCABIgINAAsLIAMoAiQiAgRAIAIoAgQiBUEASgRAQQAhAQNAIAIoAgAgAUEMbGoiBCgCCCIGBEAgBCgCBCAGEQIAIAIoAgQhBQsgAUEBaiIBIAVIDQALCyACKAIAEBQgAhAUCyADEBQLIABBADYC7AEgABAUCwvmAwIIfwR+IAAoAhQoAgAoAhQgAUHMAGxqIgkoAgwiCCAAKAIYKAIYIAFBNGxqIgo1AgQiEEIBfSISIAA1Ajx8IBCApyILIAggC0kbIQwgCSgCCCIIIAo1AgAiEUIBfSITIAA1Ajh8IBGApyIKIAggCkkbIQogCSgCBCIIIBIgADUCNHwgEICnIgsgCCALSxshCyAJKAIAIgggEyAANQIwfCARgKciDSAIIA1LGyENQQAhCCAAKAIgKALQKyABQbgIbGooAhQhDgJAIAkoAhRBACACa0F/IAIbaiICRQRAIAohACANIQggCyEBDAELIANBAXEgAkEBayIPdCIJIA1JBEAgDSAJa61CfyACrSIQhkJ/hXwgEIinIQgLQQAhAEEAIQEgA0EBdiAPdCIDIAtJBEAgCyADa61CfyACrSIQhkJ/hXwgEIinIQELIAkgCkkEQCAKIAlrrUJ/IAKtIhCGQn+FfCAQiKchAAsgAyAMTwRAQQAhDAwBCyAMIANrrUJ/IAKtIhCGQn+FfCAQiKchDAsgBEF/IABBAkEDIA5BAUYbIgJqIgMgACADSxtJIAVBfyACIAxqIgAgACAMSRtJcSAGIAggAmsiAEEAIAAgCE0bS3EgByABIAJrIgBBACAAIAFNG0txC6IBAQZ/IAAEQCAAKAIEIgIEQCACEBQgAEEANgIECyABBEAgACECA0AgAigCyAEiAwRAQQAhBSACKALEASIEBH8DQCADKAIMIgYEQCAGEBQgA0EANgIMIAIoAsQBIQQLIANBEGohAyAFQQFqIgUgBEkNAAsgAigCyAEFIAMLEBQgAkEANgLIAQsgAkHwAWohAiAHQQFqIgcgAUcNAAsLIAAQFAsLwBgCG38DeyACQQdsIQ8gAkEGbCEQIAJBBWwhESACQQJ0IQwgAkEDbCESIAJBAXQhEyAAKAIAIgogACgCDCIZQQV0IgRqIQYgCiAEayAAKAIQIQUgACgCHCELIAAoAhQhByAAKAIIIQ0CQAJAAkACQAJAAkACQCADQQhJDQAgAUEPcQ0AIAZBD3FFDQELIAUgB08NBQJAAkAgA0EBaw4CAAEDCyAHIAVrIghBF00NBSABIAVBAnRqIQkgGUEFdCIEIAogBUEGdGpqIAEgB0ECdGpJBEAgCSAKIAdBBnRqIARqQTxrSQ0GCyAF/RH9DAAAAAABAAAAAgAAAAMAAAD9rgEhICAFIAhBfHEiDmohBUEAIQQDQCAGICBBBv2rASIf/RsAaiAJIARBAnRq/QACACIh/R8AOAIAIAYgH/0bAWogIf0fATgCACAGIB/9GwJqICH9HwI4AgAgBiAf/RsDaiAh/R8DOAIAICD9DAQAAAAEAAAABAAAAAQAAAD9rgEhICAEQQRqIgQgDkcNAAsgCCAORw0FDAYLIAEgAkECdGohCCAHIAVrIg5BG00NAiAZQQV0IgQgCiAFQQZ0amoiCSABIAIgB2pBAnRqSSAKIAdBBnRqIARqQThrIgQgASACIAVqQQJ0aktxDQIgCSABIAdBAnRqSSABIAVBAnRqIARJcQ0CIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEgIAUgDkF8cSIUaiEEQQAhCQNAIAYgIEEG/asBIh/9GwBqIhUgASAFIAlqQQJ0IhZq/QACACIh/R8AOAIAIAYgH/0bAWoiFyAh/R8BOAIAIAYgH/0bAmoiGCAh/R8COAIAIAYgH/0bA2oiGiAh/R8DOAIAIBUgCCAWav0AAgAiH/0fADgCBCAXIB/9HwE4AgQgGCAf/R8COAIEIBogH/0fAzgCBCAg/QwEAAAABAAAAAQAAAAEAAAA/a4BISAgCUEEaiIJIBRHDQALIA4gFEcNAwwFCyAFIAdPDQQgASAPQQJ0aiEJIAEgEEECdGohDiABIBFBAnRqIRQgASAMQQJ0aiEVIAEgEkECdGohFiABIBNBAnRqIRcgASACQQJ0aiEYA0AgBiAFQQZ0aiIEIAEgBUECdCIIaioCADgCACAEIAggGGoqAgA4AgQgBCAIIBdqKgIAOAIIIAQgCCAWaioCADgCDCAEIAggFWoqAgA4AhAgBCAIIBRqKgIAOAIUIAQgCCAOaioCADgCGCAEIAggCWoqAgA4AhwgBUEBaiIFIAdHDQALDAQLIAEgD0ECdGohCSABIBBBAnRqIQ4gASARQQJ0aiEUIAEgDEECdGohFSABIBJBAnRqIRYgASATQQJ0aiEXIAEgAkECdGohGCADQQNGIRogA0EERiEcIANBBUYhHSADQQdGIR4DQCAGIAVBBnRqIgQgASAFQQJ0IghqKgIAOAIAIAQgCCAYaioCADgCBCAEIAggF2oqAgA4AggCQCAaDQAgBCAIIBZqKgIAOAIMIBwNACAEIAggFWoqAgA4AhAgHQ0AIAQgCCAUaioCADgCFCADQQZGDQAgBCAIIA5qKgIAOAIYIB4NACAEIAggCWoqAgA4AhwLIAVBAWoiBSAHRw0ACwwDCyAFIQQLIARBAWohBSAHIARrQQFxBEAgBiAEQQZ0aiIJIAEgBEECdCIEaioCADgCACAJIAQgCGoqAgA4AgQgBSEECyAFIAdGDQEDQCAGIARBBnRqIgUgASAEQQJ0IglqKgIAOAIAIAUgCCAJaioCADgCBCAGIARBAWoiBUEGdGoiCSABIAVBAnQiBWoqAgA4AgAgCSAFIAhqKgIAOAIEIARBAmoiBCAHRw0ACwwBCyAHIAUiBGtBA3EiCQRAQQAhCANAIAYgBEEGdGogASAEQQJ0aioCADgCACAEQQFqIQQgCEEBaiIIIAlHDQALCyAFIAdrQXxLDQADQCAGIARBBnRqIAEgBEECdGoqAgA4AgAgBiAEQQFqIgVBBnRqIAEgBUECdGoqAgA4AgAgBiAEQQJqIgVBBnRqIAEgBUECdGoqAgA4AgAgBiAEQQNqIgVBBnRqIAEgBUECdGoqAgA4AgAgBEEEaiIEIAdHDQALC0EgaiEHIAEgDUECdGohBiAAKAIYIQUCQAJAAkACQCADQQhJDQAgBkEPcQ0AIAdBD3FFDQELIAUgC08NAgJAAkACQCADQQFrDgIAAQILIAsgBWsiAEEbTQ0DIAogBUEGdEEgciAZQQV0IgJraiABIAsgDWpBAnRqSQRAIAEgBSANakECdGogC0EGdCACayAKakEca0kNBAsgBiAFQQJ0aiECIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEgIAUgAEF8cSIBaiEFQQAhBANAIAcgIEEG/asBIh/9GwBqIAIgBEECdGr9AAIAIiH9HwA4AgAgByAf/RsBaiAh/R8BOAIAIAcgH/0bAmogIf0fAjgCACAHIB/9GwNqICH9HwM4AgAgIP0MBAAAAAQAAAAEAAAABAAAAP2uASEgIARBBGoiBCABRw0ACyAAIAFHDQMMBAsgBiACQQJ0aiEDAkAgCyAFayIAQSRJBEAgBSEEDAELIAogBUEGdEEgciAZQQV0IgRraiIIIAEgAiALIA1qIgJqQQJ0akkgC0EGdCAEayAKakEYayIEIAEgDUECdGogBUECdGoiCiAMaktxBEAgBSEEDAELIAggASACQQJ0akkgBCAKS3EEQCAFIQQMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BISAgBSAAQXxxIgJqIQRBACEBA0AgByAgQQb9qwEiH/0bAGoiCiAGIAEgBWpBAnQiCGr9AAIAIiH9HwA4AgAgByAf/RsBaiIMICH9HwE4AgAgByAf/RsCaiINICH9HwI4AgAgByAf/RsDaiIPICH9HwM4AgAgCiADIAhq/QACACIf/R8AOAIEIAwgH/0fATgCBCANIB/9HwI4AgQgDyAf/R8DOAIEICD9DAQAAAAEAAAABAAAAAQAAAD9rgEhICABQQRqIgEgAkcNAAsgACACRg0ECyAEQQFqIQAgCyAEa0EBcQRAIAcgBEEGdGoiASAGIARBAnQiAmoqAgA4AgAgASACIANqKgIAOAIEIAAhBAsgACALRg0DA0AgByAEQQZ0aiIAIAYgBEECdCIBaioCADgCACAAIAEgA2oqAgA4AgQgByAEQQFqIgBBBnRqIgEgBiAAQQJ0IgBqKgIAOAIAIAEgACADaioCADgCBCAEQQJqIgQgC0cNAAsMAwsgBiAPQQJ0aiEEIAYgEEECdGohCiAGIBFBAnRqIQggBiAMQQJ0aiEMIAYgEkECdGohDSAGIBNBAnRqIQ8gBiACQQJ0aiECIANBA0YhECADQQRGIREgA0EFRiESIANBB0YhEwNAIAcgBUEGdGoiACAGIAVBAnQiAWoqAgA4AgAgACABIAJqKgIAOAIEIAAgASAPaioCADgCCAJAIBANACAAIAEgDWoqAgA4AgwgEQ0AIAAgASAMaioCADgCECASDQAgACABIAhqKgIAOAIUIANBBkYNACAAIAEgCmoqAgA4AhggEw0AIAAgASAEaioCADgCHAsgBUEBaiIFIAtHDQALDAILIAUgC08NASAGIA9BAnRqIQMgBiAQQQJ0aiEEIAYgEUECdGohCiAGIAxBAnRqIQggBiASQQJ0aiEMIAYgE0ECdGohDSAGIAJBAnRqIQIDQCAHIAVBBnRqIgAgBiAFQQJ0IgFqKgIAOAIAIAAgASACaioCADgCBCAAIAEgDWoqAgA4AgggACABIAxqKgIAOAIMIAAgASAIaioCADgCECAAIAEgCmoqAgA4AhQgACABIARqKgIAOAIYIAAgASADaioCADgCHCAFQQFqIgUgC0cNAAsMAQsgCyAFIgRrQQNxIgAEQEEAIQgDQCAHIARBBnRqIAYgBEECdGoqAgA4AgAgBEEBaiEEIAhBAWoiCCAARw0ACwsgBSALa0F8Sw0AA0AgByAEQQZ0aiAGIARBAnRqKgIAOAIAIAcgBEEBaiIAQQZ0aiAGIABBAnRqKgIAOAIAIAcgBEECaiIAQQZ0aiAGIABBAnRqKgIAOAIAIAcgBEEDaiIAQQZ0aiAGIABBAnRqKgIAOAIAIARBBGoiBCALRw0ACwsLnAEBBX8jAEHwAWsiBCQAIAQgADYCAEEBIQUCQCABQQJIDQAgACEDA0AgACADQQhrIgMgAiABQQJrIgdBAnRqKAIAayIGECtBAE4EQCAAIAMQK0EATg0CCyAEIAVBAnRqIAYgAyAGIAMQK0EATiIGGyIDNgIAIAVBAWohBSABQQFrIAcgBhsiAUEBSg0ACwsgBCAFEHYgBEHwAWokAAudAwEEfyABIABBBGoiBGpBAWtBACABa3EiBSACaiAAIAAoAgAiAWpBBGtNBH8gACgCBCIDIAAoAggiBjYCCCAGIAM2AgQgBCAFRwRAIAAgAEEEaygCAEF+cWsiAyAFIARrIgQgAygCAGoiBTYCACADIAVBfHFqQQRrIAU2AgAgACAEaiIAIAEgBGsiATYCAAsCfyABIAJBGGpPBEAgACACaiIEIAEgAmtBCGsiATYCCCAEQQhqIgUgAUF8cWpBBGsgAUEBcjYCACAEAn8gBCgCCEEIayIBQf8ATQRAIAFBA3ZBAWsMAQsgAWchAyABQR0gA2t2QQRzIANBAnRrQe4AaiABQf8fTQ0AGkE/IAFBHiADa3ZBAnMgA0EBdGtBxwBqIgEgAUE/TxsLIgNBBHQiAUHgzQFqNgIMIAQgAUHozQFqIgEoAgA2AhAgASAFNgIAIAQoAhAgBTYCBEHo1QFB6NUBKQMAQgEgA62GhDcDACAAIAJBCGoiATYCACAAIAFBfHFqDAELIAAgAWoLQQRrIAE2AgAgAEEEagVBAAsLwgEBA38CQCACKAIQIgMEfyADBSACEEcNASACKAIQCyACKAIUIgRrIAFJBEAgAiAAIAEgAigCJBEAAA8LAkACQCACKAJQQQBIDQAgAUUNACABIQMDQCAAIANqIgVBAWstAABBCkcEQCADQQFrIgMNAQwCCwsgAiAAIAMgAigCJBEAACIEIANJDQIgASADayEBIAIoAhQhBAwBCyAAIQVBACEDCyAEIAUgARAWGiACIAIoAhQgAWo2AhQgASADaiEECyAEC1kBAX8gACAAKAJIIgFBAWsgAXI2AkggACgCACIBQQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEAC8wCAQR/IAEgAP0AAgD9CwIAIAEoAhgiAgRAIAEoAhAiAwR/QQAhAgNAIAEoAhggAkE0bGooAiwiBARAIAQQFCABKAIQIQMLIAJBAWoiAiADSQ0ACyABKAIYBSACCxAUIAFBADYCGAsgASAAKAIQIgI2AhAgASACQTRsEBgiAjYCGCACBEAgASgCEARAQQAhAwNAIAIgA0E0bCIFaiICIAAoAhggBWoiBP0AAgD9CwIAIAIgBCgCMDYCMCACIAT9AAIg/QsCICACIAT9AAIQ/QsCECABKAIYIgIgBWpBADYCLCADQQFqIgMgASgCEEkNAAsLIAEgACgCFDYCFCABIAAoAiAiAjYCICACBEAgASACEBgiAjYCHCACRQRAIAFCADcCHA8LIAIgACgCHCAAKAIgEBYaDwsgAUEANgIcDwsgAUEANgIQIAFBADYCGAsEAEEBC8YBAQN/A0AgAEEEdCIBQeTNAWogAUHgzQFqIgI2AgAgAUHozQFqIAI2AgAgAEEBaiIAQcAARw0AC0EwEHoaIwBBEGsiACQAAkAgAEEMaiAAQQhqEBANAEHw1QFBCCAAKAIMQQJ0QQRqECkiATYCACABRQ0AQQggACgCCBApIgEEQEHw1QEoAgAiAiAAKAIMQQJ0akEANgIAIAIgARAPRQ0BC0Hw1QFBADYCAAsgAEEQaiQAQYzWAUEqNgIAQdTWAUGY1wE2AgALkgYCBH8DeyMAQRBrIgYkAAJ/IAAoAghBEEYEQCAAKAK0ASAAKALkAUGMLGxqDAELIAAoAgwLIQACQCADKAIAIgVFBEBBACECIARBAUGtFEEAEBMMAQsgACgC0CsgAyAFQQFrNgIAIAIgBkEMakEBEBUgAUG4CGxqIgcgBigCDCIAQQV2NgKkBiAHIABBH3EiATYCGCACQQFqIQAgAwJ/An8CQAJ/AkACQCABDgIAAwELIAMoAgAMAQsgAygCAEEBdgsiBUHiAE8EfyAGQuGAgICQDDcCBCAGIAU2AgAgBEECQZP9ACAGEBMgBygCGAUgAQsEQCAFIgENAUEADAILIAUEQCAHQRxqIQFBACECA0AgACAGQQxqQQEQFSACQeAATQRAIAYoAgwhBCABIAJBA3RqIghBADYCBCAIIARBA3Y2AgALIABBAWohACACQQFqIgIgBUcNAAsLIAUgAygCACIASwRAQQAhAgwECyAAIAVrDAILIAdBHGohBEEAIQIDQCAAIAZBDGpBAhAVIAJB4ABNBEAgBCACQQN0aiIFIAYoAgwiCEH/D3E2AgQgBSAIQQt2NgIACyAAQQJqIQAgAkEBaiICIAFHDQALIAFBAXQLIQAgACADKAIAIgFLBEBBACECDAILIAEgAGsLNgIAQQEhAiAHKAIYQQFHDQAgB0EcaiEEIAf9CQIcIQsgBygCICED/QwBAAAAAgAAAAMAAAAEAAAAIQpBACEBA0AgBCABQQN0aiIAQRhqIAsgCv0M//////////////////////2uASIJ/RsAQQNu/REgCf0bAUEDbv0cASAJ/RsCQQNu/RwCIAn9GwNBA279HAP9sQH9DAAAAAAAAAAAAAAAAAAAAAD9uAEiCf1aAgACIABBEGogCf1aAgABIABBCGogCf1aAgAAIAQgAUEEaiIBQQN0aiIFIAn9WgIAAyAAIAM2AhwgACADNgIUIAAgAzYCDCAFIAM2AgQgCv0MBAAAAAQAAAAEAAAABAAAAP2uASEKIAFB4ABHDQALCyAGQRBqJAAgAguEBwEGfyMAQSBrIgYkAAJ/IAAoAghBEEYEQCAAKAK0ASAAKALkAUGMLGxqDAELIAAoAgwLIQUCQCADKAIAQQRNBEBBACEAIARBAUGKFEEAEBMMAQsgAiAFKALQKyABQbgIbGoiBSIJQQRqQQEQFSAFIAUoAgRBAWoiBzYCBCAHQSJPBEAgBkEhNgIEIAYgBzYCACAEQQFBrjsgBhATQQAhAAwBCyAHIAAoArgBIghNBEAgBiAHNgIYIAYgCDYCFCAGIAE2AhAgBEEBQYKAASAGQRBqEBMgACAAKAIIQYCAAnI2AghBACEADAELIAJBAWogBUEIakEBEBUgBSAFKAIIQQJqNgIIIAJBAmogBUEMakEBEBUgBSAFKAIMQQJqIgA2AgwCQAJAIAUoAggiAUEKSw0AIABBCksNACAAIAFqQQ1JDQELQQAhACAEQQFBtypBABATDAELIAJBA2ogBUEQakEBEBUgBS0AEEGAAXEEQEEAIQAgBEEBQf8yQQAQEwwBCyACQQRqIAVBFGpBARAVIAUoAhRBAk8EQEEAIQAgBEEBQb4yQQAQEwwBCyADIAMoAgBBBWsiBzYCAEEBIQAgBSgCBCEBAkAgBS0AAEEBcUUEQCABRQ0CIAVBsAdqIQIgBUGsBmohBEEAIQUgAUEDTQ0BIAFBfHEhBUEAIQMDQCAEIANBAnQiB2r9DA8AAAAPAAAADwAAAA8AAAD9CwIAIAIgB2r9DA8AAAAPAAAADwAAAA8AAAD9CwIAIANBBGoiAyAFRw0ACyABIAVHDQEMAgsgASAHTQRAAkAgAUUEQEEAIQEMAQsgAkEFaiAGQRxqQQEQFSAFIAYoAhwiAEEEdjYCsAcgBSAAQQ9xNgKsBiAFKAIEIgFBAk8EQCAFQbAHaiEHIAVBrAZqIQggAkEGaiEAQQEhBQNAIAAgBkEcakEBEBUCQCAGKAIcIgFBEE8EQCABQQ9xIgINAQtBACEAIARBAUHkLkEAEBMMBgsgCCAFQQJ0IgpqIAI2AgAgByAKaiABQQR2NgIAIABBAWohACAFQQFqIgUgCSgCBCIBSQ0ACwsgAygCACEHCyADIAcgAWs2AgBBASEADAILQQAhACAEQQFBihRBABATDAELA0AgBCAFQQJ0IgBqQQ82AgAgACACakEPNgIAQQEhACAFQQFqIgUgAUkNAAsLIAZBIGokACAAC1IAIAEgAC0AADoAByABIAAtAAE6AAYgASAALQACOgAFIAEgAC0AAzoABCABIAAtAAQ6AAMgASAALQAFOgACIAEgAC0ABjoAASABIAAtAAc6AAALkgEBBH8gACABNgK4AQJAIAAoAmAiA0UNACADKAIYIgZFDQAgACgCDCIERQ0AIAQoAtArRQ0AIAMoAhAiBEUEQEEBDwtBACEDA0AgACgCDCgC0CsgA0G4CGxqKAIEIAFNBEAgAkEBQbTHAEEAEBNBAA8LIAYgA0E0bGogATYCKEEBIQUgA0EBaiIDIARHDQALCyAFC6UHAgl/CH4jAEEQayILJAACQCACRQRAIANBAUHI2gBBABATDAELIAIoAhAiCSAAKAJgIgcoAhBJBEAgA0EBQaXSAEEAEBMMAQsgACgCgAEiBSAAKAKEAWwiBiAETQRAIAsgBDYCACALIAZBAWs2AgQgA0EBQcX/ACALEBNBACEFDAELIAIgACgCbCAEIAUgBCAFbiIGbGsiCCAAKAJ0bGoiBTYCACACIAUgBygCACIHIAUgB0sbIgc2AgAgAiAAKAJsIAAoAnQgCEEBamxqIgU2AgggAiAFIAAoAmAoAggiCCAFIAhJGyIINgIIIAIgACgCcCAAKAJ4IAZsaiIFNgIEIAIgBSAAKAJgKAIEIgogBSAKSxsiCjYCBCACIAAoAnAgACgCeCAGQQFqbGoiBTYCDCACIAUgACgCYCgCDCIGIAUgBkkbIgU2AgwgACgCYCIMKAIQIgYEQCAFrEIBfSERIAisQgF9IRIgCq1CAX0hEyAHrUIBfSEUIAwoAhghCCACKAIYIQVBACEHA0AgBSAIIAdBNGxqKAIoIgo2AiggBSAUIAUoAgAiDK0iDnwgDoAiFT4CECAFIBMgBSgCBCINrSIOfCAOgCIQPgIUIAVCfyAKrSIOhiIPIBDEfSAOh6cgDyARIA2sIhB8IBB/xH0gDoenazYCDCAFIA8gFcR9IA6HpyAPIBIgDKwiD3wgD3/EfSAOh6drNgIIIAVBNGohBSAHQQFqIgcgBkcNAAsLIAYgCUkEQCACKAIYIQUDQCAFIAZBNGwiB2ooAiwQFCACKAIYIgUgB2pBADYCLCAGQQFqIgYgAigCEEkNAAsgAiAAKAJgKAIQNgIQCyAAKAJkIgUEQCAFECULIABBAUEkEBciBjYCZEEAIQUgBkUNACACIAYQSCAAIAQ2AiwgACgC2AFBGCADEChFDQAgACgC2AEiCSgCACEEIAkoAgghBgJAIAQEQEEBIQUgBEEBcSEIIARBAUYEf0EABSAEQX5xIQRBACEHA0ACf0EAIAVFDQAaQQAgACABIAMgBigCABEAAEUNABogACABIAMgBigCBBEAAEEARwshBSAGQQhqIQYgB0ECaiIHIARHDQALIAVFCyEEQQAgBSAIGyEFAkAgCEUNACAEDQAgACABIAMgBigCABEAAEEARyEFCyAJQQA2AgAgBQ0BIAAoAmAQJUEAIQUgAEEANgJgDAILIAlBADYCAAsgACACEFAhBQsgC0EQaiQAIAUL8gMBBX8CQAJAIAAoAjwiAkUEQCABKAIQDQFBAQ8LIAJBNGwQGCIFRQ0BIAEoAhAEQCABKAIYIQIDQCACIANBNGwiBGooAiwQFCABKAIYIgIgBGpBADYCLCADQQFqIgMgASgCECIESQ0ACwsgASAAKAI8BH8gACgCZCgCGCEDQQAhAgNAIAUgAkE0bGoiBCADIAAoAkAgAkECdGooAgBBNGwiBmoiA/0AAgD9CwIAIAQgAygCMDYCMCAEIAP9AAIg/QsCICAEIAP9AAIQ/QsCECAEIAAoAmQoAhgiAyAGaiIGKAIkNgIkIAQgBigCLDYCLCAGQQA2AiwgAkEBaiICIAAoAjwiBkkNAAsgASgCEAUgBAsEfyAAKAJkKAIYIQJBACEDA0AgAiADQTRsIgRqKAIsEBQgACgCZCgCGCICIARqQQA2AiwgA0EBaiIDIAEoAhBJDQALIAAoAjwFIAYLNgIQIAEoAhgQFCABIAU2AhhBAQ8LIAEoAhghBCAAKAJkKAIYIQNBACECA0AgBCACQTRsIgVqIgQgAyAFaigCJDYCJCAEKAIsEBQgASgCGCIEIAVqIAAoAmQoAhgiAyAFaiIFKAIsNgIsIAVBADYCLCACQQFqIgIgASgCEEkNAAtBAQ8LIAAoAmAQJSAAQQA2AmBBAAvFBAEIfwJAIAJFDQACQCAAKAK4ASIFRQ0AIAAoAmAiBEUNACAEKAIQRQ0AIAQoAhgoAiggBUcNACACKAIQIghFDQAgAigCGCIGKAIoDQAgBigCLA0AQQAhBCAIQQhPBEAgCEF4cSEJA0AgBiAEQTRsaiAFNgIoIAYgBEEBckE0bGogBTYCKCAGIARBAnJBNGxqIAU2AiggBiAEQQNyQTRsaiAFNgIoIAYgBEEEckE0bGogBTYCKCAGIARBBXJBNGxqIAU2AiggBiAEQQZyQTRsaiAFNgIoIAYgBEEHckE0bGogBTYCKCAEQQhqIQQgCkEIaiIKIAlHDQALCyAIQQdxIggEQANAIAYgBEE0bGogBTYCKCAEQQFqIQQgC0EBaiILIAhHDQALCyACIAMQPw0AQQAPCyAAKAJkIgVFBEAgAEEBQSQQFyIFNgJkIAVFDQELIAIgBRBIIAAoAtgBQRYgAxAoRQ0AIAAoAtgBIgYoAgAhBCAGKAIIIQUCQCAEBEBBASEHIARBAXEhCCAEQQFGBH9BAAUgBEF+cSEJQQAhBANAAn9BACAHRQ0AGkEAIAAgASADIAUoAgARAABFDQAaIAAgASADIAUoAgQRAABBAEcLIQcgBUEIaiEFIARBAmoiBCAJRw0ACyAHRQshBEEAIAcgCBshBwJAIAhFDQAgBA0AIAAgASADIAUoAgARAABBAEchBwsgBkEANgIAIAcNASAAKAJgECUgAEEANgJgQQAPCyAGQQA2AgALIAAgAhBQIQcLIAcL+AQBBn8CQEEBQTAQFyICBH8gAiAAKALgASIB/QADAP0LAwAgAiABKQMQNwMQIAIgASgCGCIBNgIYIAIgAUEYbBAYIgE2AhwgAUUEQCACEBRBAA8LAkAgACgC4AEoAhwiAwRAIAEgAyACKAIYQRhsEBYaDAELIAEQFCACQQA2AhwLIAIgACgC4AEoAiQiATYCJCACIAFBKBAXIgE2AiggAUUEQCACKAIcEBQgAhAUQQAPCwJAIAAoAuABKAIoBEAgAigCJEUNAQNAIAEgBUEobCIDaiAAKALgASgCKCADaigCFCIBNgIUIAFBGGwQGCEBIAIoAigiBCADaiIGIAE2AhggAUUEQCAFBH9BACEBA0AgAigCKCABQShsaigCGBAUIAFBAWoiASAFRw0ACyACKAIoBSAECxAUDAULAkAgACgC4AEoAiggA2ooAhgiBARAIAEgBCAGKAIUQRhsEBYaIAIoAighAQwBCyABEBQgAigCKCIBIANqQQA2AhgLIAEgA2ogACgC4AEoAiggA2ooAgQiATYCBCABQRhsEBghASACKAIoIgQgA2oiBiABNgIQIAFFBEAgBQR/QQAhAQNAIAFBKGwiACACKAIoaigCGBAUIAIoAiggAGooAhAQFCABQQFqIgEgBUcNAAsgAigCKAUgBAsQFAwFCwJAIAAoAuABKAIoIANqKAIQIgQEQCABIAQgBigCBEEYbBAWGiACKAIoIQEMAQsgARAUIAIoAigiASADakEANgIQCyABIANqQgA3AiAgBUEBaiIFIAIoAiRJDQALDAELIAEQFCACQQA2AigLIAIFQQALDwsgAigCHBAUIAIQFEEAC6AGAQ5/IwBBEGsiCCQAIAAoAmAoAhAhDSAIQQFBOBAXIgE2AgwCQCABRQ0AIAEgACgCYCgCECIJNgIYIAEgAP0AAmz9CwIAIAEgACgCgAE2AhAgACgChAEhAyABQQA2AjQgASADNgIUIAEgACgCDCIMKAIANgIgIAEgDCgCBDYCJCABIAwoAgg2AiggASAMKAIQNgIsIAEgCUG4CBAXIgA2AjAgAARAIA0EQANAIA5BuAhsIgAgDCgC0CtqIgQoAgQhAiABKAIwIABqIgUgBP0AAgD9CwIEIAUgBCgCEDYCFCAFIAQoAhQ2AhggAkEgTQRAIAVBtAdqIARBsAdqIAIQFhogBUGwBmogBEGsBmogBCgCBBAWGgsgBSAEKAIYIgA2AhwgBSAEKAKkBjYCqAZBASEGAkAgAEEBRwRAIAQoAgRBA2wiAEEDa0HfAEsNASAAQQJrIQYLIAVBpANqIQkgBUEgaiEKIARBHGohC0EAIQACQCAGQQhJDQAgBCAGQQN0akEcaiAKSwRAIAsgBSAGQQJ0akGkA2pJDQELIAZBfHEhAEEAIQMDQCAKIANBAnQiAmogCyADQQN0aiIHQRxqIAdBFGogB0EMaiAH/VwCBP1WAgAB/VYCAAL9VgIAA/0LAgAgAiAJaiAHQRhqIAdBEGogB0EIaiAH/VwCAP1WAgAB/VYCAAL9VgIAA/0LAgAgA0EEaiIDIABHDQALIAAgBkYNAQsgAEEBciECIAZBAXEEQCAKIABBAnQiA2ogCyAAQQN0aiIAKAIENgIAIAMgCWogACgCADYCACACIQALIAIgBkYNAANAIAogAEECdCIDaiALIABBA3RqIgIoAgQ2AgAgAyAJaiACKAIANgIAIAogAEEBaiICQQJ0IgNqIAsgAkEDdGoiAigCBDYCACADIAlqIAIoAgA2AgAgAEECaiIAIAZHDQALCyAFIAQoAqgGNgKsBiAOQQFqIg4gDUcNAAsLIAEhAgwBCyAIQQxqBEAgCCgCDCIBKAIwIgAEfyAAEBQgCCgCDAUgAQsQFCAIQQA2AgwLCyAIQRBqJAAgAgv5BAEIfyMAQYACayIDJAAgAARAQekNQREgAhAhIAMgACgCADYC8AEgAkGHEiADQfABahAaIAMgACgCBDYC4AEgAkGUEiADQeABahAaIAMgACgCCDYC0AEgAkG3OCADQdABahAaIAMgACgCEDYCwAEgAkHqESADQcABahAaIAFBAEoEQANAIAAoAtArIQQgAyAHNgKwASACQY8OIANBsAFqEBogAyAEIAdBuAhsaiIEKAIANgKgASACQYYSIANBoAFqEBogAyAEKAIENgKQASACQak5IANBkAFqEBogAyAEKAIINgKAASACQdU3IANBgAFqEBogAyAEKAIMNgJwIAJB5TcgA0HwAGoQGiADIAQoAhA2AmAgAkH1ESADQeAAahAaIAMgBCgCFDYCUCACQes5IANB0ABqEBpB+gtBFyACECEgBCgCBARAIARBsAdqIQYgBEGsBmohCEEAIQUDQCAIIAVBAnQiCWooAgAhCiADIAYgCWooAgA2AkQgAyAKNgJAIAJB+AwgA0FAaxAaIAVBAWoiBSAEKAIESQ0ACwsgAhB7IAMgBCgCGDYCMCACQfU3IANBMGoQGiADIAQoAqQGNgIgIAJBpjggA0EgahAaQQEhBkGSDEEUIAIQIQJAIAQoAhhBAUcEQCAEKAIEIgVBAEwNASAFQQNsQQJrIQYLIARBHGohCEEAIQUDQCADIAggBUEDdGopAgBCIIk3AxAgAkH4DCADQRBqEBogBUEBaiIFIAZHDQALCyACEHsgAyAEKAKoBjYCACACQZU4IAMQGkGGDUEFIAIQISAHQQFqIgcgAUcNAAsLQYcNQQQgAhAhCyADQYACaiQAC+sJAwl/AX4BeyMAQbABayIFJAACQCABQYADcQRAQZIuQQsgAhAhDAELAkAgAUEBcUUNACAAKAJgIgZFDQAjAEHQAGsiAyQAQdsNQQ0gAhAhIANBADoATyADQQk6AE4gAyAGKQIANwJEIAMgA0HOAGoiBDYCQCACQbs6IANBQGsQGiADIAYpAgg3AjQgAyAENgIwIAJBqjogA0EwahAaIAMgBigCEDYCJCADIAQ2AiAgAkHIOCADQSBqEBoCQCAGKAIYRQ0AIAYoAhBFDQADQCADIANBzgBqIgs2AhAgAyAINgIUIAJB+w0gA0EQahAaIAYoAhggCEE0bGohCSMAQTBrIgQkACAEQQk7AC4gBEEJOgAtIAQgCSkCADcCJCAEIARBLWoiCjYCICACQYQ4IARBIGoQGiAEIAkoAhg2AhQgBCAKNgIQIAJB+jkgBEEQahAaIAQgCSgCIDYCBCAEIAo2AgAgAkHfOSAEEBogBEEwaiQAIAMgCzYCACACQYENIAMQGiAIQQFqIgggBigCEEkNAAsLQYkNQQIgAhAhIANB0ABqJAALAkAgAUECcUUNACAAKAJgRQ0AQeYOQSQgAhAhIAUgACkCbDcDoAEgAkHUEiAFQaABahAaIAUgACkCdDcDkAEgAkGyEiAFQZABahAaIAUgACkDgAE3A4ABIAJBxBIgBUGAAWoQGiAAKAIMIAAoAmAoAhAgAhBUQYkNQQIgAhAhCwJAIAFBCHFFDQAgACgCYEUNACAAKAKAASAAKAKEAWwiBEUNACAAKAK0ASEDA0AgAyAAKAJgKAIQIAIQVCADQYwsaiEDIAdBAWoiByAERw0ACwsgAUEQcUUNACAAKALgASEAQcAOQSUgAhAhIAUgAP0AAwD9CwRwIAJBvSwgBUHwAGoQGkGuDkERIAIQIQJAIAAoAhxFDQAgACgCGEUNAEEAIQMDQCAAKAIcIANBGGxqIgEvAQAhBCABKQMIIQwgBSABKAIQNgJgIAUgDDcDWCAFIAQ2AlAgAkHAOSAFQdAAahAaIANBAWoiAyAAKAIYSQ0ACwtBhw1BBCACECECQCAAKAIoIgRFDQAgACgCJCIGRQ0AQQAhB0EAIQMDQAJAIAQgA0EobGoiASgCBCIIRQ0AIAEoAhAiAUUNACABKQMAQgBXDQAgASkDCEIAUg0AQfoKEHgNAgsgByAIaiEHIANBAWoiAyAGRw0ACyAHRQ0AQZ0OQRAgAhAhIAAoAiQEQCAAKAIoIQFBACEHA0AgBSABIAdBKGwiBGooAgQiBjYCRCAFIAc2AkAgAkGGOiAFQUBrEBogACgCKCEBAkAgBkUNAEEAIQMgASAEaigCEEUNAANAIAAoAiggBGooAhAgA0EYbGoiAf0AAwAhDSAFIAEpAxA3AzggBSAN/QsDKCAFIAM2AiAgAkGV1QAgBUEgahAaIANBAWoiAyAGRw0ACyAAKAIoIQELAkAgASAEaiIGKAIYRQ0AQQAhAyAGKAIURQ0AA0AgASAEaigCGCADQRhsaiIBLwEAIQYgASkDCCEMIAUgASgCEDYCECAFIAw3AwggBSAGNgIAIAJBwDkgBRAaIANBAWoiAyAAKAIoIgEgBGooAhRJDQALCyAHQQFqIgcgACgCJEkNAAsLQYcNQQQgAhAhC0GJDUECIAIQIQsgBUGwAWokAAuRAgEDfwJAQQFBgAIQFyIBBH8gAUEBNgIAIAFBATYC0AEgASABLQDUAUEGcjoA1AEgAUEBQYwsEBciADYCDCAARQ0BIAFBAUHoBxAXIgA2AhAgAEUNASABQgA3AzAgAUF/NgIsIAFB6Ac2AhQCQEEBQTAQFyIABEAgAEEANgIYIABB5AA2AiAgAEHkAEEYEBciAjYCHCACDQEgABAUCyABQQA2AuABDAILIABBADYCKCABIAA2AuABIAEQOSIANgLcASAARQ0BIAEQOSIANgLYASAARQ0BAkBB5goQeEUNAAsgAUEAEHMiADYC7AEgAEUEQCABQQAQcyIANgLsASAARQ0CCyABBUEACw8LIAEQQEEAC5AJAgl/AX4jAEHQAWsiByQAIAAoAmAhCQJAAkACQCAAKAKAAUEBRw0AIAAoAoQBQQFHDQAgACgCtAEoAtwrDQELIAAoAghBCEYNACAGQQFB0dIAQQAQEwwBCwJAIAEoAhAiDEUNACAAKAK4ASEKIAEoAhghCyAMQQhPBEAgDEF4cSEPA0AgCyAIQTRsaiAKNgIoIAsgCEEBckE0bGogCjYCKCALIAhBAnJBNGxqIAo2AiggCyAIQQNyQTRsaiAKNgIoIAsgCEEEckE0bGogCjYCKCALIAhBBXJBNGxqIAo2AiggCyAIQQZyQTRsaiAKNgIoIAsgCEEHckE0bGogCjYCKCAIQQhqIQggDkEIaiIOIA9HDQALCyAMQQdxIgxFDQADQCALIAhBNGxqIAo2AiggCEEBaiEIIA1BAWoiDSAMRw0ACwsgAiADciAEciAFckUEQCAGQQRBozFBABATIABCADcCHCAAIAApAoABNwIkIAEgCf0AAgD9CwIAIAEgBhA/IQgMAQsgAkEASARAIAcgAjYCACAGQQFBleIAIAcQE0EAIQgMAQsgCSgCCCIIIAJJBEAgByAINgIUIAcgAjYCECAGQQFB6eUAIAdBEGoQE0EAIQgMAQsCQCAJKAIAIgggAksEQCAHIAg2AsQBIAcgAjYCwAEgBkECQcnoACAHQcABahATIABBADYCHCAJKAIAIQIMAQsgACACIAAoAmxrIAAoAnRuNgIcCyABIAI2AgAgA0EASARAIAcgAzYCICAGQQFB1eEAIAdBIGoQE0EAIQgMAQsgCSgCDCICIANJBEAgByACNgI0IAcgAzYCMCAGQQFBvOQAIAdBMGoQE0EAIQgMAQsCQCAJKAIEIgIgA0sEQCAHIAI2ArQBIAcgAzYCsAEgBkECQZrnACAHQbABahATIABBADYCICAJKAIEIQMMAQsgACADIAAoAnBrIAAoAnhuNgIgCyABIAM2AgRBACEIIARBAEwEQCAHIAQ2AkAgBkEBQZPhACAHQUBrEBMMAQsgCSgCACICIARLBEAgByACNgJUIAcgBDYCUCAGQQFB8OcAIAdB0ABqEBMMAQsCQCAJKAIIIgIgBEkEQCAHIAI2AqQBIAcgBDYCoAEgBkECQZHlACAHQaABahATIAAgACgCgAE2AiQgCSgCCCEEDAELIAAgADUCdCIQIAQgACgCbGutfEIBfSAQgD4CJAsgASAENgIIIAVBAEwEQCAHIAU2AmAgBkEBQdDgACAHQeAAahATDAELIAkoAgQiAiAFSwRAIAcgAjYCdCAHIAU2AnAgBkEBQcDmACAHQfAAahATDAELAkAgCSgCDCICIAVJBEAgByACNgKUASAHIAU2ApABIAZBAkHj4wAgB0GQAWoQEyAAIAAoAoQBNgIoIAkoAgwhBQwBCyAAIAA1AngiECAFIAAoAnBrrXxCAX0gEIA+AigLIAEgBTYCDCAAIAAtAFxBAnI6AFwgASAGED9FBEAMAQsgByAB/QACAP0LBIABIAZBBEHpOiAHQYABahATQQEhCAsgB0HQAWokACAIC5ECAQZ/IwBBIGsiBSQAAn8gACgCYCIERQRAIANBAUGT6wBBABATQQAMAQtBAEEEIAQoAhAQFyIERQ0AGiABBEAgACgCYCEIA0ACQAJAIAIgBkECdGooAgAiByAIKAIQTwRAIAUgBzYCECADQQFB5hIgBUEQahATDAELIAQgB0ECdGoiCSgCAEUNASAFIAc2AgAgA0EBQfoaIAUQEwsgBBAUQQAMAwsgCUEBNgIAIAZBAWoiBiABRw0ACwsgBBAUIAAoAkAQFAJAIAEEQCAAIAFBAnQiBBAYIgM2AkAgA0UEQCAAQQA2AjxBAAwDCyADIAIgBBAWGgwBCyAAQQA2AkALIAAgATYCPEEBCyAFQSBqJAALmgQBB38gAUEBQSQQFyIENgJgAkACQCAERQ0AAkAgASgC3AFBEiADECgEQCABKALcAUETIAMQKA0BCwwCCyABKALcASIHKAIAIQUgBygCCCEGAkAgBQRAQQEhBCAFQQFxIQggBUEBRgR/QQAFIAVBfnEhBQNAAn9BACAERQ0AGkEAIAEgACADIAYoAgARAABFDQAaIAEgACADIAYoAgQRAABBAEcLIQQgBkEIaiEGIAlBAmoiCSAFRw0ACyAERQshBUEAIAQgCBshBAJAIAhFDQAgBQ0AIAEgACADIAYoAgARAABBAEchBAsgB0EANgIAIAQNAQwDCyAHQQA2AgALAkAgASgC2AFBFCADECgEQCABKALYAUEVIAMQKA0BCwwCCyABKALYASIHKAIAIQUgBygCCCEGAkAgBQRAQQEhBCAFQQFxIQggBUEBRgR/QQAFIAVBfnEhBUEAIQkDQAJ/QQAgBEUNABpBACABIAAgAyAGKAIAEQAARQ0AGiABIAAgAyAGKAIEEQAAQQBHCyEEIAZBCGohBiAJQQJqIgkgBUcNAAsgBEULIQVBACAEIAgbIQQCQCAIRQ0AIAUNACABIAAgAyAGKAIAEQAAQQBHIQQLIAdBADYCACAEDQEMAwsgB0EANgIACyACQQFBJBAXIgA2AgAgAEUNACABKAJgIAAQSEEBIQoLIAoPCyABKAJgECUgAUEANgJgQQALAgALBABBAQs0AAJAIABFDQAgAUUNACAAIAEoAgQ2ArwBIAAgASgCADYCuAEgACABKAK4QEECcTYC+AELC7QFAQh/IAAoAhgiBCgCECIJRQRAQQAPCyAEKAIYIQUgACgCFCgCACgCFCEEAkACQCABRQRAQQAhAQNAIAUoAhghAiAEKAIcIAQoAhhBmAFsaiIAQYwBaygCACIHIABBlAFrKAIAIghrIQMgAEGQAWsoAgAgAEGYAWsoAgBrIQACQCAHIAhGDQAgAK0gA61+QiCIUA0ADAQLIAAgA2whAwJAQQQgAkEDdiACQQdxQQBHaiIAIABBA0YbIgJFDQAgAq0gA61+QiCIUA0ADAQLQX8hACACIANsIgIgAUF/c0sNAiAEQcwAaiEEIAVBNGohBSABIAJqIgEhACAGQQFqIgYgCUcNAAsMAQtBACEBIAAoAkBFBEADQCAFKAIYIQIgBCgCHCAEKAIYQZgBbGoiAEEEaygCACIHIABBDGsoAgAiCGshAyAAQQhrKAIAIABBEGsoAgBrIQACQCAHIAhGDQAgAK0gA61+QiCIUA0ADAQLIAAgA2whAwJAQQQgAkEDdiACQQdxQQBHaiIAIABBA0YbIgJFDQAgAq0gA61+QiCIUA0ADAQLQX8hACACIANsIgIgAUF/c0sNAiAEQcwAaiEEIAVBNGohBSABIAJqIgEhACAGQQFqIgYgCUcNAAsMAQsDQCAFKAIYIQIgBCgCHCAEKAIYQZgBbGoiAEGMAWsoAgAiByAAQZQBaygCACIIayEDIABBkAFrKAIAIABBmAFrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwDCyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwDC0F/IQAgAiADbCICIAFBf3NLDQEgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALCyAADwtBfwvaBAELfyAABEAgACgCFCIBBEAgASgCACIFBEAgBSgCFCEDIAUoAhAEf0EQQREgAC0AKEEBcRshCANAIAMoAhwiAgRAIAMoAiAiAUGYAW4hCkEAIQkgAUGYAU8EfwNAIAIoAjAiAQRAIAIoAjQiBkEobiEHQQAhBCAGQShPBH8DQCABKAIgEC4gAUEANgIgIAEoAiQQLiABQQA2AiQgASAIEQIAIAFBKGohASAEQQFqIgQgB0cNAAsgAigCMAUgAQsQFCACQQA2AjALIAIoAlQiAQRAIAIoAlgiBkEobiEHQQAhBCAGQShPBH8DQCABKAIgEC4gAUEANgIgIAEoAiQQLiABQQA2AiQgASAIEQIAIAFBKGohASAEQQFqIgQgB0cNAAsgAigCVAUgAQsQFCACQQA2AlQLIAIoAngiAQRAIAIoAnwiBkEobiEHQQAhBCAGQShPBH8DQCABKAIgEC4gAUEANgIgIAEoAiQQLiABQQA2AiQgASAIEQIAIAFBKGohASAEQQFqIgQgB0cNAAsgAigCeAUgAQsQFCACQQA2AngLIAJBmAFqIQIgCUEBaiIJIApHDQALIAMoAhwFIAILEBQgA0EANgIcCwJAIAMoAihFDQAgAygCJCIBRQ0AIAEQFCAD/QwAAAAAAAAAAAAAAAAAAAAA/QsCJAsgAygCNBAUIANBzABqIQMgC0EBaiILIAUoAhBJDQALIAUoAhQFIAMLEBQgBUEANgIUIAAoAhQoAgAQFCAAKAIUIgFBADYCAAsgARAUIABBADYCFAsgACgCRBAUIAAQFAsL2RMBEX8jAEEgayIPJAAgDyAFNgIYIAEgAygCHEHMAGxqKAIcIAMoAiBBmAFsaiEQAkACQCADKAIoDQAgECgCGEUNACAQQRxqIQkDQAJAIAkoAgggCSgCAEcEfyAJKAIMIAkoAgRGBUEBCw0AIAMoAiQiASAJKAIYQShuTwRAIAhBAUHvFUEAEBMMBAsgCSgCFCABQShsaiIBKAIgEGsgASgCJBBrIAEoAhQgASgCEGwiDEUNACABKAIYIQEgDEEITwRAIAxBeHEhC0EAIQoDQCABQgA3AoQEIAFCADcCwAMgAUIANwL8AiABQgA3ArgCIAFCADcC9AEgAUIANwKwASABQgA3AmwgAUIANwIoIAFBoARqIQEgCkEIaiIKIAtHDQALC0EAIQogDEEHcSIMRQ0AA0AgAUIANwIoIAFBxABqIQEgCkEBaiIKIAxHDQALCyAJQSRqIQkgDUEBaiINIBAoAhhJDQALCyAFIQwCQCACLQAAQQJxRQ0AIAdBBU0EQCAIQQJBvyBBABATDAELAkAgBS0AAEH/AUYEQCAFLQABQZEBRg0BCyAIQQJB6SBBABATDAELIA8gBUEGaiIMNgIYC0EUEBgiC0UNAAJ/IAAtAGxBAXEEQCAAQShqIREgACgCKCEMIABBLGoMAQsgAi0AiCxBAnEEQCACQbAoaiERIAIoArAoIQwgAkG8KGoMAQsgDyAFIAdqIAxrNgIcIA9BGGohESAPQRxqCyISKAIAIQAgC0IANwIMIAsgDDYCCCALIAw2AgAgCyAAIAxqNgIEIAtBARAjRQRAIAsQbRogCygCCCALKAIAayALEDIgDGohACARKAIAIQEgEiASKAIAIgMgAi0AAEEEcQR/IAMgAGsgAWpBAU0EQCAIQQFBoSJBABATDAMLAkAgAC0AAEH/AUYEQCAALQABQZIBRg0BCyAIQQFBjCJBABATDAMLIABBAmoFIAALIAFrIgBrNgIAIBEgACABajYCACAEQQA2AgAgBiAPKAIYIAVrNgIAQQEhFwwBCyAQKAIYBEAgEEEcaiEHA0AgAygCJCEAIAcoAhQhAQJAIAcoAgggBygCAEcEfyAHKAIMIAcoAgRGBUEBCw0AIAEgAEEobGoiFCgCFCAUKAIQbCIYRQ0AIBQoAhghCUEAIRUDQAJAAn8gCSgCKEUEQCALIBQoAiAgFSADKAIoQQFqEGkMAQsgC0EBECMLRQRAIAlBADYCJAwBCyAJKAIoRQRAQQAhAQNAIAEiAEEBaiEBIAsgFCgCJCAVIAAQaUUNAAsgBygCHCEBIAlBAzYCICAJIAE2AhggCSABIABrQQFqNgIcCyAJAn9BASALQQEQI0UNABpBAiALQQEQI0UNABogC0ECECMiAEEDRwRAIABBA2oMAQsgC0EFECMiAEEfRwRAIABBBmoMAQsgC0EHECNBJWoLNgIkQQAhAQNAIAEiAEEBaiEBIAtBARAjDQALIAkgCSgCICAAajYCIAJAAkACfyAJKAIoIgBFBEAgAigC0CsgAygCHEG4CGxqKAIQIQAgCSgCMEUEQCAJKAIAQfABEBsiAUUNBCAJIAE2AgAgASAJKAIwQRhsakEAQfABEBkaIAlBCjYCMAsgCSgCACIKIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCEEEBQQpB7QAgAEEBcRsgAEEEcRshAUEADAELIAkoAgAiASAAQQFrIg1BGGxqIgooAgQgCigCDEcNASACKALQKyADKAIcQbgIbGooAhAhDSAJKAIwIgogAEEBakkEfyABIApBCmoiCkEYbBAbIgFFDQMgCSABNgIAIAEgCSgCMEEYbGpBAEHwARAZGiAJIAo2AjAgCSgCAAUgAQsgAEEYbGoiCiIB/QwAAAAAAAAAAAAAAAAAAAAA/QsCACABQgA3AhACf0EBIA1BBHENABpB7QAgDUEBcUUNABpBAkECQQEgCkEMaygCACIBQQpGGyABQQFGGwshASAACyENIAogATYCDAsgCSgCJCEAIAIoAtArIAMoAhxBuAhsai0AEEHAAHEEQANAIA1BGGwiDiAJKAIAaiAAQQEgDRsiEzYCECAJKAIgIRZBACEKIAAhASATQQJPBEADQCAKQQFqIQogAUEDSyABQQF2IQENAAsLIAogFmoiAUEhTwRAIA8gATYCECAIQQFBivkAIA9BEGoQEwwDCyALIAEQIyEKIAkoAgAiASAOaiIOIAo2AhQgACAOKAIQayIAQQBMDQMgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIOIA1BAmpJBEAgASAOQQpqIg5BGGwQGyIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQGRogCSAONgIwIAkoAgAhAQsgASANQQFqIg1BGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCECAKQQRxBEAgAUEBNgIMDAELIApBAXEEQCABQQJBAkEBIAFBDGsoAgAiAUEKRhsgAUEBRhs2AgwFIAFB7QA2AgwLDAALAAsDQCANQRhsIg4gCSgCAGoiASABKAIMIAEoAgRrIgEgACAAIAFKGyIBNgIQIAkoAiAhE0EAIQogAUECTwRAA0AgCkEBaiEKIAFBA0sgAUEBdiEBDQALCyAKIBNqIgFBIU8EQCAPIAE2AgAgCEEBQYr5ACAPEBMMAgsgCyABECMhCiAJKAIAIgEgDmoiDiAKNgIUIAAgDigCEGsiAEEATA0CIAIoAtArIAMoAhxBuAhsaigCECEKIAkoAjAiDiANQQJqSQRAIAEgDkEKaiIOQRhsEBsiAUUNAiAJIAE2AgAgASAJKAIwQRhsakEAQfABEBkaIAkgDjYCMCAJKAIAIQELIAEgDUEBaiINQRhsaiIB/QwAAAAAAAAAAAAAAAAAAAAA/QsCACABQgA3AhAgCkEEcQRAIAFBATYCDAwBCyAKQQFxBEAgAUECQQJBASABQQxrKAIAIgFBCkYbIAFBAUYbNgIMBSABQe0ANgIMCwwACwALIAsQMgwFCyAJQcQAaiEJIBVBAWoiFSAYRw0ACwsgB0EkaiEHIBlBAWoiGSAQKAIYSQ0ACwsgCxBtRQRAIAsQMgwBCyALKAIIIAsoAgBrIAsQMiAMaiEBIBEoAgAhACACLQAAQQRxBEAgEigCACABayAAakEBTQRAIAhBAUGhIkEAEBMMAgsCQCABLQAAQf8BRgRAIAEtAAFBkgFGDQELIAhBAUGMIkEAEBMMAgsgAUECaiEBCyAAIAFGDQAgEiASKAIAIAAgAWtqNgIAIBEgATYCAEEBIRcgBEEBNgIAIAYgDygCGCAFazYCAAsgD0EgaiQAIBcLlyQCFH8OfgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCVA4FAAECAwQKCwJAIAAoAjQiBiAAKALEASIBSQRAIAAoAkAiByABQQFqSQ0BCyAAKALsAUEBQYbCAEEAEBMMDAsgACgCLEUEQCAAKAIkIQJBACEBDAULIABBADYCLCAAKAJEIQNBASEBDAQLAkAgACgCNCIGIAAoAsQBIgFJBEAgACgCQCIHIAFBAWpJDQELIAAoAuwBQQFBs8IAQQAQEwwLCyAAKAIsRQRAIAAoAiQhBEEAIQEMCAsgAEEANgIsIAAoAjAhA0EBIQEMBwsCQCAAKAI0IgQgACgCxAEiCkkEQCAAKAJAIg4gCkEBakkNAQsgACgC7AFBAUG6wwBBABATDAoLIAAoAixFBEAgACgCKCELDAYLIABCADcC5AEgAEEANgIsIAAoAsgBIQwDQCAMIAdBBHRqIgUoAggiDwRAIAUoAgwhEkEAIQEDQAJAIA8gAUF/c2oiECASIAFBBHRqIhEoAgBqIglBH0sNACAFKAIAIhNBfyAJdksNACAAIAIgEyAJdCIJIAIgCUkbIAkgAhsiAjYC5AELAkAgESgCBCAQaiIJQR9LDQAgBSgCBCIQQX8gCXZLDQAgACADIBAgCXQiCSADIAlJGyAJIAMbIgM2AugBCyABQQFqIgEgD0cNAAsLIAdBAWoiByAKRw0ACyACRQ0HIANFDQcgAC0AAEUEQCAAIAAoAtABNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoCyAAKAIwIQVBASEBDAULAkAgACgCNCIFIAAoAsQBIglJBEAgACgCQCISIAlBAWpJDQELIAAoAuwBQQFBjcMAQQAQEwwJCyAAKAIsRQRAIAAoAsgBIg0gACgCHCIEQQR0aiELIAAoAighCAwECyAAQgA3AuQBIABBADYCLCAAKALIASENA0AgDSAGQQR0aiIKKAIIIg4EQCAKKAIMIRBBACEBA0ACQCAOIAFBf3NqIhEgECABQQR0aiITKAIAaiIMQR9LDQAgCigCACIUQX8gDHZLDQAgACACIBQgDHQiDCACIAxJGyAMIAIbIgI2AuQBCwJAIBMoAgQgEWoiDEEfSw0AIAooAgQiEUF/IAx2Sw0AIAAgAyARIAx0IgwgAyAMSRsgDCADGyIDNgLoAQsgAUEBaiIBIA5HDQALCyAGQQFqIgYgCUcNAAsgAkUNBiADRQ0GAkAgAC0AAARAIAAoAmwhBgwBCyAAIAAoAtABIgY2AmwgACAAKALMATYCZCAAIAAoAtgBNgJwIAAgACgC1AE2AmgLQQEhAQwDCwJAIAAoAjQiBiAAKALEASIBSQRAIAAoAkAiDyABQQFqSQ0BCyAAKALsAUEBQeDCAEEAEBMMBgsgACgCLEUEQCAAKALIASAAKAIcIgZBBHRqIQUgACgCKCEHQQAhAQwCCyAAIAY2AhwgAEEANgIsQQEhAQwBCwNAAn8CQCABRQRAIAJBAWohAgwBCyAAIAM2AiggACgCOCADTQ0JIAAoAjAhBEEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAENgIgIAQgACgCPE8NASAAIAY2AhwgBiEBQQAhBQwECyAAIAI2AiQgACgCTCACTQRAIAAoAhwhAUEBIQUMBAsgACgCECAAKAIgbCAAKAIMIAAoAihsaiAAKAIUIAAoAhxsaiAAKAIYIAJsaiIBIAAoAghPBEAMDAsgACgCBCABQQF0aiIBLwEADQEMDQsgACgCKEEBaiEDDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQCAFRQRAIAEgB08NASAAKAIgIgUgACgCyAEgAUEEdGoiDSgCCE8NAyAALQAARQRAIAAgDSgCDCAFQQR0aiIBKAIMIAEoAghsNgJMCyAAKAJIIQJBASEBDAULIAAgAUEBaiIBNgIcDAELIAAoAiBBAWohBEEAIQEMAwtBACEFDAELQQEhBQwACwALAAsACwNAAn8CQCABRQRAIAAgB0EBaiIHNgIoDAELIAYgD08NCCAAQgA3AuQBIAAoAsgBIAZBBHRqIgUoAggiC0UNCCAFKAIMIQpBACECQQAhBEEAIQEDQAJAIAsgAUF/c2oiCSAKIAFBBHRqIg4oAgBqIghBH0sNACAFKAIAIgxBfyAIdksNACAAIAQgDCAIdCIIIAQgCEkbIAggBBsiBDYC5AELAkAgDigCBCAJaiIIQR9LDQAgBSgCBCIJQX8gCHZLDQAgACACIAkgCHQiCCACIAhJGyAIIAIbIgI2AugBCyABQQFqIgEgC0cNAAsgBEUNBiACRQ0GAkAgAC0AAARAIAAoAmwhAgwBCyAAIAAoAtABIgI2AmwgACAAKALMATYCZCAAIAAoAtgBNgJwIAAgACgC1AE2AmgLQQAMAQtBAQshAQNAAkACQAJAAkAgAUUEQCAAIAI2AuABIAIgACgCcE8NASAAKAJkIQ1BACEBDAQLIAAoAjggB00EQCAAKAIgIQNBASEBDAQLIAAoAhAgACgCIGwgACgCDCAHbGogACgCFCAGbGogACgCGCAAKAIkbGoiASAAKAIITwRADAsLIAAoAgQgAUEBdGoiAS8BAA0BDAwLIAAgBkEBaiIGNgIcDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQCAAAn8gAUUEQCAAIA02AtwBIA0gACgCaE8NAiAAKAIwDAELIANBAWoLIgM2AiAgACgCPCIBIAUoAggiBCABIARJGyADSwRAIAUoAgAiASABrSIeIAQgA0F/c2oiCK0iFoYiFyAWiKdHDQMgBSgCBCIEQn8gFoincSAERw0DIAStIhUgFoYiGEIBfSIZIAA1AtgBfCAYgCEfIBkgACgC0AEiCa18IBiAIRogF0IBfSIbIAA1AtQBfCAXgCEgIBsgACgCzAEiDq18IBeAIRwgAUJ/IAUoAgwgA0EEdGoiCygCACIKIAhqrSIdiKdxIAFHDQMgBCAVIAsoAgQiASAIaq0iFYYiISAViKdHDQMgACgC4AEiBK0iIiAhgkIAUgRAIAQgCUcNBEJ/IBWGQn+FIBpC/////w+DIBaGg1ANBAsgACgC3AEiBK0iFSAeIB2GgkIAUgRAIAQgDkcNBEJ/IB2GQn+FIBxC/////w+DIBaGg1ANBAsgCygCCCIERQ0DIAsoAgxFDQMgHKciCyAgp0YNAyAapyIIIB+nRg0DIAAgACgCRCIHNgIoIAAgFSAbfCAXgKcgCnYgCyAKdmsgGSAifCAYgKcgAXYgCCABdmsgBGxqNgIkQQEhAQwFCyAAKALcASIBIAAoAuQBIgRqIAEgBHBrIQ0MAQsgACgC4AEiASAAKALoASIEaiABIARwayECQQAhAQwDC0EAIQEMAQtBASEBDAALAAsACwALA0ACfwJAIAFFBEAgACAIQQFqIgg2AigMAQsgACAGNgLgASAAKAJwIAZNDQcgACgCZCEPQQAMAQtBAQshAQNAAkACQAJAAkAgAUUEQCAAIA82AtwBIA8gACgCaE8NASAAIAU2AhwgBSEEQQAhAQwECyAAKAI4IAhNBEAgACgCICEHQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgCGxqIAAoAhQgBGxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwKCyAAKAIEIAFBAXRqIgEvAQANAQwLCyAAKALgASIBIAAoAugBIgZqIAEgBnBrIQYMAQtBACEBDAMLQQEhAQwCCwNAAkACQAJAAkAgAUUEQCAEIBJPDQIgACAAKAIwIgc2AiAgDSAEQQR0aiELDAELIAAgB0EBaiIHNgIgCyAAKAI8IgEgCygCCCICIAEgAkkbIAdLBEAgCygCACIBIAGtIh4gAiAHQX9zaiIKrSIWhiIXIBaIp0cNAyALKAIEIgJCfyAWiKdxIAJHDQMgAq0iFSAWhiIYQgF9IhkgADUC2AF8IBiAIR8gGSAAKALQASIOrXwgGIAhGiAXQgF9IhsgADUC1AF8IBeAISAgGyAAKALMASIMrXwgF4AhHCABQn8gCygCDCAHQQR0aiIDKAIAIgkgCmqtIh2Ip3EgAUcNAyACIBUgAygCBCIBIApqrSIVhiIhIBWIp0cNAyAAKALgASICrSIiICGCQgBSBEAgAiAORw0EQn8gFYZCf4UgGkL/////D4MgFoaDUA0ECyAAKALcASICrSIVIB4gHYaCQgBSBEAgAiAMRw0EQn8gHYZCf4UgHEL/////D4MgFoaDUA0ECyADKAIIIgJFDQMgAygCDEUNAyAcpyIDICCnRg0DIBqnIgogH6dGDQMgACAAKAJEIgg2AiggACAVIBt8IBeApyAJdiADIAl2ayAZICJ8IBiApyABdiAKIAF2ayACbGo2AiRBASEBDAULIAAgBEEBaiIENgIcDAELIAAoAtwBIgEgACgC5AEiAmogASACcGshD0EAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIAAgC0EBaiILNgIoDAELIAAgBTYCICAAKAI8IAVNDQYgACgCbCEIQQAMAQtBAQshAQNAAkACQAJAAkAgAUUEQCAAIAg2AuABIAggACgCcE8NASAAKAJkIQ1BACEBDAQLIAAoAjggC00EQCAAKAIcIQZBASEBDAQLIAAoAhAgACgCIGwgACgCDCALbGogACgCFCAAKAIcbGogACgCGCAAKAIkbGoiASAAKAIITwRADAkLIAAoAgQgAUEBdGoiAS8BAA0BDAoLIAAoAiBBAWohBQwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkACQCABRQRAIAAgDTYC3AEgDSAAKAJoTw0CIAAgBDYCHCAEIQYMAQsgACAGQQFqIgY2AhwLIAYgDkkEQCAAKAIgIgcgACgCyAEgBkEEdGoiASgCCCIDTw0DIAEoAgAiAiACrSIeIAMgB0F/c2oiCq0iFoYiFyAWiKdHDQMgASgCBCIDQn8gFoincSADRw0DIAOtIhUgFoYiGEIBfSIZIAA1AtgBfCAYgCEfIBkgACgC0AEiD618IBiAIRogF0IBfSIbIAA1AtQBfCAXgCEgIBsgACgCzAEiCa18IBeAIRwgAkJ/IAEoAgwgB0EEdGoiASgCACIHIApqrSIdiKdxIAJHDQMgAyAVIAEoAgQiAiAKaq0iFYYiISAViKdHDQMgACgC4AEiA60iIiAhgkIAUgRAIAMgD0cNBEJ/IBWGQn+FIBpC/////w+DIBaGg1ANBAsgACgC3AEiA60iFSAeIB2GgkIAUgRAIAMgCUcNBEJ/IB2GQn+FIBxC/////w+DIBaGg1ANBAsgASgCCCIDRQ0DIAEoAgxFDQMgHKciASAgp0YNAyAapyIKIB+nRg0DIAAgACgCRCILNgIoIAAgFSAbfCAXgKcgB3YgASAHdmsgGSAifCAYgKcgAnYgCiACdmsgA2xqNgIkQQEhAQwFCyAAKALcASIBIAAoAuQBIgJqIAEgAnBrIQ0MAQsgACgC4AEiASAAKALoASICaiABIAJwayEIQQAhAQwDC0EAIQEMAQtBASEBDAALAAsACwALA0ACfwJAIAFFBEAgBEEBaiEEDAELIAAgAzYCICAAKAI8IANNDQUgACgCRCECQQAMAQtBAQshAQNAAkACQAJAAkAgAUUEQCAAIAI2AiggAiAAKAI4Tw0BIAAgBjYCHCAGIQFBACEFDAQLIAAgBDYCJCAAKAJMIARNBEAgACgCHCEBQQEhBQwECyAAKAIQIAAoAiBsIAAoAgwgACgCKGxqIAAoAhQgACgCHGxqIAAoAhggBGxqIgEgACgCCE8EQAwICyAAKAIEIAFBAXRqIgEvAQANAQwJCyAAKAIgQQFqIQMMAQtBACEBDAMLQQEhAQwCCwNAAkACQAJAIAVFBEAgASAHTw0BIAAoAiAiBSAAKALIASABQQR0aiINKAIITw0DIAAtAABFBEAgACANKAIMIAVBBHRqIgEoAgwgASgCCGw2AkwLIAAoAkghBEEBIQEMBQsgACABQQFqIgE2AhwMAQsgACgCKEEBaiECQQAhAQwDC0EAIQUMAQtBASEFDAALAAsACwALQQAPCyAAKALsAUEBQZoKQQAQEwtBAA8LIAFBATsBAEEBC5YLAQp/AkAgASgCACAEQQNsIgx2IgZBkICAAXENACAAIABBHGoiDiAAKAJsIAZB7wNxai0AAEECdGoiCjYCaCAAIAAoAgQgCigCACIJKAIAIghrIgY2AgQCQCAIIAAoAgAiB0EQdksEQCAJKAIEIQsgACAINgIEIAogCUEIQQwgBiAISSIGG2ooAgA2AgAgCyALRSAGGyEJIAAoAgghBgNAAkAgBg0AIAAoAhAiBkEBaiELIAYtAAEhCiAGLQAAQf8BRgRAIApBkAFPBEAgACAAKAIMQQFqNgIMIAdBgP4DaiEHQQghBgwCCyAAIAs2AhAgByAKQQl0aiEHQQchBgwBCyAAIAs2AhBBCCEGIAcgCkEIdGohBwsgACAGQQFrIgY2AgggACAHQQF0Igc2AgAgACAIQQF0Igg2AgQgCEGAgAJJDQALIAghBgwBCyAAIAcgCEEQdGsiBzYCACAGQYCAAnFFBEAgCSgCBCELIAogCUEMQQggBiAISSIIG2ooAgA2AgAgC0UgCyAIGyEJIAAoAgghCANAAkAgCA0AIAAoAhAiCEEBaiELIAgtAAEhCiAILQAAQf8BRgRAIApBkAFPBEAgACAAKAIMQQFqNgIMIAdBgP4DaiEHQQghCAwCCyAAIAs2AhAgByAKQQl0aiEHQQchCAwBCyAAIAs2AhBBCCEIIAcgCkEIdGohBwsgACAIQQFrIgg2AgggACAHQQF0Igc2AgAgACAGQQF0IgY2AgQgBkGAgAJJDQALDAELIAkoAgQhCQsgCUUNACAAIA4gASgCBCAMQRFqdkEEcSABQQRrIg0oAgAgDEETanZBAXEgASgCACIIIAxBEGp2QcAAcSAIIAx2QaoBcXIgCCAMQQxqQQ4gBBt2QRBxcnJyIg9BkL4Bai0AAEECdGoiCzYCaCAAIAYgCygCACIKKAIAIghrIgY2AgQCQCAIIAdBEHZLBEAgCigCBCEJIAAgCDYCBCALIApBCEEMIAYgCEkiBhtqKAIANgIAIAkgCUUgBhshCiAAKAIIIQYDQAJAIAYNACAAKAIQIgZBAWohCyAGLQABIQkgBi0AAEH/AUYEQCAJQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQYMAgsgACALNgIQIAcgCUEJdGohB0EHIQYMAQsgACALNgIQQQghBiAHIAlBCHRqIQcLIAAgBkEBayIGNgIIIAAgB0EBdCIHNgIAIAAgCEEBdCIINgIEIAhBgIACSQ0ACwwBCyAAIAcgCEEQdGsiCTYCACAGQYCAAnFFBEAgCigCBCEHIAsgCkEMQQggBiAISSIIG2ooAgA2AgAgB0UgByAIGyEKIAAoAgghBwNAAkAgBw0AIAAoAhAiB0EBaiELIActAAEhCCAHLQAAQf8BRgRAIAhBkAFPBEAgACAAKAIMQQFqNgIMIAlBgP4DaiEJQQghBwwCCyAAIAs2AhAgCSAIQQl0aiEJQQchBwwBCyAAIAs2AhBBCCEHIAkgCEEIdGohCQsgACAHQQFrIgc2AgggACAJQQF0Igk2AgAgACAGQQF0IgY2AgQgBkGAgAJJDQALDAELIAooAgQhCgsgAiADQQAgA2sgCiAPQZDAAWotAAAiAkYbNgIAIA0gDSgCAEEgIAx0cjYCACABIAEoAgAgAiAKcyIDQRN0QRByIAx0cjYCACABIAEoAgRBCCAMdHI2AgQgBCAFckUEQCABQX4gACgCfGtBAnRqIgIgAigCBEGAgAJyNgIEIAIgAigCACADQR90ckGAgARyNgIAIAJBBGsiAiACKAIAQYCACHI2AgALIARBA0cNACABIAAoAnxBAnRqIgBBBGogACgCBEEEcjYCACAAIAAoAgxBAXI2AgwgACAAKAIIIANBEnRyQQJyNgIICwuuCwEJfwJAIAEoAgAgBEEDbCINdiIHQZCAgAFxDQAgB0HvA3EiB0UNACAAIABBHGoiDiAAKAJsIAdqLQAAQQJ0aiILNgJoIAAgACgCBCALKAIAIgooAgAiCWsiBzYCBAJAIAkgACgCACIIQRB2SwRAIAooAgQhDCAAIAk2AgQgCyAKQQhBDCAHIAlJIgcbaigCADYCACAMIAxFIAcbIQogACgCCCEHA0ACQCAHDQAgACgCECIHQQFqIQwgBy0AASELIActAABB/wFGBEAgC0GQAU8EQCAAIAAoAgxBAWo2AgwgCEGA/gNqIQhBCCEHDAILIAAgDDYCECAIIAtBCXRqIQhBByEHDAELIAAgDDYCEEEIIQcgCCALQQh0aiEICyAAIAdBAWsiBzYCCCAAIAhBAXQiCDYCACAAIAlBAXQiCTYCBCAJQYCAAkkNAAsgCSEHDAELIAAgCCAJQRB0ayIINgIAIAdBgIACcUUEQCAKKAIEIQwgCyAKQQxBCCAHIAlJIgkbaigCADYCACAMRSAMIAkbIQogACgCCCEJA0ACQCAJDQAgACgCECIJQQFqIQwgCS0AASELIAktAABB/wFGBEAgC0GQAU8EQCAAIAAoAgxBAWo2AgwgCEGA/gNqIQhBCCEJDAILIAAgDDYCECAIIAtBCXRqIQhBByEJDAELIAAgDDYCEEEIIQkgCCALQQh0aiEICyAAIAlBAWsiCTYCCCAAIAhBAXQiCDYCACAAIAdBAXQiBzYCBCAHQYCAAkkNAAsMAQsgCigCBCEKCwJAIApFDQAgACAOIAEoAgQgDUERanZBBHEgAUEEayIPKAIAIA1BE2p2QQFxIAEoAgAiCSANQRBqdkHAAHEgCSANdkGqAXFyIAkgDUEMakEOIAQbdkEQcXJyciIKQZC+AWotAABBAnRqIgw2AmggACAHIAwoAgAiCygCACIJayIHNgIEIApBkMABai0AACEOAkAgCSAIQRB2SwRAIAsoAgQhCiAAIAk2AgQgDCALQQhBDCAHIAlJIgcbaigCADYCACAKIApFIAcbIQsgACgCCCEHA0ACQCAHDQAgACgCECIHQQFqIQwgBy0AASEKIActAABB/wFGBEAgCkGQAU8EQCAAIAAoAgxBAWo2AgwgCEGA/gNqIQhBCCEHDAILIAAgDDYCECAIIApBCXRqIQhBByEHDAELIAAgDDYCEEEIIQcgCCAKQQh0aiEICyAAIAdBAWsiBzYCCCAAIAhBAXQiCDYCACAAIAlBAXQiCTYCBCAJQYCAAkkNAAsMAQsgACAIIAlBEHRrIgo2AgAgB0GAgAJxRQRAIAsoAgQhCCAMIAtBDEEIIAcgCUkiCRtqKAIANgIAIAhFIAggCRshCyAAKAIIIQgDQAJAIAgNACAAKAIQIghBAWohDCAILQABIQkgCC0AAEH/AUYEQCAJQZABTwRAIAAgACgCDEEBajYCDCAKQYD+A2ohCkEIIQgMAgsgACAMNgIQIAogCUEJdGohCkEHIQgMAQsgACAMNgIQQQghCCAKIAlBCHRqIQoLIAAgCEEBayIINgIIIAAgCkEBdCIKNgIAIAAgB0EBdCIHNgIEIAdBgIACSQ0ACwwBCyALKAIEIQsLIAIgA0EAIANrIAsgDkYbNgIAIA8gDygCAEEgIA10cjYCACABIAEoAgAgCyAOcyICQRN0QRByIA10cjYCACABIAEoAgRBCCANdHI2AgQgBCAGckUEQCABIAVBAnRrIgAgACgCBEGAgAJyNgIEIAAgACgCACACQR90ckGAgARyNgIAIABBBGsiACAAKAIAQYCACHI2AgALIARBA0cNACABIAVBAnRqIgAgACgCBEEBcjYCBCAAIAAoAgAgAkESdHJBAnI2AgAgAEEEayIAIAAoAgBBBHI2AgALIAEgASgCAEGAgIABIA10cjYCAAsLrQEAIABBsKIBNgJkIABBsKIBNgJgIABBsKIBNgJcIABBsKIBNgJYIABBsKIBNgJUIABBsKIBNgJQIABBsKIBNgJMIABBsKIBNgJIIABBsKIBNgJEIABBsKIBNgJAIABBsKIBNgI8IABBsKIBNgI4IABBsKIBNgI0IABBsKIBNgIwIABBsKIBNgIsIABBsKIBNgIoIABBsKIBNgIkIABBsKIBNgIgIABBsKIBNgIcC/QFAgl/AX4gACABNgIAIAD9DAAAAAAAAAAAAAAAAAAAAAD9CwMIIAAgAzYCHCAAIAJBAWsiBjYCGCABQQNxIQoCfyACQQBMBEAgASEEIAMMAQsgACABQQFqIgQ2AgAgAS0AAAshAUEIIQggAEEINgIQIAAgAUH/AUYiCTYCFCAAIAGtIg03AwgCQCAKQQNGDQAgACACQQJrIgs2AhggAAJ/IAJBAkgEQCAEIQUgAwwBCyAAIARBAWoiBTYCACAELQAACyIEQf8BRiIJNgIUIABBD0EQIAFB/wFGGyIINgIQIAAgBEEIdCABcq0iDTcDCCAKQQJGBEAgBSEEIAYhAiALIQYMAQsgACACQQNrIgw2AhggAAJ/IAJBA0gEQCAFIQcgAwwBCyAAIAVBAWoiBzYCACAFLQAACyIBQf8BRiIJNgIUIABBB0EIIARB/wFGGyAIaiIFNgIQIAAgAa0gCK2GIA2EIg03AwggCkEBRgRAIAchBCAFIQggCyECIAwhBgwBCyAAIAJBBGsiBjYCGCAAAn8gAkEESARAIAchBCADDAELIAAgB0EBaiIENgIAIActAAALIgJB/wFGIgk2AhQgAEEHQQggAUH/AUYbIAVqIgg2AhAgACACrSAFrYYgDYQiDTcDCCAMIQILAkAgAkEFTgRAIAQoAgAhAyAAIAJBBWs2AhggACAEQQRqNgIADAELQQAhAUF/QQAgAxshAyACQQJIDQADQCAAIARBAWoiAjYCACAELQAAIQQgACAGQQFrIgU2AhggA0H/ASABdEF/c3EgBCABdHIhAyABQQhqIQEgBkEBSyACIQQgBSEGDQALCyAAIANBGHYiAUH/AUY2AhQgAEEHQQggCRsiAkEHQQggA0H/AXEiBEH/AUYbaiIGQQdBCCADQQh2Qf8BcSIFQf8BRhtqIgdBB0EIIANBEHZB/wFxIgNB/wFGGyAIamo2AhAgACAFIAJ0IAMgBnRyIAEgB3RyIARyrSAIrYYgDYQ3AwgLtwUCEn8CfgJ/IAAoAhwgAUGYAWxqIgJBkAFrKAIAIAJBmAFrKAIAayIDIQUgAkGMAWsoAgAgAkGUAWsoAgBrIgIhBkHAACADIANBwABPGyEDQcAAIAIgAkHAAE8bIQQCQCAFRQ0AIAZFDQAgA0UNACAERQ0AIANBfyAEbkECdksNAEEBQRwQFyICIAQ2AgwgAiADNgIIIAIgBjYCBCACIAU2AgAgAiAErSIUIAatfEIBfSAUgCIUpyIENgIUIAIgA60iFSAFrXxCAX0gFYAiFaciAzYCEAJAIBRC/////w+DIBVC/////w+DfkIgiKcNACACQQQgAyAEbBAXIgM2AhggA0UNACACDAILIAIQFAtBAAsiCUUEQEEADwsCQCABBEADQCAOQZgBbCIPIAAoAhxqIgUoAhgiAgRAIAVBHGohECAFKAIUIQMgBSgCECEEQQAhCgNAIAMgBGwEQCAQIApBJGxqIQZBACELA0AgBigCFCALQShsaiIIKAIUIgIgCCgCECIHbARAQQAhBANAIAgoAhggBEHEAGxqIgMoAjwiEQRAIAMoAgwhByADKAIUIRIgAygCECEMIAMoAggiEyAGKAIAayEDIAYoAhAiDUEBcQRAIAAoAhwgD2oiAkGQAWsoAgAgA2ogAkGYAWsoAgBrIQMLIAcgBigCBGshAiANQQJxBEAgAiAAKAIcIA9qIg1BjAFrKAIAaiANQZQBaygCAGshAgsgCSADIAIgAyAMIBNrIgxqIBIgB2sgAmogEUEBIAxBABAqRQ0JIAgoAhAhByAIKAIUIQILIARBAWoiBCACIAdsSQ0ACyAFKAIQIQQgBSgCFCEDCyALQQFqIgsgAyAEbEkNAAsgBSgCGCECCyAKQQFqIgogAkkNAAsLIA5BAWoiDiABRw0ACwsgCQ8LIAkQJ0EAC8gMAg5/BnsgACgCCCILIAAoAgRqIQcCQCAAKAIMRQRAIAdBAkgNASABKAIAIAEgC0ECdGoiDSgCACIEQQFqQQF1ayEDIAAoAgAhBgJAIAdBBEkEQCAEIQIMAQsgB0EEayIAQQF2IglBAWohDAJAIABBFkkEQEEBIQAMAQsgBiABIAtBAnRqIgUgCUECdCICakEIakkgBiAJQQN0akEIaiIAIAVBBGpLcQRAQQEhAAwBCyAGIAEgAmpBCGpJIAFBBGogAElxBEBBASEADAELIAxB/P///wdxIgVBAXIhACAFQQF0IQggBP0RIRAgA/0RIRH9DAAAAAACAAAABAAAAAYAAAAhFEEAIQIDQCABIAJBAnRBBHIiA2r9AAIAIRMgAyANav0AAgAhEiAGIAJBA3RqIgMgEf1aAgADIANBCGogEyASIBAgEv0NDA0ODxAREhMUFRYXGBkaGyIT/a4B/QwCAAAAAgAAAAIAAAACAAAA/a4BQQL9rAH9sQEiEP1aAgAAIANBEGogEP1aAgABIANBGGogEP1aAgACIAYgFP0MAQAAAAEAAAABAAAAAQAAAP1QIhX9GwBBAnRqIBAgESAQ/Q0MDQ4PEBESExQVFhcYGRob/a4BQQH9rAEgE/2uASIR/VoCAAAgBiAV/RsBQQJ0aiAR/VoCAAEgBiAV/RsCQQJ0aiAR/VoCAAIgBiAV/RsDQQJ0aiAR/VoCAAMgFP0MCAAAAAgAAAAIAAAACAAAAP2uASEUIBAhESASIRAgAkEEaiICIAVHDQALIBD9GwMhAiAR/RsDIQMgBSAMRg0BIAIhBAsDQCABIABBAnQiAmooAgAhCSACIA1qKAIAIQIgBiAIQQJ0aiIFIAM2AgAgBSADIAkgAiAEakECakECdWsiA2pBAXUgBGo2AgQgCEECaiEIIAAgDEcgAiEEIABBAWohAA0ACwsgBiAIQQJ0aiADNgIAQXwhACAHQQFxBH8gBiAHQQFrIgBBAnRqIAEgAEEBdGooAgAgAkEBakEBdWsiADYCACAAIANqQQF1IQNBeAVBfAsgBiAHQQJ0IgBqaiACIANqNgIAIAEgBiAAEBYaDwsCQAJAAkAgB0EBaw4CAAECCyABIAEoAgBBAm02AgAPCyAAKAIAIgQgASgCACABIAtBAnRqIgMoAgBBAWpBAXVrIgA2AgQgBCAAIAMoAgBqNgIAIAEgBCkCADcCAA8LIAdBA0gNACAAKAIAIgogASgCACABIAtBAnRqIg4oAgQiBCAOKAIAIgBqQQJqQQJ1ayIDIABqNgIAQQEhCAJAIAdBAmsiBiAHQQFxIgxFIgBrQQJJBEAgBCECDAELIAcgAGtBBGsiAEEBdiICQQFqIQ8CQAJAIABBFkkNACAKQQRqIgUgASACQQJ0IgBqQQhqSSAKIAJBA3RqQQxqIgIgAUEEaktxDQAgBSAAIAEgC0ECdGoiAGpBDGpJIABBCGogAklxDQAgD0F8cSIFQQFyIQAgBUEBdEEBciEIIAT9ESERIAP9ESEQQQAhAgNAIAogAkEDdGoiBCABIAJBAnQiA2r9AAIEIBEgAyAOav0AAggiEf0NDA0ODxAREhMUFRYXGBkaGyITIBH9rgH9DAIAAAACAAAAAgAAAAIAAAD9rgFBAv2sAf2xASISIBIgECAS/Q0MDQ4PEBESExQVFhcYGRob/a4BQQH9rAEgE/2uASIT/Q0EBQYHGBkaGwgJCgscHR4f/QsCFCAEIBAgE/0NDA0ODxAREhMAAQIDFBUWFyAS/Q0AAQIDBAUGBxAREhMMDQ4P/QsCBCASIRAgAkEEaiICIAVHDQALIBH9GwMhAiAQ/RsDIQMgBSAPRg0CIAIhBAwBC0EBIQALA0AgASAAQQJ0aigCACENIA4gAEEBaiIFQQJ0aigCACECIAogCEECdGoiCSADNgIAIAkgAyANIAIgBGpBAmpBAnVrIgNqQQF1IARqNgIEIAhBAmohCCAAIA9HIAIhBCAFIQANAAsLIAogCEECdGogAzYCAAJAIAxFBEAgCiAGQQJ0aiABIAdBAXRqQQRrKAIAIAJBAWpBAXVrIgAgA2pBAXUgAmo2AgAMAQsgAiADaiEACyAKIAdBAnQiA2pBBGsgADYCACABIAogAxAWGgsLoAcDA30DewJ/IANBCE8EQCADQQN2IQsDQCAB/QAEACEHIAAgAP0ABAAiCCAC/QAEACIJ/Qy8dLM/vHSzP7x0sz+8dLM//eYB/eQB/QsEACABIAggB/0MzzGwPs8xsD7PMbA+zzGwPv3mAf3lASAJ/Qzh0TY/4dE2P+HRNj/h0TY//eYB/eUB/QsEACACIAggB/0M5dDiP+XQ4j/l0OI/5dDiP/3mAf3kAf0LBAAgAf0ABBAhByAAIAD9AAQQIgggAv0ABBAiCf0MvHSzP7x0sz+8dLM/vHSzP/3mAf3kAf0LBBAgASAIIAf9DM8xsD7PMbA+zzGwPs8xsD795gH95QEgCf0M4dE2P+HRNj/h0TY/4dE2P/3mAf3lAf0LBBAgAiAIIAf9DOXQ4j/l0OI/5dDiP+XQ4j/95gH95AH9CwQQIAJBIGohAiABQSBqIQEgAEEgaiEAIApBAWoiCiALRw0ACwsCQCADQQdxIgNFDQAgASoCACEEIAAgAioCACIGQ7x0sz+UIAAqAgAiBZI4AgAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIAIAIgBSAEQ+XQ4j+UkjgCACADQQFGDQAgASoCBCEEIAAgAioCBCIGQ7x0sz+UIAAqAgQiBZI4AgQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIEIAIgBSAEQ+XQ4j+UkjgCBCADQQJGDQAgASoCCCEEIAAgAioCCCIGQ7x0sz+UIAAqAggiBZI4AgggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIIIAIgBSAEQ+XQ4j+UkjgCCCADQQNGDQAgASoCDCEEIAAgAioCDCIGQ7x0sz+UIAAqAgwiBZI4AgwgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIMIAIgBSAEQ+XQ4j+UkjgCDCADQQRGDQAgASoCECEEIAAgAioCECIGQ7x0sz+UIAAqAhAiBZI4AhAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIQIAIgBSAEQ+XQ4j+UkjgCECADQQVGDQAgASoCFCEEIAAgAioCFCIGQ7x0sz+UIAAqAhQiBZI4AhQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIUIAIgBSAEQ+XQ4j+UkjgCFCADQQZGDQAgASoCGCEEIAAgAioCGCIGQ7x0sz+UIAAqAhgiBZI4AhggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIYIAIgBSAEQ+XQ4j+UkjgCGAsL4AECBn8DewJAIANFDQAgA0EETwRAIANBfHEhBgNAIAAgBEECdCIFaiIHIAf9AAIAIAIgBWoiB/0AAgAiCyABIAVqIgX9AAIAIgz9rgFBAv2sAf2xASIKIAv9rgH9CwIAIAUgCv0LAgAgByAKIAz9rgH9CwIAIARBBGoiBCAGRw0ACyADIAZGDQELA0AgACAGQQJ0IgRqIgUgBSgCACACIARqIgUoAgAiByABIARqIggoAgAiCWpBAnVrIgQgB2o2AgAgCCAENgIAIAUgBCAJajYCACAGQQFqIgYgA0cNAAsLC9kBAQN/IwBBgAFrIgYkACAGIQUCQCABKAIMIAJBBHRqIgIoAgAiBEUEQCACIQEMAQsDQCAFIAI2AgAgBUEEaiEFIAQiASICKAIAIgQNAAsLQQAhBANAIAEoAggiAiAESARAIAEgBDYCCCAEIQILAkAgAiADTg0AA0AgAiABKAIETg0BAkAgAEEBECMEQCABIAI2AgQMAQsgAkEBaiECCyACIANIDQALCyABIAI2AgggBSAGRwRAIAVBBGsiBSgCACEBIAIhBAwBCwsgASgCBCAGQYABaiQAIANIC8QJAg9/A3sjAEGAAmsiCSQAAkAgAEUEQEEAIQAMAQsCQCABIAAoAgBGBEAgACgCBCACRg0BCyAAIAI2AgQgACABNgIAIAkgAjYCACAJIAE2AoABIAIhBCABIQYDQCAJIAgiD0EBaiIIQQJ0IgpqIARBAWpBAm0iBzYCACAJQYABaiAKaiAGQQFqQQJtIgo2AgAgBSAEIAZsIgxqIQUgByEEIAohBiAMQQFLDQALIAAgBTYCCAJAAkACQCAFRQRAIAAoAgwiAUUNASABEBQgAEEANgIMDAELIAVBBHQiBSAAKAIQTQ0CIAAoAgwgBRAbIgINASADQQFBjjJBABATIAAoAgwiAUUNACABEBQgAEEANgIMCyAAEBRBACEADAMLIAAgAjYCDCACIAAoAhAiAWpBACAFIAFrEBkaIAAgBTYCECAAKAIEIQIgACgCACEBCyAAKAIMIQYgDwRAIAYgASACbEEEdGoiBCEFA0ACQCAJIBBBAnQiAWooAgAiC0EATA0AIAtBAWshDQJAAkAgCUGAAWogAWooAgAiB0EATARAIAtBAXEhCkEAIQggC0EBRw0BIAUhAQwCCyAHQQIgByAHQQJOG2tBAWpBAXYiAiAHQYGAgIB4bEH/////B2pBAXYiASABIAJLGyICQQFqIgEgAUEDcSIBQQQgARtrIg5BBHQhESAOQQV0IRIgByAOQQF0ayEMIAJBA0sgB3EhCEEAIQEgBSECA0AgCAR/IAQgEWogBiASakEAIQUDQCAG/REiFP0MAAAAACAAAABAAAAAYAAAAP2uASIV/RsAIAT9Ef0MAAAAABAAAAAgAAAAMAAAAP2uASIT/VoCAAAgFf0bASAT/VoCAAEgFf0bAiAT/VoCAAIgFf0bAyAT/VoCAAMgFP0MEAAAADAAAABQAAAAcAAAAP2uASIU/RsAIBP9WgIAACAU/RsBIBP9WgIAASAU/RsCIBP9WgIAAiAU/RsDIBP9WgIAAyAEQUBrIQQgBkGAAWohBiAFQQRqIgUgDkcNAAshBiEEIAwFIAcLIQUDQAJAIAYgBDYCACAFQQFGBEAgBkEQaiEGIARBEGohBAwBCyAGIAQ2AhAgBEEQaiEEIAZBIGohBiAFQQJKIAVBAmshBQ0BCwsgBCACIAdBBHRqIAEgASANRnJBAXEiAxshBSAEIAIgAxshBCAFIQIgAUEBaiIBIAtHDQALDAILIAtB/v///wdxIQNBACECA0AgCCANRiEBIAhBAmohCCAEIAUgARsiBCEFIAQhASACQQJqIgIgA0cNAAsLIApFBEAgBCEFDAELIAQgASAHQQR0aiAIIAggDUZyQQFxIgIbIQUgBCABIAIbIQQLIBBBAWoiECAPRw0ACwsgBkEANgIACyAAKAIIIgJFDQAgACgCDCEEIAJBBE8EQCACQXxxIQFBACEGA0AgBEEANgI8IARC5wc3AjQgBEEANgIsIARC5wc3AiQgBEEANgIcIARC5wc3AhQgBEEANgIMIARC5wc3AgQgBEFAayEEIAZBBGoiBiABRw0ACwsgAkEDcSIBRQ0AQQAhBgNAIARBADYCDCAEQucHNwIEIARBEGohBCAGQQFqIgYgAUcNAAsLIAlBgAJqJAAgAAuxAQEDfwJAIABFDQAgACgCCCIBRQ0AIAAoAgwhACABQQRPBEAgAUF8cSEDA0AgAEEANgI8IABC5wc3AjQgAEEANgIsIABC5wc3AiQgAEEANgIcIABC5wc3AhQgAEEANgIMIABC5wc3AgQgAEFAayEAIAJBBGoiAiADRw0ACwsgAUEDcSIBRQ0AQQAhAgNAIABBADYCDCAAQucHNwIEIABBEGohACACQQFqIgIgAUcNAAsLC8kIAhJ/A3sjAEGAAmsiCSQAAn9BAUEUEBciB0UEQCACQQFB6DFBABATQQAMAQsgByABNgIEIAcgADYCACAJIAE2AgAgCSAANgKAAQNAIAkgBiIPQQFqIgZBAnQiBWogAUEBakECbSIDNgIAIAlBgAFqIAVqIABBAWpBAm0iBTYCACAEIAAgAWwiCGohBCADIQEgBSEAIAhBAUsNAAsgByAENgIIIARFBEAgBxAUQQAMAQsgByAEQRAQFyIDNgIMIANFBEAgAkEBQccbQQAQEyAHEBRBAAwBCyAHIAcoAggiDEEEdDYCECADIQEgDwRAIAMgBygCBCAHKAIAbEEEdGoiACEGA0ACQCAJIBBBAnQiAmooAgAiC0EATA0AIAtBAWshDQJAIAlBgAFqIAJqKAIAIghBAEwEQEEAIQQgC0EBRwRAIAtB/v///wdxIQVBACECA0AgBCANRiEKIARBAmohBCAGIAAgChsiACEGIAJBAmoiAiAFRw0ACwsgC0EBcQ0BIAAhBgwCCyAIQQIgCCAIQQJOG2tBAWpBAXYiAiAIQYGAgIB4bEH/////B2pBAXYiBSACIAVJGyICQQFqIgUgBUEDcSIFQQQgBRtrIg5BBXQhESAOQQR0IRIgCCAOQQF0ayETIAJBA0sgCHEhFEEAIQogACECA0ACfyAURQRAIAYhACAIDAELIAEgEWogBiASaiEAQQAhBANAIAH9ESIX/QwAAAAAIAAAAEAAAABgAAAA/a4BIhX9GwAgBv0R/QwAAAAAEAAAACAAAAAwAAAA/a4BIhb9WgIAACAV/RsBIBb9WgIAASAV/RsCIBb9WgIAAiAV/RsDIBb9WgIAAyAX/QwQAAAAMAAAAFAAAABwAAAA/a4BIhX9GwAgFv1aAgAAIBX9GwEgFv1aAgABIBX9GwIgFv1aAgACIBX9GwMgFv1aAgADIAFBgAFqIQEgBkFAayEGIARBBGoiBCAORw0ACyEBIBMLIQQDQAJAIAEgADYCACAEQQFGBEAgAUEQaiEBIABBEGohAAwBCyABIAA2AhAgAEEQaiEAIAFBIGohASAEQQJKIARBAmshBA0BCwsgACACIAogCiANRnJBAXEiBRshBiAAIAIgCEEEdGogBRsiACECIApBAWoiCiALRw0ACwwBCyAGIAAgCEEEdGogBCAEIA1GckEBcSIFGyAGIAAgBRshBiEACyAQQQFqIhAgD0cNAAsLIAFBADYCAAJAIAxFDQAgDEEETwRAIAxBfHEhAEEAIQEDQCADQQA2AjwgA0LnBzcCNCADQQA2AiwgA0LnBzcCJCADQQA2AhwgA0LnBzcCFCADQQA2AgwgA0LnBzcCBCADQUBrIQMgAUEEaiIBIABHDQALCyAMQQNxIgBFDQBBACEBA0AgA0EANgIMIANC5wc3AgQgA0EQaiEDIAFBAWoiASAARw0ACwsgBwsgCUGAAmokAAtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwsFABAMAAuBAgACQCABQf8ATQ0AAkBB1NYBKAIAKAIARQRAIAFBgH9xQYC/A0YNAgwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMPCyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBA8LC0HUzQFBGTYCAEF/DwsgACABOgAAQQELfgIBfwF+IAC9IgNCNIinQf8PcSICQf8PRwR8IAJFBEAgASAARAAAAAAAAAAAYQR/QQAFIABEAAAAAAAA8EOiIAEQcCEAIAEoAgBBQGoLNgIAIAAPCyABIAJB/gdrNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC28BBX8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2AgAgAywAASAEIQIgBSEDQTBrIgFBCkkNAAsgAgtJAQF/AkBBAUEsEBciAQRAIAFBADYCEAJAIABBAEwEQCABQQFBCBAXIgA2AiQgAEUNAQwDCyABQQA2AgwLIAEQFAtBACEBCyABC64UAhJ/An4jAEFAaiIIJAAgCCABNgI8IAhBJ2ohFyAIQShqIRICQAJAAkACQANAQQAhBwNA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KAIcIgdrIgYgBCAGSRsiBgRAIAUgByAGEBYaIAMgAygCACAGaiIFNgIAIAMgAygCBCAGayIENgIECyAEIAIgAiAESxsiBARAIAUgASAEEBYaIAMgAygCACAEaiIFNgIAIAMgAygCBCAEazYCBAsgBUEAOgAAIAAgACgCLCIBNgIcIAAgATYCFCACC6YFAgZ+BH8gASABKAIAQQdqQXhxIgFBEGo2AgAgACABKQMAIQIgASkDCCEHIwBBIGsiCCQAIAdC////////P4MhBAJ+IAdCMIhC//8BgyIDpyIKQYH4AGtB/Q9NBEAgBEIEhiACQjyIhCEDIApBgPgAa60hBAJAIAJC//////////8PgyICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDC0IAIAMgA0L/////////B1YiABshAiAArSAEfAwBCwJAIAIgBIRQDQAgA0L//wFSDQAgBEIEhiACQjyIhEKAgICAgICABIQhAkL/DwwBCyAKQf6HAUsEQEIAIQJC/w8MAQtBgPgAQYH4ACADUCIBGyIAIAprIglB8ABKBEBCACECQgAMAQsgAiEDIAQgBEKAgICAgIDAAIQgARsiBSEGAkBBgAEgCWsiAUHAAHEEQCACIAFBQGqthiEGQgAhAwwBCyABRQ0AIAYgAa0iBIYgA0HAACABa62IhCEGIAMgBIYhAwsgCCADNwMQIAggBjcDGAJAIAlBwABxBEAgBSAJQUBqrYghAkIAIQUMAQsgCUUNACAFQcAAIAlrrYYgAiAJrSIDiIQhAiAFIAOIIQULIAggAjcDACAIIAU3AwggCCkDCEIEhiAIKQMAIgNCPIiEIQICQCAAIApHIAgpAxAgCCkDGIRCAFJxrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILIAJCgICAgICAgAiFIAIgAkL/////////B1YiABshAiAArQshAyAIQSBqJAAgB0KAgICAgICAgIB/gyADQjSGhCAChL85AwAL9BcDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASEQQboIIRQgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEEG9CCEUDAELQcAI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ACgCRCICQQN0aiIFIAQoAhQ7AQAgBSAEKAIQNgIEQQEhBSAAIAJBAWo2AkQgASAJaiECIAZBAWoiBiAKRw0ACwwCC0EBIAYgBkEBTRshByAAKAJEIQFBACEGA0AgBCABNgIUIAEgACgChAEgACgCgAFsTw0BIAIgBEEQaiAJEBUgCCAAKAJEIgpBA3RqIgUgATsBACAFIAQoAhA2AgRBASEFIAAgCkEBaiIBNgJEIAIgCWohAiAGQQFqIgYgB0cNAAsMAQsgAEEBNgJMIAQgATYCACADQQJB0jwgBBATCyAEQSBqJAAgBQsEAEEACwvLwQEhAEGACAvgmQFjYW5ub3QgYWxsb2NhdGUgb3BqX3RjZF9zZWdfZGF0YV9jaHVua190KiBhcnJheQAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AFVua25vd24gZm9ybWF0AEZhaWxlZCB0byBzZXR1cCB0aGUgZGVjb2RlcgBGYWlsZWQgdG8gcmVhZCB0aGUgaGVhZGVyAG5hbgAqbF90aWxlX2xlbiA+IFVJTlRfTUFYIC0gT1BKX0NPTU1PTl9DQkxLX0RBVEFfRVhUUkEgLSBwX2oyay0+bV9zcGVjaWZpY19wYXJhbS5tX2RlY29kZXIubV9zb3RfbGVuZ3RoAGluZgBGYWlsZWQgdG8gZGVjb2RlIHRoZSBpbWFnZQBJbnZhbGlkIGFjY2VzcyB0byBwaS0+aW5jbHVkZQAvdG1wL29wZW5qcGVnL3NyYy9iaW4vY29tbW9uL2NvbG9yLmMAQUxMX0NQVVMAT1BKX05VTV9USFJFQURTAE5BTgBPSlBfRE9fTk9UX0RJU1BMQVlfVElMRV9JTkRFWF9JRl9UTE0ASU5GAHBfajJrLT5tX3NwZWNpZmljX3BhcmFtLm1fZGVjb2Rlci5tX3NvdF9sZW5ndGggPiBVSU5UX01BWCAtIE9QSl9DT01NT05fQ0JMS19EQVRBX0VYVFJBAAkJCSBwcmVjY2ludHNpemUgKHcsaCk9AAkJCSBzdGVwc2l6ZXMgKG0sZSk9AFNPVCBtYXJrZXIgZm9yIHRpbGUgJXUgZGVjbGFyZXMgbW9yZSB0aWxlLXBhcnRzIHRoYW4gZm91bmQgaW4gVExNIG1hcmtlci4AKG51bGwpACglZCwlZCkgACVzfQoACQkgfQoAW0RFVl0gRHVtcCBhbiBpbWFnZV9jb21wX2hlYWRlciBzdHJ1Y3QgewoAW0RFVl0gRHVtcCBhbiBpbWFnZV9oZWFkZXIgc3RydWN0IHsKAEltYWdlIGluZm8gewoACSBkZWZhdWx0IHRpbGUgewoAJXMJIGNvbXBvbmVudCAlZCB7CgAJCSBjb21wICVkIHsKAAkgVGlsZSBpbmRleDogewoACSBNYXJrZXIgbGlzdDogewoAQ29kZXN0cmVhbSBpbmRleCBmcm9tIG1haW4gaGVhZGVyOiB7CgBDb2Rlc3RyZWFtIGluZm8gZnJvbSBtYWluIGhlYWRlcjogewoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3gKAEZvdW5kIGEgbWlzcGxhY2VkICclYyVjJWMlYycgYm94IG91dHNpZGUganAyaCBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IGZpcnN0IGJveCBtdXN0IGJlIEpQRUcgMjAwMCBzaWduYXR1cmUgYm94CgBNYWxmb3JtZWQgSlAyIGZpbGUgZm9ybWF0OiBzZWNvbmQgYm94IG11c3QgYmUgZmlsZSB0eXBlIGJveAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGJveAoATm90IGVub3VnaCBtZW1vcnkgd2l0aCBGVFlQIEJveAoAQSBtYXJrZXIgSUQgd2FzIGV4cGVjdGVkICgweGZmLS0pIGluc3RlYWQgb2YgJS44eAoACQkgbWN0PSV4CgAJCQkgY2Jsa3N0eT0lI3gKAAkJCSBjc3R5PSUjeAoACQkgcHJnPSUjeAoASW50ZWdlciBvdmVyZmxvdwoACSB0ZHg9JXUsIHRkeT0ldQoACSB0dz0ldSwgdGg9JXUKAAkgdHgwPSV1LCB0eTA9JXUKAEludmFsaWQgY29tcG9uZW50IGluZGV4OiAldQoAU3RyZWFtIHRvbyBzaG9ydAoATWFya2VyIGhhbmRsZXIgZnVuY3Rpb24gZmFpbGVkIHRvIHJlYWQgdGhlIG1hcmtlciBzZWdtZW50CgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgY3VycmVudCBwcmVjaW5jdCBjb2RlYmxvY2sgZWxlbWVudAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNRY2Qgb3IgU1FjYyBlbGVtZW50CgBBIEJQQ0MgaGVhZGVyIGJveCBpcyBhdmFpbGFibGUgYWx0aG91Z2ggQlBDIGdpdmVuIGJ5IHRoZSBJSERSIGJveCAoJWQpIGluZGljYXRlIGNvbXBvbmVudHMgYml0IGRlcHRoIGlzIGNvbnN0YW50CgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGlsbGVnYWwgdGlsZSBvZmZzZXQKAEludmFsaWQgcHJlY2luY3QKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBiYW5kIHByZWNpbnRzCgBGYWlsZWQgdG8gZGVjb2RlIGFsbCB1c2VkIGNvbXBvbmVudHMKAFNpemUgb2YgY29kZSBibG9jayBkYXRhIGV4Y2VlZHMgc3lzdGVtIGxpbWl0cwoAU2l6ZSBvZiB0aWxlIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgTUNUIG1hcmtlcnMKAENvcnJ1cHRlZCBQUE0gbWFya2VycwoATm90IGVub3VnaCBtZW1vcnkgZm9yIHRpbGUgcmVzb2x1dGlvbnMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBjb2xsZWN0aW9ucwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAwIHBhbGV0dGUgY29sdW1ucwoAV2UgZG8gbm90IHN1cHBvcnQgUk9JIGluIGRlY29kaW5nIEhUIGNvZGVibG9ja3MKAENhbm5vdCBoYW5kbGUgYm94IG9mIHVuZGVmaW5lZCBzaXplcwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIHdpdGhvdXQgc2FtZSBudW1iZXIgb2YgaW5kaXhlcwoASW52YWxpZCB0aWxlYy0+d2luX3h4eCB2YWx1ZXMKAENhbm5vdCBoYW5kbGUgYm94IG9mIGxlc3MgdGhhbiA4IGJ5dGVzCgBDYW5ub3QgaGFuZGxlIFhMIGJveCBvZiBsZXNzIHRoYW4gMTYgYnl0ZXMKAENvbXBvbmVudCBpbmRleCAldSB1c2VkIHNldmVyYWwgdGltZXMKAEludmFsaWQgUENMUiBib3guIFJlcG9ydHMgJWQgZW50cmllcwoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlIG5vZGVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbWN0IGRhdGEgd2l0aGluIG11bHRpcGxlIE1DVCByZWNvcmRzCgBDYW5ub3QgZGVjb2RlIHRpbGUsIG1lbW9yeSBlcnJvcgoAb3BqX2oya19hcHBseV9uYl90aWxlX3BhcnRzX2NvcnJlY3Rpb24gZXJyb3IKAFByb2JsZW0gd2l0aCBza2lwcGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAUHJvYmxlbSB3aXRoIHJlYWRpbmcgSlBFRzIwMDAgYm94LCBzdHJlYW0gZXJyb3IKAFVua25vd24gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgdGwgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBhZGQgbWggbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byB0YWtlIGluIGNoYXJnZSBTSVogbWFya2VyCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBTT1QgbWFya2VyCgBEaWQgbm90IGdldCBleHBlY3RlZCBTT1QgbWFya2VyCgBFcnJvciByZWFkaW5nIFBMVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIHNwYWNlIGZvciBleHBlY3RlZCBTT1AgbWFya2VyCgBFeHBlY3RlZCBTT1AgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DTyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUkdOIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQUE0gbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFBQTSBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExNIG1hcmtlcgoARXhwZWN0ZWQgRVBIIG1hcmtlcgoATm90IGVub3VnaCBzcGFjZSBmb3IgcmVxdWlyZWQgRVBIIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDUkcgbWFya2VyCgBVbmtub3duIHByb2dyZXNzaW9uIG9yZGVyIGluIENPRCBtYXJrZXIKAFVua25vd24gU2NvZCB2YWx1ZSBpbiBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIENPRCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNEIG1hcmtlcgoAQ3Jyb3IgcmVhZGluZyBDQkQgbWFya2VyCgBFcnJvciByZWFkaW5nIFBPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlcgoARXJyb3IgcmVhZGluZyBRQ0MgbWFya2VyCgBFcnJvciByZWFkaW5nIE1DQyBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgTUNDIG1hcmtlcgoAcmVxdWlyZWQgU0laIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAHJlcXVpcmVkIENPRCBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBRQ0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGpwZWcyMDAwIGZpbGUgaGVhZGVyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIGhlYWRlcgoARXJyb3Igd2l0aCBKUCBTaWduYXR1cmUgOiBiYWQgbWFnaWMgbnVtYmVyCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBjdXJyZW50IG51bWJlciBvZiB0aWxlLXBhcnQgKCVkKSwgZ2l2aW5nIHVwCgBJbiBTT1QgbWFya2VyLCBUUFNvdCAoJWQpIGlzIG5vdCB2YWxpZCByZWdhcmRzIHRvIHRoZSBwcmV2aW91cyBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0IChoZWFkZXIpICglZCksIGdpdmluZyB1cAoAdGlsZXMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgcmVzb2x1dGlvbgoATWFya2VyIGlzIG5vdCBjb21wbGlhbnQgd2l0aCBpdHMgcG9zaXRpb24KAFByb2JsZW0gd2l0aCBzZWVrIGZ1bmN0aW9uCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgY2Jsa3cvY2Jsa2ggY29tYmluYXRpb24KAEludmFsaWQgbXVsdGlwbGUgY29tcG9uZW50IHRyYW5zZm9ybWF0aW9uCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgb3RoZXIgdGhhbiBhcnJheSBkZWNvcnJlbGF0aW9uCgBUb28gbGFyZ2UgdmFsdWUgZm9yIE5wcG0KAE5vdCBlbm91Z2ggYnl0ZXMgdG8gcmVhZCBOcHBtCgBiYWQgcGxhY2VkIGpwZWcgY29kZXN0cmVhbQoACSBNYWluIGhlYWRlciBzdGFydCBwb3NpdGlvbj0lbGxpCgkgTWFpbiBoZWFkZXIgZW5kIHBvc2l0aW9uPSVsbGkKAE1hcmtlciBzaXplIGluY29uc2lzdGVudCB3aXRoIHN0cmVhbSBsZW5ndGgKAFRpbGUgcGFydCBsZW5ndGggc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgZGF0YSBzcGFubmluZwoAV3JvbmcgZmxhZwoARXJyb3Igd2l0aCBGVFlQIHNpZ25hdHVyZSBCb3ggc2l6ZQoARXJyb3Igd2l0aCBKUCBzaWduYXR1cmUgQm94IHNpemUKAEludmFsaWQgcHJlY2luY3Qgc2l6ZQoASW5jb25zaXN0ZW50IG1hcmtlciBzaXplCgBJbnZhbGlkIG1hcmtlciBzaXplCgBFcnJvciB3aXRoIFNJWiBtYXJrZXIgc2l6ZQoATm90IGVub3VnaCBtZW1vcnkgdG8gYWRkIGEgbmV3IHZhbGlkYXRpb24gcHJvY2VkdXJlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBkZWNvZGUgdGlsZQoARmFpbGVkIHRvIGRlY29kZSB0aGUgY29kZXN0cmVhbSBpbiB0aGUgSlAyIGZpbGUKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBjb2xsZWN0aW9ucyB3aXRoIGluZGl4IHNodWZmbGUKAENhbm5vdCBhbGxvY2F0ZSBUaWVyIDEgaGFuZGxlCgBObyBkZWNvZGVkIGFyZWEgcGFyYW1ldGVycywgc2V0IHRoZSBkZWNvZGVkIGFyZWEgdG8gdGhlIHdob2xlIGltYWdlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlaW5pdGlhbGl6ZSB0aGUgdGFnIHRyZWUKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudCwgSW52YWxpZCB0cmFuc2Zvcm1hdGlvbiBmb3VuZAoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LiBVbnN1cHBvcnRlZCBNaXhlZCBIVCBjb2RlLWJsb2NrIHN0eWxlIGZvdW5kCgBUaWxlIFkgY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAFRpbGUgWCBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvcnRlZAoASW1hZ2UgY29vcmRpbmF0ZXMgYWJvdmUgSU5UX01BWCBhcmUgbm90IHN1cHBvcnRlZAoASlBFRzIwMDAgSGVhZGVyIGJveCBub3QgcmVhZCB5ZXQsICclYyVjJWMlYycgYm94IHdpbGwgYmUgaWdub3JlZAoAb3BqX2oya19tZXJnZV9wcHQoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZAoAb3BqX2oya19idWlsZF90cF9pbmRleF9mcm9tX3RsbSgpOiB0aWxlIGluZGV4IGFsbG9jYXRpb24gZmFpbGVkCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIFNPVCBtYXJrZXIuIFRpbGUgaW5kZXggYWxsb2NhdGlvbiBmYWlsZWQKAElnbm9yaW5nIGloZHIgYm94LiBGaXJzdCBpaGRyIGJveCBhbHJlYWR5IHJlYWQKAFpwcHQgJXUgYWxyZWFkeSByZWFkCgBacHBtICV1IGFscmVhZHkgcmVhZAoAUFRFUk0gY2hlY2sgZmFpbHVyZTogJWQgc3ludGhlc2l6ZWQgMHhGRiBtYXJrZXJzIHJlYWQKAAkJCSBjYmxrdz0yXiVkCgAJCQkgY2Jsa2g9Ml4lZAoACQkJIHFudHN0eT0lZAoAJXMgZHg9JWQsIGR5PSVkCgAJCQkgcm9pc2hpZnQ9JWQKAAkJCSBudW1nYml0cz0lZAoACQkgbnVtbGF5ZXJzPSVkCgAlcyBudW1jb21wcz0lZAoAb3BqX2pwMl9hcHBseV9jZGVmOiBhY249JWQsIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGNuPSVkLCBudW1jb21wcz0lZAoACQkJIG51bXJlc29sdXRpb25zPSVkCgAJCSB0eXBlPSUjeCwgcG9zPSVsbGksIGxlbj0lZAoAJXMgc2duZD0lZAoACQkJIHFtZmJpZD0lZAoAJXMgcHJlYz0lZAoACQkgbmIgb2YgdGlsZS1wYXJ0IGluIHRpbGUgWyVkXT0lZAoAJXMgeDE9JWQsIHkxPSVkCgAlcyB4MD0lZCwgeTA9JWQKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAlZC8lZAoAU2V0dGluZyBkZWNvZGluZyBhcmVhIHRvICVkLCVkLCVkLCVkCgBGYWlsZWQgdG8gZGVjb2RlIGNvbXBvbmVudCAlZAoASW52YWxpZCB2YWx1ZSBmb3IgbnVtcmVzb2x1dGlvbnMgOiAlZCwgbWF4IHZhbHVlIGlzIHNldCBpbiBvcGVuanBlZy5oIGF0ICVkCgBJbnZhbGlkIGNvbXBvbmVudCBudW1iZXI6ICVkLCByZWdhcmRpbmcgdGhlIG51bWJlciBvZiBjb21wb25lbnRzICVkCgBUb28gbWFueSBQT0NzICVkCgBvcGpfajJrX3JlYWRfdGxtKCk6IGludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU290IGxlbmd0aCBpcyBsZXNzIHRoYW4gbWFya2VyIHNpemUgKyBtYXJrZXIgSUQKAFN0cmVhbSBkb2VzIG5vdCBlbmQgd2l0aCBFT0MKAENhbm5vdCBoYW5kbGUgYm94IHNpemVzIGhpZ2hlciB0aGFuIDJeMzIKAG9wal9waV9uZXh0X2xyY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JsY3AoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X2NwcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3BjcmwoKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal9waV9uZXh0X3JwY2woKTogaW52YWxpZCBjb21wbm8wL2NvbXBubzEKAG9wal90MV9kZWNvZGVfY2JsaygpOiB1bnN1cHBvcnRlZCBicG5vX3BsdXNfb25lID0gJWQgPj0gMzEKAEZhaWxlZCB0byBkZWNvZGUgdGlsZSAxLzEKAEluc3VmZmljaWVudCBkYXRhIGZvciBDTUFQIGJveC4KAE5lZWQgdG8gcmVhZCBhIFBDTFIgYm94IGJlZm9yZSB0aGUgQ01BUCBib3guCgBJbnN1ZmZpY2llbnQgZGF0YSBmb3IgQ0RFRiBib3guCgBOdW1iZXIgb2YgY2hhbm5lbCBkZXNjcmlwdGlvbiBpcyBlcXVhbCB0byB6ZXJvIGluIENERUYgYm94LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IG5vICdpaGRyJyBib3guCgBOb24gY29uZm9ybWFudCBjb2Rlc3RyZWFtIFRQc290PT1UTnNvdC4KAFN0cmVhbSBlcnJvciB3aGlsZSByZWFkaW5nIEpQMiBIZWFkZXIgYm94OiBib3ggbGVuZ3RoIGlzIGluY29uc2lzdGVudC4KAEJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAUmVzb2x1dGlvbiBmYWN0b3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHJlc29sdXRpb24gaW4gdGhlIGNvbXBvbmVudC4KAENvbXBvbmVudCBtYXBwaW5nIHNlZW1zIHdyb25nLiBUcnlpbmcgdG8gY29ycmVjdC4KAG9wal9qMmtfYnVpbGRfdHBfaW5kZXhfZnJvbV90bG0oKTogdGlsZSAlZCBoYXMgbm8gcmVnaXN0ZXJlZCB0aWxlLXBhcnQgaW4gVExNIG1hcmtlciBzZWdtZW50cy4KAG9wal9qMmtfcmVhZF90bG0oKTogdG9vIG1hbnkgVExNIG1hcmtlcnMuCgBvcGpfajJrX3JlYWRfdGxtKCk6IGNhbm5vdCBhbGxvY2F0ZSBtX3RpbGVfcGFydF9pbmZvcy4KAEluY29tcGxldGUgY2hhbm5lbCBkZWZpbml0aW9ucy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEludmFsaWQgY29kZWJsb2NrIGxlbmd0aCB2YWx1ZXMuCgBXZSBkbyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gMyBjb2RpbmcgcGFzc2VzIGluIGFuIEhUIGNvZGVibG9jazsgVGhpcyBjb2RlYmxvY2tzIGhhcyAlZCBwYXNzZXMuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBUaGVyZSBhcmUgJWQgemVybyBiaXRwbGFuZXMgaW4gJWQgYml0cGxhbmVzLgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIHRyYW5zZm9ybWF0aW9uIHN0YWdlcy4KAFVua25vd24gbWFya2VyIGhhcyBiZWVuIGRldGVjdGVkIGFuZCBnZW5lcmF0ZWQgZXJyb3IuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3NldHVwX2RlY29kZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBDb2RlYyBwcm92aWRlZCB0byB0aGUgb3BqX3JlYWRfaGVhZGVyIGZ1bmN0aW9uIGlzIG5vdCBhIGRlY29tcHJlc3NvciBoYW5kbGVyLgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyLgoAVGlsZXMgZG9uJ3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uLiBTa2lwIHRoZSBNQ1Qgc3RlcC4KAE51bWJlciBvZiBjb21wb25lbnRzICglZCkgaXMgaW5jb25zaXN0ZW50IHdpdGggYSBNQ1QuIFNraXAgdGhlIE1DVCBzdGVwLgoASlAyIGJveCB3aGljaCBhcmUgYWZ0ZXIgdGhlIGNvZGVzdHJlYW0gd2lsbCBub3QgYmUgcmVhZCBieSB0aGlzIGZ1bmN0aW9uLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gV2hlbiB0aGUgbnVtYmVyIG9mIHplcm8gcGxhbmVzIGJpdHBsYW5lcyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGJpdHBsYW5lcywgb25seSB0aGUgY2xlYW51cCBwYXNzIG1ha2VzIHNlbnNlLCBidXQgd2UgaGF2ZSAlZCBwYXNzZXMgaW4gdGhpcyBjb2RlYmxvY2suIFRoZXJlZm9yZSwgb25seSB0aGUgY2xlYW51cCBwYXNzIHdpbGwgYmUgZGVjb2RlZC4gVGhpcyBtZXNzYWdlIHdpbGwgbm90IGJlIGRpc3BsYXllZCBhZ2Fpbi4KAEltYWdlIGhhcyBsZXNzIGNvbXBvbmVudHMgdGhhbiBjb2Rlc3RyZWFtLgoATmVlZCB0byBkZWNvZGUgdGhlIG1haW4gaGVhZGVyIGJlZm9yZSBiZWdpbiB0byBkZWNvZGUgdGhlIHJlbWFpbmluZyBjb2Rlc3RyZWFtLgoAUHNvdCB2YWx1ZSBvZiB0aGUgY3VycmVudCB0aWxlLXBhcnQgaXMgZXF1YWwgdG8gemVybywgd2UgYXNzdW1pbmcgaXQgaXMgdGhlIGxhc3QgdGlsZS1wYXJ0IG9mIHRoZSBjb2Rlc3RyZWFtLgoAQSBtYWxmb3JtZWQgY29kZWJsb2NrIHRoYXQgaGFzIG1vcmUgdGhhbiBvbmUgY29kaW5nIHBhc3MsIGJ1dCB6ZXJvIGxlbmd0aCBmb3IgMm5kIGFuZCBwb3RlbnRpYWxseSB0aGUgM3JkIHBhc3MgaW4gYW4gSFQgY29kZWJsb2NrLgoACQkJIHRpbGUtcGFydFslZF06IHN0YXJfcG9zPSVsbGksIGVuZF9oZWFkZXI9JWxsaSwgZW5kX3Bvcz0lbGxpLgoAVGlsZSAldSBoYXMgVFBzb3QgPT0gMCBhbmQgVE5zb3QgPT0gMCwgYnV0IG5vIG90aGVyIHRpbGUtcGFydHMgd2VyZSBmb3VuZC4gRU9DIGlzIGFsc28gbWlzc2luZy4KAENvbXBvbmVudCAlZCBkb2Vzbid0IGhhdmUgYSBtYXBwaW5nLgoAb3BqX2oya19yZWFkX3RsbSgpOiBUTE0gbWFya2VyIG5vdCBvZiBleHBlY3RlZCBzaXplLgoAQSBjb25mb3JtaW5nIEpQMiByZWFkZXIgc2hhbGwgaWdub3JlIGFsbCBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3hlcyBhZnRlciB0aGUgZmlyc3QsIHNvIHdlIGlnbm9yZSB0aGlzIG9uZS4KAFRoZSBzaWduYXR1cmUgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSAgYm94IG11c3QgYmUgdGhlIGZpcnN0IGJveCBpbiB0aGUgZmlsZS4KAFRoZSBmdHlwIGJveCBtdXN0IGJlIHRoZSBzZWNvbmQgYm94IGluIHRoZSBmaWxlLgoARmFpbGVkIHRvIGRlY29kZS4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIEluY29ycmVjdCBNRUwgc2VnbWVudCBzZXF1ZW5jZS4KAENvbXBvbmVudCAlZCBpcyBtYXBwZWQgdHdpY2UuCgBvcGpfajJrX3JlYWRfdGxtKCk6IFNUID0gMyBpcyBpbnZhbGlkLgoAT25seSBvbmUgQ01BUCBib3ggaXMgYWxsb3dlZC4KAFdlIG5lZWQgYW4gaW1hZ2UgcHJldmlvdXNseSBjcmVhdGVkLgoASUhEUiBib3hfbWlzc2luZy4gUmVxdWlyZWQuCgBKUDJIIGJveCBtaXNzaW5nLiBSZXF1aXJlZC4KAE5vdCBzdXJlIGhvdyB0aGF0IGhhcHBlbmVkLgoATWFpbiBoZWFkZXIgaGFzIGJlZW4gY29ycmVjdGx5IGRlY29kZWQuCgBUaWxlICVkLyVkIGhhcyBiZWVuIGRlY29kZWQuCgBIZWFkZXIgb2YgdGlsZSAlZCAvICVkIGhhcyBiZWVuIHJlYWQuCgBFbXB0eSBTT1QgbWFya2VyIGRldGVjdGVkOiBQc290PSVkLgoARGlyZWN0IHVzZSBhdCAjJWQgaG93ZXZlciBwY29sPSVkLgoASW1wbGVtZW50YXRpb24gbGltaXRhdGlvbjogZm9yIHBhbGV0dGUgbWFwcGluZywgcGNvbFslZF0gc2hvdWxkIGJlIGVxdWFsIHRvICVkLCBidXQgaXMgZXF1YWwgdG8gJWQuCgBJbnZhbGlkIGNvbXBvbmVudC9wYWxldHRlIGluZGV4IGZvciBkaXJlY3QgbWFwcGluZyAlZC4KAEludmFsaWQgdmFsdWUgZm9yIGNtYXBbJWRdLm10eXAgPSAlZC4KAFBzb3QgdmFsdWUgaXMgbm90IGNvcnJlY3QgcmVnYXJkcyB0byB0aGUgSlBFRzIwMDAgbm9ybTogJWQuCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBWTEMgY29kZSBwcm9kdWNlcyBzaWduaWZpY2FudCBzYW1wbGVzIG91dHNpZGUgdGhlIGNvZGVibG9jayBhcmVhLgoAVW5leHBlY3RlZCBPT00uCgAzMiBiaXRzIGFyZSBub3QgZW5vdWdoIHRvIGRlY29kZSB0aGlzIGNvZGVibG9jaywgc2luY2UgdGhlIG51bWJlciBvZiBiaXRwbGFuZSwgJWQsIGlzIGxhcmdlciB0aGFuIDMwLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgc2hvdWxkIGJlID4gMC4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgc2hvdWxkIGJlID4gMC4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgc2hvdWxkIGJlID49IDAuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgc2hvdWxkIGJlID49IDAuCgBFcnJvciByZWFkaW5nIFBQVCBtYXJrZXI6IHBhY2tldCBoZWFkZXIgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZm91bmQgaW4gdGhlIG1haW4gaGVhZGVyIChQUE0gbWFya2VyKS4KAFN0YXJ0IHRvIHJlYWQgajJrIG1haW4gaGVhZGVyICglbGxkKS4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlzaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBMZWZ0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWHNpej0lZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFlPc2l6PSVkKS4KAFJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl94MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWE9zaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAFNpemUgeCBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS53PSVkKS4KAFNpemUgeSBvZiB0aGUgZGVjb2RlZCBjb21wb25lbnQgaW1hZ2UgaXMgaW5jb3JyZWN0IChjb21wWyVkXS5oPSVkKS4KAFRpbGUgcmVhZCwgZGVjb2RlZCBhbmQgdXBkYXRlZCBpcyBub3QgdGhlIGRlc2lyZWQgb25lICglZCB2cyAlZCkuCgBJbnZhbGlkIGNvbXBvbmVudCBpbmRleCAlZCAoPj0gJWQpLgoAb3BqX3JlYWRfaGVhZGVyKCkgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgb3BqX3NldF9kZWNvZGVkX2NvbXBvbmVudHMoKS4KAE1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbWFnZS0+Y29tcHNbJWRdLmRhdGEgPT0gTlVMTCBpbiBvcGpfanAyX2FwcGx5X3BjbHIoKS4KAGludmFsaWQgYm94IHNpemUgJWQgKCV4KQoARmFpbCB0byByZWFkIHRoZSBjdXJyZW50IG1hcmtlciBzZWdtZW50ICglI3gpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IElIRFIgdygldSkgaCgldSkgdnMuIFNJWiB3KCV1KSBoKCV1KQoARXJyb3IgcmVhZGluZyBDT0MgbWFya2VyIChiYWQgbnVtYmVyIG9mIGNvbXBvbmVudHMpCgBJbnZhbGlkIG51bWJlciBvZiB0aWxlcyA6ICV1IHggJXUgKG1heGltdW0gZml4ZWQgYnkganBlZzIwMDAgbm9ybSBpcyA2NTUzNSB0aWxlcykKAEludmFsaWQgbnVtYmVyIG9mIGNvbXBvbmVudHMgKGloZHIpCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUgaW1hZ2UgaGVhZGVyIChpaGRyKQoAV3JvbmcgdmFsdWVzIGZvcjogdyglZCkgaCglZCkgbnVtY29tcHMoJWQpIChpaGRyKQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IGR4PSV1IGR5PSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAyNTUgYWNjb3JkaW5nIHRvIHRoZSBKUEVHMjAwMCBub3JtKQoAQmFkIGltYWdlIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBCYWQgQlBDQyBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbmVnYXRpdmUgb3IgemVybyBpbWFnZSBzaXplICglbGxkIHggJWxsZCkKAHNraXA6IHNlZ21lbnQgdG9vIGxvbmcgKCVkKSB3aXRoIG1heCAoJWQpIGZvciBjb2RlYmxvY2sgJWQgKHA9JWQsIGI9JWQsIHI9JWQsIGM9JWQpCgByZWFkOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoARGVzcGl0ZSBKUDIgQlBDIT0yNTUsIHByZWNpc2lvbiBhbmQvb3Igc2duZCB2YWx1ZXMgZm9yIGNvbXBbJWRdIGlzIGRpZmZlcmVudCB0aGFuIGNvbXBbMF06CiAgICAgICAgWzBdIHByZWMoJWQpIHNnbmQoJWQpIFslZF0gcHJlYyglZCkgc2duZCglZCkKAGJhZCBjb21wb25lbnQgbnVtYmVyIGluIFJHTiAoJWQgd2hlbiB0aGVyZSBhcmUgb25seSAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogbnVtYmVyIG9mIGNvbXBvbmVudCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCAlZCB2cyAlZCkKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaW52YWxpZCB0aWxlIHNpemUgKHRkeDogJWQsIHRkeTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChiYWQgc2l6ZTogJWQpCgBCYWQgQ09MUiBoZWFkZXIgYm94IChDSUVMYWIsIGJhZCBzaXplOiAlZCkKAFBURVJNIGNoZWNrIGZhaWx1cmU6ICVkIHJlbWFpbmluZyBieXRlcyBpbiBjb2RlIGJsb2NrICglZCB1c2VkIC8gJWQpCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBPbmUgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgbm90IG1ldDogMiA8PSBTY3VwIDw9IG1pbihMY3VwLCA0MDc5KQoASW52YWxpZCB2YWx1ZXMgZm9yIGNvbXAgPSAlZCA6IHByZWM9JXUgKHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kIDM4IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybS4gT3BlbkpwZWcgb25seSBzdXBwb3J0cyB1cCB0byAzMSkKAEludmFsaWQgYml0IG51bWJlciAlZCBpbiBvcGpfdDJfcmVhZF9wYWNrZXRfaGVhZGVyKCkKAFN0cmVhbSBlcnJvciEKAEVycm9yIG9uIHdyaXRpbmcgc3RyZWFtIQoAU3RyZWFtIHJlYWNoZWQgaXRzIGVuZCAhCgBFeHBlY3RlZCBhIFNPQyBtYXJrZXIgCgBJbnZhbGlkIGJveCBzaXplICVkIGZvciBib3ggJyVjJWMlYyVjJy4gTmVlZCAlZCBieXRlcywgJWQgYnl0ZXMgcmVtYWluaW5nIAoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gRGVjb2RpbmcgdGhpcyBjb2RlYmxvY2sgaXMgc3RvcHBlZC4gVV9xIGlzIGxhcmdlciB0aGFuIHplcm8gYml0cGxhbmVzICsgMSAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpc2xhcmdlciB0aGFuIGJpdHBsYW5lcyArIDEgCgBDT0xSIEJPWCBtZXRoIHZhbHVlIGlzIG5vdCBhIHJlZ3VsYXIgdmFsdWUgKCVkKSwgc28gd2Ugd2lsbCBpZ25vcmUgdGhlIGVudGlyZSBDb2xvdXIgU3BlY2lmaWNhdGlvbiBib3guIAoAV2hpbGUgcmVhZGluZyBDQ1BfUU5UU1RZIGVsZW1lbnQgaW5zaWRlIFFDRCBvciBRQ0MgbWFy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AAAAAFQAAKBTAAABJAAAAAAAABBUAACwUwAAASQAAAEAAAAgVAAAwFMAAAEiAAAAAAAAMFQAANBTAAABIgAAAQAAAEBUAADgUwAAARwAAAAAAABQVAAA8FMAAAEcAAABAAAAYFQAAABUAAABGAAAAAAAAHBUAAAQVAAAARgAAAEAAACAVAAAIFQAAAEWAAAAAAAAkFQAADBUAAABFgAAAQAAAKBUAABAVAAAARQAAAAAAACwVAAAUFQAAAEUAAABAAAAwFQAAGBUAAABEgAAAAAAANBUAABwVAAAARIAAAEAAADgVAAAgFQAAAERAAAAAAAA8FQAAJBUAAABEQAAAQAAAABVAACgVAAAwQoAAAAAAAAQVQAAsFQAAMEKAAABAAAAIFUAAMBUAADBCQAAAAAAADBVAADQVAAAwQkAAAEAAABAVQAA4FQAAKEIAAAAAAAAUFUAAPBUAAChCAAAAQAAAGBVAAAAVQAAIQUAAAAAAABwVQAAEFUAACEFAAABAAAAgFUAACBVAABBBAAAAAAAAJBVAAAwVQAAQQQAAAEAAACgVQAAQFUAAKECAAAAAAAAsFUAAFBVAAChAgAAAQAAAMBVAABgVQAAIQIAAAAAAADQVQAAcFUAACECAAABAAAA4FUAAIBVAABBAQAAAAAAAPBVAACQVQAAQQEAAAEAAAAAVgAAoFUAABEBAAAAAAAAEFYAALBVAAARAQAAAQAAACBWAADAVQAAhQAAAAAAAAAwVgAA0FUAAIUAAAABAAAAQFYAAOBVAABJAAAAAAAAAFBWAADwVQAASQAAAAEAAABgVgAAAFYAACUAAAAAAAAAcFYAABBWAAAlAAAAAQAAAIBWAAAgVgAAFQAAAAAAAACQVgAAMFYAABUAAAABAAAAoFYAAEBWAAAJAAAAAAAAALBWAABQVgAACQAAAAEAAADAVgAAYFYAAAUAAAAAAAAA0FYAAHBWAAAFAAAAAQAAAOBWAACAVgAAAQAAAAAAAADQVgAAkFYAAAEAAAABAAAA4FYAAKBWAAABVgAAAAAAAPBWAADwVgAAAVYAAAEAAAAAVwAAAFcAAAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAEFBgECBgYDAwcHAwMHBwABBQYBAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwECBgYCAgYGAwMHBwMDBwcBAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcFBggIBgYICAcHCAgHBwgIBQYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAECBgYCAgYGAwMHBwMDBwcBAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcCAgYGAgIGBgMDBwcDAwcHAgIGBgICBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgAAQMDAQIDAwUGBwcGBgcHAAEDAwECAwMFBgcHBgYHBwUGBwcGBgcHCAgICAgICAgFBgcHBgYHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAQIDAwICAwMGBgcHBgYHBwECAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAICAwMCAgMDBgYHBwYGBwcCAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAADAQQDBgQHAQQCBQQHBQcAAwEEAwYEBwEEAgUEBwUHAQQCBQQHBQcCBQIFBQcFBwEEAgUEBwUHAgUCBQUHBQcDBgQHBggHCAQHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIAQQCBQQHBQcCBQIFBQcFBwEEAgUEBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgDBgQHBggHCAQHBQcHCAcIAwYEBwYIBwgEBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgEBwUHBwgHCAUHBQcHCAcIBggHCAgICAgHCAcICAgICAYIBwgICAgIBwgHCAgICAgH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";
      return V;
    }
    var X;
    function qA(V) {
      if (V == X && h)
        return new Uint8Array(h);
      var AA = B(V);
      if (AA)
        return AA;
      throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
    }
    function IA(V, AA) {
      var fA, GA = qA(V);
      fA = new WebAssembly.Module(GA);
      var HA = new WebAssembly.Instance(fA, AA);
      return [HA, fA];
    }
    function U() {
      return {
        a: Fh
      };
    }
    function J() {
      function V(GA, HA) {
        return ri = GA.exports, Q = ri.t, m(), _(ri.u), $(), ri;
      }
      tA();
      var AA = U();
      if (s.instantiateWasm)
        try {
          return s.instantiateWasm(AA, V);
        } catch (GA) {
          l(`Module.instantiateWasm callback failed with error: ${GA}`), n(GA);
        }
      X ?? (X = DA());
      var fA = IA(X, AA);
      return V(fA[0]);
    }
    class q {
      constructor(AA) {
        Me(this, "name", "ExitStatus");
        this.message = `Program terminated with exit(${AA})`, this.status = AA;
      }
    }
    var Z = (V) => {
      for (; V.length > 0; )
        V.shift()(s);
    }, sA = s.noExitRuntime || !0, z = () => hA(""), W = (V, AA, fA) => u.copyWithin(V, AA, AA + fA), M = 0, CA = () => {
      sA = !1, M = 0;
    }, EA = {}, mA = (V) => {
      if (V instanceof q || V == "unwind")
        return f;
      o(1, V);
    }, QA = () => sA || M > 0, uA = (V) => {
      var AA;
      f = V, QA() || ((AA = s.onExit) == null || AA.call(s, V), E = !0), o(V, new q(V));
    }, gA = (V, AA) => {
      f = V, uA(V);
    }, cA = gA, wA = () => {
      if (!QA())
        try {
          cA(f);
        } catch (V) {
          mA(V);
        }
    }, rA = (V) => {
      if (!E)
        try {
          V(), wA();
        } catch (AA) {
          mA(AA);
        }
    }, bA = () => performance.now(), NA = (V, AA) => {
      if (EA[V] && (clearTimeout(EA[V].id), delete EA[V]), !AA) return 0;
      var fA = setTimeout(() => {
        delete EA[V], rA(() => Rh(V, bA()));
      }, AA);
      return EA[V] = {
        id: fA,
        timeout_ms: AA
      }, 0;
    };
    function ue(V, AA) {
      V >>= 2;
      const fA = s.imageData = new Uint8ClampedArray(AA), GA = s.HEAP32.subarray(V, V + AA);
      fA.set(GA);
    }
    function xA(V, AA, fA, GA) {
      V >>= 2, AA >>= 2, fA >>= 2;
      const HA = s.imageData = new Uint8ClampedArray(GA * 3), ge = s.HEAP32.subarray(V, V + GA), ie = s.HEAP32.subarray(AA, AA + GA), rt = s.HEAP32.subarray(fA, fA + GA);
      for (let ne = 0; ne < GA; ne++)
        HA[3 * ne] = ge[ne], HA[3 * ne + 1] = ie[ne], HA[3 * ne + 2] = rt[ne];
    }
    function KA(V, AA, fA, GA, HA) {
      V >>= 2, AA >>= 2, fA >>= 2, GA >>= 2;
      const ge = s.imageData = new Uint8ClampedArray(HA * 4), ie = s.HEAP32.subarray(V, V + HA), rt = s.HEAP32.subarray(AA, AA + HA), ne = s.HEAP32.subarray(fA, fA + HA), Ma = s.HEAP32.subarray(GA, GA + HA);
      for (let Xt = 0; Xt < HA; Xt++)
        ge[4 * Xt] = ie[Xt], ge[4 * Xt + 1] = rt[Xt], ge[4 * Xt + 2] = ne[Xt], ge[4 * Xt + 3] = Ma[Xt];
    }
    var UA = () => 2147483648, OA = (V, AA) => Math.ceil(V / AA) * AA, re = (V) => {
      var AA = Q.buffer, fA = (V - AA.byteLength + 65535) / 65536 | 0;
      try {
        return Q.grow(fA), m(), 1;
      } catch {
      }
    }, Ve = (V) => {
      var AA = u.length;
      V >>>= 0;
      var fA = UA();
      if (V > fA)
        return !1;
      for (var GA = 1; GA <= 4; GA *= 2) {
        var HA = AA * (1 + 0.2 / GA);
        HA = Math.min(HA, V + 100663296);
        var ge = Math.min(fA, OA(Math.max(V, HA), 65536)), ie = re(ge);
        if (ie)
          return !0;
      }
      return !1;
    }, d0 = {}, Ga = () => g || "./this.program", yi = () => {
      if (!yi.strings) {
        var V = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", AA = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: V,
          _: Ga()
        };
        for (var fA in d0)
          d0[fA] === void 0 ? delete AA[fA] : AA[fA] = d0[fA];
        var GA = [];
        for (var fA in AA)
          GA.push(`${fA}=${AA[fA]}`);
        yi.strings = GA;
      }
      return yi.strings;
    }, Er = (V, AA) => {
      for (var fA = 0; fA < V.length; ++fA)
        d[AA++] = V.charCodeAt(fA);
      d[AA] = 0;
    }, fh = (V, AA) => {
      var fA = 0;
      return yi().forEach((GA, HA) => {
        var ge = AA + fA;
        x[V + HA * 4 >> 2] = ge, Er(GA, ge), fA += GA.length + 1;
      }), 0;
    }, uh = (V, AA) => {
      var fA = yi();
      x[V >> 2] = fA.length;
      var GA = 0;
      return fA.forEach((HA) => GA += HA.length + 1), x[AA >> 2] = GA, 0;
    }, dh = (V) => 52;
    function xh(V, AA, fA, GA, HA) {
      return 70;
    }
    var mh = [null, [], []], wo = typeof TextDecoder < "u" ? new TextDecoder() : void 0, bo = (V, AA = 0, fA = NaN) => {
      for (var GA = AA + fA, HA = AA; V[HA] && !(HA >= GA); ) ++HA;
      if (HA - AA > 16 && V.buffer && wo)
        return wo.decode(V.subarray(AA, HA));
      for (var ge = ""; AA < HA; ) {
        var ie = V[AA++];
        if (!(ie & 128)) {
          ge += String.fromCharCode(ie);
          continue;
        }
        var rt = V[AA++] & 63;
        if ((ie & 224) == 192) {
          ge += String.fromCharCode((ie & 31) << 6 | rt);
          continue;
        }
        var ne = V[AA++] & 63;
        if ((ie & 240) == 224 ? ie = (ie & 15) << 12 | rt << 6 | ne : ie = (ie & 7) << 18 | rt << 12 | ne << 6 | V[AA++] & 63, ie < 65536)
          ge += String.fromCharCode(ie);
        else {
          var Ma = ie - 65536;
          ge += String.fromCharCode(55296 | Ma >> 10, 56320 | Ma & 1023);
        }
      }
      return ge;
    }, ph = (V, AA) => {
      var fA = mh[V];
      AA === 0 || AA === 10 ? ((V === 1 ? c : l)(bo(fA)), fA.length = 0) : fA.push(AA);
    }, Do = (V, AA) => V ? bo(u, V, AA) : "", yh = (V, AA, fA, GA) => {
      for (var HA = 0, ge = 0; ge < fA; ge++) {
        var ie = x[AA >> 2], rt = x[AA + 4 >> 2];
        AA += 8;
        for (var ne = 0; ne < rt; ne++)
          ph(V, u[ie + ne]);
        HA += rt;
      }
      return x[GA >> 2] = HA, 0;
    };
    function wh(V, AA) {
      V >>= 2;
      const fA = s.imageData = new Uint8ClampedArray(AA * 4), GA = s.HEAP32.subarray(V, V + AA);
      for (let HA = 0; HA < AA; HA++)
        fA[4 * HA] = fA[4 * HA + 1] = fA[4 * HA + 2] = GA[HA], fA[4 * HA + 3] = 255;
    }
    function bh(V, AA, fA) {
      V >>= 2, AA >>= 2;
      const GA = s.imageData = new Uint8ClampedArray(fA * 4), HA = s.HEAP32.subarray(V, V + fA), ge = s.HEAP32.subarray(AA, AA + fA);
      for (let ie = 0; ie < fA; ie++)
        GA[4 * ie] = GA[4 * ie + 1] = GA[4 * ie + 2] = HA[ie], GA[4 * ie + 3] = ge[ie];
    }
    function Dh(V) {
      const AA = Do(V);
      (s.warn || console.warn)(`OpenJPEG: ${AA}`);
    }
    function kh(V, AA, fA, GA) {
      V >>= 2, AA >>= 2, fA >>= 2;
      const HA = s.imageData = new Uint8ClampedArray(GA * 4), ge = s.HEAP32.subarray(V, V + GA), ie = s.HEAP32.subarray(AA, AA + GA), rt = s.HEAP32.subarray(fA, fA + GA);
      for (let ne = 0; ne < GA; ne++)
        HA[4 * ne] = ge[ne], HA[4 * ne + 1] = ie[ne], HA[4 * ne + 2] = rt[ne], HA[4 * ne + 3] = 255;
    }
    function Sh(V) {
      const AA = Do(V);
      s.errorMessages ? s.errorMessages += `
` + AA : s.errorMessages = AA;
    }
    var Fh = {
      m: z,
      c: W,
      l: CA,
      n: NA,
      g: ue,
      f: xA,
      e: KA,
      o: Ve,
      p: fh,
      q: uh,
      r: dh,
      j: xh,
      b: yh,
      s: wh,
      i: bh,
      d: Dh,
      k: uA,
      h: kh,
      a: Sh
    }, ri = J();
    ri.u, s._malloc = ri.v, s._free = ri.w, s._jp2_decode = ri.y;
    var Rh = ri.z, Na;
    S = function V() {
      Na || ko(), Na || (S = V);
    };
    function ko() {
      if (G > 0 || (y(), G > 0))
        return;
      function V() {
        var AA;
        Na || (Na = !0, s.calledRun = !0, !E && (H(), a(s), (AA = s.onRuntimeInitialized) == null || AA.call(s), N()));
      }
      s.setStatus ? (s.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => s.setStatus(""), 1), V();
      }, 1)) : V();
    }
    if (s.preInit)
      for (typeof s.preInit == "function" && (s.preInit = [s.preInit]); s.preInit.length > 0; )
        s.preInit.pop()();
    return ko(), i = s, i;
  };
})();
const nB = aB;
class _o extends At {
  constructor(A) {
    super(A, "JpxError");
  }
}
var _0;
class tr {
  static decode(A, t) {
    t || (t = {}), PA(this, _0) || wt(this, _0, nB({
      warn: k
    }));
    const i = PA(this, _0).decode(A, t);
    if (typeof i == "string")
      throw new _o(i);
    return i;
  }
  static cleanup() {
    wt(this, _0, null);
  }
  static parseImageProperties(A) {
    let t = A.getByte();
    for (; t >= 0; ) {
      const i = t;
      if (t = A.getByte(), (i << 8 | t) === 65361) {
        A.skip(4);
        const a = A.getInt32() >>> 0, n = A.getInt32() >>> 0, r = A.getInt32() >>> 0, g = A.getInt32() >>> 0;
        A.skip(16);
        const o = A.getUint16();
        return {
          width: a - r,
          height: n - g,
          bitsPerComponent: 8,
          componentsCount: o
        };
      }
    }
    throw new _o("No size marker found in JPX stream");
  }
}
_0 = new WeakMap(), ZA(tr, _0, null);
class rB extends $e {
  constructor(A, t, i) {
    super(t), this.stream = A, this.dict = A.dict, this.maybeLength = t, this.params = i;
  }
  get bytes() {
    return iA(this, "bytes", this.stream.getBytes(this.maybeLength));
  }
  ensureBuffer(A) {
  }
  readBlock(A) {
    this.decodeImage(null, A);
  }
  decodeImage(A, t) {
    return this.eof ? this.buffer : (A || (A = this.bytes), this.buffer = tr.decode(A, t), this.bufferLength = this.buffer.length, this.eof = !0, this.buffer);
  }
  get canAsyncDecodeImageFromBuffer() {
    return this.stream.isAsync;
  }
}
class zo extends $e {
  constructor(A, t, i) {
    super(t), this.str = A, this.dict = A.dict, this.cachedData = 0, this.bitsCached = 0;
    const s = 4096, a = {
      earlyChange: i,
      codeLength: 9,
      nextCode: 258,
      dictionaryValues: new Uint8Array(s),
      dictionaryLengths: new Uint16Array(s),
      dictionaryPrevCodes: new Uint16Array(s),
      currentSequence: new Uint8Array(s),
      currentSequenceLength: 0
    };
    for (let n = 0; n < 256; ++n)
      a.dictionaryValues[n] = n, a.dictionaryLengths[n] = 1;
    this.lzwState = a;
  }
  readBits(A) {
    let t = this.bitsCached, i = this.cachedData;
    for (; t < A; ) {
      const s = this.str.getByte();
      if (s === -1)
        return this.eof = !0, null;
      i = i << 8 | s, t += 8;
    }
    return this.bitsCached = t -= A, this.cachedData = i, this.lastCode = null, i >>> t & (1 << A) - 1;
  }
  readBlock() {
    let i = 1024, s, a, n;
    const r = this.lzwState;
    if (!r)
      return;
    const g = r.earlyChange;
    let o = r.nextCode;
    const I = r.dictionaryValues, c = r.dictionaryLengths, l = r.dictionaryPrevCodes;
    let h = r.codeLength, C = r.prevCode;
    const B = r.currentSequence;
    let Q = r.currentSequenceLength, E = 0, f = this.bufferLength, d = this.ensureBuffer(this.bufferLength + i);
    for (s = 0; s < 512; s++) {
      const u = this.readBits(h), x = Q > 0;
      if (u < 256)
        B[0] = u, Q = 1;
      else if (u >= 258)
        if (u < o)
          for (Q = c[u], a = Q - 1, n = u; a >= 0; a--)
            B[a] = I[n], n = l[n];
        else
          B[Q++] = B[0];
      else if (u === 256) {
        h = 9, o = 258, Q = 0;
        continue;
      } else {
        this.eof = !0, delete this.lzwState;
        break;
      }
      if (x && (l[o] = C, c[o] = c[C] + 1, I[o] = B[0], o++, h = o + g & o + g - 1 ? h : Math.min(Math.log(o + g) / 0.6931471805599453 + 1, 12) | 0), C = u, E += Q, i < E) {
        do
          i += 512;
        while (i < E);
        d = this.ensureBuffer(this.bufferLength + i);
      }
      for (a = 0; a < Q; a++)
        d[f++] = B[a];
    }
    r.nextCode = o, r.codeLength = h, r.prevCode = C, r.currentSequenceLength = Q, this.bufferLength = f;
  }
}
class $o extends $e {
  constructor(A, t, i) {
    if (super(t), !(i instanceof R))
      return A;
    const s = this.predictor = i.get("Predictor") || 1;
    if (s <= 1)
      return A;
    if (s !== 2 && (s < 10 || s > 15))
      throw new v(`Unsupported predictor: ${s}`);
    this.readBlock = s === 2 ? this.readBlockTiff : this.readBlockPng, this.str = A, this.dict = A.dict;
    const a = this.colors = i.get("Colors") || 1, n = this.bits = i.get("BPC", "BitsPerComponent") || 8, r = this.columns = i.get("Columns") || 1;
    return this.pixBytes = a * n + 7 >> 3, this.rowBytes = r * a * n + 7 >> 3, this;
  }
  readBlockTiff() {
    const A = this.rowBytes, t = this.bufferLength, i = this.ensureBuffer(t + A), s = this.bits, a = this.colors, n = this.str.getBytes(A);
    if (this.eof = !n.length, this.eof)
      return;
    let r = 0, g = 0, o = 0, I = 0, c = t, l;
    if (s === 1 && a === 1)
      for (l = 0; l < A; ++l) {
        let h = n[l] ^ r;
        h ^= h >> 1, h ^= h >> 2, h ^= h >> 4, r = (h & 1) << 7, i[c++] = h;
      }
    else if (s === 8) {
      for (l = 0; l < a; ++l)
        i[c++] = n[l];
      for (; l < A; ++l)
        i[c] = i[c - a] + n[l], c++;
    } else if (s === 16) {
      const h = a * 2;
      for (l = 0; l < h; ++l)
        i[c++] = n[l];
      for (; l < A; l += 2) {
        const C = ((n[l] & 255) << 8) + (n[l + 1] & 255) + ((i[c - h] & 255) << 8) + (i[c - h + 1] & 255);
        i[c++] = C >> 8 & 255, i[c++] = C & 255;
      }
    } else {
      const h = new Uint8Array(a + 1), C = (1 << s) - 1;
      let B = 0, Q = t;
      const E = this.columns;
      for (l = 0; l < E; ++l)
        for (let f = 0; f < a; ++f)
          o < s && (r = r << 8 | n[B++] & 255, o += 8), h[f] = h[f] + (r >> o - s) & C, o -= s, g = g << s | h[f], I += s, I >= 8 && (i[Q++] = g >> I - 8 & 255, I -= 8);
      I > 0 && (i[Q++] = (g << 8 - I) + (r & (1 << 8 - I) - 1));
    }
    this.bufferLength += A;
  }
  readBlockPng() {
    const A = this.rowBytes, t = this.pixBytes, i = this.str.getByte(), s = this.str.getBytes(A);
    if (this.eof = !s.length, this.eof)
      return;
    const a = this.bufferLength, n = this.ensureBuffer(a + A);
    let r = n.subarray(a - A, a);
    r.length === 0 && (r = new Uint8Array(A));
    let g, o = a, I, c;
    switch (i) {
      case 0:
        for (g = 0; g < A; ++g)
          n[o++] = s[g];
        break;
      case 1:
        for (g = 0; g < t; ++g)
          n[o++] = s[g];
        for (; g < A; ++g)
          n[o] = n[o - t] + s[g] & 255, o++;
        break;
      case 2:
        for (g = 0; g < A; ++g)
          n[o++] = r[g] + s[g] & 255;
        break;
      case 3:
        for (g = 0; g < t; ++g)
          n[o++] = (r[g] >> 1) + s[g];
        for (; g < A; ++g)
          n[o] = (r[g] + n[o - t] >> 1) + s[g] & 255, o++;
        break;
      case 4:
        for (g = 0; g < t; ++g)
          I = r[g], c = s[g], n[o++] = I + c;
        for (; g < A; ++g) {
          I = r[g];
          const l = r[g - t], h = n[o - t], C = h + I - l;
          let B = C - h;
          B < 0 && (B = -B);
          let Q = C - I;
          Q < 0 && (Q = -Q);
          let E = C - l;
          E < 0 && (E = -E), c = s[g], B <= Q && B <= E ? n[o++] = h + c : Q <= E ? n[o++] = I + c : n[o++] = l + c;
        }
        break;
      default:
        throw new v(`Unsupported predictor: ${i}`);
    }
    this.bufferLength += A;
  }
}
class gB extends $e {
  constructor(A, t) {
    super(t), this.str = A, this.dict = A.dict;
  }
  readBlock() {
    const A = this.str.getBytes(2);
    if (!A || A.length < 2 || A[0] === 128) {
      this.eof = !0;
      return;
    }
    let t, i = this.bufferLength, s = A[0];
    if (s < 128) {
      if (t = this.ensureBuffer(i + s + 1), t[i++] = A[1], s > 0) {
        const a = this.str.getBytes(s);
        t.set(a, i), i += s;
      }
    } else {
      s = 257 - s;
      const a = A[1];
      t = this.ensureBuffer(i + s + 1);
      for (let n = 0; n < s; n++)
        t[i++] = a;
    }
    this.bufferLength = i;
  }
}
const oB = 1e3;
function IB(e) {
  const A = [], t = e.length;
  let i = 0;
  for (; i < t - 1; )
    A.push(e[i++] << 8 | e[i++]);
  return i < t && A.push(e[i]), t + "_" + String.fromCharCode.apply(null, A);
}
var Vn, Jc;
class Si {
  constructor({
    lexer: A,
    xref: t,
    allowStreams: i = !1,
    recoveryMode: s = !1
  }) {
    ZA(this, Vn);
    this.lexer = A, this.xref = t, this.allowStreams = i, this.recoveryMode = s, this.imageCache = /* @__PURE__ */ Object.create(null), this._imageId = 0, this.refill();
  }
  refill() {
    this.buf1 = this.lexer.getObj(), this.buf2 = this.lexer.getObj();
  }
  shift() {
    this.buf2 instanceof be && this.buf2.cmd === "ID" ? (this.buf1 = this.buf2, this.buf2 = null) : (this.buf1 = this.buf2, this.buf2 = this.lexer.getObj());
  }
  tryShift() {
    try {
      return this.shift(), !0;
    } catch (A) {
      if (A instanceof oe)
        throw A;
      return !1;
    }
  }
  getObj(A = null) {
    const t = this.buf1;
    if (this.shift(), t instanceof be)
      switch (t.cmd) {
        case "BI":
          return this.makeInlineImage(A);
        case "[":
          const i = [];
          for (; !Ge(this.buf1, "]") && this.buf1 !== Le; )
            i.push(this.getObj(A));
          if (this.buf1 === Le) {
            if (this.recoveryMode)
              return i;
            throw new Xr("End of file inside array.");
          }
          return this.shift(), i;
        case "<<":
          const s = new R(this.xref);
          for (; !Ge(this.buf1, ">>") && this.buf1 !== Le; ) {
            if (!(this.buf1 instanceof L)) {
              vA("Malformed dictionary: key must be a name object"), this.shift();
              continue;
            }
            const a = this.buf1.name;
            if (this.shift(), this.buf1 === Le)
              break;
            s.set(a, this.getObj(A));
          }
          if (this.buf1 === Le) {
            if (this.recoveryMode)
              return s;
            throw new Xr("End of file inside dictionary.");
          }
          return Ge(this.buf2, "stream") ? this.allowStreams ? this.makeStream(s, A) : s : (this.shift(), s);
        default:
          return t;
      }
    if (Number.isInteger(t)) {
      if (Number.isInteger(this.buf1) && Ge(this.buf2, "R")) {
        const i = nA.get(t, this.buf1);
        return this.shift(), this.shift(), i;
      }
      return t;
    }
    return typeof t == "string" && A ? A.decryptString(t) : t;
  }
  findDefaultInlineStreamEnd(A) {
    const {
      knownCommands: g
    } = this.lexer, o = A.pos, I = 15;
    let c = 0, l, h;
    for (; (l = A.getByte()) !== -1; )
      if (c === 0)
        c = l === 69 ? 1 : 0;
      else if (c === 1)
        c = l === 73 ? 2 : 0;
      else if (l === 32 || l === 10 || l === 13) {
        h = A.pos;
        const B = A.peekBytes(I), Q = B.length;
        if (Q === 0)
          break;
        for (let d = 0; d < Q; d++)
          if (l = B[d], !(l === 0 && B[d + 1] !== 0) && l !== 10 && l !== 13 && (l < 32 || l > 127)) {
            c = 0;
            break;
          }
        if (c !== 2)
          continue;
        if (!g) {
          k("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          continue;
        }
        const E = new qt(new Qe(B.slice()), g);
        E._hexStringWarn = () => {
        };
        let f = 0;
        for (; ; ) {
          const d = E.getObj();
          if (d === Le) {
            c = 0;
            break;
          }
          if (d instanceof be) {
            const u = g[d.cmd];
            if (u) {
              if (u.variableArgs ? f <= u.numArgs : f === u.numArgs)
                break;
            } else {
              c = 0;
              break;
            }
            f = 0;
            continue;
          }
          f++;
        }
        if (c === 2)
          break;
      } else
        c = 0;
    l === -1 && (k("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker"), h && (k('... trying to recover by using the last "EI" occurrence.'), A.skip(-(A.pos - h))));
    let C = 4;
    return A.skip(-C), l = A.peekByte(), A.skip(C), mt(l) || C--, A.pos - C - o;
  }
  findDCTDecodeInlineStreamEnd(A) {
    const t = A.pos;
    let i = !1, s, a;
    for (; (s = A.getByte()) !== -1; )
      if (s === 255) {
        switch (A.getByte()) {
          case 0:
            break;
          case 255:
            A.skip(-1);
            break;
          case 217:
            i = !0;
            break;
          case 192:
          case 193:
          case 194:
          case 195:
          case 197:
          case 198:
          case 199:
          case 201:
          case 202:
          case 203:
          case 205:
          case 206:
          case 207:
          case 196:
          case 204:
          case 218:
          case 219:
          case 220:
          case 221:
          case 222:
          case 223:
          case 224:
          case 225:
          case 226:
          case 227:
          case 228:
          case 229:
          case 230:
          case 231:
          case 232:
          case 233:
          case 234:
          case 235:
          case 236:
          case 237:
          case 238:
          case 239:
          case 254:
            a = A.getUint16(), a > 2 ? A.skip(a - 2) : A.skip(-2);
            break;
        }
        if (i)
          break;
      }
    const n = A.pos - t;
    return s === -1 ? (k("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead."), A.skip(-n), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), n);
  }
  findASCII85DecodeInlineStreamEnd(A) {
    const s = A.pos;
    let a;
    for (; (a = A.getByte()) !== -1; )
      if (a === 126) {
        const r = A.pos;
        for (a = A.peekByte(); mt(a); )
          A.skip(), a = A.peekByte();
        if (a === 62) {
          A.skip();
          break;
        }
        if (A.pos > r) {
          const g = A.peekBytes(2);
          if (g[0] === 69 && g[1] === 73)
            break;
        }
      }
    const n = A.pos - s;
    return a === -1 ? (k("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead."), A.skip(-n), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), n);
  }
  findASCIIHexDecodeInlineStreamEnd(A) {
    const i = A.pos;
    let s;
    for (; (s = A.getByte()) !== -1 && s !== 62; )
      ;
    const a = A.pos - i;
    return s === -1 ? (k("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead."), A.skip(-a), this.findDefaultInlineStreamEnd(A)) : (this.inlineStreamSkipEI(A), a);
  }
  inlineStreamSkipEI(A) {
    let s = 0, a;
    for (; (a = A.getByte()) !== -1; )
      if (s === 0)
        s = a === 69 ? 1 : 0;
      else if (s === 1)
        s = a === 73 ? 2 : 0;
      else if (s === 2)
        break;
  }
  makeInlineImage(A) {
    const t = this.lexer, i = t.stream, s = /* @__PURE__ */ Object.create(null);
    let a;
    for (; !Ge(this.buf1, "ID") && this.buf1 !== Le; ) {
      if (!(this.buf1 instanceof L))
        throw new v("Dictionary key must be a name object");
      const h = this.buf1.name;
      if (this.shift(), this.buf1 === Le)
        break;
      s[h] = this.getObj(A);
    }
    t.beginInlineImagePos !== -1 && (a = i.pos - t.beginInlineImagePos);
    const n = this.xref.fetchIfRef(s.F || s.Filter);
    let r;
    if (n instanceof L)
      r = n.name;
    else if (Array.isArray(n)) {
      const h = this.xref.fetchIfRef(n[0]);
      h instanceof L && (r = h.name);
    }
    const g = i.pos;
    let o;
    switch (r) {
      case "DCT":
      case "DCTDecode":
        o = this.findDCTDecodeInlineStreamEnd(i);
        break;
      case "A85":
      case "ASCII85Decode":
        o = this.findASCII85DecodeInlineStreamEnd(i);
        break;
      case "AHx":
      case "ASCIIHexDecode":
        o = this.findASCIIHexDecodeInlineStreamEnd(i);
        break;
      default:
        o = this.findDefaultInlineStreamEnd(i);
    }
    let I;
    if (o < oB && a > 0) {
      const h = i.pos;
      i.pos = t.beginInlineImagePos, I = IB(i.getBytes(a + o)), i.pos = h;
      const C = this.imageCache[I];
      if (C !== void 0)
        return this.buf2 = be.get("EI"), this.shift(), C.reset(), C;
    }
    const c = new R(this.xref);
    for (const h in s)
      c.set(h, s[h]);
    let l = i.makeSubStream(g, o, c);
    return A && (l = A.createStream(l, o)), l = this.filter(l, c, o), l.dict = c, I !== void 0 && (l.cacheKey = `inline_img_${++this._imageId}`, this.imageCache[I] = l), this.buf2 = be.get("EI"), this.shift(), l;
  }
  makeStream(A, t) {
    const i = this.lexer;
    let s = i.stream;
    i.skipToNextLine();
    const a = s.pos - 1;
    let n = A.get("Length");
    if (Number.isInteger(n) || (vA(`Bad length "${n && n.toString()}" in stream.`), n = 0), s.pos = a + n, i.nextChar(), this.tryShift() && Ge(this.buf2, "endstream"))
      this.shift();
    else {
      if (n = BA(this, Vn, Jc).call(this, a), n < 0)
        throw new v("Missing endstream command.");
      i.nextChar(), this.shift(), this.shift();
    }
    return this.shift(), s = s.makeSubStream(a, n, A), t && (s = t.createStream(s, n)), s = this.filter(s, A, n), s.dict = A, s;
  }
  filter(A, t, i) {
    let s = t.get("F", "Filter"), a = t.get("DP", "DecodeParms");
    if (s instanceof L)
      return Array.isArray(a) && k("/DecodeParms should not be an Array, when /Filter is a Name."), this.makeFilter(A, s.name, i, a);
    let n = i;
    if (Array.isArray(s)) {
      const r = s, g = a;
      for (let o = 0, I = r.length; o < I; ++o) {
        if (s = this.xref.fetchIfRef(r[o]), !(s instanceof L))
          throw new v(`Bad filter name "${s}"`);
        a = null, Array.isArray(g) && o in g && (a = this.xref.fetchIfRef(g[o])), A = this.makeFilter(A, s.name, n, a), n = null;
      }
    }
    return A;
  }
  makeFilter(A, t, i, s) {
    if (i === 0)
      return k(`Empty "${t}" stream.`), new $r();
    try {
      switch (t) {
        case "Fl":
        case "FlateDecode":
          return s ? new $o(new Oo(A, i), i, s) : new Oo(A, i);
        case "LZW":
        case "LZWDecode":
          let a = 1;
          return s ? (s.has("EarlyChange") && (a = s.get("EarlyChange")), new $o(new zo(A, i, a), i, s)) : new zo(A, i, a);
        case "DCT":
        case "DCTDecode":
          return new ts(A, i, s);
        case "JPX":
        case "JPXDecode":
          return new rB(A, i, s);
        case "A85":
        case "ASCII85Decode":
          return new mC(A, i);
        case "AHx":
        case "ASCIIHexDecode":
          return new pC(A, i);
        case "CCF":
        case "CCITTFaxDecode":
          return new yC(A, i, s);
        case "RL":
        case "RunLengthDecode":
          return new gB(A, i);
        case "JBIG2Decode":
          return new jC(A, i, s);
      }
      return k(`Filter "${t}" is not supported.`), A;
    } catch (a) {
      if (a instanceof oe)
        throw a;
      return k(`Invalid stream: "${a}"`), new $r();
    }
  }
}
Vn = new WeakSet(), Jc = function(A) {
  const {
    stream: t
  } = this.lexer;
  t.pos = A;
  const i = 2048, s = 9, a = new Uint8Array([101, 110, 100]), n = a.length, r = [new Uint8Array([115, 116, 114, 101, 97, 109]), new Uint8Array([115, 116, 101, 97, 109]), new Uint8Array([115, 116, 114, 101, 97])], g = s - n;
  for (; t.pos < t.end; ) {
    const o = t.peekBytes(i), I = o.length - s;
    if (I <= 0)
      break;
    let c = 0;
    for (; c < I; ) {
      let l = 0;
      for (; l < n && o[c + l] === a[l]; )
        l++;
      if (l >= n) {
        let h = !1;
        for (const C of r) {
          const B = C.length;
          let Q = 0;
          for (; Q < B && o[c + l + Q] === C[Q]; )
            Q++;
          if (Q >= g) {
            h = !0;
            break;
          }
          if (Q >= B) {
            const E = o[c + l + Q];
            mt(E) && (vA(`Found "${ct([...a, ...C])}" when searching for endstream command.`), h = !0);
            break;
          }
        }
        if (h)
          return t.pos += c, t.pos - A;
      }
      c++;
    }
    t.pos += I;
  }
  return -1;
};
const y0 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
function mr(e) {
  return e >= 48 && e <= 57 ? e & 15 : e >= 65 && e <= 70 || e >= 97 && e <= 102 ? (e & 15) + 9 : -1;
}
class qt {
  constructor(A, t = null) {
    this.stream = A, this.nextChar(), this.strBuf = [], this.knownCommands = t, this._hexStringNumWarn = 0, this.beginInlineImagePos = -1;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  peekChar() {
    return this.stream.peekByte();
  }
  getNumber() {
    let A = this.currentChar, t = !1, i = 0, s = 1;
    if (A === 45 ? (s = -1, A = this.nextChar(), A === 45 && (A = this.nextChar())) : A === 43 && (A = this.nextChar()), A === 10 || A === 13)
      do
        A = this.nextChar();
      while (A === 10 || A === 13);
    if (A === 46 && (i = 10, A = this.nextChar()), A < 48 || A > 57) {
      const g = `Invalid number: ${String.fromCharCode(A)} (charCode ${A})`;
      if (mt(A) || A === -1)
        return vA(`Lexer.getNumber - "${g}".`), 0;
      throw new v(g);
    }
    let a = A - 48, n = 0, r = 1;
    for (; (A = this.nextChar()) >= 0; )
      if (A >= 48 && A <= 57) {
        const g = A - 48;
        t ? n = n * 10 + g : (i !== 0 && (i *= 10), a = a * 10 + g);
      } else if (A === 46)
        if (i === 0)
          i = 1;
        else
          break;
      else if (A === 45)
        k("Badly formatted number: minus sign in the middle");
      else if (A === 69 || A === 101) {
        if (A = this.peekChar(), A === 43 || A === 45)
          r = A === 45 ? -1 : 1, this.nextChar();
        else if (A < 48 || A > 57)
          break;
        t = !0;
      } else
        break;
    return i !== 0 && (a /= i), t && (a *= 10 ** (r * n)), s * a;
  }
  getString() {
    let A = 1, t = !1;
    const i = this.strBuf;
    i.length = 0;
    let s = this.nextChar();
    for (; ; ) {
      let a = !1;
      switch (s | 0) {
        case -1:
          k("Unterminated string"), t = !0;
          break;
        case 40:
          ++A, i.push("(");
          break;
        case 41:
          --A === 0 ? (this.nextChar(), t = !0) : i.push(")");
          break;
        case 92:
          switch (s = this.nextChar(), s) {
            case -1:
              k("Unterminated string"), t = !0;
              break;
            case 110:
              i.push(`
`);
              break;
            case 114:
              i.push("\r");
              break;
            case 116:
              i.push("	");
              break;
            case 98:
              i.push("\b");
              break;
            case 102:
              i.push("\f");
              break;
            case 92:
            case 40:
            case 41:
              i.push(String.fromCharCode(s));
              break;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
              let n = s & 15;
              s = this.nextChar(), a = !0, s >= 48 && s <= 55 && (n = (n << 3) + (s & 15), s = this.nextChar(), s >= 48 && s <= 55 && (a = !1, n = (n << 3) + (s & 15))), i.push(String.fromCharCode(n));
              break;
            case 13:
              this.peekChar() === 10 && this.nextChar();
              break;
            case 10:
              break;
            default:
              i.push(String.fromCharCode(s));
              break;
          }
          break;
        default:
          i.push(String.fromCharCode(s));
          break;
      }
      if (t)
        break;
      a || (s = this.nextChar());
    }
    return i.join("");
  }
  getName() {
    let A, t;
    const i = this.strBuf;
    for (i.length = 0; (A = this.nextChar()) >= 0 && !y0[A]; )
      if (A === 35) {
        if (A = this.nextChar(), y0[A]) {
          k("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number."), i.push("#");
          break;
        }
        const s = mr(A);
        if (s !== -1) {
          t = A, A = this.nextChar();
          const a = mr(A);
          if (a === -1) {
            if (k(`Lexer_getName: Illegal digit (${String.fromCharCode(A)}) in hexadecimal number.`), i.push("#", String.fromCharCode(t)), y0[A])
              break;
            i.push(String.fromCharCode(A));
            continue;
          }
          i.push(String.fromCharCode(s << 4 | a));
        } else
          i.push("#", String.fromCharCode(A));
      } else
        i.push(String.fromCharCode(A));
    return i.length > 127 && k(`Name token is longer than allowed by the spec: ${i.length}`), L.get(i.join(""));
  }
  _hexStringWarn(A) {
    if (this._hexStringNumWarn++ === 5) {
      k("getHexString - ignoring additional invalid characters.");
      return;
    }
    this._hexStringNumWarn > 5 || k(`getHexString - ignoring invalid character: ${A}`);
  }
  getHexString() {
    const A = this.strBuf;
    A.length = 0;
    let t = this.currentChar, i = -1, s = -1;
    for (this._hexStringNumWarn = 0; ; )
      if (t < 0) {
        k("Unterminated hex string");
        break;
      } else if (t === 62) {
        this.nextChar();
        break;
      } else if (y0[t] === 1) {
        t = this.nextChar();
        continue;
      } else
        s = mr(t), s === -1 ? this._hexStringWarn(t) : i === -1 ? i = s : (A.push(String.fromCharCode(i << 4 | s)), i = -1), t = this.nextChar();
    return i !== -1 && A.push(String.fromCharCode(i << 4)), A.join("");
  }
  getObj() {
    let A = !1, t = this.currentChar;
    for (; ; ) {
      if (t < 0)
        return Le;
      if (A)
        (t === 10 || t === 13) && (A = !1);
      else if (t === 37)
        A = !0;
      else if (y0[t] !== 1)
        break;
      t = this.nextChar();
    }
    switch (t | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return this.getNumber();
      case 40:
        return this.getString();
      case 47:
        return this.getName();
      case 91:
        return this.nextChar(), be.get("[");
      case 93:
        return this.nextChar(), be.get("]");
      case 60:
        return t = this.nextChar(), t === 60 ? (this.nextChar(), be.get("<<")) : this.getHexString();
      case 62:
        return t = this.nextChar(), t === 62 ? (this.nextChar(), be.get(">>")) : be.get(">");
      case 123:
        return this.nextChar(), be.get("{");
      case 125:
        return this.nextChar(), be.get("}");
      case 41:
        throw this.nextChar(), new v(`Illegal character: ${t}`);
    }
    let i = String.fromCharCode(t);
    if (t < 32 || t > 127) {
      const n = this.peekChar();
      if (n >= 32 && n <= 127)
        return this.nextChar(), be.get(i);
    }
    const s = this.knownCommands;
    let a = (s == null ? void 0 : s[i]) !== void 0;
    for (; (t = this.nextChar()) >= 0 && !y0[t]; ) {
      const n = i + String.fromCharCode(t);
      if (a && s[n] === void 0)
        break;
      if (i.length === 128)
        throw new v(`Command token too long: ${i.length}`);
      i = n, a = (s == null ? void 0 : s[i]) !== void 0;
    }
    return i === "true" ? !0 : i === "false" ? !1 : i === "null" ? null : (i === "BI" && (this.beginInlineImagePos = this.stream.pos), be.get(i));
  }
  skipToNextLine() {
    let A = this.currentChar;
    for (; A >= 0; ) {
      if (A === 13) {
        A = this.nextChar(), A === 10 && this.nextChar();
        break;
      } else if (A === 10) {
        this.nextChar();
        break;
      }
      A = this.nextChar();
    }
  }
}
class cB {
  static create(A) {
    function t(c, l, h = !1) {
      const C = c.get(l);
      if (Number.isInteger(C) && (h ? C >= 0 : C > 0))
        return C;
      throw new Error(`The "${l}" parameter in the linearization dictionary is invalid.`);
    }
    function i(c) {
      const l = c.get("H");
      let h;
      if (Array.isArray(l) && ((h = l.length) === 2 || h === 4)) {
        for (let C = 0; C < h; C++) {
          const B = l[C];
          if (!(Number.isInteger(B) && B > 0))
            throw new Error(`Hint (${C}) in the linearization dictionary is invalid.`);
        }
        return l;
      }
      throw new Error("Hint array in the linearization dictionary is invalid.");
    }
    const s = new Si({
      lexer: new qt(A),
      xref: null
    }), a = s.getObj(), n = s.getObj(), r = s.getObj(), g = s.getObj();
    let o, I;
    if (Number.isInteger(a) && Number.isInteger(n) && Ge(r, "obj") && g instanceof R && typeof (o = g.get("Linearized")) == "number" && o > 0) {
      if ((I = t(g, "L")) !== A.length)
        throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
    } else return null;
    return {
      length: I,
      hints: i(g),
      objectNumberFirst: t(g, "O"),
      endFirst: t(g, "E"),
      numPages: t(g, "N"),
      mainXRefEntriesOffset: t(g, "T"),
      pageFirst: g.has("P") ? t(g, "P", !0) : 0
    };
  }
}
const lB = ["Adobe-GB1-UCS2", "Adobe-CNS1-UCS2", "Adobe-Japan1-UCS2", "Adobe-Korea1-UCS2", "78-EUC-H", "78-EUC-V", "78-H", "78-RKSJ-H", "78-RKSJ-V", "78-V", "78ms-RKSJ-H", "78ms-RKSJ-V", "83pv-RKSJ-H", "90ms-RKSJ-H", "90ms-RKSJ-V", "90msp-RKSJ-H", "90msp-RKSJ-V", "90pv-RKSJ-H", "90pv-RKSJ-V", "Add-H", "Add-RKSJ-H", "Add-RKSJ-V", "Add-V", "Adobe-CNS1-0", "Adobe-CNS1-1", "Adobe-CNS1-2", "Adobe-CNS1-3", "Adobe-CNS1-4", "Adobe-CNS1-5", "Adobe-CNS1-6", "Adobe-GB1-0", "Adobe-GB1-1", "Adobe-GB1-2", "Adobe-GB1-3", "Adobe-GB1-4", "Adobe-GB1-5", "Adobe-Japan1-0", "Adobe-Japan1-1", "Adobe-Japan1-2", "Adobe-Japan1-3", "Adobe-Japan1-4", "Adobe-Japan1-5", "Adobe-Japan1-6", "Adobe-Korea1-0", "Adobe-Korea1-1", "Adobe-Korea1-2", "B5-H", "B5-V", "B5pc-H", "B5pc-V", "CNS-EUC-H", "CNS-EUC-V", "CNS1-H", "CNS1-V", "CNS2-H", "CNS2-V", "ETHK-B5-H", "ETHK-B5-V", "ETen-B5-H", "ETen-B5-V", "ETenms-B5-H", "ETenms-B5-V", "EUC-H", "EUC-V", "Ext-H", "Ext-RKSJ-H", "Ext-RKSJ-V", "Ext-V", "GB-EUC-H", "GB-EUC-V", "GB-H", "GB-V", "GBK-EUC-H", "GBK-EUC-V", "GBK2K-H", "GBK2K-V", "GBKp-EUC-H", "GBKp-EUC-V", "GBT-EUC-H", "GBT-EUC-V", "GBT-H", "GBT-V", "GBTpc-EUC-H", "GBTpc-EUC-V", "GBpc-EUC-H", "GBpc-EUC-V", "H", "HKdla-B5-H", "HKdla-B5-V", "HKdlb-B5-H", "HKdlb-B5-V", "HKgccs-B5-H", "HKgccs-B5-V", "HKm314-B5-H", "HKm314-B5-V", "HKm471-B5-H", "HKm471-B5-V", "HKscs-B5-H", "HKscs-B5-V", "Hankaku", "Hiragana", "KSC-EUC-H", "KSC-EUC-V", "KSC-H", "KSC-Johab-H", "KSC-Johab-V", "KSC-V", "KSCms-UHC-H", "KSCms-UHC-HW-H", "KSCms-UHC-HW-V", "KSCms-UHC-V", "KSCpc-EUC-H", "KSCpc-EUC-V", "Katakana", "NWP-H", "NWP-V", "RKSJ-H", "RKSJ-V", "Roman", "UniCNS-UCS2-H", "UniCNS-UCS2-V", "UniCNS-UTF16-H", "UniCNS-UTF16-V", "UniCNS-UTF32-H", "UniCNS-UTF32-V", "UniCNS-UTF8-H", "UniCNS-UTF8-V", "UniGB-UCS2-H", "UniGB-UCS2-V", "UniGB-UTF16-H", "UniGB-UTF16-V", "UniGB-UTF32-H", "UniGB-UTF32-V", "UniGB-UTF8-H", "UniGB-UTF8-V", "UniJIS-UCS2-H", "UniJIS-UCS2-HW-H", "UniJIS-UCS2-HW-V", "UniJIS-UCS2-V", "UniJIS-UTF16-H", "UniJIS-UTF16-V", "UniJIS-UTF32-H", "UniJIS-UTF32-V", "UniJIS-UTF8-H", "UniJIS-UTF8-V", "UniJIS2004-UTF16-H", "UniJIS2004-UTF16-V", "UniJIS2004-UTF32-H", "UniJIS2004-UTF32-V", "UniJIS2004-UTF8-H", "UniJIS2004-UTF8-V", "UniJISPro-UCS2-HW-V", "UniJISPro-UCS2-V", "UniJISPro-UTF8-V", "UniJISX0213-UTF32-H", "UniJISX0213-UTF32-V", "UniJISX02132004-UTF32-H", "UniJISX02132004-UTF32-V", "UniKS-UCS2-H", "UniKS-UCS2-V", "UniKS-UTF16-H", "UniKS-UTF16-V", "UniKS-UTF32-H", "UniKS-UTF32-V", "UniKS-UTF8-H", "UniKS-UTF8-V", "V", "WP-Symbol"], pr = 2 ** 24 - 1;
class Og {
  constructor(A = !1) {
    this.codespaceRanges = [[], [], [], []], this.numCodespaceRanges = 0, this._map = [], this.name = "", this.vertical = !1, this.useCMap = null, this.builtInCMap = A;
  }
  addCodespaceRange(A, t, i) {
    this.codespaceRanges[A - 1].push(t, i), this.numCodespaceRanges++;
  }
  mapCidRange(A, t, i) {
    if (t - A > pr)
      throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
    for (; A <= t; )
      this._map[A++] = i++;
  }
  mapBfRange(A, t, i) {
    if (t - A > pr)
      throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
    const s = i.length - 1;
    for (; A <= t; ) {
      this._map[A++] = i;
      const a = i.charCodeAt(s) + 1;
      if (a > 255) {
        i = i.substring(0, s - 1) + String.fromCharCode(i.charCodeAt(s - 1) + 1) + "\0";
        continue;
      }
      i = i.substring(0, s) + String.fromCharCode(a);
    }
  }
  mapBfRangeToArray(A, t, i) {
    if (t - A > pr)
      throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
    const s = i.length;
    let a = 0;
    for (; A <= t && a < s; )
      this._map[A] = i[a++], ++A;
  }
  mapOne(A, t) {
    this._map[A] = t;
  }
  lookup(A) {
    return this._map[A];
  }
  contains(A) {
    return this._map[A] !== void 0;
  }
  forEach(A) {
    const t = this._map, i = t.length;
    if (i <= 65536)
      for (let s = 0; s < i; s++)
        t[s] !== void 0 && A(s, t[s]);
    else
      for (const s in t)
        A(s, t[s]);
  }
  charCodeOf(A) {
    const t = this._map;
    if (t.length <= 65536)
      return t.indexOf(A);
    for (const i in t)
      if (t[i] === A)
        return i | 0;
    return -1;
  }
  getMap() {
    return this._map;
  }
  readCharCode(A, t, i) {
    let s = 0;
    const a = this.codespaceRanges;
    for (let n = 0, r = a.length; n < r; n++) {
      s = (s << 8 | A.charCodeAt(t + n)) >>> 0;
      const g = a[n];
      for (let o = 0, I = g.length; o < I; ) {
        const c = g[o++], l = g[o++];
        if (s >= c && s <= l) {
          i.charcode = s, i.length = n + 1;
          return;
        }
      }
    }
    i.charcode = 0, i.length = 1;
  }
  getCharCodeLength(A) {
    const t = this.codespaceRanges;
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i];
      for (let n = 0, r = a.length; n < r; ) {
        const g = a[n++], o = a[n++];
        if (A >= g && A <= o)
          return i + 1;
      }
    }
    return 1;
  }
  get length() {
    return this._map.length;
  }
  get isIdentityCMap() {
    if (!(this.name === "Identity-H" || this.name === "Identity-V") || this._map.length !== 65536)
      return !1;
    for (let A = 0; A < 65536; A++)
      if (this._map[A] !== A)
        return !1;
    return !0;
  }
}
class O0 extends Og {
  constructor(A, t) {
    super(), this.vertical = A, this.addCodespaceRange(t, 0, 65535);
  }
  mapCidRange(A, t, i) {
    WA("should not call mapCidRange");
  }
  mapBfRange(A, t, i) {
    WA("should not call mapBfRange");
  }
  mapBfRangeToArray(A, t, i) {
    WA("should not call mapBfRangeToArray");
  }
  mapOne(A, t) {
    WA("should not call mapCidOne");
  }
  lookup(A) {
    return Number.isInteger(A) && A <= 65535 ? A : void 0;
  }
  contains(A) {
    return Number.isInteger(A) && A <= 65535;
  }
  forEach(A) {
    for (let t = 0; t <= 65535; t++)
      A(t, t);
  }
  charCodeOf(A) {
    return Number.isInteger(A) && A <= 65535 ? A : -1;
  }
  getMap() {
    const A = new Array(65536);
    for (let t = 0; t <= 65535; t++)
      A[t] = t;
    return A;
  }
  get length() {
    return 65536;
  }
  get isIdentityCMap() {
    WA("should not access .isIdentityCMap");
  }
}
function Pi(e) {
  let A = 0;
  for (let t = 0; t < e.length; t++)
    A = A << 8 | e.charCodeAt(t);
  return A >>> 0;
}
function Q0(e) {
  if (typeof e != "string")
    throw new v("Malformed CMap: expected string.");
}
function Yc(e) {
  if (!Number.isInteger(e))
    throw new v("Malformed CMap: expected int.");
}
function hB(e, A) {
  for (; ; ) {
    let t = A.getObj();
    if (t === Le)
      break;
    if (Ge(t, "endbfchar"))
      return;
    Q0(t);
    const i = Pi(t);
    t = A.getObj(), Q0(t);
    const s = t;
    e.mapOne(i, s);
  }
}
function CB(e, A) {
  for (; ; ) {
    let t = A.getObj();
    if (t === Le)
      break;
    if (Ge(t, "endbfrange"))
      return;
    Q0(t);
    const i = Pi(t);
    t = A.getObj(), Q0(t);
    const s = Pi(t);
    if (t = A.getObj(), Number.isInteger(t) || typeof t == "string") {
      const a = Number.isInteger(t) ? String.fromCharCode(t) : t;
      e.mapBfRange(i, s, a);
    } else if (Ge(t, "[")) {
      t = A.getObj();
      const a = [];
      for (; !Ge(t, "]") && t !== Le; )
        a.push(t), t = A.getObj();
      e.mapBfRangeToArray(i, s, a);
    } else
      break;
  }
  throw new v("Invalid bf range.");
}
function BB(e, A) {
  for (; ; ) {
    let t = A.getObj();
    if (t === Le)
      break;
    if (Ge(t, "endcidchar"))
      return;
    Q0(t);
    const i = Pi(t);
    t = A.getObj(), Yc(t);
    const s = t;
    e.mapOne(i, s);
  }
}
function QB(e, A) {
  for (; ; ) {
    let t = A.getObj();
    if (t === Le)
      break;
    if (Ge(t, "endcidrange"))
      return;
    Q0(t);
    const i = Pi(t);
    t = A.getObj(), Q0(t);
    const s = Pi(t);
    t = A.getObj(), Yc(t);
    const a = t;
    e.mapCidRange(i, s, a);
  }
}
function EB(e, A) {
  for (; ; ) {
    let t = A.getObj();
    if (t === Le)
      break;
    if (Ge(t, "endcodespacerange"))
      return;
    if (typeof t != "string")
      break;
    const i = Pi(t);
    if (t = A.getObj(), typeof t != "string")
      break;
    const s = Pi(t);
    e.addCodespaceRange(t.length, i, s);
  }
  throw new v("Invalid codespace range.");
}
function fB(e, A) {
  const t = A.getObj();
  Number.isInteger(t) && (e.vertical = !!t);
}
function uB(e, A) {
  const t = A.getObj();
  t instanceof L && (e.name = t.name);
}
async function Kc(e, A, t, i) {
  let s, a;
  A: for (; ; )
    try {
      const n = A.getObj();
      if (n === Le)
        break;
      if (n instanceof L)
        n.name === "WMode" ? fB(e, A) : n.name === "CMapName" && uB(e, A), s = n;
      else if (n instanceof be)
        switch (n.cmd) {
          case "endcmap":
            break A;
          case "usecmap":
            s instanceof L && (a = s.name);
            break;
          case "begincodespacerange":
            EB(e, A);
            break;
          case "beginbfchar":
            hB(e, A);
            break;
          case "begincidchar":
            BB(e, A);
            break;
          case "beginbfrange":
            CB(e, A);
            break;
          case "begincidrange":
            QB(e, A);
            break;
        }
    } catch (n) {
      if (n instanceof oe)
        throw n;
      k("Invalid cMap data: " + n);
      continue;
    }
  return !i && a && (i = a), i ? vc(e, t, i) : e;
}
async function vc(e, A, t) {
  if (e.useCMap = await lg(t, A), e.numCodespaceRanges === 0) {
    const i = e.useCMap.codespaceRanges;
    for (let s = 0; s < i.length; s++)
      e.codespaceRanges[s] = i[s].slice();
    e.numCodespaceRanges = e.useCMap.numCodespaceRanges;
  }
  return e.useCMap.forEach(function(i, s) {
    e.contains(i) || e.mapOne(i, s);
  }), e;
}
async function lg(e, A) {
  if (e === "Identity-H")
    return new O0(!1, 2);
  if (e === "Identity-V")
    return new O0(!0, 2);
  if (!lB.includes(e))
    throw new Error("Unknown CMap name: " + e);
  if (!A)
    throw new Error("Built-in CMap parameters are not provided.");
  const {
    cMapData: t,
    isCompressed: i
  } = await A(e), s = new Og(!0);
  if (i)
    return new uC().process(t, s, (n) => vc(s, A, n));
  const a = new qt(new Qe(t));
  return Kc(s, a, A, null);
}
class qa {
  static async create({
    encoding: A,
    fetchBuiltInCMap: t,
    useCMap: i
  }) {
    if (A instanceof L)
      return lg(A.name, t);
    if (A instanceof JA) {
      const s = await Kc(new Og(), new qt(A), t, i);
      return s.isIdentityCMap ? lg(s.name, t) : s;
    }
    throw new Error("Encoding required.");
  }
}
const dB = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], xB = [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], mB = [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"], Tc = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], pB = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "centoldstyle", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "", "threequartersemdash", "", "questionsmall", "", "", "", "", "Ethsmall", "", "", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "", "", "", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hypheninferior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "asuperior", "centsuperior", "", "", "", "", "Aacutesmall", "Agravesmall", "Acircumflexsmall", "Adieresissmall", "Atildesmall", "Aringsmall", "Ccedillasmall", "Eacutesmall", "Egravesmall", "Ecircumflexsmall", "Edieresissmall", "Iacutesmall", "Igravesmall", "Icircumflexsmall", "Idieresissmall", "Ntildesmall", "Oacutesmall", "Ogravesmall", "Ocircumflexsmall", "Odieresissmall", "Otildesmall", "Uacutesmall", "Ugravesmall", "Ucircumflexsmall", "Udieresissmall", "", "eightsuperior", "fourinferior", "threeinferior", "sixinferior", "eightinferior", "seveninferior", "Scaronsmall", "", "centinferior", "twoinferior", "", "Dieresissmall", "", "Caronsmall", "osuperior", "fiveinferior", "", "commainferior", "periodinferior", "Yacutesmall", "", "dollarinferior", "", "", "Thornsmall", "", "nineinferior", "zeroinferior", "Zcaronsmall", "AEsmall", "Oslashsmall", "questiondownsmall", "oneinferior", "Lslashsmall", "", "", "", "", "", "", "Cedillasmall", "", "", "", "", "", "OEsmall", "figuredash", "hyphensuperior", "", "", "", "", "exclamdownsmall", "", "Ydieresissmall", "", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "ninesuperior", "zerosuperior", "", "esuperior", "rsuperior", "tsuperior", "", "", "isuperior", "ssuperior", "dsuperior", "", "", "", "", "", "lsuperior", "Ogoneksmall", "Brevesmall", "Macronsmall", "bsuperior", "nsuperior", "msuperior", "commasuperior", "periodsuperior", "Dotaccentsmall", "Ringsmall", "", "", "", ""], Vg = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "space", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron"], Ei = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls", "", "", "", ""], js = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "bullet", "Euro", "bullet", "quotesinglbase", "florin", "quotedblbase", "ellipsis", "dagger", "daggerdbl", "circumflex", "perthousand", "Scaron", "guilsinglleft", "OE", "bullet", "Zcaron", "bullet", "bullet", "quoteleft", "quoteright", "quotedblleft", "quotedblright", "bullet", "endash", "emdash", "tilde", "trademark", "scaron", "guilsinglright", "oe", "bullet", "zcaron", "Ydieresis", "space", "exclamdown", "cent", "sterling", "currency", "yen", "brokenbar", "section", "dieresis", "copyright", "ordfeminine", "guillemotleft", "logicalnot", "hyphen", "registered", "macron", "degree", "plusminus", "twosuperior", "threesuperior", "acute", "mu", "paragraph", "periodcentered", "cedilla", "onesuperior", "ordmasculine", "guillemotright", "onequarter", "onehalf", "threequarters", "questiondown", "Agrave", "Aacute", "Acircumflex", "Atilde", "Adieresis", "Aring", "AE", "Ccedilla", "Egrave", "Eacute", "Ecircumflex", "Edieresis", "Igrave", "Iacute", "Icircumflex", "Idieresis", "Eth", "Ntilde", "Ograve", "Oacute", "Ocircumflex", "Otilde", "Odieresis", "multiply", "Oslash", "Ugrave", "Uacute", "Ucircumflex", "Udieresis", "Yacute", "Thorn", "germandbls", "agrave", "aacute", "acircumflex", "atilde", "adieresis", "aring", "ae", "ccedilla", "egrave", "eacute", "ecircumflex", "edieresis", "igrave", "iacute", "icircumflex", "idieresis", "eth", "ntilde", "ograve", "oacute", "ocircumflex", "otilde", "odieresis", "divide", "oslash", "ugrave", "uacute", "ucircumflex", "udieresis", "yacute", "thorn", "ydieresis"], Zg = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "universal", "numbersign", "existential", "percent", "ampersand", "suchthat", "parenleft", "parenright", "asteriskmath", "plus", "comma", "minus", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "congruent", "Alpha", "Beta", "Chi", "Delta", "Epsilon", "Phi", "Gamma", "Eta", "Iota", "theta1", "Kappa", "Lambda", "Mu", "Nu", "Omicron", "Pi", "Theta", "Rho", "Sigma", "Tau", "Upsilon", "sigma1", "Omega", "Xi", "Psi", "Zeta", "bracketleft", "therefore", "bracketright", "perpendicular", "underscore", "radicalex", "alpha", "beta", "chi", "delta", "epsilon", "phi", "gamma", "eta", "iota", "phi1", "kappa", "lambda", "mu", "nu", "omicron", "pi", "theta", "rho", "sigma", "tau", "upsilon", "omega1", "omega", "xi", "psi", "zeta", "braceleft", "bar", "braceright", "similar", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Euro", "Upsilon1", "minute", "lessequal", "fraction", "infinity", "florin", "club", "diamond", "heart", "spade", "arrowboth", "arrowleft", "arrowup", "arrowright", "arrowdown", "degree", "plusminus", "second", "greaterequal", "multiply", "proportional", "partialdiff", "bullet", "divide", "notequal", "equivalence", "approxequal", "ellipsis", "arrowvertex", "arrowhorizex", "carriagereturn", "aleph", "Ifraktur", "Rfraktur", "weierstrass", "circlemultiply", "circleplus", "emptyset", "intersection", "union", "propersuperset", "reflexsuperset", "notsubset", "propersubset", "reflexsubset", "element", "notelement", "angle", "gradient", "registerserif", "copyrightserif", "trademarkserif", "product", "radical", "dotmath", "logicalnot", "logicaland", "logicalor", "arrowdblboth", "arrowdblleft", "arrowdblup", "arrowdblright", "arrowdbldown", "lozenge", "angleleft", "registersans", "copyrightsans", "trademarksans", "summation", "parenlefttp", "parenleftex", "parenleftbt", "bracketlefttp", "bracketleftex", "bracketleftbt", "bracelefttp", "braceleftmid", "braceleftbt", "braceex", "", "angleright", "integral", "integraltp", "integralex", "integralbt", "parenrighttp", "parenrightex", "parenrightbt", "bracketrighttp", "bracketrightex", "bracketrightbt", "bracerighttp", "bracerightmid", "bracerightbt", ""], jg = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "a1", "a2", "a202", "a3", "a4", "a5", "a119", "a118", "a117", "a11", "a12", "a13", "a14", "a15", "a16", "a105", "a17", "a18", "a19", "a20", "a21", "a22", "a23", "a24", "a25", "a26", "a27", "a28", "a6", "a7", "a8", "a9", "a10", "a29", "a30", "a31", "a32", "a33", "a34", "a35", "a36", "a37", "a38", "a39", "a40", "a41", "a42", "a43", "a44", "a45", "a46", "a47", "a48", "a49", "a50", "a51", "a52", "a53", "a54", "a55", "a56", "a57", "a58", "a59", "a60", "a61", "a62", "a63", "a64", "a65", "a66", "a67", "a68", "a69", "a70", "a71", "a72", "a73", "a74", "a203", "a75", "a204", "a76", "a77", "a78", "a79", "a81", "a82", "a83", "a84", "a97", "a98", "a99", "a100", "", "a89", "a90", "a93", "a94", "a91", "a92", "a205", "a85", "a206", "a86", "a87", "a88", "a95", "a96", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "a101", "a102", "a103", "a104", "a106", "a107", "a108", "a112", "a111", "a110", "a109", "a120", "a121", "a122", "a123", "a124", "a125", "a126", "a127", "a128", "a129", "a130", "a131", "a132", "a133", "a134", "a135", "a136", "a137", "a138", "a139", "a140", "a141", "a142", "a143", "a144", "a145", "a146", "a147", "a148", "a149", "a150", "a151", "a152", "a153", "a154", "a155", "a156", "a157", "a158", "a159", "a160", "a161", "a163", "a164", "a196", "a165", "a192", "a166", "a167", "a168", "a169", "a170", "a171", "a172", "a173", "a162", "a174", "a175", "a176", "a177", "a178", "a179", "a193", "a180", "a199", "a181", "a200", "a182", "", "a201", "a183", "a184", "a197", "a185", "a194", "a198", "a186", "a195", "a187", "a188", "a189", "a190", "a191", ""];
function Xs(e) {
  switch (e) {
    case "WinAnsiEncoding":
      return js;
    case "StandardEncoding":
      return Ei;
    case "MacRomanEncoding":
      return Vg;
    case "SymbolSetEncoding":
      return Zg;
    case "ZapfDingbatsEncoding":
      return jg;
    case "ExpertEncoding":
      return Tc;
    case "MacExpertEncoding":
      return pB;
    default:
      return null;
  }
}
const yB = 10, Cn = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], Pa = 391, w0 = [null, {
  id: "hstem",
  min: 2,
  stackClearing: !0,
  stem: !0
}, null, {
  id: "vstem",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "vmoveto",
  min: 1,
  stackClearing: !0
}, {
  id: "rlineto",
  min: 2,
  resetStack: !0
}, {
  id: "hlineto",
  min: 1,
  resetStack: !0
}, {
  id: "vlineto",
  min: 1,
  resetStack: !0
}, {
  id: "rrcurveto",
  min: 6,
  resetStack: !0
}, null, {
  id: "callsubr",
  min: 1,
  undefStack: !0
}, {
  id: "return",
  min: 0,
  undefStack: !0
}, null, null, {
  id: "endchar",
  min: 0,
  stackClearing: !0
}, null, null, null, {
  id: "hstemhm",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "hintmask",
  min: 0,
  stackClearing: !0
}, {
  id: "cntrmask",
  min: 0,
  stackClearing: !0
}, {
  id: "rmoveto",
  min: 2,
  stackClearing: !0
}, {
  id: "hmoveto",
  min: 1,
  stackClearing: !0
}, {
  id: "vstemhm",
  min: 2,
  stackClearing: !0,
  stem: !0
}, {
  id: "rcurveline",
  min: 8,
  resetStack: !0
}, {
  id: "rlinecurve",
  min: 8,
  resetStack: !0
}, {
  id: "vvcurveto",
  min: 4,
  resetStack: !0
}, {
  id: "hhcurveto",
  min: 4,
  resetStack: !0
}, null, {
  id: "callgsubr",
  min: 1,
  undefStack: !0
}, {
  id: "vhcurveto",
  min: 4,
  resetStack: !0
}, {
  id: "hvcurveto",
  min: 4,
  resetStack: !0
}], wB = [null, null, null, {
  id: "and",
  min: 2,
  stackDelta: -1
}, {
  id: "or",
  min: 2,
  stackDelta: -1
}, {
  id: "not",
  min: 1,
  stackDelta: 0
}, null, null, null, {
  id: "abs",
  min: 1,
  stackDelta: 0
}, {
  id: "add",
  min: 2,
  stackDelta: -1,
  stackFn(e, A) {
    e[A - 2] = e[A - 2] + e[A - 1];
  }
}, {
  id: "sub",
  min: 2,
  stackDelta: -1,
  stackFn(e, A) {
    e[A - 2] = e[A - 2] - e[A - 1];
  }
}, {
  id: "div",
  min: 2,
  stackDelta: -1,
  stackFn(e, A) {
    e[A - 2] = e[A - 2] / e[A - 1];
  }
}, null, {
  id: "neg",
  min: 1,
  stackDelta: 0,
  stackFn(e, A) {
    e[A - 1] = -e[A - 1];
  }
}, {
  id: "eq",
  min: 2,
  stackDelta: -1
}, null, null, {
  id: "drop",
  min: 1,
  stackDelta: -1
}, null, {
  id: "put",
  min: 2,
  stackDelta: -2
}, {
  id: "get",
  min: 1,
  stackDelta: 0
}, {
  id: "ifelse",
  min: 4,
  stackDelta: -3
}, {
  id: "random",
  min: 0,
  stackDelta: 1
}, {
  id: "mul",
  min: 2,
  stackDelta: -1,
  stackFn(e, A) {
    e[A - 2] = e[A - 2] * e[A - 1];
  }
}, null, {
  id: "sqrt",
  min: 1,
  stackDelta: 0
}, {
  id: "dup",
  min: 1,
  stackDelta: 1
}, {
  id: "exch",
  min: 2,
  stackDelta: 0
}, {
  id: "index",
  min: 2,
  stackDelta: 0
}, {
  id: "roll",
  min: 3,
  stackDelta: -2
}, null, null, null, {
  id: "hflex",
  min: 7,
  resetStack: !0
}, {
  id: "flex",
  min: 13,
  resetStack: !0
}, {
  id: "hflex1",
  min: 9,
  resetStack: !0
}, {
  id: "flex1",
  min: 11,
  resetStack: !0
}];
class Xg {
  constructor(A, t, i) {
    this.bytes = A.getBytes(), this.properties = t, this.seacAnalysisEnabled = !!i;
  }
  parse() {
    const A = this.properties, t = new qc();
    this.cff = t;
    const i = this.parseHeader(), s = this.parseIndex(i.endPos), a = this.parseIndex(s.endPos), n = this.parseIndex(a.endPos), r = this.parseIndex(n.endPos), g = this.parseDict(a.obj.get(0)), o = this.createDict(_s, g, t.strings);
    t.header = i.obj, t.names = this.parseNameIndex(s.obj), t.strings = this.parseStringIndex(n.obj), t.topDict = o, t.globalSubrIndex = r.obj, this.parsePrivateDict(t.topDict), t.isCIDFont = o.hasName("ROS");
    const I = o.getByName("CharStrings"), c = this.parseIndex(I).obj, l = o.getByName("FontMatrix");
    l && (A.fontMatrix = l);
    const h = o.getByName("FontBBox");
    h && (A.ascent = Math.max(h[3], h[1]), A.descent = Math.min(h[1], h[3]), A.ascentScaled = !0);
    let C, B;
    if (t.isCIDFont) {
      const E = this.parseIndex(o.getByName("FDArray")).obj;
      for (let f = 0, d = E.count; f < d; ++f) {
        const u = E.get(f), x = this.createDict(_s, this.parseDict(u), t.strings);
        this.parsePrivateDict(x), t.fdArray.push(x);
      }
      B = null, C = this.parseCharsets(o.getByName("charset"), c.count, t.strings, !0), t.fdSelect = this.parseFDSelect(o.getByName("FDSelect"), c.count);
    } else
      C = this.parseCharsets(o.getByName("charset"), c.count, t.strings, !1), B = this.parseEncoding(o.getByName("Encoding"), A, t.strings, C.charset);
    t.charset = C, t.encoding = B;
    const Q = this.parseCharStrings({
      charStrings: c,
      localSubrIndex: o.privateDict.subrsIndex,
      globalSubrIndex: r.obj,
      fdSelect: t.fdSelect,
      fdArray: t.fdArray,
      privateDict: o.privateDict
    });
    return t.charStrings = Q.charStrings, t.seacs = Q.seacs, t.widths = Q.widths, t;
  }
  parseHeader() {
    let A = this.bytes;
    const t = A.length;
    let i = 0;
    for (; i < t && A[i] !== 1; )
      ++i;
    if (i >= t)
      throw new v("Invalid CFF header");
    i !== 0 && (vA("cff data is shifted"), A = A.subarray(i), this.bytes = A);
    const s = A[0], a = A[1], n = A[2], r = A[3];
    return {
      obj: new Pc(s, a, n, r),
      endPos: n
    };
  }
  parseDict(A) {
    let t = 0;
    function i() {
      let g = A[t++];
      return g === 30 ? s() : g === 28 ? (g = A[t++], g = (g << 24 | A[t++] << 16) >> 16, g) : g === 29 ? (g = A[t++], g = g << 8 | A[t++], g = g << 8 | A[t++], g = g << 8 | A[t++], g) : g >= 32 && g <= 246 ? g - 139 : g >= 247 && g <= 250 ? (g - 247) * 256 + A[t++] + 108 : g >= 251 && g <= 254 ? -((g - 251) * 256) - A[t++] - 108 : (k('CFFParser_parseDict: "' + g + '" is a reserved command.'), NaN);
    }
    function s() {
      let g = "";
      const I = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], c = A.length;
      for (; t < c; ) {
        const l = A[t++], h = l >> 4, C = l & 15;
        if (h === 15 || (g += I[h], C === 15))
          break;
        g += I[C];
      }
      return parseFloat(g);
    }
    let a = [];
    const n = [];
    t = 0;
    const r = A.length;
    for (; t < r; ) {
      let g = A[t];
      g <= 21 ? (g === 12 && (g = g << 8 | A[++t]), n.push([g, a]), a = [], ++t) : a.push(i());
    }
    return n;
  }
  parseIndex(A) {
    const t = new vi(), i = this.bytes, s = i[A++] << 8 | i[A++], a = [];
    let n = A, r, g;
    if (s !== 0) {
      const o = i[A++], I = A + (s + 1) * o - 1;
      for (r = 0, g = s + 1; r < g; ++r) {
        let c = 0;
        for (let l = 0; l < o; ++l)
          c <<= 8, c += i[A++];
        a.push(I + c);
      }
      n = a[s];
    }
    for (r = 0, g = a.length - 1; r < g; ++r) {
      const o = a[r], I = a[r + 1];
      t.add(i.subarray(o, I));
    }
    return {
      obj: t,
      endPos: n
    };
  }
  parseNameIndex(A) {
    const t = [];
    for (let i = 0, s = A.count; i < s; ++i) {
      const a = A.get(i);
      t.push(ct(a));
    }
    return t;
  }
  parseStringIndex(A) {
    const t = new _g();
    for (let i = 0, s = A.count; i < s; ++i) {
      const a = A.get(i);
      t.add(ct(a));
    }
    return t;
  }
  createDict(A, t, i) {
    const s = new A(i);
    for (const [a, n] of t)
      s.setByKey(a, n);
    return s;
  }
  parseCharString(A, t, i, s) {
    if (!t || A.callDepth > yB)
      return !1;
    let a = A.stackSize;
    const n = A.stack;
    let r = t.length;
    for (let g = 0; g < r; ) {
      const o = t[g++];
      let I = null;
      if (o === 12) {
        const c = t[g++];
        c === 0 ? (t[g - 2] = 139, t[g - 1] = 22, a = 0) : I = wB[c];
      } else if (o === 28)
        n[a] = (t[g] << 24 | t[g + 1] << 16) >> 16, g += 2, a++;
      else if (o === 14) {
        if (a >= 4 && (a -= 4, this.seacAnalysisEnabled))
          return A.seac = n.slice(a, a + 4), !1;
        I = w0[o];
      } else if (o >= 32 && o <= 246)
        n[a] = o - 139, a++;
      else if (o >= 247 && o <= 254)
        n[a] = o < 251 ? (o - 247 << 8) + t[g] + 108 : -(o - 251 << 8) - t[g] - 108, g++, a++;
      else if (o === 255)
        n[a] = (t[g] << 24 | t[g + 1] << 16 | t[g + 2] << 8 | t[g + 3]) / 65536, g += 4, a++;
      else if (o === 19 || o === 20) {
        if (A.hints += a >> 1, A.hints === 0) {
          t.copyWithin(g - 1, g, -1), g -= 1, r -= 1;
          continue;
        }
        g += A.hints + 7 >> 3, a %= 2, I = w0[o];
      } else if (o === 10 || o === 29) {
        const c = o === 10 ? i : s;
        if (!c)
          return I = w0[o], k("Missing subrsIndex for " + I.id), !1;
        let l = 32768;
        c.count < 1240 ? l = 107 : c.count < 33900 && (l = 1131);
        const h = n[--a] + l;
        if (h < 0 || h >= c.count || isNaN(h))
          return I = w0[o], k("Out of bounds subrIndex for " + I.id), !1;
        if (A.stackSize = a, A.callDepth++, !this.parseCharString(A, c.get(h), i, s))
          return !1;
        A.callDepth--, a = A.stackSize;
        continue;
      } else {
        if (o === 11)
          return A.stackSize = a, !0;
        if (o === 0 && g === t.length)
          t[g - 1] = 14, I = w0[14];
        else if (o === 9) {
          t.copyWithin(g - 1, g, -1), g -= 1, r -= 1;
          continue;
        } else
          I = w0[o];
      }
      if (I) {
        if (I.stem && (A.hints += a >> 1, o === 3 || o === 23 ? A.hasVStems = !0 : A.hasVStems && (o === 1 || o === 18) && (k("CFF stem hints are in wrong order"), t[g - 1] = o === 1 ? 3 : 23)), "min" in I && !A.undefStack && a < I.min)
          return k("Not enough parameters for " + I.id + "; actual: " + a + ", expected: " + I.min), a === 0 ? (t[g - 1] = 14, !0) : !1;
        A.firstStackClearing && I.stackClearing && (A.firstStackClearing = !1, a -= I.min, a >= 2 && I.stem ? a %= 2 : a > 1 && k("Found too many parameters for stack-clearing command"), a > 0 && (A.width = n[a - 1])), "stackDelta" in I ? ("stackFn" in I && I.stackFn(n, a), a += I.stackDelta) : I.stackClearing ? a = 0 : I.resetStack ? (a = 0, A.undefStack = !1) : I.undefStack && (a = 0, A.undefStack = !0, A.firstStackClearing = !1);
      }
    }
    return r < t.length && t.fill(14, r), A.stackSize = a, !0;
  }
  parseCharStrings({
    charStrings: A,
    localSubrIndex: t,
    globalSubrIndex: i,
    fdSelect: s,
    fdArray: a,
    privateDict: n
  }) {
    const r = [], g = [], o = A.count;
    for (let I = 0; I < o; I++) {
      const c = A.get(I), l = {
        callDepth: 0,
        stackSize: 0,
        stack: [],
        undefStack: !0,
        hints: 0,
        firstStackClearing: !0,
        seac: null,
        width: null,
        hasVStems: !1
      };
      let h = !0, C = null, B = n;
      if (s && a.length) {
        const Q = s.getFDIndex(I);
        Q === -1 && (k("Glyph index is not in fd select."), h = !1), Q >= a.length && (k("Invalid fd index for glyph index."), h = !1), h && (B = a[Q].privateDict, C = B.subrsIndex);
      } else t && (C = t);
      if (h && (h = this.parseCharString(l, c, C, i)), l.width !== null) {
        const Q = B.getByName("nominalWidthX");
        g[I] = Q + l.width;
      } else {
        const Q = B.getByName("defaultWidthX");
        g[I] = Q;
      }
      l.seac !== null && (r[I] = l.seac), h || A.set(I, new Uint8Array([14]));
    }
    return {
      charStrings: A,
      seacs: r,
      widths: g
    };
  }
  emptyPrivateDictionary(A) {
    const t = this.createDict(zs, [], A.strings);
    A.setByKey(18, [0, 0]), A.privateDict = t;
  }
  parsePrivateDict(A) {
    if (!A.hasName("Private")) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const t = A.getByName("Private");
    if (!Array.isArray(t) || t.length !== 2) {
      A.removeByName("Private");
      return;
    }
    const i = t[0], s = t[1];
    if (i === 0 || s >= this.bytes.length) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const a = s + i, n = this.bytes.subarray(s, a), r = this.parseDict(n), g = this.createDict(zs, r, A.strings);
    if (A.privateDict = g, g.getByName("ExpansionFactor") === 0 && g.setByName("ExpansionFactor", 0.06), !g.getByName("Subrs"))
      return;
    const o = g.getByName("Subrs"), I = s + o;
    if (o === 0 || I >= this.bytes.length) {
      this.emptyPrivateDictionary(A);
      return;
    }
    const c = this.parseIndex(I);
    g.subrsIndex = c.obj;
  }
  parseCharsets(A, t, i, s) {
    if (A === 0)
      return new Rs(!0, yr.ISO_ADOBE, dB);
    if (A === 1)
      return new Rs(!0, yr.EXPERT, xB);
    if (A === 2)
      return new Rs(!0, yr.EXPERT_SUBSET, mB);
    const a = this.bytes, n = A, r = a[A++], g = [s ? 0 : ".notdef"];
    let o, I, c;
    switch (t -= 1, r) {
      case 0:
        for (c = 0; c < t; c++)
          o = a[A++] << 8 | a[A++], g.push(s ? o : i.get(o));
        break;
      case 1:
        for (; g.length <= t; )
          for (o = a[A++] << 8 | a[A++], I = a[A++], c = 0; c <= I; c++)
            g.push(s ? o++ : i.get(o++));
        break;
      case 2:
        for (; g.length <= t; )
          for (o = a[A++] << 8 | a[A++], I = a[A++] << 8 | a[A++], c = 0; c <= I; c++)
            g.push(s ? o++ : i.get(o++));
        break;
      default:
        throw new v("Unknown charset format");
    }
    const l = A, h = a.subarray(n, l);
    return new Rs(!1, r, g, h);
  }
  parseEncoding(A, t, i, s) {
    const a = /* @__PURE__ */ Object.create(null), n = this.bytes;
    let r = !1, g, o, I, c = null;
    function l() {
      const h = n[A++];
      for (o = 0; o < h; o++) {
        const C = n[A++], B = (n[A++] << 8) + (n[A++] & 255);
        a[C] = s.indexOf(i.get(B));
      }
    }
    if (A === 0 || A === 1) {
      r = !0, g = A;
      const h = A ? Tc : Ei;
      for (o = 0, I = s.length; o < I; o++) {
        const C = h.indexOf(s[o]);
        C !== -1 && (a[C] = o);
      }
    } else {
      const h = A;
      switch (g = n[A++], g & 127) {
        case 0:
          const B = n[A++];
          for (o = 1; o <= B; o++)
            a[n[A++]] = o;
          break;
        case 1:
          const Q = n[A++];
          let E = 1;
          for (o = 0; o < Q; o++) {
            const f = n[A++], d = n[A++];
            for (let u = f; u <= f + d; u++)
              a[u] = E++;
          }
          break;
        default:
          throw new v(`Unknown encoding format: ${g} in CFF`);
      }
      const C = A;
      g & 128 && (n[h] &= 127, l()), c = n.subarray(h, C);
    }
    return g &= 127, new kB(r, g, a, c);
  }
  parseFDSelect(A, t) {
    const i = this.bytes, s = i[A++], a = [];
    let n;
    switch (s) {
      case 0:
        for (n = 0; n < t; ++n) {
          const g = i[A++];
          a.push(g);
        }
        break;
      case 3:
        const r = i[A++] << 8 | i[A++];
        for (n = 0; n < r; ++n) {
          let g = i[A++] << 8 | i[A++];
          n === 0 && g !== 0 && (k("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."), g = 0);
          const o = i[A++], I = i[A] << 8 | i[A + 1];
          for (let c = g; c < I; ++c)
            a.push(o);
        }
        A += 2;
        break;
      default:
        throw new v(`parseFDSelect: Unknown format "${s}".`);
    }
    if (a.length !== t)
      throw new v("parseFDSelect: Invalid font data.");
    return new SB(s, a);
  }
}
class qc {
  constructor() {
    this.header = null, this.names = [], this.topDict = null, this.strings = new _g(), this.globalSubrIndex = null, this.encoding = null, this.charset = null, this.charStrings = null, this.fdArray = [], this.fdSelect = null, this.isCIDFont = !1;
  }
  duplicateFirstGlyph() {
    if (this.charStrings.count >= 65535) {
      k("Not enough space in charstrings to duplicate first glyph.");
      return;
    }
    const A = this.charStrings.get(0);
    this.charStrings.add(A), this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
  }
  hasGlyphId(A) {
    return A < 0 || A >= this.charStrings.count ? !1 : this.charStrings.get(A).length > 0;
  }
}
class Pc {
  constructor(A, t, i, s) {
    this.major = A, this.minor = t, this.hdrSize = i, this.offSize = s;
  }
}
class _g {
  constructor() {
    this.strings = [];
  }
  get(A) {
    return A >= 0 && A <= Pa - 1 ? Cn[A] : A - Pa <= this.strings.length ? this.strings[A - Pa] : Cn[0];
  }
  getSID(A) {
    let t = Cn.indexOf(A);
    return t !== -1 ? t : (t = this.strings.indexOf(A), t !== -1 ? t + Pa : -1);
  }
  add(A) {
    this.strings.push(A);
  }
  get count() {
    return this.strings.length;
  }
}
class vi {
  constructor() {
    this.objects = [], this.length = 0;
  }
  add(A) {
    this.length += A.length, this.objects.push(A);
  }
  set(A, t) {
    this.length += t.length - this.objects[A].length, this.objects[A] = t;
  }
  get(A) {
    return this.objects[A];
  }
  get count() {
    return this.objects.length;
  }
}
class Wc {
  constructor(A, t) {
    this.keyToNameMap = A.keyToNameMap, this.nameToKeyMap = A.nameToKeyMap, this.defaults = A.defaults, this.types = A.types, this.opcodes = A.opcodes, this.order = A.order, this.strings = t, this.values = /* @__PURE__ */ Object.create(null);
  }
  setByKey(A, t) {
    if (!(A in this.keyToNameMap))
      return !1;
    if (t.length === 0)
      return !0;
    for (const s of t)
      if (isNaN(s))
        return k(`Invalid CFFDict value: "${t}" for key "${A}".`), !0;
    const i = this.types[A];
    return (i === "num" || i === "sid" || i === "offset") && (t = t[0]), this.values[A] = t, !0;
  }
  setByName(A, t) {
    if (!(A in this.nameToKeyMap))
      throw new v(`Invalid dictionary name "${A}"`);
    this.values[this.nameToKeyMap[A]] = t;
  }
  hasName(A) {
    return this.nameToKeyMap[A] in this.values;
  }
  getByName(A) {
    if (!(A in this.nameToKeyMap))
      throw new v(`Invalid dictionary name ${A}"`);
    const t = this.nameToKeyMap[A];
    return t in this.values ? this.values[t] : this.defaults[t];
  }
  removeByName(A) {
    delete this.values[this.nameToKeyMap[A]];
  }
  static createTables(A) {
    const t = {
      keyToNameMap: {},
      nameToKeyMap: {},
      defaults: {},
      types: {},
      opcodes: {},
      order: []
    };
    for (const i of A) {
      const s = Array.isArray(i[0]) ? (i[0][0] << 8) + i[0][1] : i[0];
      t.keyToNameMap[s] = i[1], t.nameToKeyMap[i[1]] = s, t.types[s] = i[2], t.defaults[s] = i[3], t.opcodes[s] = Array.isArray(i[0]) ? i[0] : [i[0]], t.order.push(s);
    }
    return t;
  }
}
const bB = [[[12, 30], "ROS", ["sid", "sid", "num"], null], [[12, 20], "SyntheticBase", "num", null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "num", 0], [[12, 2], "ItalicAngle", "num", 0], [[12, 3], "UnderlinePosition", "num", -100], [[12, 4], "UnderlineThickness", "num", 50], [[12, 5], "PaintType", "num", 0], [[12, 6], "CharstringType", "num", 2], [[12, 7], "FontMatrix", ["num", "num", "num", "num", "num", "num"], [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "num", null], [5, "FontBBox", ["num", "num", "num", "num"], [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "num", 0], [14, "XUID", "array", null], [15, "charset", "offset", 0], [16, "Encoding", "offset", 0], [17, "CharStrings", "offset", 0], [18, "Private", ["offset", "offset"], null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "num", 0], [[12, 32], "CIDFontRevision", "num", 0], [[12, 33], "CIDFontType", "num", 0], [[12, 34], "CIDCount", "num", 8720], [[12, 35], "UIDBase", "num", null], [[12, 37], "FDSelect", "offset", null], [[12, 36], "FDArray", "offset", null], [[12, 38], "FontName", "sid", null]];
class _s extends Wc {
  static get tables() {
    return iA(this, "tables", this.createTables(bB));
  }
  constructor(A) {
    super(_s.tables, A), this.privateDict = null;
  }
}
const DB = [[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "num", 0.039625], [[12, 10], "BlueShift", "num", 7], [[12, 11], "BlueFuzz", "num", 1], [10, "StdHW", "num", null], [11, "StdVW", "num", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "num", 0], [[12, 17], "LanguageGroup", "num", 0], [[12, 18], "ExpansionFactor", "num", 0.06], [[12, 19], "initialRandomSeed", "num", 0], [20, "defaultWidthX", "num", 0], [21, "nominalWidthX", "num", 0], [19, "Subrs", "offset", null]];
class zs extends Wc {
  static get tables() {
    return iA(this, "tables", this.createTables(DB));
  }
  constructor(A) {
    super(zs.tables, A), this.subrsIndex = null;
  }
}
const yr = {
  ISO_ADOBE: 0,
  EXPERT: 1,
  EXPERT_SUBSET: 2
};
class Rs {
  constructor(A, t, i, s) {
    this.predefined = A, this.format = t, this.charset = i, this.raw = s;
  }
}
class kB {
  constructor(A, t, i, s) {
    this.predefined = A, this.format = t, this.encoding = i, this.raw = s;
  }
}
class SB {
  constructor(A, t) {
    this.format = A, this.fdSelect = t;
  }
  getFDIndex(A) {
    return A < 0 || A >= this.fdSelect.length ? -1 : this.fdSelect[A];
  }
}
class AI {
  constructor() {
    this.offsets = /* @__PURE__ */ Object.create(null);
  }
  isTracking(A) {
    return A in this.offsets;
  }
  track(A, t) {
    if (A in this.offsets)
      throw new v(`Already tracking location of ${A}`);
    this.offsets[A] = t;
  }
  offset(A) {
    for (const t in this.offsets)
      this.offsets[t] += A;
  }
  setEntryLocation(A, t, i) {
    if (!(A in this.offsets))
      throw new v(`Not tracking location of ${A}`);
    const s = i.data, a = this.offsets[A], n = 5;
    for (let r = 0, g = t.length; r < g; ++r) {
      const o = r * n + a, I = o + 1, c = o + 2, l = o + 3, h = o + 4;
      if (s[o] !== 29 || s[I] !== 0 || s[c] !== 0 || s[l] !== 0 || s[h] !== 0)
        throw new v("writing to an offset that is not empty");
      const C = t[r];
      s[o] = 29, s[I] = C >> 24 & 255, s[c] = C >> 16 & 255, s[l] = C >> 8 & 255, s[h] = C & 255;
    }
  }
}
class ya {
  constructor(A) {
    this.cff = A;
  }
  compile() {
    const A = this.cff, t = {
      data: [],
      length: 0,
      add(l) {
        try {
          this.data.push(...l);
        } catch {
          this.data = this.data.concat(l);
        }
        this.length = this.data.length;
      }
    }, i = this.compileHeader(A.header);
    t.add(i);
    const s = this.compileNameIndex(A.names);
    if (t.add(s), A.isCIDFont && A.topDict.hasName("FontMatrix")) {
      const l = A.topDict.getByName("FontMatrix");
      A.topDict.removeByName("FontMatrix");
      for (const h of A.fdArray) {
        let C = l.slice(0);
        h.hasName("FontMatrix") && (C = de.transform(C, h.getByName("FontMatrix"))), h.setByName("FontMatrix", C);
      }
    }
    const a = A.topDict.getByName("XUID");
    (a == null ? void 0 : a.length) > 16 && A.topDict.removeByName("XUID"), A.topDict.setByName("charset", 0);
    let n = this.compileTopDicts([A.topDict], t.length, A.isCIDFont);
    t.add(n.output);
    const r = n.trackers[0], g = this.compileStringIndex(A.strings.strings);
    t.add(g);
    const o = this.compileIndex(A.globalSubrIndex);
    if (t.add(o), A.encoding && A.topDict.hasName("Encoding"))
      if (A.encoding.predefined)
        r.setEntryLocation("Encoding", [A.encoding.format], t);
      else {
        const l = this.compileEncoding(A.encoding);
        r.setEntryLocation("Encoding", [t.length], t), t.add(l);
      }
    const I = this.compileCharset(A.charset, A.charStrings.count, A.strings, A.isCIDFont);
    r.setEntryLocation("charset", [t.length], t), t.add(I);
    const c = this.compileCharStrings(A.charStrings);
    if (r.setEntryLocation("CharStrings", [t.length], t), t.add(c), A.isCIDFont) {
      r.setEntryLocation("FDSelect", [t.length], t);
      const l = this.compileFDSelect(A.fdSelect);
      t.add(l), n = this.compileTopDicts(A.fdArray, t.length, !0), r.setEntryLocation("FDArray", [t.length], t), t.add(n.output);
      const h = n.trackers;
      this.compilePrivateDicts(A.fdArray, h, t);
    }
    return this.compilePrivateDicts([A.topDict], [r], t), t.add([0]), t.data;
  }
  encodeNumber(A) {
    return Number.isInteger(A) ? this.encodeInteger(A) : this.encodeFloat(A);
  }
  static get EncodeFloatRegExp() {
    return iA(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
  }
  encodeFloat(A) {
    let t = A.toString();
    const i = ya.EncodeFloatRegExp.exec(t);
    if (i) {
      const g = parseFloat("1e" + ((i[2] ? +i[2] : 0) + i[1].length));
      t = (Math.round(A * g) / g).toString();
    }
    let s = "", a, n;
    for (a = 0, n = t.length; a < n; ++a) {
      const g = t[a];
      g === "e" ? s += t[++a] === "-" ? "c" : "b" : g === "." ? s += "a" : g === "-" ? s += "e" : s += g;
    }
    s += s.length & 1 ? "f" : "ff";
    const r = [30];
    for (a = 0, n = s.length; a < n; a += 2)
      r.push(parseInt(s.substring(a, a + 2), 16));
    return r;
  }
  encodeInteger(A) {
    let t;
    return A >= -107 && A <= 107 ? t = [A + 139] : A >= 108 && A <= 1131 ? (A -= 108, t = [(A >> 8) + 247, A & 255]) : A >= -1131 && A <= -108 ? (A = -A - 108, t = [(A >> 8) + 251, A & 255]) : A >= -32768 && A <= 32767 ? t = [28, A >> 8 & 255, A & 255] : t = [29, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, A & 255], t;
  }
  compileHeader(A) {
    return [A.major, A.minor, 4, A.offSize];
  }
  compileNameIndex(A) {
    const t = new vi();
    for (const i of A) {
      const s = Math.min(i.length, 127);
      let a = new Array(s);
      for (let n = 0; n < s; n++) {
        let r = i[n];
        (r < "!" || r > "~" || r === "[" || r === "]" || r === "(" || r === ")" || r === "{" || r === "}" || r === "<" || r === ">" || r === "/" || r === "%") && (r = "_"), a[n] = r;
      }
      a = a.join(""), a === "" && (a = "Bad_Font_Name"), t.add(We(a));
    }
    return this.compileIndex(t);
  }
  compileTopDicts(A, t, i) {
    const s = [];
    let a = new vi();
    for (const n of A) {
      i && (n.removeByName("CIDFontVersion"), n.removeByName("CIDFontRevision"), n.removeByName("CIDFontType"), n.removeByName("CIDCount"), n.removeByName("UIDBase"));
      const r = new AI(), g = this.compileDict(n, r);
      s.push(r), a.add(g), r.offset(t);
    }
    return a = this.compileIndex(a, s), {
      trackers: s,
      output: a
    };
  }
  compilePrivateDicts(A, t, i) {
    for (let s = 0, a = A.length; s < a; ++s) {
      const n = A[s], r = n.privateDict;
      if (!r || !n.hasName("Private"))
        throw new v("There must be a private dictionary.");
      const g = new AI(), o = this.compileDict(r, g);
      let I = i.length;
      if (g.offset(I), o.length || (I = 0), t[s].setEntryLocation("Private", [o.length, I], i), i.add(o), r.subrsIndex && r.hasName("Subrs")) {
        const c = this.compileIndex(r.subrsIndex);
        g.setEntryLocation("Subrs", [o.length], i), i.add(c);
      }
    }
  }
  compileDict(A, t) {
    const i = [];
    for (const s of A.order) {
      if (!(s in A.values))
        continue;
      let a = A.values[s], n = A.types[s];
      if (Array.isArray(n) || (n = [n]), Array.isArray(a) || (a = [a]), a.length !== 0) {
        for (let r = 0, g = n.length; r < g; ++r) {
          const o = n[r], I = a[r];
          switch (o) {
            case "num":
            case "sid":
              i.push(...this.encodeNumber(I));
              break;
            case "offset":
              const c = A.keyToNameMap[s];
              t.isTracking(c) || t.track(c, i.length), i.push(29, 0, 0, 0, 0);
              break;
            case "array":
            case "delta":
              i.push(...this.encodeNumber(I));
              for (let l = 1, h = a.length; l < h; ++l)
                i.push(...this.encodeNumber(a[l]));
              break;
            default:
              throw new v(`Unknown data type of ${o}`);
          }
        }
        i.push(...A.opcodes[s]);
      }
    }
    return i;
  }
  compileStringIndex(A) {
    const t = new vi();
    for (const i of A)
      t.add(We(i));
    return this.compileIndex(t);
  }
  compileCharStrings(A) {
    const t = new vi();
    for (let i = 0; i < A.count; i++) {
      const s = A.get(i);
      if (s.length === 0) {
        t.add(new Uint8Array([139, 14]));
        continue;
      }
      t.add(s);
    }
    return this.compileIndex(t);
  }
  compileCharset(A, t, i, s) {
    let a;
    const n = t - 1;
    if (s)
      a = new Uint8Array([2, 0, 0, n >> 8 & 255, n & 255]);
    else {
      const r = 1 + n * 2;
      a = new Uint8Array(r), a[0] = 0;
      let g = 0;
      const o = A.charset.length;
      let I = !1;
      for (let c = 1; c < a.length; c += 2) {
        let l = 0;
        if (g < o) {
          const h = A.charset[g++];
          l = i.getSID(h), l === -1 && (l = 0, I || (I = !0, k(`Couldn't find ${h} in CFF strings`)));
        }
        a[c] = l >> 8 & 255, a[c + 1] = l & 255;
      }
    }
    return this.compileTypedArray(a);
  }
  compileEncoding(A) {
    return this.compileTypedArray(A.raw);
  }
  compileFDSelect(A) {
    const t = A.format;
    let i, s;
    switch (t) {
      case 0:
        for (i = new Uint8Array(1 + A.fdSelect.length), i[0] = t, s = 0; s < A.fdSelect.length; s++)
          i[s + 1] = A.fdSelect[s];
        break;
      case 3:
        const a = 0;
        let n = A.fdSelect[0];
        const r = [t, 0, 0, a >> 8 & 255, a & 255, n];
        for (s = 1; s < A.fdSelect.length; s++) {
          const o = A.fdSelect[s];
          o !== n && (r.push(s >> 8 & 255, s & 255, o), n = o);
        }
        const g = (r.length - 3) / 3;
        r[1] = g >> 8 & 255, r[2] = g & 255, r.push(s >> 8 & 255, s & 255), i = new Uint8Array(r);
        break;
    }
    return this.compileTypedArray(i);
  }
  compileTypedArray(A) {
    return Array.from(A);
  }
  compileIndex(A, t = []) {
    const i = A.objects, s = i.length;
    if (s === 0)
      return [0, 0];
    const a = [s >> 8 & 255, s & 255];
    let n = 1, r;
    for (r = 0; r < s; ++r)
      n += i[r].length;
    let g;
    n < 256 ? g = 1 : n < 65536 ? g = 2 : n < 16777216 ? g = 3 : g = 4, a.push(g);
    let o = 1;
    for (r = 0; r < s + 1; r++)
      g === 1 ? a.push(o & 255) : g === 2 ? a.push(o >> 8 & 255, o & 255) : g === 3 ? a.push(o >> 16 & 255, o >> 8 & 255, o & 255) : a.push(o >>> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255), i[r] && (o += i[r].length);
    for (r = 0; r < s; r++)
      t[r] && t[r].offset(a.length), a.push(...i[r]);
    return a;
  }
}
const ti = le(function(e) {
  e.A = 65, e.AE = 198, e.AEacute = 508, e.AEmacron = 482, e.AEsmall = 63462, e.Aacute = 193, e.Aacutesmall = 63457, e.Abreve = 258, e.Abreveacute = 7854, e.Abrevecyrillic = 1232, e.Abrevedotbelow = 7862, e.Abrevegrave = 7856, e.Abrevehookabove = 7858, e.Abrevetilde = 7860, e.Acaron = 461, e.Acircle = 9398, e.Acircumflex = 194, e.Acircumflexacute = 7844, e.Acircumflexdotbelow = 7852, e.Acircumflexgrave = 7846, e.Acircumflexhookabove = 7848, e.Acircumflexsmall = 63458, e.Acircumflextilde = 7850, e.Acute = 63177, e.Acutesmall = 63412, e.Acyrillic = 1040, e.Adblgrave = 512, e.Adieresis = 196, e.Adieresiscyrillic = 1234, e.Adieresismacron = 478, e.Adieresissmall = 63460, e.Adotbelow = 7840, e.Adotmacron = 480, e.Agrave = 192, e.Agravesmall = 63456, e.Ahookabove = 7842, e.Aiecyrillic = 1236, e.Ainvertedbreve = 514, e.Alpha = 913, e.Alphatonos = 902, e.Amacron = 256, e.Amonospace = 65313, e.Aogonek = 260, e.Aring = 197, e.Aringacute = 506, e.Aringbelow = 7680, e.Aringsmall = 63461, e.Asmall = 63329, e.Atilde = 195, e.Atildesmall = 63459, e.Aybarmenian = 1329, e.B = 66, e.Bcircle = 9399, e.Bdotaccent = 7682, e.Bdotbelow = 7684, e.Becyrillic = 1041, e.Benarmenian = 1330, e.Beta = 914, e.Bhook = 385, e.Blinebelow = 7686, e.Bmonospace = 65314, e.Brevesmall = 63220, e.Bsmall = 63330, e.Btopbar = 386, e.C = 67, e.Caarmenian = 1342, e.Cacute = 262, e.Caron = 63178, e.Caronsmall = 63221, e.Ccaron = 268, e.Ccedilla = 199, e.Ccedillaacute = 7688, e.Ccedillasmall = 63463, e.Ccircle = 9400, e.Ccircumflex = 264, e.Cdot = 266, e.Cdotaccent = 266, e.Cedillasmall = 63416, e.Chaarmenian = 1353, e.Cheabkhasiancyrillic = 1212, e.Checyrillic = 1063, e.Chedescenderabkhasiancyrillic = 1214, e.Chedescendercyrillic = 1206, e.Chedieresiscyrillic = 1268, e.Cheharmenian = 1347, e.Chekhakassiancyrillic = 1227, e.Cheverticalstrokecyrillic = 1208, e.Chi = 935, e.Chook = 391, e.Circumflexsmall = 63222, e.Cmonospace = 65315, e.Coarmenian = 1361, e.Csmall = 63331, e.D = 68, e.DZ = 497, e.DZcaron = 452, e.Daarmenian = 1332, e.Dafrican = 393, e.Dcaron = 270, e.Dcedilla = 7696, e.Dcircle = 9401, e.Dcircumflexbelow = 7698, e.Dcroat = 272, e.Ddotaccent = 7690, e.Ddotbelow = 7692, e.Decyrillic = 1044, e.Deicoptic = 1006, e.Delta = 8710, e.Deltagreek = 916, e.Dhook = 394, e.Dieresis = 63179, e.DieresisAcute = 63180, e.DieresisGrave = 63181, e.Dieresissmall = 63400, e.Digammagreek = 988, e.Djecyrillic = 1026, e.Dlinebelow = 7694, e.Dmonospace = 65316, e.Dotaccentsmall = 63223, e.Dslash = 272, e.Dsmall = 63332, e.Dtopbar = 395, e.Dz = 498, e.Dzcaron = 453, e.Dzeabkhasiancyrillic = 1248, e.Dzecyrillic = 1029, e.Dzhecyrillic = 1039, e.E = 69, e.Eacute = 201, e.Eacutesmall = 63465, e.Ebreve = 276, e.Ecaron = 282, e.Ecedillabreve = 7708, e.Echarmenian = 1333, e.Ecircle = 9402, e.Ecircumflex = 202, e.Ecircumflexacute = 7870, e.Ecircumflexbelow = 7704, e.Ecircumflexdotbelow = 7878, e.Ecircumflexgrave = 7872, e.Ecircumflexhookabove = 7874, e.Ecircumflexsmall = 63466, e.Ecircumflextilde = 7876, e.Ecyrillic = 1028, e.Edblgrave = 516, e.Edieresis = 203, e.Edieresissmall = 63467, e.Edot = 278, e.Edotaccent = 278, e.Edotbelow = 7864, e.Efcyrillic = 1060, e.Egrave = 200, e.Egravesmall = 63464, e.Eharmenian = 1335, e.Ehookabove = 7866, e.Eightroman = 8551, e.Einvertedbreve = 518, e.Eiotifiedcyrillic = 1124, e.Elcyrillic = 1051, e.Elevenroman = 8554, e.Emacron = 274, e.Emacronacute = 7702, e.Emacrongrave = 7700, e.Emcyrillic = 1052, e.Emonospace = 65317, e.Encyrillic = 1053, e.Endescendercyrillic = 1186, e.Eng = 330, e.Enghecyrillic = 1188, e.Enhookcyrillic = 1223, e.Eogonek = 280, e.Eopen = 400, e.Epsilon = 917, e.Epsilontonos = 904, e.Ercyrillic = 1056, e.Ereversed = 398, e.Ereversedcyrillic = 1069, e.Escyrillic = 1057, e.Esdescendercyrillic = 1194, e.Esh = 425, e.Esmall = 63333, e.Eta = 919, e.Etarmenian = 1336, e.Etatonos = 905, e.Eth = 208, e.Ethsmall = 63472, e.Etilde = 7868, e.Etildebelow = 7706, e.Euro = 8364, e.Ezh = 439, e.Ezhcaron = 494, e.Ezhreversed = 440, e.F = 70, e.Fcircle = 9403, e.Fdotaccent = 7710, e.Feharmenian = 1366, e.Feicoptic = 996, e.Fhook = 401, e.Fitacyrillic = 1138, e.Fiveroman = 8548, e.Fmonospace = 65318, e.Fourroman = 8547, e.Fsmall = 63334, e.G = 71, e.GBsquare = 13191, e.Gacute = 500, e.Gamma = 915, e.Gammaafrican = 404, e.Gangiacoptic = 1002, e.Gbreve = 286, e.Gcaron = 486, e.Gcedilla = 290, e.Gcircle = 9404, e.Gcircumflex = 284, e.Gcommaaccent = 290, e.Gdot = 288, e.Gdotaccent = 288, e.Gecyrillic = 1043, e.Ghadarmenian = 1346, e.Ghemiddlehookcyrillic = 1172, e.Ghestrokecyrillic = 1170, e.Gheupturncyrillic = 1168, e.Ghook = 403, e.Gimarmenian = 1331, e.Gjecyrillic = 1027, e.Gmacron = 7712, e.Gmonospace = 65319, e.Grave = 63182, e.Gravesmall = 63328, e.Gsmall = 63335, e.Gsmallhook = 667, e.Gstroke = 484, e.H = 72, e.H18533 = 9679, e.H18543 = 9642, e.H18551 = 9643, e.H22073 = 9633, e.HPsquare = 13259, e.Haabkhasiancyrillic = 1192, e.Hadescendercyrillic = 1202, e.Hardsigncyrillic = 1066, e.Hbar = 294, e.Hbrevebelow = 7722, e.Hcedilla = 7720, e.Hcircle = 9405, e.Hcircumflex = 292, e.Hdieresis = 7718, e.Hdotaccent = 7714, e.Hdotbelow = 7716, e.Hmonospace = 65320, e.Hoarmenian = 1344, e.Horicoptic = 1e3, e.Hsmall = 63336, e.Hungarumlaut = 63183, e.Hungarumlautsmall = 63224, e.Hzsquare = 13200, e.I = 73, e.IAcyrillic = 1071, e.IJ = 306, e.IUcyrillic = 1070, e.Iacute = 205, e.Iacutesmall = 63469, e.Ibreve = 300, e.Icaron = 463, e.Icircle = 9406, e.Icircumflex = 206, e.Icircumflexsmall = 63470, e.Icyrillic = 1030, e.Idblgrave = 520, e.Idieresis = 207, e.Idieresisacute = 7726, e.Idieresiscyrillic = 1252, e.Idieresissmall = 63471, e.Idot = 304, e.Idotaccent = 304, e.Idotbelow = 7882, e.Iebrevecyrillic = 1238, e.Iecyrillic = 1045, e.Ifraktur = 8465, e.Igrave = 204, e.Igravesmall = 63468, e.Ihookabove = 7880, e.Iicyrillic = 1048, e.Iinvertedbreve = 522, e.Iishortcyrillic = 1049, e.Imacron = 298, e.Imacroncyrillic = 1250, e.Imonospace = 65321, e.Iniarmenian = 1339, e.Iocyrillic = 1025, e.Iogonek = 302, e.Iota = 921, e.Iotaafrican = 406, e.Iotadieresis = 938, e.Iotatonos = 906, e.Ismall = 63337, e.Istroke = 407, e.Itilde = 296, e.Itildebelow = 7724, e.Izhitsacyrillic = 1140, e.Izhitsadblgravecyrillic = 1142, e.J = 74, e.Jaarmenian = 1345, e.Jcircle = 9407, e.Jcircumflex = 308, e.Jecyrillic = 1032, e.Jheharmenian = 1355, e.Jmonospace = 65322, e.Jsmall = 63338, e.K = 75, e.KBsquare = 13189, e.KKsquare = 13261, e.Kabashkircyrillic = 1184, e.Kacute = 7728, e.Kacyrillic = 1050, e.Kadescendercyrillic = 1178, e.Kahookcyrillic = 1219, e.Kappa = 922, e.Kastrokecyrillic = 1182, e.Kaverticalstrokecyrillic = 1180, e.Kcaron = 488, e.Kcedilla = 310, e.Kcircle = 9408, e.Kcommaaccent = 310, e.Kdotbelow = 7730, e.Keharmenian = 1364, e.Kenarmenian = 1343, e.Khacyrillic = 1061, e.Kheicoptic = 998, e.Khook = 408, e.Kjecyrillic = 1036, e.Klinebelow = 7732, e.Kmonospace = 65323, e.Koppacyrillic = 1152, e.Koppagreek = 990, e.Ksicyrillic = 1134, e.Ksmall = 63339, e.L = 76, e.LJ = 455, e.LL = 63167, e.Lacute = 313, e.Lambda = 923, e.Lcaron = 317, e.Lcedilla = 315, e.Lcircle = 9409, e.Lcircumflexbelow = 7740, e.Lcommaaccent = 315, e.Ldot = 319, e.Ldotaccent = 319, e.Ldotbelow = 7734, e.Ldotbelowmacron = 7736, e.Liwnarmenian = 1340, e.Lj = 456, e.Ljecyrillic = 1033, e.Llinebelow = 7738, e.Lmonospace = 65324, e.Lslash = 321, e.Lslashsmall = 63225, e.Lsmall = 63340, e.M = 77, e.MBsquare = 13190, e.Macron = 63184, e.Macronsmall = 63407, e.Macute = 7742, e.Mcircle = 9410, e.Mdotaccent = 7744, e.Mdotbelow = 7746, e.Menarmenian = 1348, e.Mmonospace = 65325, e.Msmall = 63341, e.Mturned = 412, e.Mu = 924, e.N = 78, e.NJ = 458, e.Nacute = 323, e.Ncaron = 327, e.Ncedilla = 325, e.Ncircle = 9411, e.Ncircumflexbelow = 7754, e.Ncommaaccent = 325, e.Ndotaccent = 7748, e.Ndotbelow = 7750, e.Nhookleft = 413, e.Nineroman = 8552, e.Nj = 459, e.Njecyrillic = 1034, e.Nlinebelow = 7752, e.Nmonospace = 65326, e.Nowarmenian = 1350, e.Nsmall = 63342, e.Ntilde = 209, e.Ntildesmall = 63473, e.Nu = 925, e.O = 79, e.OE = 338, e.OEsmall = 63226, e.Oacute = 211, e.Oacutesmall = 63475, e.Obarredcyrillic = 1256, e.Obarreddieresiscyrillic = 1258, e.Obreve = 334, e.Ocaron = 465, e.Ocenteredtilde = 415, e.Ocircle = 9412, e.Ocircumflex = 212, e.Ocircumflexacute = 7888, e.Ocircumflexdotbelow = 7896, e.Ocircumflexgrave = 7890, e.Ocircumflexhookabove = 7892, e.Ocircumflexsmall = 63476, e.Ocircumflextilde = 7894, e.Ocyrillic = 1054, e.Odblacute = 336, e.Odblgrave = 524, e.Odieresis = 214, e.Odieresiscyrillic = 1254, e.Odieresissmall = 63478, e.Odotbelow = 7884, e.Ogoneksmall = 63227, e.Ograve = 210, e.Ogravesmall = 63474, e.Oharmenian = 1365, e.Ohm = 8486, e.Ohookabove = 7886, e.Ohorn = 416, e.Ohornacute = 7898, e.Ohorndotbelow = 7906, e.Ohorngrave = 7900, e.Ohornhookabove = 7902, e.Ohorntilde = 7904, e.Ohungarumlaut = 336, e.Oi = 418, e.Oinvertedbreve = 526, e.Omacron = 332, e.Omacronacute = 7762, e.Omacrongrave = 7760, e.Omega = 8486, e.Omegacyrillic = 1120, e.Omegagreek = 937, e.Omegaroundcyrillic = 1146, e.Omegatitlocyrillic = 1148, e.Omegatonos = 911, e.Omicron = 927, e.Omicrontonos = 908, e.Omonospace = 65327, e.Oneroman = 8544, e.Oogonek = 490, e.Oogonekmacron = 492, e.Oopen = 390, e.Oslash = 216, e.Oslashacute = 510, e.Oslashsmall = 63480, e.Osmall = 63343, e.Ostrokeacute = 510, e.Otcyrillic = 1150, e.Otilde = 213, e.Otildeacute = 7756, e.Otildedieresis = 7758, e.Otildesmall = 63477, e.P = 80, e.Pacute = 7764, e.Pcircle = 9413, e.Pdotaccent = 7766, e.Pecyrillic = 1055, e.Peharmenian = 1354, e.Pemiddlehookcyrillic = 1190, e.Phi = 934, e.Phook = 420, e.Pi = 928, e.Piwrarmenian = 1363, e.Pmonospace = 65328, e.Psi = 936, e.Psicyrillic = 1136, e.Psmall = 63344, e.Q = 81, e.Qcircle = 9414, e.Qmonospace = 65329, e.Qsmall = 63345, e.R = 82, e.Raarmenian = 1356, e.Racute = 340, e.Rcaron = 344, e.Rcedilla = 342, e.Rcircle = 9415, e.Rcommaaccent = 342, e.Rdblgrave = 528, e.Rdotaccent = 7768, e.Rdotbelow = 7770, e.Rdotbelowmacron = 7772, e.Reharmenian = 1360, e.Rfraktur = 8476, e.Rho = 929, e.Ringsmall = 63228, e.Rinvertedbreve = 530, e.Rlinebelow = 7774, e.Rmonospace = 65330, e.Rsmall = 63346, e.Rsmallinverted = 641, e.Rsmallinvertedsuperior = 694, e.S = 83, e.SF010000 = 9484, e.SF020000 = 9492, e.SF030000 = 9488, e.SF040000 = 9496, e.SF050000 = 9532, e.SF060000 = 9516, e.SF070000 = 9524, e.SF080000 = 9500, e.SF090000 = 9508, e.SF100000 = 9472, e.SF110000 = 9474, e.SF190000 = 9569, e.SF200000 = 9570, e.SF210000 = 9558, e.SF220000 = 9557, e.SF230000 = 9571, e.SF240000 = 9553, e.SF250000 = 9559, e.SF260000 = 9565, e.SF270000 = 9564, e.SF280000 = 9563, e.SF360000 = 9566, e.SF370000 = 9567, e.SF380000 = 9562, e.SF390000 = 9556, e.SF400000 = 9577, e.SF410000 = 9574, e.SF420000 = 9568, e.SF430000 = 9552, e.SF440000 = 9580, e.SF450000 = 9575, e.SF460000 = 9576, e.SF470000 = 9572, e.SF480000 = 9573, e.SF490000 = 9561, e.SF500000 = 9560, e.SF510000 = 9554, e.SF520000 = 9555, e.SF530000 = 9579, e.SF540000 = 9578, e.Sacute = 346, e.Sacutedotaccent = 7780, e.Sampigreek = 992, e.Scaron = 352, e.Scarondotaccent = 7782, e.Scaronsmall = 63229, e.Scedilla = 350, e.Schwa = 399, e.Schwacyrillic = 1240, e.Schwadieresiscyrillic = 1242, e.Scircle = 9416, e.Scircumflex = 348, e.Scommaaccent = 536, e.Sdotaccent = 7776, e.Sdotbelow = 7778, e.Sdotbelowdotaccent = 7784, e.Seharmenian = 1357, e.Sevenroman = 8550, e.Shaarmenian = 1351, e.Shacyrillic = 1064, e.Shchacyrillic = 1065, e.Sheicoptic = 994, e.Shhacyrillic = 1210, e.Shimacoptic = 1004, e.Sigma = 931, e.Sixroman = 8549, e.Smonospace = 65331, e.Softsigncyrillic = 1068, e.Ssmall = 63347, e.Stigmagreek = 986, e.T = 84, e.Tau = 932, e.Tbar = 358, e.Tcaron = 356, e.Tcedilla = 354, e.Tcircle = 9417, e.Tcircumflexbelow = 7792, e.Tcommaaccent = 354, e.Tdotaccent = 7786, e.Tdotbelow = 7788, e.Tecyrillic = 1058, e.Tedescendercyrillic = 1196, e.Tenroman = 8553, e.Tetsecyrillic = 1204, e.Theta = 920, e.Thook = 428, e.Thorn = 222, e.Thornsmall = 63486, e.Threeroman = 8546, e.Tildesmall = 63230, e.Tiwnarmenian = 1359, e.Tlinebelow = 7790, e.Tmonospace = 65332, e.Toarmenian = 1337, e.Tonefive = 444, e.Tonesix = 388, e.Tonetwo = 423, e.Tretroflexhook = 430, e.Tsecyrillic = 1062, e.Tshecyrillic = 1035, e.Tsmall = 63348, e.Twelveroman = 8555, e.Tworoman = 8545, e.U = 85, e.Uacute = 218, e.Uacutesmall = 63482, e.Ubreve = 364, e.Ucaron = 467, e.Ucircle = 9418, e.Ucircumflex = 219, e.Ucircumflexbelow = 7798, e.Ucircumflexsmall = 63483, e.Ucyrillic = 1059, e.Udblacute = 368, e.Udblgrave = 532, e.Udieresis = 220, e.Udieresisacute = 471, e.Udieresisbelow = 7794, e.Udieresiscaron = 473, e.Udieresiscyrillic = 1264, e.Udieresisgrave = 475, e.Udieresismacron = 469, e.Udieresissmall = 63484, e.Udotbelow = 7908, e.Ugrave = 217, e.Ugravesmall = 63481, e.Uhookabove = 7910, e.Uhorn = 431, e.Uhornacute = 7912, e.Uhorndotbelow = 7920, e.Uhorngrave = 7914, e.Uhornhookabove = 7916, e.Uhorntilde = 7918, e.Uhungarumlaut = 368, e.Uhungarumlautcyrillic = 1266, e.Uinvertedbreve = 534, e.Ukcyrillic = 1144, e.Umacron = 362, e.Umacroncyrillic = 1262, e.Umacrondieresis = 7802, e.Umonospace = 65333, e.Uogonek = 370, e.Upsilon = 933, e.Upsilon1 = 978, e.Upsilonacutehooksymbolgreek = 979, e.Upsilonafrican = 433, e.Upsilondieresis = 939, e.Upsilondieresishooksymbolgreek = 980, e.Upsilonhooksymbol = 978, e.Upsilontonos = 910, e.Uring = 366, e.Ushortcyrillic = 1038, e.Usmall = 63349, e.Ustraightcyrillic = 1198, e.Ustraightstrokecyrillic = 1200, e.Utilde = 360, e.Utildeacute = 7800, e.Utildebelow = 7796, e.V = 86, e.Vcircle = 9419, e.Vdotbelow = 7806, e.Vecyrillic = 1042, e.Vewarmenian = 1358, e.Vhook = 434, e.Vmonospace = 65334, e.Voarmenian = 1352, e.Vsmall = 63350, e.Vtilde = 7804, e.W = 87, e.Wacute = 7810, e.Wcircle = 9420, e.Wcircumflex = 372, e.Wdieresis = 7812, e.Wdotaccent = 7814, e.Wdotbelow = 7816, e.Wgrave = 7808, e.Wmonospace = 65335, e.Wsmall = 63351, e.X = 88, e.Xcircle = 9421, e.Xdieresis = 7820, e.Xdotaccent = 7818, e.Xeharmenian = 1341, e.Xi = 926, e.Xmonospace = 65336, e.Xsmall = 63352, e.Y = 89, e.Yacute = 221, e.Yacutesmall = 63485, e.Yatcyrillic = 1122, e.Ycircle = 9422, e.Ycircumflex = 374, e.Ydieresis = 376, e.Ydieresissmall = 63487, e.Ydotaccent = 7822, e.Ydotbelow = 7924, e.Yericyrillic = 1067, e.Yerudieresiscyrillic = 1272, e.Ygrave = 7922, e.Yhook = 435, e.Yhookabove = 7926, e.Yiarmenian = 1349, e.Yicyrillic = 1031, e.Yiwnarmenian = 1362, e.Ymonospace = 65337, e.Ysmall = 63353, e.Ytilde = 7928, e.Yusbigcyrillic = 1130, e.Yusbigiotifiedcyrillic = 1132, e.Yuslittlecyrillic = 1126, e.Yuslittleiotifiedcyrillic = 1128, e.Z = 90, e.Zaarmenian = 1334, e.Zacute = 377, e.Zcaron = 381, e.Zcaronsmall = 63231, e.Zcircle = 9423, e.Zcircumflex = 7824, e.Zdot = 379, e.Zdotaccent = 379, e.Zdotbelow = 7826, e.Zecyrillic = 1047, e.Zedescendercyrillic = 1176, e.Zedieresiscyrillic = 1246, e.Zeta = 918, e.Zhearmenian = 1338, e.Zhebrevecyrillic = 1217, e.Zhecyrillic = 1046, e.Zhedescendercyrillic = 1174, e.Zhedieresiscyrillic = 1244, e.Zlinebelow = 7828, e.Zmonospace = 65338, e.Zsmall = 63354, e.Zstroke = 437, e.a = 97, e.aabengali = 2438, e.aacute = 225, e.aadeva = 2310, e.aagujarati = 2694, e.aagurmukhi = 2566, e.aamatragurmukhi = 2622, e.aarusquare = 13059, e.aavowelsignbengali = 2494, e.aavowelsigndeva = 2366, e.aavowelsigngujarati = 2750, e.abbreviationmarkarmenian = 1375, e.abbreviationsigndeva = 2416, e.abengali = 2437, e.abopomofo = 12570, e.abreve = 259, e.abreveacute = 7855, e.abrevecyrillic = 1233, e.abrevedotbelow = 7863, e.abrevegrave = 7857, e.abrevehookabove = 7859, e.abrevetilde = 7861, e.acaron = 462, e.acircle = 9424, e.acircumflex = 226, e.acircumflexacute = 7845, e.acircumflexdotbelow = 7853, e.acircumflexgrave = 7847, e.acircumflexhookabove = 7849, e.acircumflextilde = 7851, e.acute = 180, e.acutebelowcmb = 791, e.acutecmb = 769, e.acutecomb = 769, e.acutedeva = 2388, e.acutelowmod = 719, e.acutetonecmb = 833, e.acyrillic = 1072, e.adblgrave = 513, e.addakgurmukhi = 2673, e.adeva = 2309, e.adieresis = 228, e.adieresiscyrillic = 1235, e.adieresismacron = 479, e.adotbelow = 7841, e.adotmacron = 481, e.ae = 230, e.aeacute = 509, e.aekorean = 12624, e.aemacron = 483, e.afii00208 = 8213, e.afii08941 = 8356, e.afii10017 = 1040, e.afii10018 = 1041, e.afii10019 = 1042, e.afii10020 = 1043, e.afii10021 = 1044, e.afii10022 = 1045, e.afii10023 = 1025, e.afii10024 = 1046, e.afii10025 = 1047, e.afii10026 = 1048, e.afii10027 = 1049, e.afii10028 = 1050, e.afii10029 = 1051, e.afii10030 = 1052, e.afii10031 = 1053, e.afii10032 = 1054, e.afii10033 = 1055, e.afii10034 = 1056, e.afii10035 = 1057, e.afii10036 = 1058, e.afii10037 = 1059, e.afii10038 = 1060, e.afii10039 = 1061, e.afii10040 = 1062, e.afii10041 = 1063, e.afii10042 = 1064, e.afii10043 = 1065, e.afii10044 = 1066, e.afii10045 = 1067, e.afii10046 = 1068, e.afii10047 = 1069, e.afii10048 = 1070, e.afii10049 = 1071, e.afii10050 = 1168, e.afii10051 = 1026, e.afii10052 = 1027, e.afii10053 = 1028, e.afii10054 = 1029, e.afii10055 = 1030, e.afii10056 = 1031, e.afii10057 = 1032, e.afii10058 = 1033, e.afii10059 = 1034, e.afii10060 = 1035, e.afii10061 = 1036, e.afii10062 = 1038, e.afii10063 = 63172, e.afii10064 = 63173, e.afii10065 = 1072, e.afii10066 = 1073, e.afii10067 = 1074, e.afii10068 = 1075, e.afii10069 = 1076, e.afii10070 = 1077, e.afii10071 = 1105, e.afii10072 = 1078, e.afii10073 = 1079, e.afii10074 = 1080, e.afii10075 = 1081, e.afii10076 = 1082, e.afii10077 = 1083, e.afii10078 = 1084, e.afii10079 = 1085, e.afii10080 = 1086, e.afii10081 = 1087, e.afii10082 = 1088, e.afii10083 = 1089, e.afii10084 = 1090, e.afii10085 = 1091, e.afii10086 = 1092, e.afii10087 = 1093, e.afii10088 = 1094, e.afii10089 = 1095, e.afii10090 = 1096, e.afii10091 = 1097, e.afii10092 = 1098, e.afii10093 = 1099, e.afii10094 = 1100, e.afii10095 = 1101, e.afii10096 = 1102, e.afii10097 = 1103, e.afii10098 = 1169, e.afii10099 = 1106, e.afii10100 = 1107, e.afii10101 = 1108, e.afii10102 = 1109, e.afii10103 = 1110, e.afii10104 = 1111, e.afii10105 = 1112, e.afii10106 = 1113, e.afii10107 = 1114, e.afii10108 = 1115, e.afii10109 = 1116, e.afii10110 = 1118, e.afii10145 = 1039, e.afii10146 = 1122, e.afii10147 = 1138, e.afii10148 = 1140, e.afii10192 = 63174, e.afii10193 = 1119, e.afii10194 = 1123, e.afii10195 = 1139, e.afii10196 = 1141, e.afii10831 = 63175, e.afii10832 = 63176, e.afii10846 = 1241, e.afii299 = 8206, e.afii300 = 8207, e.afii301 = 8205, e.afii57381 = 1642, e.afii57388 = 1548, e.afii57392 = 1632, e.afii57393 = 1633, e.afii57394 = 1634, e.afii57395 = 1635, e.afii57396 = 1636, e.afii57397 = 1637, e.afii57398 = 1638, e.afii57399 = 1639, e.afii57400 = 1640, e.afii57401 = 1641, e.afii57403 = 1563, e.afii57407 = 1567, e.afii57409 = 1569, e.afii57410 = 1570, e.afii57411 = 1571, e.afii57412 = 1572, e.afii57413 = 1573, e.afii57414 = 1574, e.afii57415 = 1575, e.afii57416 = 1576, e.afii57417 = 1577, e.afii57418 = 1578, e.afii57419 = 1579, e.afii57420 = 1580, e.afii57421 = 1581, e.afii57422 = 1582, e.afii57423 = 1583, e.afii57424 = 1584, e.afii57425 = 1585, e.afii57426 = 1586, e.afii57427 = 1587, e.afii57428 = 1588, e.afii57429 = 1589, e.afii57430 = 1590, e.afii57431 = 1591, e.afii57432 = 1592, e.afii57433 = 1593, e.afii57434 = 1594, e.afii57440 = 1600, e.afii57441 = 1601, e.afii57442 = 1602, e.afii57443 = 1603, e.afii57444 = 1604, e.afii57445 = 1605, e.afii57446 = 1606, e.afii57448 = 1608, e.afii57449 = 1609, e.afii57450 = 1610, e.afii57451 = 1611, e.afii57452 = 1612, e.afii57453 = 1613, e.afii57454 = 1614, e.afii57455 = 1615, e.afii57456 = 1616, e.afii57457 = 1617, e.afii57458 = 1618, e.afii57470 = 1607, e.afii57505 = 1700, e.afii57506 = 1662, e.afii57507 = 1670, e.afii57508 = 1688, e.afii57509 = 1711, e.afii57511 = 1657, e.afii57512 = 1672, e.afii57513 = 1681, e.afii57514 = 1722, e.afii57519 = 1746, e.afii57534 = 1749, e.afii57636 = 8362, e.afii57645 = 1470, e.afii57658 = 1475, e.afii57664 = 1488, e.afii57665 = 1489, e.afii57666 = 1490, e.afii57667 = 1491, e.afii57668 = 1492, e.afii57669 = 1493, e.afii57670 = 1494, e.afii57671 = 1495, e.afii57672 = 1496, e.afii57673 = 1497, e.afii57674 = 1498, e.afii57675 = 1499, e.afii57676 = 1500, e.afii57677 = 1501, e.afii57678 = 1502, e.afii57679 = 1503, e.afii57680 = 1504, e.afii57681 = 1505, e.afii57682 = 1506, e.afii57683 = 1507, e.afii57684 = 1508, e.afii57685 = 1509, e.afii57686 = 1510, e.afii57687 = 1511, e.afii57688 = 1512, e.afii57689 = 1513, e.afii57690 = 1514, e.afii57694 = 64298, e.afii57695 = 64299, e.afii57700 = 64331, e.afii57705 = 64287, e.afii57716 = 1520, e.afii57717 = 1521, e.afii57718 = 1522, e.afii57723 = 64309, e.afii57793 = 1460, e.afii57794 = 1461, e.afii57795 = 1462, e.afii57796 = 1467, e.afii57797 = 1464, e.afii57798 = 1463, e.afii57799 = 1456, e.afii57800 = 1458, e.afii57801 = 1457, e.afii57802 = 1459, e.afii57803 = 1474, e.afii57804 = 1473, e.afii57806 = 1465, e.afii57807 = 1468, e.afii57839 = 1469, e.afii57841 = 1471, e.afii57842 = 1472, e.afii57929 = 700, e.afii61248 = 8453, e.afii61289 = 8467, e.afii61352 = 8470, e.afii61573 = 8236, e.afii61574 = 8237, e.afii61575 = 8238, e.afii61664 = 8204, e.afii63167 = 1645, e.afii64937 = 701, e.agrave = 224, e.agujarati = 2693, e.agurmukhi = 2565, e.ahiragana = 12354, e.ahookabove = 7843, e.aibengali = 2448, e.aibopomofo = 12574, e.aideva = 2320, e.aiecyrillic = 1237, e.aigujarati = 2704, e.aigurmukhi = 2576, e.aimatragurmukhi = 2632, e.ainarabic = 1593, e.ainfinalarabic = 65226, e.aininitialarabic = 65227, e.ainmedialarabic = 65228, e.ainvertedbreve = 515, e.aivowelsignbengali = 2504, e.aivowelsigndeva = 2376, e.aivowelsigngujarati = 2760, e.akatakana = 12450, e.akatakanahalfwidth = 65393, e.akorean = 12623, e.alef = 1488, e.alefarabic = 1575, e.alefdageshhebrew = 64304, e.aleffinalarabic = 65166, e.alefhamzaabovearabic = 1571, e.alefhamzaabovefinalarabic = 65156, e.alefhamzabelowarabic = 1573, e.alefhamzabelowfinalarabic = 65160, e.alefhebrew = 1488, e.aleflamedhebrew = 64335, e.alefmaddaabovearabic = 1570, e.alefmaddaabovefinalarabic = 65154, e.alefmaksuraarabic = 1609, e.alefmaksurafinalarabic = 65264, e.alefmaksurainitialarabic = 65267, e.alefmaksuramedialarabic = 65268, e.alefpatahhebrew = 64302, e.alefqamatshebrew = 64303, e.aleph = 8501, e.allequal = 8780, e.alpha = 945, e.alphatonos = 940, e.amacron = 257, e.amonospace = 65345, e.ampersand = 38, e.ampersandmonospace = 65286, e.ampersandsmall = 63270, e.amsquare = 13250, e.anbopomofo = 12578, e.angbopomofo = 12580, e.angbracketleft = 12296, e.angbracketright = 12297, e.angkhankhuthai = 3674, e.angle = 8736, e.anglebracketleft = 12296, e.anglebracketleftvertical = 65087, e.anglebracketright = 12297, e.anglebracketrightvertical = 65088, e.angleleft = 9001, e.angleright = 9002, e.angstrom = 8491, e.anoteleia = 903, e.anudattadeva = 2386, e.anusvarabengali = 2434, e.anusvaradeva = 2306, e.anusvaragujarati = 2690, e.aogonek = 261, e.apaatosquare = 13056, e.aparen = 9372, e.apostrophearmenian = 1370, e.apostrophemod = 700, e.apple = 63743, e.approaches = 8784, e.approxequal = 8776, e.approxequalorimage = 8786, e.approximatelyequal = 8773, e.araeaekorean = 12686, e.araeakorean = 12685, e.arc = 8978, e.arighthalfring = 7834, e.aring = 229, e.aringacute = 507, e.aringbelow = 7681, e.arrowboth = 8596, e.arrowdashdown = 8675, e.arrowdashleft = 8672, e.arrowdashright = 8674, e.arrowdashup = 8673, e.arrowdblboth = 8660, e.arrowdbldown = 8659, e.arrowdblleft = 8656, e.arrowdblright = 8658, e.arrowdblup = 8657, e.arrowdown = 8595, e.arrowdownleft = 8601, e.arrowdownright = 8600, e.arrowdownwhite = 8681, e.arrowheaddownmod = 709, e.arrowheadleftmod = 706, e.arrowheadrightmod = 707, e.arrowheadupmod = 708, e.arrowhorizex = 63719, e.arrowleft = 8592, e.arrowleftdbl = 8656, e.arrowleftdblstroke = 8653, e.arrowleftoverright = 8646, e.arrowleftwhite = 8678, e.arrowright = 8594, e.arrowrightdblstroke = 8655, e.arrowrightheavy = 10142, e.arrowrightoverleft = 8644, e.arrowrightwhite = 8680, e.arrowtableft = 8676, e.arrowtabright = 8677, e.arrowup = 8593, e.arrowupdn = 8597, e.arrowupdnbse = 8616, e.arrowupdownbase = 8616, e.arrowupleft = 8598, e.arrowupleftofdown = 8645, e.arrowupright = 8599, e.arrowupwhite = 8679, e.arrowvertex = 63718, e.asciicircum = 94, e.asciicircummonospace = 65342, e.asciitilde = 126, e.asciitildemonospace = 65374, e.ascript = 593, e.ascriptturned = 594, e.asmallhiragana = 12353, e.asmallkatakana = 12449, e.asmallkatakanahalfwidth = 65383, e.asterisk = 42, e.asteriskaltonearabic = 1645, e.asteriskarabic = 1645, e.asteriskmath = 8727, e.asteriskmonospace = 65290, e.asterisksmall = 65121, e.asterism = 8258, e.asuperior = 63209, e.asymptoticallyequal = 8771, e.at = 64, e.atilde = 227, e.atmonospace = 65312, e.atsmall = 65131, e.aturned = 592, e.aubengali = 2452, e.aubopomofo = 12576, e.audeva = 2324, e.augujarati = 2708, e.augurmukhi = 2580, e.aulengthmarkbengali = 2519, e.aumatragurmukhi = 2636, e.auvowelsignbengali = 2508, e.auvowelsigndeva = 2380, e.auvowelsigngujarati = 2764, e.avagrahadeva = 2365, e.aybarmenian = 1377, e.ayin = 1506, e.ayinaltonehebrew = 64288, e.ayinhebrew = 1506, e.b = 98, e.babengali = 2476, e.backslash = 92, e.backslashmonospace = 65340, e.badeva = 2348, e.bagujarati = 2732, e.bagurmukhi = 2604, e.bahiragana = 12400, e.bahtthai = 3647, e.bakatakana = 12496, e.bar = 124, e.barmonospace = 65372, e.bbopomofo = 12549, e.bcircle = 9425, e.bdotaccent = 7683, e.bdotbelow = 7685, e.beamedsixteenthnotes = 9836, e.because = 8757, e.becyrillic = 1073, e.beharabic = 1576, e.behfinalarabic = 65168, e.behinitialarabic = 65169, e.behiragana = 12409, e.behmedialarabic = 65170, e.behmeeminitialarabic = 64671, e.behmeemisolatedarabic = 64520, e.behnoonfinalarabic = 64621, e.bekatakana = 12505, e.benarmenian = 1378, e.bet = 1489, e.beta = 946, e.betasymbolgreek = 976, e.betdagesh = 64305, e.betdageshhebrew = 64305, e.bethebrew = 1489, e.betrafehebrew = 64332, e.bhabengali = 2477, e.bhadeva = 2349, e.bhagujarati = 2733, e.bhagurmukhi = 2605, e.bhook = 595, e.bihiragana = 12403, e.bikatakana = 12499, e.bilabialclick = 664, e.bindigurmukhi = 2562, e.birusquare = 13105, e.blackcircle = 9679, e.blackdiamond = 9670, e.blackdownpointingtriangle = 9660, e.blackleftpointingpointer = 9668, e.blackleftpointingtriangle = 9664, e.blacklenticularbracketleft = 12304, e.blacklenticularbracketleftvertical = 65083, e.blacklenticularbracketright = 12305, e.blacklenticularbracketrightvertical = 65084, e.blacklowerlefttriangle = 9699, e.blacklowerrighttriangle = 9698, e.blackrectangle = 9644, e.blackrightpointingpointer = 9658, e.blackrightpointingtriangle = 9654, e.blacksmallsquare = 9642, e.blacksmilingface = 9787, e.blacksquare = 9632, e.blackstar = 9733, e.blackupperlefttriangle = 9700, e.blackupperrighttriangle = 9701, e.blackuppointingsmalltriangle = 9652, e.blackuppointingtriangle = 9650, e.blank = 9251, e.blinebelow = 7687, e.block = 9608, e.bmonospace = 65346, e.bobaimaithai = 3610, e.bohiragana = 12412, e.bokatakana = 12508, e.bparen = 9373, e.bqsquare = 13251, e.braceex = 63732, e.braceleft = 123, e.braceleftbt = 63731, e.braceleftmid = 63730, e.braceleftmonospace = 65371, e.braceleftsmall = 65115, e.bracelefttp = 63729, e.braceleftvertical = 65079, e.braceright = 125, e.bracerightbt = 63742, e.bracerightmid = 63741, e.bracerightmonospace = 65373, e.bracerightsmall = 65116, e.bracerighttp = 63740, e.bracerightvertical = 65080, e.bracketleft = 91, e.bracketleftbt = 63728, e.bracketleftex = 63727, e.bracketleftmonospace = 65339, e.bracketlefttp = 63726, e.bracketright = 93, e.bracketrightbt = 63739, e.bracketrightex = 63738, e.bracketrightmonospace = 65341, e.bracketrighttp = 63737, e.breve = 728, e.brevebelowcmb = 814, e.brevecmb = 774, e.breveinvertedbelowcmb = 815, e.breveinvertedcmb = 785, e.breveinverteddoublecmb = 865, e.bridgebelowcmb = 810, e.bridgeinvertedbelowcmb = 826, e.brokenbar = 166, e.bstroke = 384, e.bsuperior = 63210, e.btopbar = 387, e.buhiragana = 12406, e.bukatakana = 12502, e.bullet = 8226, e.bulletinverse = 9688, e.bulletoperator = 8729, e.bullseye = 9678, e.c = 99, e.caarmenian = 1390, e.cabengali = 2458, e.cacute = 263, e.cadeva = 2330, e.cagujarati = 2714, e.cagurmukhi = 2586, e.calsquare = 13192, e.candrabindubengali = 2433, e.candrabinducmb = 784, e.candrabindudeva = 2305, e.candrabindugujarati = 2689, e.capslock = 8682, e.careof = 8453, e.caron = 711, e.caronbelowcmb = 812, e.caroncmb = 780, e.carriagereturn = 8629, e.cbopomofo = 12568, e.ccaron = 269, e.ccedilla = 231, e.ccedillaacute = 7689, e.ccircle = 9426, e.ccircumflex = 265, e.ccurl = 597, e.cdot = 267, e.cdotaccent = 267, e.cdsquare = 13253, e.cedilla = 184, e.cedillacmb = 807, e.cent = 162, e.centigrade = 8451, e.centinferior = 63199, e.centmonospace = 65504, e.centoldstyle = 63394, e.centsuperior = 63200, e.chaarmenian = 1401, e.chabengali = 2459, e.chadeva = 2331, e.chagujarati = 2715, e.chagurmukhi = 2587, e.chbopomofo = 12564, e.cheabkhasiancyrillic = 1213, e.checkmark = 10003, e.checyrillic = 1095, e.chedescenderabkhasiancyrillic = 1215, e.chedescendercyrillic = 1207, e.chedieresiscyrillic = 1269, e.cheharmenian = 1395, e.chekhakassiancyrillic = 1228, e.cheverticalstrokecyrillic = 1209, e.chi = 967, e.chieuchacirclekorean = 12919, e.chieuchaparenkorean = 12823, e.chieuchcirclekorean = 12905, e.chieuchkorean = 12618, e.chieuchparenkorean = 12809, e.chochangthai = 3594, e.chochanthai = 3592, e.chochingthai = 3593, e.chochoethai = 3596, e.chook = 392, e.cieucacirclekorean = 12918, e.cieucaparenkorean = 12822, e.cieuccirclekorean = 12904, e.cieuckorean = 12616, e.cieucparenkorean = 12808, e.cieucuparenkorean = 12828, e.circle = 9675, e.circlecopyrt = 169, e.circlemultiply = 8855, e.circleot = 8857, e.circleplus = 8853, e.circlepostalmark = 12342, e.circlewithlefthalfblack = 9680, e.circlewithrighthalfblack = 9681, e.circumflex = 710, e.circumflexbelowcmb = 813, e.circumflexcmb = 770, e.clear = 8999, e.clickalveolar = 450, e.clickdental = 448, e.clicklateral = 449, e.clickretroflex = 451, e.club = 9827, e.clubsuitblack = 9827, e.clubsuitwhite = 9831, e.cmcubedsquare = 13220, e.cmonospace = 65347, e.cmsquaredsquare = 13216, e.coarmenian = 1409, e.colon = 58, e.colonmonetary = 8353, e.colonmonospace = 65306, e.colonsign = 8353, e.colonsmall = 65109, e.colontriangularhalfmod = 721, e.colontriangularmod = 720, e.comma = 44, e.commaabovecmb = 787, e.commaaboverightcmb = 789, e.commaaccent = 63171, e.commaarabic = 1548, e.commaarmenian = 1373, e.commainferior = 63201, e.commamonospace = 65292, e.commareversedabovecmb = 788, e.commareversedmod = 701, e.commasmall = 65104, e.commasuperior = 63202, e.commaturnedabovecmb = 786, e.commaturnedmod = 699, e.compass = 9788, e.congruent = 8773, e.contourintegral = 8750, e.control = 8963, e.controlACK = 6, e.controlBEL = 7, e.controlBS = 8, e.controlCAN = 24, e.controlCR = 13, e.controlDC1 = 17, e.controlDC2 = 18, e.controlDC3 = 19, e.controlDC4 = 20, e.controlDEL = 127, e.controlDLE = 16, e.controlEM = 25, e.controlENQ = 5, e.controlEOT = 4, e.controlESC = 27, e.controlETB = 23, e.controlETX = 3, e.controlFF = 12, e.controlFS = 28, e.controlGS = 29, e.controlHT = 9, e.controlLF = 10, e.controlNAK = 21, e.controlNULL = 0, e.controlRS = 30, e.controlSI = 15, e.controlSO = 14, e.controlSOT = 2, e.controlSTX = 1, e.controlSUB = 26, e.controlSYN = 22, e.controlUS = 31, e.controlVT = 11, e.copyright = 169, e.copyrightsans = 63721, e.copyrightserif = 63193, e.cornerbracketleft = 12300, e.cornerbracketlefthalfwidth = 65378, e.cornerbracketleftvertical = 65089, e.cornerbracketright = 12301, e.cornerbracketrighthalfwidth = 65379, e.cornerbracketrightvertical = 65090, e.corporationsquare = 13183, e.cosquare = 13255, e.coverkgsquare = 13254, e.cparen = 9374, e.cruzeiro = 8354, e.cstretched = 663, e.curlyand = 8911, e.curlyor = 8910, e.currency = 164, e.cyrBreve = 63185, e.cyrFlex = 63186, e.cyrbreve = 63188, e.cyrflex = 63189, e.d = 100, e.daarmenian = 1380, e.dabengali = 2470, e.dadarabic = 1590, e.dadeva = 2342, e.dadfinalarabic = 65214, e.dadinitialarabic = 65215, e.dadmedialarabic = 65216, e.dagesh = 1468, e.dageshhebrew = 1468, e.dagger = 8224, e.daggerdbl = 8225, e.dagujarati = 2726, e.dagurmukhi = 2598, e.dahiragana = 12384, e.dakatakana = 12480, e.dalarabic = 1583, e.dalet = 1491, e.daletdagesh = 64307, e.daletdageshhebrew = 64307, e.dalethebrew = 1491, e.dalfinalarabic = 65194, e.dammaarabic = 1615, e.dammalowarabic = 1615, e.dammatanaltonearabic = 1612, e.dammatanarabic = 1612, e.danda = 2404, e.dargahebrew = 1447, e.dargalefthebrew = 1447, e.dasiapneumatacyrilliccmb = 1157, e.dblGrave = 63187, e.dblanglebracketleft = 12298, e.dblanglebracketleftvertical = 65085, e.dblanglebracketright = 12299, e.dblanglebracketrightvertical = 65086, e.dblarchinvertedbelowcmb = 811, e.dblarrowleft = 8660, e.dblarrowright = 8658, e.dbldanda = 2405, e.dblgrave = 63190, e.dblgravecmb = 783, e.dblintegral = 8748, e.dbllowline = 8215, e.dbllowlinecmb = 819, e.dbloverlinecmb = 831, e.dblprimemod = 698, e.dblverticalbar = 8214, e.dblverticallineabovecmb = 782, e.dbopomofo = 12553, e.dbsquare = 13256, e.dcaron = 271, e.dcedilla = 7697, e.dcircle = 9427, e.dcircumflexbelow = 7699, e.dcroat = 273, e.ddabengali = 2465, e.ddadeva = 2337, e.ddagujarati = 2721, e.ddagurmukhi = 2593, e.ddalarabic = 1672, e.ddalfinalarabic = 64393, e.dddhadeva = 2396, e.ddhabengali = 2466, e.ddhadeva = 2338, e.ddhagujarati = 2722, e.ddhagurmukhi = 2594, e.ddotaccent = 7691, e.ddotbelow = 7693, e.decimalseparatorarabic = 1643, e.decimalseparatorpersian = 1643, e.decyrillic = 1076, e.degree = 176, e.dehihebrew = 1453, e.dehiragana = 12391, e.deicoptic = 1007, e.dekatakana = 12487, e.deleteleft = 9003, e.deleteright = 8998, e.delta = 948, e.deltaturned = 397, e.denominatorminusonenumeratorbengali = 2552, e.dezh = 676, e.dhabengali = 2471, e.dhadeva = 2343, e.dhagujarati = 2727, e.dhagurmukhi = 2599, e.dhook = 599, e.dialytikatonos = 901, e.dialytikatonoscmb = 836, e.diamond = 9830, e.diamondsuitwhite = 9826, e.dieresis = 168, e.dieresisacute = 63191, e.dieresisbelowcmb = 804, e.dieresiscmb = 776, e.dieresisgrave = 63192, e.dieresistonos = 901, e.dihiragana = 12386, e.dikatakana = 12482, e.dittomark = 12291, e.divide = 247, e.divides = 8739, e.divisionslash = 8725, e.djecyrillic = 1106, e.dkshade = 9619, e.dlinebelow = 7695, e.dlsquare = 13207, e.dmacron = 273, e.dmonospace = 65348, e.dnblock = 9604, e.dochadathai = 3598, e.dodekthai = 3604, e.dohiragana = 12393, e.dokatakana = 12489, e.dollar = 36, e.dollarinferior = 63203, e.dollarmonospace = 65284, e.dollaroldstyle = 63268, e.dollarsmall = 65129, e.dollarsuperior = 63204, e.dong = 8363, e.dorusquare = 13094, e.dotaccent = 729, e.dotaccentcmb = 775, e.dotbelowcmb = 803, e.dotbelowcomb = 803, e.dotkatakana = 12539, e.dotlessi = 305, e.dotlessj = 63166, e.dotlessjstrokehook = 644, e.dotmath = 8901, e.dottedcircle = 9676, e.doubleyodpatah = 64287, e.doubleyodpatahhebrew = 64287, e.downtackbelowcmb = 798, e.downtackmod = 725, e.dparen = 9375, e.dsuperior = 63211, e.dtail = 598, e.dtopbar = 396, e.duhiragana = 12389, e.dukatakana = 12485, e.dz = 499, e.dzaltone = 675, e.dzcaron = 454, e.dzcurl = 677, e.dzeabkhasiancyrillic = 1249, e.dzecyrillic = 1109, e.dzhecyrillic = 1119, e.e = 101, e.eacute = 233, e.earth = 9793, e.ebengali = 2447, e.ebopomofo = 12572, e.ebreve = 277, e.ecandradeva = 2317, e.ecandragujarati = 2701, e.ecandravowelsigndeva = 2373, e.ecandravowelsigngujarati = 2757, e.ecaron = 283, e.ecedillabreve = 7709, e.echarmenian = 1381, e.echyiwnarmenian = 1415, e.ecircle = 9428, e.ecircumflex = 234, e.ecircumflexacute = 7871, e.ecircumflexbelow = 7705, e.ecircumflexdotbelow = 7879, e.ecircumflexgrave = 7873, e.ecircumflexhookabove = 7875, e.ecircumflextilde = 7877, e.ecyrillic = 1108, e.edblgrave = 517, e.edeva = 2319, e.edieresis = 235, e.edot = 279, e.edotaccent = 279, e.edotbelow = 7865, e.eegurmukhi = 2575, e.eematragurmukhi = 2631, e.efcyrillic = 1092, e.egrave = 232, e.egujarati = 2703, e.eharmenian = 1383, e.ehbopomofo = 12573, e.ehiragana = 12360, e.ehookabove = 7867, e.eibopomofo = 12575, e.eight = 56, e.eightarabic = 1640, e.eightbengali = 2542, e.eightcircle = 9319, e.eightcircleinversesansserif = 10129, e.eightdeva = 2414, e.eighteencircle = 9329, e.eighteenparen = 9349, e.eighteenperiod = 9369, e.eightgujarati = 2798, e.eightgurmukhi = 2670, e.eighthackarabic = 1640, e.eighthangzhou = 12328, e.eighthnotebeamed = 9835, e.eightideographicparen = 12839, e.eightinferior = 8328, e.eightmonospace = 65304, e.eightoldstyle = 63288, e.eightparen = 9339, e.eightperiod = 9359, e.eightpersian = 1784, e.eightroman = 8567, e.eightsuperior = 8312, e.eightthai = 3672, e.einvertedbreve = 519, e.eiotifiedcyrillic = 1125, e.ekatakana = 12456, e.ekatakanahalfwidth = 65396, e.ekonkargurmukhi = 2676, e.ekorean = 12628, e.elcyrillic = 1083, e.element = 8712, e.elevencircle = 9322, e.elevenparen = 9342, e.elevenperiod = 9362, e.elevenroman = 8570, e.ellipsis = 8230, e.ellipsisvertical = 8942, e.emacron = 275, e.emacronacute = 7703, e.emacrongrave = 7701, e.emcyrillic = 1084, e.emdash = 8212, e.emdashvertical = 65073, e.emonospace = 65349, e.emphasismarkarmenian = 1371, e.emptyset = 8709, e.enbopomofo = 12579, e.encyrillic = 1085, e.endash = 8211, e.endashvertical = 65074, e.endescendercyrillic = 1187, e.eng = 331, e.engbopomofo = 12581, e.enghecyrillic = 1189, e.enhookcyrillic = 1224, e.enspace = 8194, e.eogonek = 281, e.eokorean = 12627, e.eopen = 603, e.eopenclosed = 666, e.eopenreversed = 604, e.eopenreversedclosed = 606, e.eopenreversedhook = 605, e.eparen = 9376, e.epsilon = 949, e.epsilontonos = 941, e.equal = 61, e.equalmonospace = 65309, e.equalsmall = 65126, e.equalsuperior = 8316, e.equivalence = 8801, e.erbopomofo = 12582, e.ercyrillic = 1088, e.ereversed = 600, e.ereversedcyrillic = 1101, e.escyrillic = 1089, e.esdescendercyrillic = 1195, e.esh = 643, e.eshcurl = 646, e.eshortdeva = 2318, e.eshortvowelsigndeva = 2374, e.eshreversedloop = 426, e.eshsquatreversed = 645, e.esmallhiragana = 12359, e.esmallkatakana = 12455, e.esmallkatakanahalfwidth = 65386, e.estimated = 8494, e.esuperior = 63212, e.eta = 951, e.etarmenian = 1384, e.etatonos = 942, e.eth = 240, e.etilde = 7869, e.etildebelow = 7707, e.etnahtafoukhhebrew = 1425, e.etnahtafoukhlefthebrew = 1425, e.etnahtahebrew = 1425, e.etnahtalefthebrew = 1425, e.eturned = 477, e.eukorean = 12641, e.euro = 8364, e.evowelsignbengali = 2503, e.evowelsigndeva = 2375, e.evowelsigngujarati = 2759, e.exclam = 33, e.exclamarmenian = 1372, e.exclamdbl = 8252, e.exclamdown = 161, e.exclamdownsmall = 63393, e.exclammonospace = 65281, e.exclamsmall = 63265, e.existential = 8707, e.ezh = 658, e.ezhcaron = 495, e.ezhcurl = 659, e.ezhreversed = 441, e.ezhtail = 442, e.f = 102, e.fadeva = 2398, e.fagurmukhi = 2654, e.fahrenheit = 8457, e.fathaarabic = 1614, e.fathalowarabic = 1614, e.fathatanarabic = 1611, e.fbopomofo = 12552, e.fcircle = 9429, e.fdotaccent = 7711, e.feharabic = 1601, e.feharmenian = 1414, e.fehfinalarabic = 65234, e.fehinitialarabic = 65235, e.fehmedialarabic = 65236, e.feicoptic = 997, e.female = 9792, e.ff = 64256, e.f_f = 64256, e.ffi = 64259, e.f_f_i = 64259, e.ffl = 64260, e.f_f_l = 64260, e.fi = 64257, e.f_i = 64257, e.fifteencircle = 9326, e.fifteenparen = 9346, e.fifteenperiod = 9366, e.figuredash = 8210, e.filledbox = 9632, e.filledrect = 9644, e.finalkaf = 1498, e.finalkafdagesh = 64314, e.finalkafdageshhebrew = 64314, e.finalkafhebrew = 1498, e.finalmem = 1501, e.finalmemhebrew = 1501, e.finalnun = 1503, e.finalnunhebrew = 1503, e.finalpe = 1507, e.finalpehebrew = 1507, e.finaltsadi = 1509, e.finaltsadihebrew = 1509, e.firsttonechinese = 713, e.fisheye = 9673, e.fitacyrillic = 1139, e.five = 53, e.fivearabic = 1637, e.fivebengali = 2539, e.fivecircle = 9316, e.fivecircleinversesansserif = 10126, e.fivedeva = 2411, e.fiveeighths = 8541, e.fivegujarati = 2795, e.fivegurmukhi = 2667, e.fivehackarabic = 1637, e.fivehangzhou = 12325, e.fiveideographicparen = 12836, e.fiveinferior = 8325, e.fivemonospace = 65301, e.fiveoldstyle = 63285, e.fiveparen = 9336, e.fiveperiod = 9356, e.fivepersian = 1781, e.fiveroman = 8564, e.fivesuperior = 8309, e.fivethai = 3669, e.fl = 64258, e.f_l = 64258, e.florin = 402, e.fmonospace = 65350, e.fmsquare = 13209, e.fofanthai = 3615, e.fofathai = 3613, e.fongmanthai = 3663, e.forall = 8704, e.four = 52, e.fourarabic = 1636, e.fourbengali = 2538, e.fourcircle = 9315, e.fourcircleinversesansserif = 10125, e.fourdeva = 2410, e.fourgujarati = 2794, e.fourgurmukhi = 2666, e.fourhackarabic = 1636, e.fourhangzhou = 12324, e.fourideographicparen = 12835, e.fourinferior = 8324, e.fourmonospace = 65300, e.fournumeratorbengali = 2551, e.fouroldstyle = 63284, e.fourparen = 9335, e.fourperiod = 9355, e.fourpersian = 1780, e.fourroman = 8563, e.foursuperior = 8308, e.fourteencircle = 9325, e.fourteenparen = 9345, e.fourteenperiod = 9365, e.fourthai = 3668, e.fourthtonechinese = 715, e.fparen = 9377, e.fraction = 8260, e.franc = 8355, e.g = 103, e.gabengali = 2455, e.gacute = 501, e.gadeva = 2327, e.gafarabic = 1711, e.gaffinalarabic = 64403, e.gafinitialarabic = 64404, e.gafmedialarabic = 64405, e.gagujarati = 2711, e.gagurmukhi = 2583, e.gahiragana = 12364, e.gakatakana = 12460, e.gamma = 947, e.gammalatinsmall = 611, e.gammasuperior = 736, e.gangiacoptic = 1003, e.gbopomofo = 12557, e.gbreve = 287, e.gcaron = 487, e.gcedilla = 291, e.gcircle = 9430, e.gcircumflex = 285, e.gcommaaccent = 291, e.gdot = 289, e.gdotaccent = 289, e.gecyrillic = 1075, e.gehiragana = 12370, e.gekatakana = 12466, e.geometricallyequal = 8785, e.gereshaccenthebrew = 1436, e.gereshhebrew = 1523, e.gereshmuqdamhebrew = 1437, e.germandbls = 223, e.gershayimaccenthebrew = 1438, e.gershayimhebrew = 1524, e.getamark = 12307, e.ghabengali = 2456, e.ghadarmenian = 1394, e.ghadeva = 2328, e.ghagujarati = 2712, e.ghagurmukhi = 2584, e.ghainarabic = 1594, e.ghainfinalarabic = 65230, e.ghaininitialarabic = 65231, e.ghainmedialarabic = 65232, e.ghemiddlehookcyrillic = 1173, e.ghestrokecyrillic = 1171, e.gheupturncyrillic = 1169, e.ghhadeva = 2394, e.ghhagurmukhi = 2650, e.ghook = 608, e.ghzsquare = 13203, e.gihiragana = 12366, e.gikatakana = 12462, e.gimarmenian = 1379, e.gimel = 1490, e.gimeldagesh = 64306, e.gimeldageshhebrew = 64306, e.gimelhebrew = 1490, e.gjecyrillic = 1107, e.glottalinvertedstroke = 446, e.glottalstop = 660, e.glottalstopinverted = 662, e.glottalstopmod = 704, e.glottalstopreversed = 661, e.glottalstopreversedmod = 705, e.glottalstopreversedsuperior = 740, e.glottalstopstroke = 673, e.glottalstopstrokereversed = 674, e.gmacron = 7713, e.gmonospace = 65351, e.gohiragana = 12372, e.gokatakana = 12468, e.gparen = 9378, e.gpasquare = 13228, e.gradient = 8711, e.grave = 96, e.gravebelowcmb = 790, e.gravecmb = 768, e.gravecomb = 768, e.gravedeva = 2387, e.gravelowmod = 718, e.gravemonospace = 65344, e.gravetonecmb = 832, e.greater = 62, e.greaterequal = 8805, e.greaterequalorless = 8923, e.greatermonospace = 65310, e.greaterorequivalent = 8819, e.greaterorless = 8823, e.greateroverequal = 8807, e.greatersmall = 65125, e.gscript = 609, e.gstroke = 485, e.guhiragana = 12368, e.guillemotleft = 171, e.guillemotright = 187, e.guilsinglleft = 8249, e.guilsinglright = 8250, e.gukatakana = 12464, e.guramusquare = 13080, e.gysquare = 13257, e.h = 104, e.haabkhasiancyrillic = 1193, e.haaltonearabic = 1729, e.habengali = 2489, e.hadescendercyrillic = 1203, e.hadeva = 2361, e.hagujarati = 2745, e.hagurmukhi = 2617, e.haharabic = 1581, e.hahfinalarabic = 65186, e.hahinitialarabic = 65187, e.hahiragana = 12399, e.hahmedialarabic = 65188, e.haitusquare = 13098, e.hakatakana = 12495, e.hakatakanahalfwidth = 65418, e.halantgurmukhi = 2637, e.hamzaarabic = 1569, e.hamzalowarabic = 1569, e.hangulfiller = 12644, e.hardsigncyrillic = 1098, e.harpoonleftbarbup = 8636, e.harpoonrightbarbup = 8640, e.hasquare = 13258, e.hatafpatah = 1458, e.hatafpatah16 = 1458, e.hatafpatah23 = 1458, e.hatafpatah2f = 1458, e.hatafpatahhebrew = 1458, e.hatafpatahnarrowhebrew = 1458, e.hatafpatahquarterhebrew = 1458, e.hatafpatahwidehebrew = 1458, e.hatafqamats = 1459, e.hatafqamats1b = 1459, e.hatafqamats28 = 1459, e.hatafqamats34 = 1459, e.hatafqamatshebrew = 1459, e.hatafqamatsnarrowhebrew = 1459, e.hatafqamatsquarterhebrew = 1459, e.hatafqamatswidehebrew = 1459, e.hatafsegol = 1457, e.hatafsegol17 = 1457, e.hatafsegol24 = 1457, e.hatafsegol30 = 1457, e.hatafsegolhebrew = 1457, e.hatafsegolnarrowhebrew = 1457, e.hatafsegolquarterhebrew = 1457, e.hatafsegolwidehebrew = 1457, e.hbar = 295, e.hbopomofo = 12559, e.hbrevebelow = 7723, e.hcedilla = 7721, e.hcircle = 9431, e.hcircumflex = 293, e.hdieresis = 7719, e.hdotaccent = 7715, e.hdotbelow = 7717, e.he = 1492, e.heart = 9829, e.heartsuitblack = 9829, e.heartsuitwhite = 9825, e.hedagesh = 64308, e.hedageshhebrew = 64308, e.hehaltonearabic = 1729, e.heharabic = 1607, e.hehebrew = 1492, e.hehfinalaltonearabic = 64423, e.hehfinalalttwoarabic = 65258, e.hehfinalarabic = 65258, e.hehhamzaabovefinalarabic = 64421, e.hehhamzaaboveisolatedarabic = 64420, e.hehinitialaltonearabic = 64424, e.hehinitialarabic = 65259, e.hehiragana = 12408, e.hehmedialaltonearabic = 64425, e.hehmedialarabic = 65260, e.heiseierasquare = 13179, e.hekatakana = 12504, e.hekatakanahalfwidth = 65421, e.hekutaarusquare = 13110, e.henghook = 615, e.herutusquare = 13113, e.het = 1495, e.hethebrew = 1495, e.hhook = 614, e.hhooksuperior = 689, e.hieuhacirclekorean = 12923, e.hieuhaparenkorean = 12827, e.hieuhcirclekorean = 12909, e.hieuhkorean = 12622, e.hieuhparenkorean = 12813, e.hihiragana = 12402, e.hikatakana = 12498, e.hikatakanahalfwidth = 65419, e.hiriq = 1460, e.hiriq14 = 1460, e.hiriq21 = 1460, e.hiriq2d = 1460, e.hiriqhebrew = 1460, e.hiriqnarrowhebrew = 1460, e.hiriqquarterhebrew = 1460, e.hiriqwidehebrew = 1460, e.hlinebelow = 7830, e.hmonospace = 65352, e.hoarmenian = 1392, e.hohipthai = 3627, e.hohiragana = 12411, e.hokatakana = 12507, e.hokatakanahalfwidth = 65422, e.holam = 1465, e.holam19 = 1465, e.holam26 = 1465, e.holam32 = 1465, e.holamhebrew = 1465, e.holamnarrowhebrew = 1465, e.holamquarterhebrew = 1465, e.holamwidehebrew = 1465, e.honokhukthai = 3630, e.hookabovecomb = 777, e.hookcmb = 777, e.hookpalatalizedbelowcmb = 801, e.hookretroflexbelowcmb = 802, e.hoonsquare = 13122, e.horicoptic = 1001, e.horizontalbar = 8213, e.horncmb = 795, e.hotsprings = 9832, e.house = 8962, e.hparen = 9379, e.hsuperior = 688, e.hturned = 613, e.huhiragana = 12405, e.huiitosquare = 13107, e.hukatakana = 12501, e.hukatakanahalfwidth = 65420, e.hungarumlaut = 733, e.hungarumlautcmb = 779, e.hv = 405, e.hyphen = 45, e.hypheninferior = 63205, e.hyphenmonospace = 65293, e.hyphensmall = 65123, e.hyphensuperior = 63206, e.hyphentwo = 8208, e.i = 105, e.iacute = 237, e.iacyrillic = 1103, e.ibengali = 2439, e.ibopomofo = 12583, e.ibreve = 301, e.icaron = 464, e.icircle = 9432, e.icircumflex = 238, e.icyrillic = 1110, e.idblgrave = 521, e.ideographearthcircle = 12943, e.ideographfirecircle = 12939, e.ideographicallianceparen = 12863, e.ideographiccallparen = 12858, e.ideographiccentrecircle = 12965, e.ideographicclose = 12294, e.ideographiccomma = 12289, e.ideographiccommaleft = 65380, e.ideographiccongratulationparen = 12855, e.ideographiccorrectcircle = 12963, e.ideographicearthparen = 12847, e.ideographicenterpriseparen = 12861, e.ideographicexcellentcircle = 12957, e.ideographicfestivalparen = 12864, e.ideographicfinancialcircle = 12950, e.ideographicfinancialparen = 12854, e.ideographicfireparen = 12843, e.ideographichaveparen = 12850, e.ideographichighcircle = 12964, e.ideographiciterationmark = 12293, e.ideographiclaborcircle = 12952, e.ideographiclaborparen = 12856, e.ideographicleftcircle = 12967, e.ideographiclowcircle = 12966, e.ideographicmedicinecircle = 12969, e.ideographicmetalparen = 12846, e.ideographicmoonparen = 12842, e.ideographicnameparen = 12852, e.ideographicperiod = 12290, e.ideographicprintcircle = 12958, e.ideographicreachparen = 12867, e.ideographicrepresentparen = 12857, e.ideographicresourceparen = 12862, e.ideographicrightcircle = 12968, e.ideographicsecretcircle = 12953, e.ideographicselfparen = 12866, e.ideographicsocietyparen = 12851, e.ideographicspace = 12288, e.ideographicspecialparen = 12853, e.ideographicstockparen = 12849, e.ideographicstudyparen = 12859, e.ideographicsunparen = 12848, e.ideographicsuperviseparen = 12860, e.ideographicwaterparen = 12844, e.ideographicwoodparen = 12845, e.ideographiczero = 12295, e.ideographmetalcircle = 12942, e.ideographmooncircle = 12938, e.ideographnamecircle = 12948, e.ideographsuncircle = 12944, e.ideographwatercircle = 12940, e.ideographwoodcircle = 12941, e.ideva = 2311, e.idieresis = 239, e.idieresisacute = 7727, e.idieresiscyrillic = 1253, e.idotbelow = 7883, e.iebrevecyrillic = 1239, e.iecyrillic = 1077, e.ieungacirclekorean = 12917, e.ieungaparenkorean = 12821, e.ieungcirclekorean = 12903, e.ieungkorean = 12615, e.ieungparenkorean = 12807, e.igrave = 236, e.igujarati = 2695, e.igurmukhi = 2567, e.ihiragana = 12356, e.ihookabove = 7881, e.iibengali = 2440, e.iicyrillic = 1080, e.iideva = 2312, e.iigujarati = 2696, e.iigurmukhi = 2568, e.iimatragurmukhi = 2624, e.iinvertedbreve = 523, e.iishortcyrillic = 1081, e.iivowelsignbengali = 2496, e.iivowelsigndeva = 2368, e.iivowelsigngujarati = 2752, e.ij = 307, e.ikatakana = 12452, e.ikatakanahalfwidth = 65394, e.ikorean = 12643, e.ilde = 732, e.iluyhebrew = 1452, e.imacron = 299, e.imacroncyrillic = 1251, e.imageorapproximatelyequal = 8787, e.imatragurmukhi = 2623, e.imonospace = 65353, e.increment = 8710, e.infinity = 8734, e.iniarmenian = 1387, e.integral = 8747, e.integralbottom = 8993, e.integralbt = 8993, e.integralex = 63733, e.integraltop = 8992, e.integraltp = 8992, e.intersection = 8745, e.intisquare = 13061, e.invbullet = 9688, e.invcircle = 9689, e.invsmileface = 9787, e.iocyrillic = 1105, e.iogonek = 303, e.iota = 953, e.iotadieresis = 970, e.iotadieresistonos = 912, e.iotalatin = 617, e.iotatonos = 943, e.iparen = 9380, e.irigurmukhi = 2674, e.ismallhiragana = 12355, e.ismallkatakana = 12451, e.ismallkatakanahalfwidth = 65384, e.issharbengali = 2554, e.istroke = 616, e.isuperior = 63213, e.iterationhiragana = 12445, e.iterationkatakana = 12541, e.itilde = 297, e.itildebelow = 7725, e.iubopomofo = 12585, e.iucyrillic = 1102, e.ivowelsignbengali = 2495, e.ivowelsigndeva = 2367, e.ivowelsigngujarati = 2751, e.izhitsacyrillic = 1141, e.izhitsadblgravecyrillic = 1143, e.j = 106, e.jaarmenian = 1393, e.jabengali = 2460, e.jadeva = 2332, e.jagujarati = 2716, e.jagurmukhi = 2588, e.jbopomofo = 12560, e.jcaron = 496, e.jcircle = 9433, e.jcircumflex = 309, e.jcrossedtail = 669, e.jdotlessstroke = 607, e.jecyrillic = 1112, e.jeemarabic = 1580, e.jeemfinalarabic = 65182, e.jeeminitialarabic = 65183, e.jeemmedialarabic = 65184, e.jeharabic = 1688, e.jehfinalarabic = 64395, e.jhabengali = 2461, e.jhadeva = 2333, e.jhagujarati = 2717, e.jhagurmukhi = 2589, e.jheharmenian = 1403, e.jis = 12292, e.jmonospace = 65354, e.jparen = 9381, e.jsuperior = 690, e.k = 107, e.kabashkircyrillic = 1185, e.kabengali = 2453, e.kacute = 7729, e.kacyrillic = 1082, e.kadescendercyrillic = 1179, e.kadeva = 2325, e.kaf = 1499, e.kafarabic = 1603, e.kafdagesh = 64315, e.kafdageshhebrew = 64315, e.kaffinalarabic = 65242, e.kafhebrew = 1499, e.kafinitialarabic = 65243, e.kafmedialarabic = 65244, e.kafrafehebrew = 64333, e.kagujarati = 2709, e.kagurmukhi = 2581, e.kahiragana = 12363, e.kahookcyrillic = 1220, e.kakatakana = 12459, e.kakatakanahalfwidth = 65398, e.kappa = 954, e.kappasymbolgreek = 1008, e.kapyeounmieumkorean = 12657, e.kapyeounphieuphkorean = 12676, e.kapyeounpieupkorean = 12664, e.kapyeounssangpieupkorean = 12665, e.karoriisquare = 13069, e.kashidaautoarabic = 1600, e.kashidaautonosidebearingarabic = 1600, e.kasmallkatakana = 12533, e.kasquare = 13188, e.kasraarabic = 1616, e.kasratanarabic = 1613, e.kastrokecyrillic = 1183, e.katahiraprolongmarkhalfwidth = 65392, e.kaverticalstrokecyrillic = 1181, e.kbopomofo = 12558, e.kcalsquare = 13193, e.kcaron = 489, e.kcedilla = 311, e.kcircle = 9434, e.kcommaaccent = 311, e.kdotbelow = 7731, e.keharmenian = 1412, e.kehiragana = 12369, e.kekatakana = 12465, e.kekatakanahalfwidth = 65401, e.kenarmenian = 1391, e.kesmallkatakana = 12534, e.kgreenlandic = 312, e.khabengali = 2454, e.khacyrillic = 1093, e.khadeva = 2326, e.khagujarati = 2710, e.khagurmukhi = 2582, e.khaharabic = 1582, e.khahfinalarabic = 65190, e.khahinitialarabic = 65191, e.khahmedialarabic = 65192, e.kheicoptic = 999, e.khhadeva = 2393, e.khhagurmukhi = 2649, e.khieukhacirclekorean = 12920, e.khieukhaparenkorean = 12824, e.khieukhcirclekorean = 12906, e.khieukhkorean = 12619, e.khieukhparenkorean = 12810, e.khokhaithai = 3586, e.khokhonthai = 3589, e.khokhuatthai = 3587, e.khokhwaithai = 3588, e.khomutthai = 3675, e.khook = 409, e.khorakhangthai = 3590, e.khzsquare = 13201, e.kihiragana = 12365, e.kikatakana = 12461, e.kikatakanahalfwidth = 65399, e.kiroguramusquare = 13077, e.kiromeetorusquare = 13078, e.kirosquare = 13076, e.kiyeokacirclekorean = 12910, e.kiyeokaparenkorean = 12814, e.kiyeokcirclekorean = 12896, e.kiyeokkorean = 12593, e.kiyeokparenkorean = 12800, e.kiyeoksioskorean = 12595, e.kjecyrillic = 1116, e.klinebelow = 7733, e.klsquare = 13208, e.kmcubedsquare = 13222, e.kmonospace = 65355, e.kmsquaredsquare = 13218, e.kohiragana = 12371, e.kohmsquare = 13248, e.kokaithai = 3585, e.kokatakana = 12467, e.kokatakanahalfwidth = 65402, e.kooposquare = 13086, e.koppacyrillic = 1153, e.koreanstandardsymbol = 12927, e.koroniscmb = 835, e.kparen = 9382, e.kpasquare = 13226, e.ksicyrillic = 1135, e.ktsquare = 13263, e.kturned = 670, e.kuhiragana = 12367, e.kukatakana = 12463, e.kukatakanahalfwidth = 65400, e.kvsquare = 13240, e.kwsquare = 13246, e.l = 108, e.labengali = 2482, e.lacute = 314, e.ladeva = 2354, e.lagujarati = 2738, e.lagurmukhi = 2610, e.lakkhangyaothai = 3653, e.lamaleffinalarabic = 65276, e.lamalefhamzaabovefinalarabic = 65272, e.lamalefhamzaaboveisolatedarabic = 65271, e.lamalefhamzabelowfinalarabic = 65274, e.lamalefhamzabelowisolatedarabic = 65273, e.lamalefisolatedarabic = 65275, e.lamalefmaddaabovefinalarabic = 65270, e.lamalefmaddaaboveisolatedarabic = 65269, e.lamarabic = 1604, e.lambda = 955, e.lambdastroke = 411, e.lamed = 1500, e.lameddagesh = 64316, e.lameddageshhebrew = 64316, e.lamedhebrew = 1500, e.lamfinalarabic = 65246, e.lamhahinitialarabic = 64714, e.laminitialarabic = 65247, e.lamjeeminitialarabic = 64713, e.lamkhahinitialarabic = 64715, e.lamlamhehisolatedarabic = 65010, e.lammedialarabic = 65248, e.lammeemhahinitialarabic = 64904, e.lammeeminitialarabic = 64716, e.largecircle = 9711, e.lbar = 410, e.lbelt = 620, e.lbopomofo = 12556, e.lcaron = 318, e.lcedilla = 316, e.lcircle = 9435, e.lcircumflexbelow = 7741, e.lcommaaccent = 316, e.ldot = 320, e.ldotaccent = 320, e.ldotbelow = 7735, e.ldotbelowmacron = 7737, e.leftangleabovecmb = 794, e.lefttackbelowcmb = 792, e.less = 60, e.lessequal = 8804, e.lessequalorgreater = 8922, e.lessmonospace = 65308, e.lessorequivalent = 8818, e.lessorgreater = 8822, e.lessoverequal = 8806, e.lesssmall = 65124, e.lezh = 622, e.lfblock = 9612, e.lhookretroflex = 621, e.lira = 8356, e.liwnarmenian = 1388, e.lj = 457, e.ljecyrillic = 1113, e.ll = 63168, e.lladeva = 2355, e.llagujarati = 2739, e.llinebelow = 7739, e.llladeva = 2356, e.llvocalicbengali = 2529, e.llvocalicdeva = 2401, e.llvocalicvowelsignbengali = 2531, e.llvocalicvowelsigndeva = 2403, e.lmiddletilde = 619, e.lmonospace = 65356, e.lmsquare = 13264, e.lochulathai = 3628, e.logicaland = 8743, e.logicalnot = 172, e.logicalnotreversed = 8976, e.logicalor = 8744, e.lolingthai = 3621, e.longs = 383, e.lowlinecenterline = 65102, e.lowlinecmb = 818, e.lowlinedashed = 65101, e.lozenge = 9674, e.lparen = 9383, e.lslash = 322, e.lsquare = 8467, e.lsuperior = 63214, e.ltshade = 9617, e.luthai = 3622, e.lvocalicbengali = 2444, e.lvocalicdeva = 2316, e.lvocalicvowelsignbengali = 2530, e.lvocalicvowelsigndeva = 2402, e.lxsquare = 13267, e.m = 109, e.mabengali = 2478, e.macron = 175, e.macronbelowcmb = 817, e.macroncmb = 772, e.macronlowmod = 717, e.macronmonospace = 65507, e.macute = 7743, e.madeva = 2350, e.magujarati = 2734, e.magurmukhi = 2606, e.mahapakhhebrew = 1444, e.mahapakhlefthebrew = 1444, e.mahiragana = 12414, e.maichattawalowleftthai = 63637, e.maichattawalowrightthai = 63636, e.maichattawathai = 3659, e.maichattawaupperleftthai = 63635, e.maieklowleftthai = 63628, e.maieklowrightthai = 63627, e.maiekthai = 3656, e.maiekupperleftthai = 63626, e.maihanakatleftthai = 63620, e.maihanakatthai = 3633, e.maitaikhuleftthai = 63625, e.maitaikhuthai = 3655, e.maitholowleftthai = 63631, e.maitholowrightthai = 63630, e.maithothai = 3657, e.maithoupperleftthai = 63629, e.maitrilowleftthai = 63634, e.maitrilowrightthai = 63633, e.maitrithai = 3658, e.maitriupperleftthai = 63632, e.maiyamokthai = 3654, e.makatakana = 12510, e.makatakanahalfwidth = 65423, e.male = 9794, e.mansyonsquare = 13127, e.maqafhebrew = 1470, e.mars = 9794, e.masoracirclehebrew = 1455, e.masquare = 13187, e.mbopomofo = 12551, e.mbsquare = 13268, e.mcircle = 9436, e.mcubedsquare = 13221, e.mdotaccent = 7745, e.mdotbelow = 7747, e.meemarabic = 1605, e.meemfinalarabic = 65250, e.meeminitialarabic = 65251, e.meemmedialarabic = 65252, e.meemmeeminitialarabic = 64721, e.meemmeemisolatedarabic = 64584, e.meetorusquare = 13133, e.mehiragana = 12417, e.meizierasquare = 13182, e.mekatakana = 12513, e.mekatakanahalfwidth = 65426, e.mem = 1502, e.memdagesh = 64318, e.memdageshhebrew = 64318, e.memhebrew = 1502, e.menarmenian = 1396, e.merkhahebrew = 1445, e.merkhakefulahebrew = 1446, e.merkhakefulalefthebrew = 1446, e.merkhalefthebrew = 1445, e.mhook = 625, e.mhzsquare = 13202, e.middledotkatakanahalfwidth = 65381, e.middot = 183, e.mieumacirclekorean = 12914, e.mieumaparenkorean = 12818, e.mieumcirclekorean = 12900, e.mieumkorean = 12609, e.mieumpansioskorean = 12656, e.mieumparenkorean = 12804, e.mieumpieupkorean = 12654, e.mieumsioskorean = 12655, e.mihiragana = 12415, e.mikatakana = 12511, e.mikatakanahalfwidth = 65424, e.minus = 8722, e.minusbelowcmb = 800, e.minuscircle = 8854, e.minusmod = 727, e.minusplus = 8723, e.minute = 8242, e.miribaarusquare = 13130, e.mirisquare = 13129, e.mlonglegturned = 624, e.mlsquare = 13206, e.mmcubedsquare = 13219, e.mmonospace = 65357, e.mmsquaredsquare = 13215, e.mohiragana = 12418, e.mohmsquare = 13249, e.mokatakana = 12514, e.mokatakanahalfwidth = 65427, e.molsquare = 13270, e.momathai = 3617, e.moverssquare = 13223, e.moverssquaredsquare = 13224, e.mparen = 9384, e.mpasquare = 13227, e.mssquare = 13235, e.msuperior = 63215, e.mturned = 623, e.mu = 181, e.mu1 = 181, e.muasquare = 13186, e.muchgreater = 8811, e.muchless = 8810, e.mufsquare = 13196, e.mugreek = 956, e.mugsquare = 13197, e.muhiragana = 12416, e.mukatakana = 12512, e.mukatakanahalfwidth = 65425, e.mulsquare = 13205, e.multiply = 215, e.mumsquare = 13211, e.munahhebrew = 1443, e.munahlefthebrew = 1443, e.musicalnote = 9834, e.musicalnotedbl = 9835, e.musicflatsign = 9837, e.musicsharpsign = 9839, e.mussquare = 13234, e.muvsquare = 13238, e.muwsquare = 13244, e.mvmegasquare = 13241, e.mvsquare = 13239, e.mwmegasquare = 13247, e.mwsquare = 13245, e.n = 110, e.nabengali = 2472, e.nabla = 8711, e.nacute = 324, e.nadeva = 2344, e.nagujarati = 2728, e.nagurmukhi = 2600, e.nahiragana = 12394, e.nakatakana = 12490, e.nakatakanahalfwidth = 65413, e.napostrophe = 329, e.nasquare = 13185, e.nbopomofo = 12555, e.nbspace = 160, e.ncaron = 328, e.ncedilla = 326, e.ncircle = 9437, e.ncircumflexbelow = 7755, e.ncommaaccent = 326, e.ndotaccent = 7749, e.ndotbelow = 7751, e.nehiragana = 12397, e.nekatakana = 12493, e.nekatakanahalfwidth = 65416, e.newsheqelsign = 8362, e.nfsquare = 13195, e.ngabengali = 2457, e.ngadeva = 2329, e.ngagujarati = 2713, e.ngagurmukhi = 2585, e.ngonguthai = 3591, e.nhiragana = 12435, e.nhookleft = 626, e.nhookretroflex = 627, e.nieunacirclekorean = 12911, e.nieunaparenkorean = 12815, e.nieuncieuckorean = 12597, e.nieuncirclekorean = 12897, e.nieunhieuhkorean = 12598, e.nieunkorean = 12596, e.nieunpansioskorean = 12648, e.nieunparenkorean = 12801, e.nieunsioskorean = 12647, e.nieuntikeutkorean = 12646, e.nihiragana = 12395, e.nikatakana = 12491, e.nikatakanahalfwidth = 65414, e.nikhahitleftthai = 63641, e.nikhahitthai = 3661, e.nine = 57, e.ninearabic = 1641, e.ninebengali = 2543, e.ninecircle = 9320, e.ninecircleinversesansserif = 10130, e.ninedeva = 2415, e.ninegujarati = 2799, e.ninegurmukhi = 2671, e.ninehackarabic = 1641, e.ninehangzhou = 12329, e.nineideographicparen = 12840, e.nineinferior = 8329, e.ninemonospace = 65305, e.nineoldstyle = 63289, e.nineparen = 9340, e.nineperiod = 9360, e.ninepersian = 1785, e.nineroman = 8568, e.ninesuperior = 8313, e.nineteencircle = 9330, e.nineteenparen = 9350, e.nineteenperiod = 9370, e.ninethai = 3673, e.nj = 460, e.njecyrillic = 1114, e.nkatakana = 12531, e.nkatakanahalfwidth = 65437, e.nlegrightlong = 414, e.nlinebelow = 7753, e.nmonospace = 65358, e.nmsquare = 13210, e.nnabengali = 2467, e.nnadeva = 2339, e.nnagujarati = 2723, e.nnagurmukhi = 2595, e.nnnadeva = 2345, e.nohiragana = 12398, e.nokatakana = 12494, e.nokatakanahalfwidth = 65417, e.nonbreakingspace = 160, e.nonenthai = 3603, e.nonuthai = 3609, e.noonarabic = 1606, e.noonfinalarabic = 65254, e.noonghunnaarabic = 1722, e.noonghunnafinalarabic = 64415, e.nooninitialarabic = 65255, e.noonjeeminitialarabic = 64722, e.noonjeemisolatedarabic = 64587, e.noonmedialarabic = 65256, e.noonmeeminitialarabic = 64725, e.noonmeemisolatedarabic = 64590, e.noonnoonfinalarabic = 64653, e.notcontains = 8716, e.notelement = 8713, e.notelementof = 8713, e.notequal = 8800, e.notgreater = 8815, e.notgreaternorequal = 8817, e.notgreaternorless = 8825, e.notidentical = 8802, e.notless = 8814, e.notlessnorequal = 8816, e.notparallel = 8742, e.notprecedes = 8832, e.notsubset = 8836, e.notsucceeds = 8833, e.notsuperset = 8837, e.nowarmenian = 1398, e.nparen = 9385, e.nssquare = 13233, e.nsuperior = 8319, e.ntilde = 241, e.nu = 957, e.nuhiragana = 12396, e.nukatakana = 12492, e.nukatakanahalfwidth = 65415, e.nuktabengali = 2492, e.nuktadeva = 2364, e.nuktagujarati = 2748, e.nuktagurmukhi = 2620, e.numbersign = 35, e.numbersignmonospace = 65283, e.numbersignsmall = 65119, e.numeralsigngreek = 884, e.numeralsignlowergreek = 885, e.numero = 8470, e.nun = 1504, e.nundagesh = 64320, e.nundageshhebrew = 64320, e.nunhebrew = 1504, e.nvsquare = 13237, e.nwsquare = 13243, e.nyabengali = 2462, e.nyadeva = 2334, e.nyagujarati = 2718, e.nyagurmukhi = 2590, e.o = 111, e.oacute = 243, e.oangthai = 3629, e.obarred = 629, e.obarredcyrillic = 1257, e.obarreddieresiscyrillic = 1259, e.obengali = 2451, e.obopomofo = 12571, e.obreve = 335, e.ocandradeva = 2321, e.ocandragujarati = 2705, e.ocandravowelsigndeva = 2377, e.ocandravowelsigngujarati = 2761, e.ocaron = 466, e.ocircle = 9438, e.ocircumflex = 244, e.ocircumflexacute = 7889, e.ocircumflexdotbelow = 7897, e.ocircumflexgrave = 7891, e.ocircumflexhookabove = 7893, e.ocircumflextilde = 7895, e.ocyrillic = 1086, e.odblacute = 337, e.odblgrave = 525, e.odeva = 2323, e.odieresis = 246, e.odieresiscyrillic = 1255, e.odotbelow = 7885, e.oe = 339, e.oekorean = 12634, e.ogonek = 731, e.ogonekcmb = 808, e.ograve = 242, e.ogujarati = 2707, e.oharmenian = 1413, e.ohiragana = 12362, e.ohookabove = 7887, e.ohorn = 417, e.ohornacute = 7899, e.ohorndotbelow = 7907, e.ohorngrave = 7901, e.ohornhookabove = 7903, e.ohorntilde = 7905, e.ohungarumlaut = 337, e.oi = 419, e.oinvertedbreve = 527, e.okatakana = 12458, e.okatakanahalfwidth = 65397, e.okorean = 12631, e.olehebrew = 1451, e.omacron = 333, e.omacronacute = 7763, e.omacrongrave = 7761, e.omdeva = 2384, e.omega = 969, e.omega1 = 982, e.omegacyrillic = 1121, e.omegalatinclosed = 631, e.omegaroundcyrillic = 1147, e.omegatitlocyrillic = 1149, e.omegatonos = 974, e.omgujarati = 2768, e.omicron = 959, e.omicrontonos = 972, e.omonospace = 65359, e.one = 49, e.onearabic = 1633, e.onebengali = 2535, e.onecircle = 9312, e.onecircleinversesansserif = 10122, e.onedeva = 2407, e.onedotenleader = 8228, e.oneeighth = 8539, e.onefitted = 63196, e.onegujarati = 2791, e.onegurmukhi = 2663, e.onehackarabic = 1633, e.onehalf = 189, e.onehangzhou = 12321, e.oneideographicparen = 12832, e.oneinferior = 8321, e.onemonospace = 65297, e.onenumeratorbengali = 2548, e.oneoldstyle = 63281, e.oneparen = 9332, e.oneperiod = 9352, e.onepersian = 1777, e.onequarter = 188, e.oneroman = 8560, e.onesuperior = 185, e.onethai = 3665, e.onethird = 8531, e.oogonek = 491, e.oogonekmacron = 493, e.oogurmukhi = 2579, e.oomatragurmukhi = 2635, e.oopen = 596, e.oparen = 9386, e.openbullet = 9702, e.option = 8997, e.ordfeminine = 170, e.ordmasculine = 186, e.orthogonal = 8735, e.oshortdeva = 2322, e.oshortvowelsigndeva = 2378, e.oslash = 248, e.oslashacute = 511, e.osmallhiragana = 12361, e.osmallkatakana = 12457, e.osmallkatakanahalfwidth = 65387, e.ostrokeacute = 511, e.osuperior = 63216, e.otcyrillic = 1151, e.otilde = 245, e.otildeacute = 7757, e.otildedieresis = 7759, e.oubopomofo = 12577, e.overline = 8254, e.overlinecenterline = 65098, e.overlinecmb = 773, e.overlinedashed = 65097, e.overlinedblwavy = 65100, e.overlinewavy = 65099, e.overscore = 175, e.ovowelsignbengali = 2507, e.ovowelsigndeva = 2379, e.ovowelsigngujarati = 2763, e.p = 112, e.paampssquare = 13184, e.paasentosquare = 13099, e.pabengali = 2474, e.pacute = 7765, e.padeva = 2346, e.pagedown = 8671, e.pageup = 8670, e.pagujarati = 2730, e.pagurmukhi = 2602, e.pahiragana = 12401, e.paiyannoithai = 3631, e.pakatakana = 12497, e.palatalizationcyrilliccmb = 1156, e.palochkacyrillic = 1216, e.pansioskorean = 12671, e.paragraph = 182, e.parallel = 8741, e.parenleft = 40, e.parenleftaltonearabic = 64830, e.parenleftbt = 63725, e.parenleftex = 63724, e.parenleftinferior = 8333, e.parenleftmonospace = 65288, e.parenleftsmall = 65113, e.parenleftsuperior = 8317, e.parenlefttp = 63723, e.parenleftvertical = 65077, e.parenright = 41, e.parenrightaltonearabic = 64831, e.parenrightbt = 63736, e.parenrightex = 63735, e.parenrightinferior = 8334, e.parenrightmonospace = 65289, e.parenrightsmall = 65114, e.parenrightsuperior = 8318, e.parenrighttp = 63734, e.parenrightvertical = 65078, e.partialdiff = 8706, e.paseqhebrew = 1472, e.pashtahebrew = 1433, e.pasquare = 13225, e.patah = 1463, e.patah11 = 1463, e.patah1d = 1463, e.patah2a = 1463, e.patahhebrew = 1463, e.patahnarrowhebrew = 1463, e.patahquarterhebrew = 1463, e.patahwidehebrew = 1463, e.pazerhebrew = 1441, e.pbopomofo = 12550, e.pcircle = 9439, e.pdotaccent = 7767, e.pe = 1508, e.pecyrillic = 1087, e.pedagesh = 64324, e.pedageshhebrew = 64324, e.peezisquare = 13115, e.pefinaldageshhebrew = 64323, e.peharabic = 1662, e.peharmenian = 1402, e.pehebrew = 1508, e.pehfinalarabic = 64343, e.pehinitialarabic = 64344, e.pehiragana = 12410, e.pehmedialarabic = 64345, e.pekatakana = 12506, e.pemiddlehookcyrillic = 1191, e.perafehebrew = 64334, e.percent = 37, e.percentarabic = 1642, e.percentmonospace = 65285, e.percentsmall = 65130, e.period = 46, e.periodarmenian = 1417, e.periodcentered = 183, e.periodhalfwidth = 65377, e.periodinferior = 63207, e.periodmonospace = 65294, e.periodsmall = 65106, e.periodsuperior = 63208, e.perispomenigreekcmb = 834, e.perpendicular = 8869, e.perthousand = 8240, e.peseta = 8359, e.pfsquare = 13194, e.phabengali = 2475, e.phadeva = 2347, e.phagujarati = 2731, e.phagurmukhi = 2603, e.phi = 966, e.phi1 = 981, e.phieuphacirclekorean = 12922, e.phieuphaparenkorean = 12826, e.phieuphcirclekorean = 12908, e.phieuphkorean = 12621, e.phieuphparenkorean = 12812, e.philatin = 632, e.phinthuthai = 3642, e.phisymbolgreek = 981, e.phook = 421, e.phophanthai = 3614, e.phophungthai = 3612, e.phosamphaothai = 3616, e.pi = 960, e.pieupacirclekorean = 12915, e.pieupaparenkorean = 12819, e.pieupcieuckorean = 12662, e.pieupcirclekorean = 12901, e.pieupkiyeokkorean = 12658, e.pieupkorean = 12610, e.pieupparenkorean = 12805, e.pieupsioskiyeokkorean = 12660, e.pieupsioskorean = 12612, e.pieupsiostikeutkorean = 12661, e.pieupthieuthkorean = 12663, e.pieuptikeutkorean = 12659, e.pihiragana = 12404, e.pikatakana = 12500, e.pisymbolgreek = 982, e.piwrarmenian = 1411, e.planckover2pi = 8463, e.planckover2pi1 = 8463, e.plus = 43, e.plusbelowcmb = 799, e.pluscircle = 8853, e.plusminus = 177, e.plusmod = 726, e.plusmonospace = 65291, e.plussmall = 65122, e.plussuperior = 8314, e.pmonospace = 65360, e.pmsquare = 13272, e.pohiragana = 12413, e.pointingindexdownwhite = 9759, e.pointingindexleftwhite = 9756, e.pointingindexrightwhite = 9758, e.pointingindexupwhite = 9757, e.pokatakana = 12509, e.poplathai = 3611, e.postalmark = 12306, e.postalmarkface = 12320, e.pparen = 9387, e.precedes = 8826, e.prescription = 8478, e.primemod = 697, e.primereversed = 8245, e.product = 8719, e.projective = 8965, e.prolongedkana = 12540, e.propellor = 8984, e.propersubset = 8834, e.propersuperset = 8835, e.proportion = 8759, e.proportional = 8733, e.psi = 968, e.psicyrillic = 1137, e.psilipneumatacyrilliccmb = 1158, e.pssquare = 13232, e.puhiragana = 12407, e.pukatakana = 12503, e.pvsquare = 13236, e.pwsquare = 13242, e.q = 113, e.qadeva = 2392, e.qadmahebrew = 1448, e.qafarabic = 1602, e.qaffinalarabic = 65238, e.qafinitialarabic = 65239, e.qafmedialarabic = 65240, e.qamats = 1464, e.qamats10 = 1464, e.qamats1a = 1464, e.qamats1c = 1464, e.qamats27 = 1464, e.qamats29 = 1464, e.qamats33 = 1464, e.qamatsde = 1464, e.qamatshebrew = 1464, e.qamatsnarrowhebrew = 1464, e.qamatsqatanhebrew = 1464, e.qamatsqatannarrowhebrew = 1464, e.qamatsqatanquarterhebrew = 1464, e.qamatsqatanwidehebrew = 1464, e.qamatsquarterhebrew = 1464, e.qamatswidehebrew = 1464, e.qarneyparahebrew = 1439, e.qbopomofo = 12561, e.qcircle = 9440, e.qhook = 672, e.qmonospace = 65361, e.qof = 1511, e.qofdagesh = 64327, e.qofdageshhebrew = 64327, e.qofhebrew = 1511, e.qparen = 9388, e.quarternote = 9833, e.qubuts = 1467, e.qubuts18 = 1467, e.qubuts25 = 1467, e.qubuts31 = 1467, e.qubutshebrew = 1467, e.qubutsnarrowhebrew = 1467, e.qubutsquarterhebrew = 1467, e.qubutswidehebrew = 1467, e.question = 63, e.questionarabic = 1567, e.questionarmenian = 1374, e.questiondown = 191, e.questiondownsmall = 63423, e.questiongreek = 894, e.questionmonospace = 65311, e.questionsmall = 63295, e.quotedbl = 34, e.quotedblbase = 8222, e.quotedblleft = 8220, e.quotedblmonospace = 65282, e.quotedblprime = 12318, e.quotedblprimereversed = 12317, e.quotedblright = 8221, e.quoteleft = 8216, e.quoteleftreversed = 8219, e.quotereversed = 8219, e.quoteright = 8217, e.quoterightn = 329, e.quotesinglbase = 8218, e.quotesingle = 39, e.quotesinglemonospace = 65287, e.r = 114, e.raarmenian = 1404, e.rabengali = 2480, e.racute = 341, e.radeva = 2352, e.radical = 8730, e.radicalex = 63717, e.radoverssquare = 13230, e.radoverssquaredsquare = 13231, e.radsquare = 13229, e.rafe = 1471, e.rafehebrew = 1471, e.ragujarati = 2736, e.ragurmukhi = 2608, e.rahiragana = 12425, e.rakatakana = 12521, e.rakatakanahalfwidth = 65431, e.ralowerdiagonalbengali = 2545, e.ramiddlediagonalbengali = 2544, e.ramshorn = 612, e.ratio = 8758, e.rbopomofo = 12566, e.rcaron = 345, e.rcedilla = 343, e.rcircle = 9441, e.rcommaaccent = 343, e.rdblgrave = 529, e.rdotaccent = 7769, e.rdotbelow = 7771, e.rdotbelowmacron = 7773, e.referencemark = 8251, e.reflexsubset = 8838, e.reflexsuperset = 8839, e.registered = 174, e.registersans = 63720, e.registerserif = 63194, e.reharabic = 1585, e.reharmenian = 1408, e.rehfinalarabic = 65198, e.rehiragana = 12428, e.rekatakana = 12524, e.rekatakanahalfwidth = 65434, e.resh = 1512, e.reshdageshhebrew = 64328, e.reshhebrew = 1512, e.reversedtilde = 8765, e.reviahebrew = 1431, e.reviamugrashhebrew = 1431, e.revlogicalnot = 8976, e.rfishhook = 638, e.rfishhookreversed = 639, e.rhabengali = 2525, e.rhadeva = 2397, e.rho = 961, e.rhook = 637, e.rhookturned = 635, e.rhookturnedsuperior = 693, e.rhosymbolgreek = 1009, e.rhotichookmod = 734, e.rieulacirclekorean = 12913, e.rieulaparenkorean = 12817, e.rieulcirclekorean = 12899, e.rieulhieuhkorean = 12608, e.rieulkiyeokkorean = 12602, e.rieulkiyeoksioskorean = 12649, e.rieulkorean = 12601, e.rieulmieumkorean = 12603, e.rieulpansioskorean = 12652, e.rieulparenkorean = 12803, e.rieulphieuphkorean = 12607, e.rieulpieupkorean = 12604, e.rieulpieupsioskorean = 12651, e.rieulsioskorean = 12605, e.rieulthieuthkorean = 12606, e.rieultikeutkorean = 12650, e.rieulyeorinhieuhkorean = 12653, e.rightangle = 8735, e.righttackbelowcmb = 793, e.righttriangle = 8895, e.rihiragana = 12426, e.rikatakana = 12522, e.rikatakanahalfwidth = 65432, e.ring = 730, e.ringbelowcmb = 805, e.ringcmb = 778, e.ringhalfleft = 703, e.ringhalfleftarmenian = 1369, e.ringhalfleftbelowcmb = 796, e.ringhalfleftcentered = 723, e.ringhalfright = 702, e.ringhalfrightbelowcmb = 825, e.ringhalfrightcentered = 722, e.rinvertedbreve = 531, e.rittorusquare = 13137, e.rlinebelow = 7775, e.rlongleg = 636, e.rlonglegturned = 634, e.rmonospace = 65362, e.rohiragana = 12429, e.rokatakana = 12525, e.rokatakanahalfwidth = 65435, e.roruathai = 3619, e.rparen = 9389, e.rrabengali = 2524, e.rradeva = 2353, e.rragurmukhi = 2652, e.rreharabic = 1681, e.rrehfinalarabic = 64397, e.rrvocalicbengali = 2528, e.rrvocalicdeva = 2400, e.rrvocalicgujarati = 2784, e.rrvocalicvowelsignbengali = 2500, e.rrvocalicvowelsigndeva = 2372, e.rrvocalicvowelsigngujarati = 2756, e.rsuperior = 63217, e.rtblock = 9616, e.rturned = 633, e.rturnedsuperior = 692, e.ruhiragana = 12427, e.rukatakana = 12523, e.rukatakanahalfwidth = 65433, e.rupeemarkbengali = 2546, e.rupeesignbengali = 2547, e.rupiah = 63197, e.ruthai = 3620, e.rvocalicbengali = 2443, e.rvocalicdeva = 2315, e.rvocalicgujarati = 2699, e.rvocalicvowelsignbengali = 2499, e.rvocalicvowelsigndeva = 2371, e.rvocalicvowelsigngujarati = 2755, e.s = 115, e.sabengali = 2488, e.sacute = 347, e.sacutedotaccent = 7781, e.sadarabic = 1589, e.sadeva = 2360, e.sadfinalarabic = 65210, e.sadinitialarabic = 65211, e.sadmedialarabic = 65212, e.sagujarati = 2744, e.sagurmukhi = 2616, e.sahiragana = 12373, e.sakatakana = 12469, e.sakatakanahalfwidth = 65403, e.sallallahoualayhewasallamarabic = 65018, e.samekh = 1505, e.samekhdagesh = 64321, e.samekhdageshhebrew = 64321, e.samekhhebrew = 1505, e.saraaathai = 3634, e.saraaethai = 3649, e.saraaimaimalaithai = 3652, e.saraaimaimuanthai = 3651, e.saraamthai = 3635, e.saraathai = 3632, e.saraethai = 3648, e.saraiileftthai = 63622, e.saraiithai = 3637, e.saraileftthai = 63621, e.saraithai = 3636, e.saraothai = 3650, e.saraueeleftthai = 63624, e.saraueethai = 3639, e.saraueleftthai = 63623, e.sarauethai = 3638, e.sarauthai = 3640, e.sarauuthai = 3641, e.sbopomofo = 12569, e.scaron = 353, e.scarondotaccent = 7783, e.scedilla = 351, e.schwa = 601, e.schwacyrillic = 1241, e.schwadieresiscyrillic = 1243, e.schwahook = 602, e.scircle = 9442, e.scircumflex = 349, e.scommaaccent = 537, e.sdotaccent = 7777, e.sdotbelow = 7779, e.sdotbelowdotaccent = 7785, e.seagullbelowcmb = 828, e.second = 8243, e.secondtonechinese = 714, e.section = 167, e.seenarabic = 1587, e.seenfinalarabic = 65202, e.seeninitialarabic = 65203, e.seenmedialarabic = 65204, e.segol = 1462, e.segol13 = 1462, e.segol1f = 1462, e.segol2c = 1462, e.segolhebrew = 1462, e.segolnarrowhebrew = 1462, e.segolquarterhebrew = 1462, e.segoltahebrew = 1426, e.segolwidehebrew = 1462, e.seharmenian = 1405, e.sehiragana = 12379, e.sekatakana = 12475, e.sekatakanahalfwidth = 65406, e.semicolon = 59, e.semicolonarabic = 1563, e.semicolonmonospace = 65307, e.semicolonsmall = 65108, e.semivoicedmarkkana = 12444, e.semivoicedmarkkanahalfwidth = 65439, e.sentisquare = 13090, e.sentosquare = 13091, e.seven = 55, e.sevenarabic = 1639, e.sevenbengali = 2541, e.sevencircle = 9318, e.sevencircleinversesansserif = 10128, e.sevendeva = 2413, e.seveneighths = 8542, e.sevengujarati = 2797, e.sevengurmukhi = 2669, e.sevenhackarabic = 1639, e.sevenhangzhou = 12327, e.sevenideographicparen = 12838, e.seveninferior = 8327, e.sevenmonospace = 65303, e.sevenoldstyle = 63287, e.sevenparen = 9338, e.sevenperiod = 9358, e.sevenpersian = 1783, e.sevenroman = 8566, e.sevensuperior = 8311, e.seventeencircle = 9328, e.seventeenparen = 9348, e.seventeenperiod = 9368, e.seventhai = 3671, e.sfthyphen = 173, e.shaarmenian = 1399, e.shabengali = 2486, e.shacyrillic = 1096, e.shaddaarabic = 1617, e.shaddadammaarabic = 64609, e.shaddadammatanarabic = 64606, e.shaddafathaarabic = 64608, e.shaddakasraarabic = 64610, e.shaddakasratanarabic = 64607, e.shade = 9618, e.shadedark = 9619, e.shadelight = 9617, e.shademedium = 9618, e.shadeva = 2358, e.shagujarati = 2742, e.shagurmukhi = 2614, e.shalshelethebrew = 1427, e.shbopomofo = 12565, e.shchacyrillic = 1097, e.sheenarabic = 1588, e.sheenfinalarabic = 65206, e.sheeninitialarabic = 65207, e.sheenmedialarabic = 65208, e.sheicoptic = 995, e.sheqel = 8362, e.sheqelhebrew = 8362, e.sheva = 1456, e.sheva115 = 1456, e.sheva15 = 1456, e.sheva22 = 1456, e.sheva2e = 1456, e.shevahebrew = 1456, e.shevanarrowhebrew = 1456, e.shevaquarterhebrew = 1456, e.shevawidehebrew = 1456, e.shhacyrillic = 1211, e.shimacoptic = 1005, e.shin = 1513, e.shindagesh = 64329, e.shindageshhebrew = 64329, e.shindageshshindot = 64300, e.shindageshshindothebrew = 64300, e.shindageshsindot = 64301, e.shindageshsindothebrew = 64301, e.shindothebrew = 1473, e.shinhebrew = 1513, e.shinshindot = 64298, e.shinshindothebrew = 64298, e.shinsindot = 64299, e.shinsindothebrew = 64299, e.shook = 642, e.sigma = 963, e.sigma1 = 962, e.sigmafinal = 962, e.sigmalunatesymbolgreek = 1010, e.sihiragana = 12375, e.sikatakana = 12471, e.sikatakanahalfwidth = 65404, e.siluqhebrew = 1469, e.siluqlefthebrew = 1469, e.similar = 8764, e.sindothebrew = 1474, e.siosacirclekorean = 12916, e.siosaparenkorean = 12820, e.sioscieuckorean = 12670, e.sioscirclekorean = 12902, e.sioskiyeokkorean = 12666, e.sioskorean = 12613, e.siosnieunkorean = 12667, e.siosparenkorean = 12806, e.siospieupkorean = 12669, e.siostikeutkorean = 12668, e.six = 54, e.sixarabic = 1638, e.sixbengali = 2540, e.sixcircle = 9317, e.sixcircleinversesansserif = 10127, e.sixdeva = 2412, e.sixgujarati = 2796, e.sixgurmukhi = 2668, e.sixhackarabic = 1638, e.sixhangzhou = 12326, e.sixideographicparen = 12837, e.sixinferior = 8326, e.sixmonospace = 65302, e.sixoldstyle = 63286, e.sixparen = 9337, e.sixperiod = 9357, e.sixpersian = 1782, e.sixroman = 8565, e.sixsuperior = 8310, e.sixteencircle = 9327, e.sixteencurrencydenominatorbengali = 2553, e.sixteenparen = 9347, e.sixteenperiod = 9367, e.sixthai = 3670, e.slash = 47, e.slashmonospace = 65295, e.slong = 383, e.slongdotaccent = 7835, e.smileface = 9786, e.smonospace = 65363, e.sofpasuqhebrew = 1475, e.softhyphen = 173, e.softsigncyrillic = 1100, e.sohiragana = 12381, e.sokatakana = 12477, e.sokatakanahalfwidth = 65407, e.soliduslongoverlaycmb = 824, e.solidusshortoverlaycmb = 823, e.sorusithai = 3625, e.sosalathai = 3624, e.sosothai = 3595, e.sosuathai = 3626, e.space = 32, e.spacehackarabic = 32, e.spade = 9824, e.spadesuitblack = 9824, e.spadesuitwhite = 9828, e.sparen = 9390, e.squarebelowcmb = 827, e.squarecc = 13252, e.squarecm = 13213, e.squarediagonalcrosshatchfill = 9641, e.squarehorizontalfill = 9636, e.squarekg = 13199, e.squarekm = 13214, e.squarekmcapital = 13262, e.squareln = 13265, e.squarelog = 13266, e.squaremg = 13198, e.squaremil = 13269, e.squaremm = 13212, e.squaremsquared = 13217, e.squareorthogonalcrosshatchfill = 9638, e.squareupperlefttolowerrightfill = 9639, e.squareupperrighttolowerleftfill = 9640, e.squareverticalfill = 9637, e.squarewhitewithsmallblack = 9635, e.srsquare = 13275, e.ssabengali = 2487, e.ssadeva = 2359, e.ssagujarati = 2743, e.ssangcieuckorean = 12617, e.ssanghieuhkorean = 12677, e.ssangieungkorean = 12672, e.ssangkiyeokkorean = 12594, e.ssangnieunkorean = 12645, e.ssangpieupkorean = 12611, e.ssangsioskorean = 12614, e.ssangtikeutkorean = 12600, e.ssuperior = 63218, e.sterling = 163, e.sterlingmonospace = 65505, e.strokelongoverlaycmb = 822, e.strokeshortoverlaycmb = 821, e.subset = 8834, e.subsetnotequal = 8842, e.subsetorequal = 8838, e.succeeds = 8827, e.suchthat = 8715, e.suhiragana = 12377, e.sukatakana = 12473, e.sukatakanahalfwidth = 65405, e.sukunarabic = 1618, e.summation = 8721, e.sun = 9788, e.superset = 8835, e.supersetnotequal = 8843, e.supersetorequal = 8839, e.svsquare = 13276, e.syouwaerasquare = 13180, e.t = 116, e.tabengali = 2468, e.tackdown = 8868, e.tackleft = 8867, e.tadeva = 2340, e.tagujarati = 2724, e.tagurmukhi = 2596, e.taharabic = 1591, e.tahfinalarabic = 65218, e.tahinitialarabic = 65219, e.tahiragana = 12383, e.tahmedialarabic = 65220, e.taisyouerasquare = 13181, e.takatakana = 12479, e.takatakanahalfwidth = 65408, e.tatweelarabic = 1600, e.tau = 964, e.tav = 1514, e.tavdages = 64330, e.tavdagesh = 64330, e.tavdageshhebrew = 64330, e.tavhebrew = 1514, e.tbar = 359, e.tbopomofo = 12554, e.tcaron = 357, e.tccurl = 680, e.tcedilla = 355, e.tcheharabic = 1670, e.tchehfinalarabic = 64379, e.tchehinitialarabic = 64380, e.tchehmedialarabic = 64381, e.tcircle = 9443, e.tcircumflexbelow = 7793, e.tcommaaccent = 355, e.tdieresis = 7831, e.tdotaccent = 7787, e.tdotbelow = 7789, e.tecyrillic = 1090, e.tedescendercyrillic = 1197, e.teharabic = 1578, e.tehfinalarabic = 65174, e.tehhahinitialarabic = 64674, e.tehhahisolatedarabic = 64524, e.tehinitialarabic = 65175, e.tehiragana = 12390, e.tehjeeminitialarabic = 64673, e.tehjeemisolatedarabic = 64523, e.tehmarbutaarabic = 1577, e.tehmarbutafinalarabic = 65172, e.tehmedialarabic = 65176, e.tehmeeminitialarabic = 64676, e.tehmeemisolatedarabic = 64526, e.tehnoonfinalarabic = 64627, e.tekatakana = 12486, e.tekatakanahalfwidth = 65411, e.telephone = 8481, e.telephoneblack = 9742, e.telishagedolahebrew = 1440, e.telishaqetanahebrew = 1449, e.tencircle = 9321, e.tenideographicparen = 12841, e.tenparen = 9341, e.tenperiod = 9361, e.tenroman = 8569, e.tesh = 679, e.tet = 1496, e.tetdagesh = 64312, e.tetdageshhebrew = 64312, e.tethebrew = 1496, e.tetsecyrillic = 1205, e.tevirhebrew = 1435, e.tevirlefthebrew = 1435, e.thabengali = 2469, e.thadeva = 2341, e.thagujarati = 2725, e.thagurmukhi = 2597, e.thalarabic = 1584, e.thalfinalarabic = 65196, e.thanthakhatlowleftthai = 63640, e.thanthakhatlowrightthai = 63639, e.thanthakhatthai = 3660, e.thanthakhatupperleftthai = 63638, e.theharabic = 1579, e.thehfinalarabic = 65178, e.thehinitialarabic = 65179, e.thehmedialarabic = 65180, e.thereexists = 8707, e.therefore = 8756, e.theta = 952, e.theta1 = 977, e.thetasymbolgreek = 977, e.thieuthacirclekorean = 12921, e.thieuthaparenkorean = 12825, e.thieuthcirclekorean = 12907, e.thieuthkorean = 12620, e.thieuthparenkorean = 12811, e.thirteencircle = 9324, e.thirteenparen = 9344, e.thirteenperiod = 9364, e.thonangmonthothai = 3601, e.thook = 429, e.thophuthaothai = 3602, e.thorn = 254, e.thothahanthai = 3607, e.thothanthai = 3600, e.thothongthai = 3608, e.thothungthai = 3606, e.thousandcyrillic = 1154, e.thousandsseparatorarabic = 1644, e.thousandsseparatorpersian = 1644, e.three = 51, e.threearabic = 1635, e.threebengali = 2537, e.threecircle = 9314, e.threecircleinversesansserif = 10124, e.threedeva = 2409, e.threeeighths = 8540, e.threegujarati = 2793, e.threegurmukhi = 2665, e.threehackarabic = 1635, e.threehangzhou = 12323, e.threeideographicparen = 12834, e.threeinferior = 8323, e.threemonospace = 65299, e.threenumeratorbengali = 2550, e.threeoldstyle = 63283, e.threeparen = 9334, e.threeperiod = 9354, e.threepersian = 1779, e.threequarters = 190, e.threequartersemdash = 63198, e.threeroman = 8562, e.threesuperior = 179, e.threethai = 3667, e.thzsquare = 13204, e.tihiragana = 12385, e.tikatakana = 12481, e.tikatakanahalfwidth = 65409, e.tikeutacirclekorean = 12912, e.tikeutaparenkorean = 12816, e.tikeutcirclekorean = 12898, e.tikeutkorean = 12599, e.tikeutparenkorean = 12802, e.tilde = 732, e.tildebelowcmb = 816, e.tildecmb = 771, e.tildecomb = 771, e.tildedoublecmb = 864, e.tildeoperator = 8764, e.tildeoverlaycmb = 820, e.tildeverticalcmb = 830, e.timescircle = 8855, e.tipehahebrew = 1430, e.tipehalefthebrew = 1430, e.tippigurmukhi = 2672, e.titlocyrilliccmb = 1155, e.tiwnarmenian = 1407, e.tlinebelow = 7791, e.tmonospace = 65364, e.toarmenian = 1385, e.tohiragana = 12392, e.tokatakana = 12488, e.tokatakanahalfwidth = 65412, e.tonebarextrahighmod = 741, e.tonebarextralowmod = 745, e.tonebarhighmod = 742, e.tonebarlowmod = 744, e.tonebarmidmod = 743, e.tonefive = 445, e.tonesix = 389, e.tonetwo = 424, e.tonos = 900, e.tonsquare = 13095, e.topatakthai = 3599, e.tortoiseshellbracketleft = 12308, e.tortoiseshellbracketleftsmall = 65117, e.tortoiseshellbracketleftvertical = 65081, e.tortoiseshellbracketright = 12309, e.tortoiseshellbracketrightsmall = 65118, e.tortoiseshellbracketrightvertical = 65082, e.totaothai = 3605, e.tpalatalhook = 427, e.tparen = 9391, e.trademark = 8482, e.trademarksans = 63722, e.trademarkserif = 63195, e.tretroflexhook = 648, e.triagdn = 9660, e.triaglf = 9668, e.triagrt = 9658, e.triagup = 9650, e.ts = 678, e.tsadi = 1510, e.tsadidagesh = 64326, e.tsadidageshhebrew = 64326, e.tsadihebrew = 1510, e.tsecyrillic = 1094, e.tsere = 1461, e.tsere12 = 1461, e.tsere1e = 1461, e.tsere2b = 1461, e.tserehebrew = 1461, e.tserenarrowhebrew = 1461, e.tserequarterhebrew = 1461, e.tserewidehebrew = 1461, e.tshecyrillic = 1115, e.tsuperior = 63219, e.ttabengali = 2463, e.ttadeva = 2335, e.ttagujarati = 2719, e.ttagurmukhi = 2591, e.tteharabic = 1657, e.ttehfinalarabic = 64359, e.ttehinitialarabic = 64360, e.ttehmedialarabic = 64361, e.tthabengali = 2464, e.tthadeva = 2336, e.tthagujarati = 2720, e.tthagurmukhi = 2592, e.tturned = 647, e.tuhiragana = 12388, e.tukatakana = 12484, e.tukatakanahalfwidth = 65410, e.tusmallhiragana = 12387, e.tusmallkatakana = 12483, e.tusmallkatakanahalfwidth = 65391, e.twelvecircle = 9323, e.twelveparen = 9343, e.twelveperiod = 9363, e.twelveroman = 8571, e.twentycircle = 9331, e.twentyhangzhou = 21316, e.twentyparen = 9351, e.twentyperiod = 9371, e.two = 50, e.twoarabic = 1634, e.twobengali = 2536, e.twocircle = 9313, e.twocircleinversesansserif = 10123, e.twodeva = 2408, e.twodotenleader = 8229, e.twodotleader = 8229, e.twodotleadervertical = 65072, e.twogujarati = 2792, e.twogurmukhi = 2664, e.twohackarabic = 1634, e.twohangzhou = 12322, e.twoideographicparen = 12833, e.twoinferior = 8322, e.twomonospace = 65298, e.twonumeratorbengali = 2549, e.twooldstyle = 63282, e.twoparen = 9333, e.twoperiod = 9353, e.twopersian = 1778, e.tworoman = 8561, e.twostroke = 443, e.twosuperior = 178, e.twothai = 3666, e.twothirds = 8532, e.u = 117, e.uacute = 250, e.ubar = 649, e.ubengali = 2441, e.ubopomofo = 12584, e.ubreve = 365, e.ucaron = 468, e.ucircle = 9444, e.ucircumflex = 251, e.ucircumflexbelow = 7799, e.ucyrillic = 1091, e.udattadeva = 2385, e.udblacute = 369, e.udblgrave = 533, e.udeva = 2313, e.udieresis = 252, e.udieresisacute = 472, e.udieresisbelow = 7795, e.udieresiscaron = 474, e.udieresiscyrillic = 1265, e.udieresisgrave = 476, e.udieresismacron = 470, e.udotbelow = 7909, e.ugrave = 249, e.ugujarati = 2697, e.ugurmukhi = 2569, e.uhiragana = 12358, e.uhookabove = 7911, e.uhorn = 432, e.uhornacute = 7913, e.uhorndotbelow = 7921, e.uhorngrave = 7915, e.uhornhookabove = 7917, e.uhorntilde = 7919, e.uhungarumlaut = 369, e.uhungarumlautcyrillic = 1267, e.uinvertedbreve = 535, e.ukatakana = 12454, e.ukatakanahalfwidth = 65395, e.ukcyrillic = 1145, e.ukorean = 12636, e.umacron = 363, e.umacroncyrillic = 1263, e.umacrondieresis = 7803, e.umatragurmukhi = 2625, e.umonospace = 65365, e.underscore = 95, e.underscoredbl = 8215, e.underscoremonospace = 65343, e.underscorevertical = 65075, e.underscorewavy = 65103, e.union = 8746, e.universal = 8704, e.uogonek = 371, e.uparen = 9392, e.upblock = 9600, e.upperdothebrew = 1476, e.upsilon = 965, e.upsilondieresis = 971, e.upsilondieresistonos = 944, e.upsilonlatin = 650, e.upsilontonos = 973, e.uptackbelowcmb = 797, e.uptackmod = 724, e.uragurmukhi = 2675, e.uring = 367, e.ushortcyrillic = 1118, e.usmallhiragana = 12357, e.usmallkatakana = 12453, e.usmallkatakanahalfwidth = 65385, e.ustraightcyrillic = 1199, e.ustraightstrokecyrillic = 1201, e.utilde = 361, e.utildeacute = 7801, e.utildebelow = 7797, e.uubengali = 2442, e.uudeva = 2314, e.uugujarati = 2698, e.uugurmukhi = 2570, e.uumatragurmukhi = 2626, e.uuvowelsignbengali = 2498, e.uuvowelsigndeva = 2370, e.uuvowelsigngujarati = 2754, e.uvowelsignbengali = 2497, e.uvowelsigndeva = 2369, e.uvowelsigngujarati = 2753, e.v = 118, e.vadeva = 2357, e.vagujarati = 2741, e.vagurmukhi = 2613, e.vakatakana = 12535, e.vav = 1493, e.vavdagesh = 64309, e.vavdagesh65 = 64309, e.vavdageshhebrew = 64309, e.vavhebrew = 1493, e.vavholam = 64331, e.vavholamhebrew = 64331, e.vavvavhebrew = 1520, e.vavyodhebrew = 1521, e.vcircle = 9445, e.vdotbelow = 7807, e.vecyrillic = 1074, e.veharabic = 1700, e.vehfinalarabic = 64363, e.vehinitialarabic = 64364, e.vehmedialarabic = 64365, e.vekatakana = 12537, e.venus = 9792, e.verticalbar = 124, e.verticallineabovecmb = 781, e.verticallinebelowcmb = 809, e.verticallinelowmod = 716, e.verticallinemod = 712, e.vewarmenian = 1406, e.vhook = 651, e.vikatakana = 12536, e.viramabengali = 2509, e.viramadeva = 2381, e.viramagujarati = 2765, e.visargabengali = 2435, e.visargadeva = 2307, e.visargagujarati = 2691, e.vmonospace = 65366, e.voarmenian = 1400, e.voicediterationhiragana = 12446, e.voicediterationkatakana = 12542, e.voicedmarkkana = 12443, e.voicedmarkkanahalfwidth = 65438, e.vokatakana = 12538, e.vparen = 9393, e.vtilde = 7805, e.vturned = 652, e.vuhiragana = 12436, e.vukatakana = 12532, e.w = 119, e.wacute = 7811, e.waekorean = 12633, e.wahiragana = 12431, e.wakatakana = 12527, e.wakatakanahalfwidth = 65436, e.wakorean = 12632, e.wasmallhiragana = 12430, e.wasmallkatakana = 12526, e.wattosquare = 13143, e.wavedash = 12316, e.wavyunderscorevertical = 65076, e.wawarabic = 1608, e.wawfinalarabic = 65262, e.wawhamzaabovearabic = 1572, e.wawhamzaabovefinalarabic = 65158, e.wbsquare = 13277, e.wcircle = 9446, e.wcircumflex = 373, e.wdieresis = 7813, e.wdotaccent = 7815, e.wdotbelow = 7817, e.wehiragana = 12433, e.weierstrass = 8472, e.wekatakana = 12529, e.wekorean = 12638, e.weokorean = 12637, e.wgrave = 7809, e.whitebullet = 9702, e.whitecircle = 9675, e.whitecircleinverse = 9689, e.whitecornerbracketleft = 12302, e.whitecornerbracketleftvertical = 65091, e.whitecornerbracketright = 12303, e.whitecornerbracketrightvertical = 65092, e.whitediamond = 9671, e.whitediamondcontainingblacksmalldiamond = 9672, e.whitedownpointingsmalltriangle = 9663, e.whitedownpointingtriangle = 9661, e.whiteleftpointingsmalltriangle = 9667, e.whiteleftpointingtriangle = 9665, e.whitelenticularbracketleft = 12310, e.whitelenticularbracketright = 12311, e.whiterightpointingsmalltriangle = 9657, e.whiterightpointingtriangle = 9655, e.whitesmallsquare = 9643, e.whitesmilingface = 9786, e.whitesquare = 9633, e.whitestar = 9734, e.whitetelephone = 9743, e.whitetortoiseshellbracketleft = 12312, e.whitetortoiseshellbracketright = 12313, e.whiteuppointingsmalltriangle = 9653, e.whiteuppointingtriangle = 9651, e.wihiragana = 12432, e.wikatakana = 12528, e.wikorean = 12639, e.wmonospace = 65367, e.wohiragana = 12434, e.wokatakana = 12530, e.wokatakanahalfwidth = 65382, e.won = 8361, e.wonmonospace = 65510, e.wowaenthai = 3623, e.wparen = 9394, e.wring = 7832, e.wsuperior = 695, e.wturned = 653, e.wynn = 447, e.x = 120, e.xabovecmb = 829, e.xbopomofo = 12562, e.xcircle = 9447, e.xdieresis = 7821, e.xdotaccent = 7819, e.xeharmenian = 1389, e.xi = 958, e.xmonospace = 65368, e.xparen = 9395, e.xsuperior = 739, e.y = 121, e.yaadosquare = 13134, e.yabengali = 2479, e.yacute = 253, e.yadeva = 2351, e.yaekorean = 12626, e.yagujarati = 2735, e.yagurmukhi = 2607, e.yahiragana = 12420, e.yakatakana = 12516, e.yakatakanahalfwidth = 65428, e.yakorean = 12625, e.yamakkanthai = 3662, e.yasmallhiragana = 12419, e.yasmallkatakana = 12515, e.yasmallkatakanahalfwidth = 65388, e.yatcyrillic = 1123, e.ycircle = 9448, e.ycircumflex = 375, e.ydieresis = 255, e.ydotaccent = 7823, e.ydotbelow = 7925, e.yeharabic = 1610, e.yehbarreearabic = 1746, e.yehbarreefinalarabic = 64431, e.yehfinalarabic = 65266, e.yehhamzaabovearabic = 1574, e.yehhamzaabovefinalarabic = 65162, e.yehhamzaaboveinitialarabic = 65163, e.yehhamzaabovemedialarabic = 65164, e.yehinitialarabic = 65267, e.yehmedialarabic = 65268, e.yehmeeminitialarabic = 64733, e.yehmeemisolatedarabic = 64600, e.yehnoonfinalarabic = 64660, e.yehthreedotsbelowarabic = 1745, e.yekorean = 12630, e.yen = 165, e.yenmonospace = 65509, e.yeokorean = 12629, e.yeorinhieuhkorean = 12678, e.yerahbenyomohebrew = 1450, e.yerahbenyomolefthebrew = 1450, e.yericyrillic = 1099, e.yerudieresiscyrillic = 1273, e.yesieungkorean = 12673, e.yesieungpansioskorean = 12675, e.yesieungsioskorean = 12674, e.yetivhebrew = 1434, e.ygrave = 7923, e.yhook = 436, e.yhookabove = 7927, e.yiarmenian = 1397, e.yicyrillic = 1111, e.yikorean = 12642, e.yinyang = 9775, e.yiwnarmenian = 1410, e.ymonospace = 65369, e.yod = 1497, e.yoddagesh = 64313, e.yoddageshhebrew = 64313, e.yodhebrew = 1497, e.yodyodhebrew = 1522, e.yodyodpatahhebrew = 64287, e.yohiragana = 12424, e.yoikorean = 12681, e.yokatakana = 12520, e.yokatakanahalfwidth = 65430, e.yokorean = 12635, e.yosmallhiragana = 12423, e.yosmallkatakana = 12519, e.yosmallkatakanahalfwidth = 65390, e.yotgreek = 1011, e.yoyaekorean = 12680, e.yoyakorean = 12679, e.yoyakthai = 3618, e.yoyingthai = 3597, e.yparen = 9396, e.ypogegrammeni = 890, e.ypogegrammenigreekcmb = 837, e.yr = 422, e.yring = 7833, e.ysuperior = 696, e.ytilde = 7929, e.yturned = 654, e.yuhiragana = 12422, e.yuikorean = 12684, e.yukatakana = 12518, e.yukatakanahalfwidth = 65429, e.yukorean = 12640, e.yusbigcyrillic = 1131, e.yusbigiotifiedcyrillic = 1133, e.yuslittlecyrillic = 1127, e.yuslittleiotifiedcyrillic = 1129, e.yusmallhiragana = 12421, e.yusmallkatakana = 12517, e.yusmallkatakanahalfwidth = 65389, e.yuyekorean = 12683, e.yuyeokorean = 12682, e.yyabengali = 2527, e.yyadeva = 2399, e.z = 122, e.zaarmenian = 1382, e.zacute = 378, e.zadeva = 2395, e.zagurmukhi = 2651, e.zaharabic = 1592, e.zahfinalarabic = 65222, e.zahinitialarabic = 65223, e.zahiragana = 12374, e.zahmedialarabic = 65224, e.zainarabic = 1586, e.zainfinalarabic = 65200, e.zakatakana = 12470, e.zaqefgadolhebrew = 1429, e.zaqefqatanhebrew = 1428, e.zarqahebrew = 1432, e.zayin = 1494, e.zayindagesh = 64310, e.zayindageshhebrew = 64310, e.zayinhebrew = 1494, e.zbopomofo = 12567, e.zcaron = 382, e.zcircle = 9449, e.zcircumflex = 7825, e.zcurl = 657, e.zdot = 380, e.zdotaccent = 380, e.zdotbelow = 7827, e.zecyrillic = 1079, e.zedescendercyrillic = 1177, e.zedieresiscyrillic = 1247, e.zehiragana = 12380, e.zekatakana = 12476, e.zero = 48, e.zeroarabic = 1632, e.zerobengali = 2534, e.zerodeva = 2406, e.zerogujarati = 2790, e.zerogurmukhi = 2662, e.zerohackarabic = 1632, e.zeroinferior = 8320, e.zeromonospace = 65296, e.zerooldstyle = 63280, e.zeropersian = 1776, e.zerosuperior = 8304, e.zerothai = 3664, e.zerowidthjoiner = 65279, e.zerowidthnonjoiner = 8204, e.zerowidthspace = 8203, e.zeta = 950, e.zhbopomofo = 12563, e.zhearmenian = 1386, e.zhebrevecyrillic = 1218, e.zhecyrillic = 1078, e.zhedescendercyrillic = 1175, e.zhedieresiscyrillic = 1245, e.zihiragana = 12376, e.zikatakana = 12472, e.zinorhebrew = 1454, e.zlinebelow = 7829, e.zmonospace = 65370, e.zohiragana = 12382, e.zokatakana = 12478, e.zparen = 9397, e.zretroflexhook = 656, e.zstroke = 438, e.zuhiragana = 12378, e.zukatakana = 12474, e[".notdef"] = 0, e.angbracketleftbig = 9001, e.angbracketleftBig = 9001, e.angbracketleftbigg = 9001, e.angbracketleftBigg = 9001, e.angbracketrightBig = 9002, e.angbracketrightbig = 9002, e.angbracketrightBigg = 9002, e.angbracketrightbigg = 9002, e.arrowhookleft = 8618, e.arrowhookright = 8617, e.arrowlefttophalf = 8636, e.arrowleftbothalf = 8637, e.arrownortheast = 8599, e.arrownorthwest = 8598, e.arrowrighttophalf = 8640, e.arrowrightbothalf = 8641, e.arrowsoutheast = 8600, e.arrowsouthwest = 8601, e.backslashbig = 8726, e.backslashBig = 8726, e.backslashBigg = 8726, e.backslashbigg = 8726, e.bardbl = 8214, e.bracehtipdownleft = 65079, e.bracehtipdownright = 65079, e.bracehtipupleft = 65080, e.bracehtipupright = 65080, e.braceleftBig = 123, e.braceleftbig = 123, e.braceleftbigg = 123, e.braceleftBigg = 123, e.bracerightBig = 125, e.bracerightbig = 125, e.bracerightbigg = 125, e.bracerightBigg = 125, e.bracketleftbig = 91, e.bracketleftBig = 91, e.bracketleftbigg = 91, e.bracketleftBigg = 91, e.bracketrightBig = 93, e.bracketrightbig = 93, e.bracketrightbigg = 93, e.bracketrightBigg = 93, e.ceilingleftbig = 8968, e.ceilingleftBig = 8968, e.ceilingleftBigg = 8968, e.ceilingleftbigg = 8968, e.ceilingrightbig = 8969, e.ceilingrightBig = 8969, e.ceilingrightbigg = 8969, e.ceilingrightBigg = 8969, e.circledotdisplay = 8857, e.circledottext = 8857, e.circlemultiplydisplay = 8855, e.circlemultiplytext = 8855, e.circleplusdisplay = 8853, e.circleplustext = 8853, e.contintegraldisplay = 8750, e.contintegraltext = 8750, e.coproductdisplay = 8720, e.coproducttext = 8720, e.floorleftBig = 8970, e.floorleftbig = 8970, e.floorleftbigg = 8970, e.floorleftBigg = 8970, e.floorrightbig = 8971, e.floorrightBig = 8971, e.floorrightBigg = 8971, e.floorrightbigg = 8971, e.hatwide = 770, e.hatwider = 770, e.hatwidest = 770, e.intercal = 7488, e.integraldisplay = 8747, e.integraltext = 8747, e.intersectiondisplay = 8898, e.intersectiontext = 8898, e.logicalanddisplay = 8743, e.logicalandtext = 8743, e.logicalordisplay = 8744, e.logicalortext = 8744, e.parenleftBig = 40, e.parenleftbig = 40, e.parenleftBigg = 40, e.parenleftbigg = 40, e.parenrightBig = 41, e.parenrightbig = 41, e.parenrightBigg = 41, e.parenrightbigg = 41, e.prime = 8242, e.productdisplay = 8719, e.producttext = 8719, e.radicalbig = 8730, e.radicalBig = 8730, e.radicalBigg = 8730, e.radicalbigg = 8730, e.radicalbt = 8730, e.radicaltp = 8730, e.radicalvertex = 8730, e.slashbig = 47, e.slashBig = 47, e.slashBigg = 47, e.slashbigg = 47, e.summationdisplay = 8721, e.summationtext = 8721, e.tildewide = 732, e.tildewider = 732, e.tildewidest = 732, e.uniondisplay = 8899, e.unionmultidisplay = 8846, e.unionmultitext = 8846, e.unionsqdisplay = 8852, e.unionsqtext = 8852, e.uniontext = 8899, e.vextenddouble = 8741, e.vextendsingle = 8739;
}), FB = le(function(e) {
  e.space = 32, e.a1 = 9985, e.a2 = 9986, e.a202 = 9987, e.a3 = 9988, e.a4 = 9742, e.a5 = 9990, e.a119 = 9991, e.a118 = 9992, e.a117 = 9993, e.a11 = 9755, e.a12 = 9758, e.a13 = 9996, e.a14 = 9997, e.a15 = 9998, e.a16 = 9999, e.a105 = 1e4, e.a17 = 10001, e.a18 = 10002, e.a19 = 10003, e.a20 = 10004, e.a21 = 10005, e.a22 = 10006, e.a23 = 10007, e.a24 = 10008, e.a25 = 10009, e.a26 = 10010, e.a27 = 10011, e.a28 = 10012, e.a6 = 10013, e.a7 = 10014, e.a8 = 10015, e.a9 = 10016, e.a10 = 10017, e.a29 = 10018, e.a30 = 10019, e.a31 = 10020, e.a32 = 10021, e.a33 = 10022, e.a34 = 10023, e.a35 = 9733, e.a36 = 10025, e.a37 = 10026, e.a38 = 10027, e.a39 = 10028, e.a40 = 10029, e.a41 = 10030, e.a42 = 10031, e.a43 = 10032, e.a44 = 10033, e.a45 = 10034, e.a46 = 10035, e.a47 = 10036, e.a48 = 10037, e.a49 = 10038, e.a50 = 10039, e.a51 = 10040, e.a52 = 10041, e.a53 = 10042, e.a54 = 10043, e.a55 = 10044, e.a56 = 10045, e.a57 = 10046, e.a58 = 10047, e.a59 = 10048, e.a60 = 10049, e.a61 = 10050, e.a62 = 10051, e.a63 = 10052, e.a64 = 10053, e.a65 = 10054, e.a66 = 10055, e.a67 = 10056, e.a68 = 10057, e.a69 = 10058, e.a70 = 10059, e.a71 = 9679, e.a72 = 10061, e.a73 = 9632, e.a74 = 10063, e.a203 = 10064, e.a75 = 10065, e.a204 = 10066, e.a76 = 9650, e.a77 = 9660, e.a78 = 9670, e.a79 = 10070, e.a81 = 9687, e.a82 = 10072, e.a83 = 10073, e.a84 = 10074, e.a97 = 10075, e.a98 = 10076, e.a99 = 10077, e.a100 = 10078, e.a101 = 10081, e.a102 = 10082, e.a103 = 10083, e.a104 = 10084, e.a106 = 10085, e.a107 = 10086, e.a108 = 10087, e.a112 = 9827, e.a111 = 9830, e.a110 = 9829, e.a109 = 9824, e.a120 = 9312, e.a121 = 9313, e.a122 = 9314, e.a123 = 9315, e.a124 = 9316, e.a125 = 9317, e.a126 = 9318, e.a127 = 9319, e.a128 = 9320, e.a129 = 9321, e.a130 = 10102, e.a131 = 10103, e.a132 = 10104, e.a133 = 10105, e.a134 = 10106, e.a135 = 10107, e.a136 = 10108, e.a137 = 10109, e.a138 = 10110, e.a139 = 10111, e.a140 = 10112, e.a141 = 10113, e.a142 = 10114, e.a143 = 10115, e.a144 = 10116, e.a145 = 10117, e.a146 = 10118, e.a147 = 10119, e.a148 = 10120, e.a149 = 10121, e.a150 = 10122, e.a151 = 10123, e.a152 = 10124, e.a153 = 10125, e.a154 = 10126, e.a155 = 10127, e.a156 = 10128, e.a157 = 10129, e.a158 = 10130, e.a159 = 10131, e.a160 = 10132, e.a161 = 8594, e.a163 = 8596, e.a164 = 8597, e.a196 = 10136, e.a165 = 10137, e.a192 = 10138, e.a166 = 10139, e.a167 = 10140, e.a168 = 10141, e.a169 = 10142, e.a170 = 10143, e.a171 = 10144, e.a172 = 10145, e.a173 = 10146, e.a162 = 10147, e.a174 = 10148, e.a175 = 10149, e.a176 = 10150, e.a177 = 10151, e.a178 = 10152, e.a179 = 10153, e.a193 = 10154, e.a180 = 10155, e.a199 = 10156, e.a181 = 10157, e.a200 = 10158, e.a182 = 10159, e.a201 = 10161, e.a183 = 10162, e.a184 = 10163, e.a197 = 10164, e.a185 = 10165, e.a194 = 10166, e.a198 = 10167, e.a186 = 10168, e.a195 = 10169, e.a187 = 10170, e.a188 = 10171, e.a189 = 10172, e.a190 = 10173, e.a191 = 10174, e.a89 = 10088, e.a90 = 10089, e.a93 = 10090, e.a94 = 10091, e.a91 = 10092, e.a92 = 10093, e.a205 = 10094, e.a85 = 10095, e.a206 = 10096, e.a86 = 10097, e.a87 = 10098, e.a88 = 10099, e.a95 = 10100, e.a96 = 10101, e[".notdef"] = 0;
}), RB = le(function(e) {
  e[63721] = 169, e[63193] = 169, e[63720] = 174, e[63194] = 174, e[63722] = 8482, e[63195] = 8482, e[63729] = 9127, e[63730] = 9128, e[63731] = 9129, e[63740] = 9131, e[63741] = 9132, e[63742] = 9133, e[63726] = 9121, e[63727] = 9122, e[63728] = 9123, e[63737] = 9124, e[63738] = 9125, e[63739] = 9126, e[63723] = 9115, e[63724] = 9116, e[63725] = 9117, e[63734] = 9118, e[63735] = 9119, e[63736] = 9120;
});
function GB(e) {
  return e >= 65520 && e <= 65535 ? 0 : e >= 62976 && e <= 63743 ? RB()[e] || e : e === 173 ? 45 : e;
}
function is(e, A) {
  let t = A[e];
  if (t !== void 0)
    return t;
  if (!e)
    return -1;
  if (e[0] === "u") {
    const i = e.length;
    let s;
    if (i === 7 && e[1] === "n" && e[2] === "i")
      s = e.substring(3);
    else if (i >= 5 && i <= 7)
      s = e.substring(1);
    else
      return -1;
    if (s === s.toUpperCase() && (t = parseInt(s, 16), t >= 0))
      return t;
  }
  return -1;
}
const wr = [[0, 127], [128, 255], [256, 383], [384, 591], [592, 687, 7424, 7551, 7552, 7615], [688, 767, 42752, 42783], [768, 879, 7616, 7679], [880, 1023], [11392, 11519], [1024, 1279, 1280, 1327, 11744, 11775, 42560, 42655], [1328, 1423], [1424, 1535], [42240, 42559], [1536, 1791, 1872, 1919], [1984, 2047], [2304, 2431], [2432, 2559], [2560, 2687], [2688, 2815], [2816, 2943], [2944, 3071], [3072, 3199], [3200, 3327], [3328, 3455], [3584, 3711], [3712, 3839], [4256, 4351, 11520, 11567], [6912, 7039], [4352, 4607], [7680, 7935, 11360, 11391, 42784, 43007], [7936, 8191], [8192, 8303, 11776, 11903], [8304, 8351], [8352, 8399], [8400, 8447], [8448, 8527], [8528, 8591], [8592, 8703, 10224, 10239, 10496, 10623, 11008, 11263], [8704, 8959, 10752, 11007, 10176, 10223, 10624, 10751], [8960, 9215], [9216, 9279], [9280, 9311], [9312, 9471], [9472, 9599], [9600, 9631], [9632, 9727], [9728, 9983], [9984, 10175], [12288, 12351], [12352, 12447], [12448, 12543, 12784, 12799], [12544, 12591, 12704, 12735], [12592, 12687], [43072, 43135], [12800, 13055], [13056, 13311], [44032, 55215], [55296, 57343], [67840, 67871], [19968, 40959, 11904, 12031, 12032, 12255, 12272, 12287, 13312, 19903, 131072, 173791, 12688, 12703], [57344, 63743], [12736, 12783, 63744, 64255, 194560, 195103], [64256, 64335], [64336, 65023], [65056, 65071], [65040, 65055], [65104, 65135], [65136, 65279], [65280, 65519], [65520, 65535], [3840, 4095], [1792, 1871], [1920, 1983], [3456, 3583], [4096, 4255], [4608, 4991, 4992, 5023, 11648, 11743], [5024, 5119], [5120, 5759], [5760, 5791], [5792, 5887], [6016, 6143], [6144, 6319], [10240, 10495], [40960, 42127], [5888, 5919, 5920, 5951, 5952, 5983, 5984, 6015], [66304, 66351], [66352, 66383], [66560, 66639], [118784, 119039, 119040, 119295, 119296, 119375], [119808, 120831], [1044480, 1048573], [65024, 65039, 917760, 917999], [917504, 917631], [6400, 6479], [6480, 6527], [6528, 6623], [6656, 6687], [11264, 11359], [11568, 11647], [19904, 19967], [43008, 43055], [65536, 65663, 65664, 65791, 65792, 65855], [65856, 65935], [66432, 66463], [66464, 66527], [66640, 66687], [66688, 66735], [67584, 67647], [68096, 68191], [119552, 119647], [73728, 74751, 74752, 74879], [119648, 119679], [7040, 7103], [7168, 7247], [7248, 7295], [43136, 43231], [43264, 43311], [43312, 43359], [43520, 43615], [65936, 65999], [66e3, 66047], [66208, 66271, 66176, 66207, 67872, 67903], [127024, 127135, 126976, 127023]];
function NB(e, A = -1) {
  if (A !== -1) {
    const t = wr[A];
    for (let i = 0, s = t.length; i < s; i += 2)
      if (e >= t[i] && e <= t[i + 1])
        return A;
  }
  for (let t = 0, i = wr.length; t < i; t++) {
    const s = wr[t];
    for (let a = 0, n = s.length; a < n; a += 2)
      if (e >= s[a] && e <= s[a + 1])
        return t;
  }
  return -1;
}
const MB = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), hg = /* @__PURE__ */ new Map();
function UB(e) {
  const A = hg.get(e);
  if (A)
    return A;
  const t = e.match(MB), i = {
    isWhitespace: !!(t != null && t[1]),
    isZeroWidthDiacritic: !!(t != null && t[2]),
    isInvisibleFormatMark: !!(t != null && t[3])
  };
  return hg.set(e, i), i;
}
function LB() {
  hg.clear();
}
const V0 = !0, vt = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Nonsymbolic: 32
}, eI = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
function Oc(e, A) {
  if (A[e] !== void 0)
    return e;
  const t = is(e, A);
  if (t !== -1) {
    for (const i in A)
      if (A[i] === t)
        return i;
  }
  return vA("Unable to recover a standard glyph name for: " + e), e;
}
function Vc(e, A, t) {
  const i = /* @__PURE__ */ Object.create(null);
  let s, a, n;
  const r = !!(e.flags & vt.Symbolic);
  if (e.isInternalFont)
    for (n = A, a = 0; a < n.length; a++)
      s = t.indexOf(n[a]), i[a] = s >= 0 ? s : 0;
  else if (e.baseEncodingName)
    for (n = Xs(e.baseEncodingName), a = 0; a < n.length; a++)
      s = t.indexOf(n[a]), i[a] = s >= 0 ? s : 0;
  else if (r)
    for (a in A)
      i[a] = A[a];
  else
    for (n = Ei, a = 0; a < n.length; a++)
      s = t.indexOf(n[a]), i[a] = s >= 0 ? s : 0;
  const g = e.differences;
  let o;
  if (g)
    for (a in g) {
      const I = g[a];
      if (s = t.indexOf(I), s === -1) {
        o || (o = ti());
        const c = Oc(I, o);
        c !== I && (s = t.indexOf(c));
      }
      i[a] = s >= 0 ? s : 0;
    }
  return i;
}
function wa(e) {
  return e.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
}
const HB = le((e) => {
  e[8211] = 65074, e[8212] = 65073, e[8229] = 65072, e[8230] = 65049, e[12289] = 65041, e[12290] = 65042, e[12296] = 65087, e[12297] = 65088, e[12298] = 65085, e[12299] = 65086, e[12300] = 65089, e[12301] = 65090, e[12302] = 65091, e[12303] = 65092, e[12304] = 65083, e[12305] = 65084, e[12308] = 65081, e[12309] = 65082, e[12310] = 65047, e[12311] = 65048, e[65103] = 65076, e[65281] = 65045, e[65288] = 65077, e[65289] = 65078, e[65292] = 65040, e[65306] = 65043, e[65307] = 65044, e[65311] = 65046, e[65339] = 65095, e[65341] = 65096, e[65343] = 65075, e[65371] = 65079, e[65373] = 65080;
}), ir = le(function(e) {
  e["Times-Roman"] = "Times-Roman", e.Helvetica = "Helvetica", e.Courier = "Courier", e.Symbol = "Symbol", e["Times-Bold"] = "Times-Bold", e["Helvetica-Bold"] = "Helvetica-Bold", e["Courier-Bold"] = "Courier-Bold", e.ZapfDingbats = "ZapfDingbats", e["Times-Italic"] = "Times-Italic", e["Helvetica-Oblique"] = "Helvetica-Oblique", e["Courier-Oblique"] = "Courier-Oblique", e["Times-BoldItalic"] = "Times-BoldItalic", e["Helvetica-BoldOblique"] = "Helvetica-BoldOblique", e["Courier-BoldOblique"] = "Courier-BoldOblique", e.ArialNarrow = "Helvetica", e["ArialNarrow-Bold"] = "Helvetica-Bold", e["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique", e["ArialNarrow-Italic"] = "Helvetica-Oblique", e.ArialBlack = "Helvetica", e["ArialBlack-Bold"] = "Helvetica-Bold", e["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique", e["ArialBlack-Italic"] = "Helvetica-Oblique", e["Arial-Black"] = "Helvetica", e["Arial-Black-Bold"] = "Helvetica-Bold", e["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique", e["Arial-Black-Italic"] = "Helvetica-Oblique", e.Arial = "Helvetica", e["Arial-Bold"] = "Helvetica-Bold", e["Arial-BoldItalic"] = "Helvetica-BoldOblique", e["Arial-Italic"] = "Helvetica-Oblique", e.ArialMT = "Helvetica", e["Arial-BoldItalicMT"] = "Helvetica-BoldOblique", e["Arial-BoldMT"] = "Helvetica-Bold", e["Arial-ItalicMT"] = "Helvetica-Oblique", e["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique", e["Arial-BoldMT-Bold"] = "Helvetica-Bold", e["Arial-ItalicMT-Italic"] = "Helvetica-Oblique", e.ArialUnicodeMS = "Helvetica", e["ArialUnicodeMS-Bold"] = "Helvetica-Bold", e["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique", e["ArialUnicodeMS-Italic"] = "Helvetica-Oblique", e["Courier-BoldItalic"] = "Courier-BoldOblique", e["Courier-Italic"] = "Courier-Oblique", e.CourierNew = "Courier", e["CourierNew-Bold"] = "Courier-Bold", e["CourierNew-BoldItalic"] = "Courier-BoldOblique", e["CourierNew-Italic"] = "Courier-Oblique", e["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique", e["CourierNewPS-BoldMT"] = "Courier-Bold", e["CourierNewPS-ItalicMT"] = "Courier-Oblique", e.CourierNewPSMT = "Courier", e["Helvetica-BoldItalic"] = "Helvetica-BoldOblique", e["Helvetica-Italic"] = "Helvetica-Oblique", e["HelveticaLTStd-Bold"] = "Helvetica-Bold", e["Symbol-Bold"] = "Symbol", e["Symbol-BoldItalic"] = "Symbol", e["Symbol-Italic"] = "Symbol", e.TimesNewRoman = "Times-Roman", e["TimesNewRoman-Bold"] = "Times-Bold", e["TimesNewRoman-BoldItalic"] = "Times-BoldItalic", e["TimesNewRoman-Italic"] = "Times-Italic", e.TimesNewRomanPS = "Times-Roman", e["TimesNewRomanPS-Bold"] = "Times-Bold", e["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic", e["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic", e["TimesNewRomanPS-BoldMT"] = "Times-Bold", e["TimesNewRomanPS-Italic"] = "Times-Italic", e["TimesNewRomanPS-ItalicMT"] = "Times-Italic", e.TimesNewRomanPSMT = "Times-Roman", e["TimesNewRomanPSMT-Bold"] = "Times-Bold", e["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic", e["TimesNewRomanPSMT-Italic"] = "Times-Italic";
}), JB = le(function(e) {
  e.Courier = "FoxitFixed.pfb", e["Courier-Bold"] = "FoxitFixedBold.pfb", e["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb", e["Courier-Oblique"] = "FoxitFixedItalic.pfb", e.Helvetica = "LiberationSans-Regular.ttf", e["Helvetica-Bold"] = "LiberationSans-Bold.ttf", e["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf", e["Helvetica-Oblique"] = "LiberationSans-Italic.ttf", e["Times-Roman"] = "FoxitSerif.pfb", e["Times-Bold"] = "FoxitSerifBold.pfb", e["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb", e["Times-Italic"] = "FoxitSerifItalic.pfb", e.Symbol = "FoxitSymbol.pfb", e.ZapfDingbats = "FoxitDingbats.pfb", e["LiberationSans-Regular"] = "LiberationSans-Regular.ttf", e["LiberationSans-Bold"] = "LiberationSans-Bold.ttf", e["LiberationSans-Italic"] = "LiberationSans-Italic.ttf", e["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
}), Zc = le(function(e) {
  e.Calibri = "Helvetica", e["Calibri-Bold"] = "Helvetica-Bold", e["Calibri-BoldItalic"] = "Helvetica-BoldOblique", e["Calibri-Italic"] = "Helvetica-Oblique", e.CenturyGothic = "Helvetica", e["CenturyGothic-Bold"] = "Helvetica-Bold", e["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique", e["CenturyGothic-Italic"] = "Helvetica-Oblique", e.ComicSansMS = "Comic Sans MS", e["ComicSansMS-Bold"] = "Comic Sans MS-Bold", e["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic", e["ComicSansMS-Italic"] = "Comic Sans MS-Italic", e.GillSansMT = "Helvetica", e["GillSansMT-Bold"] = "Helvetica-Bold", e["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique", e["GillSansMT-Italic"] = "Helvetica-Oblique", e.Impact = "Helvetica", e["ItcSymbol-Bold"] = "Helvetica-Bold", e["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique", e["ItcSymbol-Book"] = "Helvetica", e["ItcSymbol-BookItalic"] = "Helvetica-Oblique", e["ItcSymbol-Medium"] = "Helvetica", e["ItcSymbol-MediumItalic"] = "Helvetica-Oblique", e.LucidaConsole = "Courier", e["LucidaConsole-Bold"] = "Courier-Bold", e["LucidaConsole-BoldItalic"] = "Courier-BoldOblique", e["LucidaConsole-Italic"] = "Courier-Oblique", e["LucidaSans-Demi"] = "Helvetica-Bold", e["MS-Gothic"] = "MS Gothic", e["MS-Gothic-Bold"] = "MS Gothic-Bold", e["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic", e["MS-Gothic-Italic"] = "MS Gothic-Italic", e["MS-Mincho"] = "MS Mincho", e["MS-Mincho-Bold"] = "MS Mincho-Bold", e["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic", e["MS-Mincho-Italic"] = "MS Mincho-Italic", e["MS-PGothic"] = "MS PGothic", e["MS-PGothic-Bold"] = "MS PGothic-Bold", e["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic", e["MS-PGothic-Italic"] = "MS PGothic-Italic", e["MS-PMincho"] = "MS PMincho", e["MS-PMincho-Bold"] = "MS PMincho-Bold", e["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic", e["MS-PMincho-Italic"] = "MS PMincho-Italic", e.NuptialScript = "Times-Italic", e.SegoeUISymbol = "Helvetica";
}), zg = le(function(e) {
  e["Adobe Jenson"] = !0, e["Adobe Text"] = !0, e.Albertus = !0, e.Aldus = !0, e.Alexandria = !0, e.Algerian = !0, e["American Typewriter"] = !0, e.Antiqua = !0, e.Apex = !0, e.Arno = !0, e.Aster = !0, e.Aurora = !0, e.Baskerville = !0, e.Bell = !0, e.Bembo = !0, e["Bembo Schoolbook"] = !0, e.Benguiat = !0, e["Berkeley Old Style"] = !0, e["Bernhard Modern"] = !0, e["Berthold City"] = !0, e.Bodoni = !0, e["Bauer Bodoni"] = !0, e["Book Antiqua"] = !0, e.Bookman = !0, e["Bordeaux Roman"] = !0, e["Californian FB"] = !0, e.Calisto = !0, e.Calvert = !0, e.Capitals = !0, e.Cambria = !0, e.Cartier = !0, e.Caslon = !0, e.Catull = !0, e.Centaur = !0, e["Century Old Style"] = !0, e["Century Schoolbook"] = !0, e.Chaparral = !0, e["Charis SIL"] = !0, e.Cheltenham = !0, e["Cholla Slab"] = !0, e.Clarendon = !0, e.Clearface = !0, e.Cochin = !0, e.Colonna = !0, e["Computer Modern"] = !0, e["Concrete Roman"] = !0, e.Constantia = !0, e["Cooper Black"] = !0, e.Corona = !0, e.Ecotype = !0, e.Egyptienne = !0, e.Elephant = !0, e.Excelsior = !0, e.Fairfield = !0, e["FF Scala"] = !0, e.Folkard = !0, e.Footlight = !0, e.FreeSerif = !0, e["Friz Quadrata"] = !0, e.Garamond = !0, e.Gentium = !0, e.Georgia = !0, e.Gloucester = !0, e["Goudy Old Style"] = !0, e["Goudy Schoolbook"] = !0, e["Goudy Pro Font"] = !0, e.Granjon = !0, e["Guardian Egyptian"] = !0, e.Heather = !0, e.Hercules = !0, e["High Tower Text"] = !0, e.Hiroshige = !0, e["Hoefler Text"] = !0, e["Humana Serif"] = !0, e.Imprint = !0, e["Ionic No. 5"] = !0, e.Janson = !0, e.Joanna = !0, e.Korinna = !0, e.Lexicon = !0, e.LiberationSerif = !0, e["Liberation Serif"] = !0, e["Linux Libertine"] = !0, e.Literaturnaya = !0, e.Lucida = !0, e["Lucida Bright"] = !0, e.Melior = !0, e.Memphis = !0, e.Miller = !0, e.Minion = !0, e.Modern = !0, e["Mona Lisa"] = !0, e["Mrs Eaves"] = !0, e["MS Serif"] = !0, e["Museo Slab"] = !0, e["New York"] = !0, e["Nimbus Roman"] = !0, e["NPS Rawlinson Roadway"] = !0, e.NuptialScript = !0, e.Palatino = !0, e.Perpetua = !0, e.Plantin = !0, e["Plantin Schoolbook"] = !0, e.Playbill = !0, e["Poor Richard"] = !0, e["Rawlinson Roadway"] = !0, e.Renault = !0, e.Requiem = !0, e.Rockwell = !0, e.Roman = !0, e["Rotis Serif"] = !0, e.Sabon = !0, e.Scala = !0, e.Seagull = !0, e.Sistina = !0, e.Souvenir = !0, e.STIX = !0, e["Stone Informal"] = !0, e["Stone Serif"] = !0, e.Sylfaen = !0, e.Times = !0, e.Trajan = !0, e.Trinité = !0, e["Trump Mediaeval"] = !0, e.Utopia = !0, e["Vale Type"] = !0, e["Bitstream Vera"] = !0, e["Vera Serif"] = !0, e.Versailles = !0, e.Wanted = !0, e.Weiss = !0, e["Wide Latin"] = !0, e.Windsor = !0, e.XITS = !0;
}), Cg = le(function(e) {
  e.Dingbats = !0, e.Symbol = !0, e.ZapfDingbats = !0, e.Wingdings = !0, e["Wingdings-Bold"] = !0, e["Wingdings-Regular"] = !0;
}), tI = le(function(e) {
  e[2] = 10, e[3] = 32, e[4] = 33, e[5] = 34, e[6] = 35, e[7] = 36, e[8] = 37, e[9] = 38, e[10] = 39, e[11] = 40, e[12] = 41, e[13] = 42, e[14] = 43, e[15] = 44, e[16] = 45, e[17] = 46, e[18] = 47, e[19] = 48, e[20] = 49, e[21] = 50, e[22] = 51, e[23] = 52, e[24] = 53, e[25] = 54, e[26] = 55, e[27] = 56, e[28] = 57, e[29] = 58, e[30] = 894, e[31] = 60, e[32] = 61, e[33] = 62, e[34] = 63, e[35] = 64, e[36] = 65, e[37] = 66, e[38] = 67, e[39] = 68, e[40] = 69, e[41] = 70, e[42] = 71, e[43] = 72, e[44] = 73, e[45] = 74, e[46] = 75, e[47] = 76, e[48] = 77, e[49] = 78, e[50] = 79, e[51] = 80, e[52] = 81, e[53] = 82, e[54] = 83, e[55] = 84, e[56] = 85, e[57] = 86, e[58] = 87, e[59] = 88, e[60] = 89, e[61] = 90, e[62] = 91, e[63] = 92, e[64] = 93, e[65] = 94, e[66] = 95, e[67] = 96, e[68] = 97, e[69] = 98, e[70] = 99, e[71] = 100, e[72] = 101, e[73] = 102, e[74] = 103, e[75] = 104, e[76] = 105, e[77] = 106, e[78] = 107, e[79] = 108, e[80] = 109, e[81] = 110, e[82] = 111, e[83] = 112, e[84] = 113, e[85] = 114, e[86] = 115, e[87] = 116, e[88] = 117, e[89] = 118, e[90] = 119, e[91] = 120, e[92] = 121, e[93] = 122, e[94] = 123, e[95] = 124, e[96] = 125, e[97] = 126, e[98] = 196, e[99] = 197, e[100] = 199, e[101] = 201, e[102] = 209, e[103] = 214, e[104] = 220, e[105] = 225, e[106] = 224, e[107] = 226, e[108] = 228, e[109] = 227, e[110] = 229, e[111] = 231, e[112] = 233, e[113] = 232, e[114] = 234, e[115] = 235, e[116] = 237, e[117] = 236, e[118] = 238, e[119] = 239, e[120] = 241, e[121] = 243, e[122] = 242, e[123] = 244, e[124] = 246, e[125] = 245, e[126] = 250, e[127] = 249, e[128] = 251, e[129] = 252, e[130] = 8224, e[131] = 176, e[132] = 162, e[133] = 163, e[134] = 167, e[135] = 8226, e[136] = 182, e[137] = 223, e[138] = 174, e[139] = 169, e[140] = 8482, e[141] = 180, e[142] = 168, e[143] = 8800, e[144] = 198, e[145] = 216, e[146] = 8734, e[147] = 177, e[148] = 8804, e[149] = 8805, e[150] = 165, e[151] = 181, e[152] = 8706, e[153] = 8721, e[154] = 8719, e[156] = 8747, e[157] = 170, e[158] = 186, e[159] = 8486, e[160] = 230, e[161] = 248, e[162] = 191, e[163] = 161, e[164] = 172, e[165] = 8730, e[166] = 402, e[167] = 8776, e[168] = 8710, e[169] = 171, e[170] = 187, e[171] = 8230, e[179] = 8220, e[180] = 8221, e[181] = 8216, e[182] = 8217, e[200] = 193, e[203] = 205, e[207] = 211, e[210] = 218, e[223] = 711, e[224] = 321, e[225] = 322, e[226] = 352, e[227] = 353, e[228] = 381, e[229] = 382, e[233] = 221, e[234] = 253, e[252] = 263, e[253] = 268, e[254] = 269, e[258] = 258, e[260] = 260, e[261] = 261, e[265] = 280, e[266] = 281, e[267] = 282, e[268] = 283, e[269] = 313, e[275] = 323, e[276] = 324, e[278] = 328, e[283] = 344, e[284] = 345, e[285] = 346, e[286] = 347, e[292] = 367, e[295] = 377, e[296] = 378, e[298] = 380, e[305] = 963, e[306] = 964, e[307] = 966, e[308] = 8215, e[309] = 8252, e[310] = 8319, e[311] = 8359, e[312] = 8592, e[313] = 8593, e[337] = 9552, e[493] = 1039, e[494] = 1040, e[672] = 1488, e[673] = 1489, e[674] = 1490, e[675] = 1491, e[676] = 1492, e[677] = 1493, e[678] = 1494, e[679] = 1495, e[680] = 1496, e[681] = 1497, e[682] = 1498, e[683] = 1499, e[684] = 1500, e[685] = 1501, e[686] = 1502, e[687] = 1503, e[688] = 1504, e[689] = 1505, e[690] = 1506, e[691] = 1507, e[692] = 1508, e[693] = 1509, e[694] = 1510, e[695] = 1511, e[696] = 1512, e[697] = 1513, e[698] = 1514, e[705] = 1524, e[706] = 8362, e[710] = 64288, e[711] = 64298, e[759] = 1617, e[761] = 1776, e[763] = 1778, e[775] = 1652, e[777] = 1764, e[778] = 1780, e[779] = 1781, e[780] = 1782, e[782] = 771, e[783] = 64726, e[786] = 8363, e[788] = 8532, e[790] = 768, e[791] = 769, e[792] = 768, e[795] = 803, e[797] = 64336, e[798] = 64337, e[799] = 64342, e[800] = 64343, e[801] = 64344, e[802] = 64345, e[803] = 64362, e[804] = 64363, e[805] = 64364, e[2424] = 7821, e[2425] = 7822, e[2426] = 7823, e[2427] = 7824, e[2428] = 7825, e[2429] = 7826, e[2430] = 7827, e[2433] = 7682, e[2678] = 8045, e[2679] = 8046, e[2830] = 1552, e[2838] = 686, e[2840] = 751, e[2842] = 753, e[2843] = 754, e[2844] = 755, e[2846] = 757, e[2856] = 767, e[2857] = 848, e[2858] = 849, e[2862] = 853, e[2863] = 854, e[2864] = 855, e[2865] = 861, e[2866] = 862, e[2906] = 7460, e[2908] = 7462, e[2909] = 7463, e[2910] = 7464, e[2912] = 7466, e[2913] = 7467, e[2914] = 7468, e[2916] = 7470, e[2917] = 7471, e[2918] = 7472, e[2920] = 7474, e[2921] = 7475, e[2922] = 7476, e[2924] = 7478, e[2925] = 7479, e[2926] = 7480, e[2928] = 7482, e[2929] = 7483, e[2930] = 7484, e[2932] = 7486, e[2933] = 7487, e[2934] = 7488, e[2936] = 7490, e[2937] = 7491, e[2938] = 7492, e[2940] = 7494, e[2941] = 7495, e[2942] = 7496, e[2944] = 7498, e[2946] = 7500, e[2948] = 7502, e[2950] = 7504, e[2951] = 7505, e[2952] = 7506, e[2954] = 7508, e[2955] = 7509, e[2956] = 7510, e[2958] = 7512, e[2959] = 7513, e[2960] = 7514, e[2962] = 7516, e[2963] = 7517, e[2964] = 7518, e[2966] = 7520, e[2967] = 7521, e[2968] = 7522, e[2970] = 7524, e[2971] = 7525, e[2972] = 7526, e[2974] = 7528, e[2975] = 7529, e[2976] = 7530, e[2978] = 1537, e[2979] = 1538, e[2980] = 1539, e[2982] = 1549, e[2983] = 1551, e[2984] = 1552, e[2986] = 1554, e[2987] = 1555, e[2988] = 1556, e[2990] = 1623, e[2991] = 1624, e[2995] = 1775, e[2999] = 1791, e[3002] = 64290, e[3003] = 64291, e[3004] = 64292, e[3006] = 64294, e[3007] = 64295, e[3008] = 64296, e[3011] = 1900, e[3014] = 8223, e[3015] = 8244, e[3017] = 7532, e[3018] = 7533, e[3019] = 7534, e[3075] = 7590, e[3076] = 7591, e[3079] = 7594, e[3080] = 7595, e[3083] = 7598, e[3084] = 7599, e[3087] = 7602, e[3088] = 7603, e[3091] = 7606, e[3092] = 7607, e[3095] = 7610, e[3096] = 7611, e[3099] = 7614, e[3100] = 7615, e[3103] = 7618, e[3104] = 7619, e[3107] = 8337, e[3108] = 8338, e[3116] = 1884, e[3119] = 1885, e[3120] = 1885, e[3123] = 1886, e[3124] = 1886, e[3127] = 1887, e[3128] = 1887, e[3131] = 1888, e[3132] = 1888, e[3135] = 1889, e[3136] = 1889, e[3139] = 1890, e[3140] = 1890, e[3143] = 1891, e[3144] = 1891, e[3147] = 1892, e[3148] = 1892, e[3153] = 580, e[3154] = 581, e[3157] = 584, e[3158] = 585, e[3161] = 588, e[3162] = 589, e[3165] = 891, e[3166] = 892, e[3169] = 1274, e[3170] = 1275, e[3173] = 1278, e[3174] = 1279, e[3181] = 7622, e[3182] = 7623, e[3282] = 11799, e[3316] = 578, e[3379] = 42785, e[3393] = 1159, e[3416] = 8377;
}), YB = le(function(e) {
  e[227] = 322, e[264] = 261, e[291] = 346;
}), KB = le(function(e) {
  e[1] = 32, e[4] = 65, e[5] = 192, e[6] = 193, e[9] = 196, e[17] = 66, e[18] = 67, e[21] = 268, e[24] = 68, e[28] = 69, e[29] = 200, e[30] = 201, e[32] = 282, e[38] = 70, e[39] = 71, e[44] = 72, e[47] = 73, e[48] = 204, e[49] = 205, e[58] = 74, e[60] = 75, e[62] = 76, e[68] = 77, e[69] = 78, e[75] = 79, e[76] = 210, e[80] = 214, e[87] = 80, e[89] = 81, e[90] = 82, e[92] = 344, e[94] = 83, e[97] = 352, e[100] = 84, e[104] = 85, e[109] = 220, e[115] = 86, e[116] = 87, e[121] = 88, e[122] = 89, e[124] = 221, e[127] = 90, e[129] = 381, e[258] = 97, e[259] = 224, e[260] = 225, e[263] = 228, e[268] = 261, e[271] = 98, e[272] = 99, e[273] = 263, e[275] = 269, e[282] = 100, e[286] = 101, e[287] = 232, e[288] = 233, e[290] = 283, e[295] = 281, e[296] = 102, e[336] = 103, e[346] = 104, e[349] = 105, e[350] = 236, e[351] = 237, e[361] = 106, e[364] = 107, e[367] = 108, e[371] = 322, e[373] = 109, e[374] = 110, e[381] = 111, e[382] = 242, e[383] = 243, e[386] = 246, e[393] = 112, e[395] = 113, e[396] = 114, e[398] = 345, e[400] = 115, e[401] = 347, e[403] = 353, e[410] = 116, e[437] = 117, e[442] = 252, e[448] = 118, e[449] = 119, e[454] = 120, e[455] = 121, e[457] = 253, e[460] = 122, e[462] = 382, e[463] = 380, e[853] = 44, e[855] = 58, e[856] = 46, e[876] = 47, e[878] = 45, e[882] = 45, e[894] = 40, e[895] = 41, e[896] = 91, e[897] = 93, e[923] = 64, e[1004] = 48, e[1005] = 49, e[1006] = 50, e[1007] = 51, e[1008] = 52, e[1009] = 53, e[1010] = 54, e[1011] = 55, e[1012] = 56, e[1013] = 57, e[1081] = 37, e[1085] = 43, e[1086] = 45;
});
function iI(e) {
  const A = wa(e);
  return ir()[A];
}
function sI(e) {
  const A = wa(e);
  return !!(ir()[A] || Zc()[A] || zg()[A] || Cg()[A]);
}
class Gs {
  constructor(A = []) {
    this._map = A;
  }
  get length() {
    return this._map.length;
  }
  forEach(A) {
    for (const t in this._map)
      A(t, this._map[t].codePointAt(0));
  }
  has(A) {
    return this._map[A] !== void 0;
  }
  get(A) {
    return this._map[A];
  }
  charCodeOf(A) {
    const t = this._map;
    if (t.length <= 65536)
      return t.indexOf(A);
    for (const i in t)
      if (t[i] === A)
        return i | 0;
    return -1;
  }
  amend(A) {
    for (const t in A)
      this._map[t] = A[t];
  }
}
class Rt {
  constructor(A, t) {
    this.firstChar = A, this.lastChar = t;
  }
  get length() {
    return this.lastChar + 1 - this.firstChar;
  }
  forEach(A) {
    for (let t = this.firstChar, i = this.lastChar; t <= i; t++)
      A(t, t);
  }
  has(A) {
    return this.firstChar <= A && A <= this.lastChar;
  }
  get(A) {
    if (this.firstChar <= A && A <= this.lastChar)
      return String.fromCharCode(A);
  }
  charCodeOf(A) {
    return Number.isInteger(A) && A >= this.firstChar && A <= this.lastChar ? A : -1;
  }
  amend(A) {
    WA("Should not call amend()");
  }
}
class br {
  constructor(A, t) {
    this.properties = t;
    const i = new Xg(A, t, V0);
    this.cff = i.parse(), this.cff.duplicateFirstGlyph();
    const s = new ya(this.cff);
    this.seacs = this.cff.seacs;
    try {
      this.data = s.compile();
    } catch {
      k("Failed to compile font " + t.loadedName), this.data = A;
    }
    this._createBuiltInEncoding();
  }
  get numGlyphs() {
    return this.cff.charStrings.count;
  }
  getCharset() {
    return this.cff.charset.charset;
  }
  getGlyphMapping() {
    const A = this.cff, t = this.properties, {
      cidToGidMap: i,
      cMap: s
    } = t, a = A.charset.charset;
    let n, r;
    if (t.composite) {
      let o;
      if ((i == null ? void 0 : i.length) > 0) {
        o = /* @__PURE__ */ Object.create(null);
        for (let c = 0, l = i.length; c < l; c++) {
          const h = i[c];
          h !== void 0 && (o[h] = c);
        }
      }
      n = /* @__PURE__ */ Object.create(null);
      let I;
      if (A.isCIDFont)
        for (r = 0; r < a.length; r++) {
          const c = a[r];
          I = s.charCodeOf(c), (o == null ? void 0 : o[I]) !== void 0 && (I = o[I]), n[I] = r;
        }
      else
        for (r = 0; r < A.charStrings.count; r++)
          I = s.charCodeOf(r), n[I] = r;
      return n;
    }
    let g = A.encoding ? A.encoding.encoding : null;
    return t.isInternalFont && (g = t.defaultEncoding), n = Vc(t, g, a), n;
  }
  hasGlyphId(A) {
    return this.cff.hasGlyphId(A);
  }
  _createBuiltInEncoding() {
    const {
      charset: A,
      encoding: t
    } = this.cff;
    if (!A || !t)
      return;
    const i = A.charset, s = t.encoding, a = [];
    for (const n in s) {
      const r = s[n];
      if (r >= 0) {
        const g = i[r];
        g && (a[n] = g);
      }
    }
    a.length > 0 && (this.properties.builtInEncoding = a);
  }
}
function li(e, A) {
  return (e[A] << 24 | e[A + 1] << 16 | e[A + 2] << 8 | e[A + 3]) >>> 0;
}
function Re(e, A) {
  return e[A] << 8 | e[A + 1];
}
function N0(e, A) {
  return (e[A] << 24 | e[A + 1] << 16) >> 16;
}
function aI(e, A) {
  return e[A] << 24 >> 24;
}
function Zi(e, A) {
  return N0(e, A) / 16384;
}
function Bg(e) {
  const A = e.length;
  let t = 32768;
  return A < 1240 ? t = 107 : A < 33900 && (t = 1131), t;
}
function vB(e, A, t) {
  const i = Re(e, A + 2) === 1 ? li(e, A + 8) : li(e, A + 16), s = Re(e, A + i);
  let a, n, r;
  if (s === 4) {
    Re(e, A + i + 2);
    const g = Re(e, A + i + 6) >> 1;
    for (n = A + i + 14, a = [], r = 0; r < g; r++, n += 2)
      a[r] = {
        end: Re(e, n)
      };
    for (n += 2, r = 0; r < g; r++, n += 2)
      a[r].start = Re(e, n);
    for (r = 0; r < g; r++, n += 2)
      a[r].idDelta = Re(e, n);
    for (r = 0; r < g; r++, n += 2) {
      let o = Re(e, n);
      if (o !== 0) {
        a[r].ids = [];
        for (let I = 0, c = a[r].end - a[r].start + 1; I < c; I++)
          a[r].ids[I] = Re(e, n + o), o += 2;
      }
    }
    return a;
  } else if (s === 12) {
    const g = li(e, A + i + 12);
    for (n = A + i + 16, a = [], r = 0; r < g; r++)
      A = li(e, n), a.push({
        start: A,
        end: li(e, n + 4),
        idDelta: li(e, n + 8) - A
      }), n += 12;
    return a;
  }
  throw new v(`unsupported cmap: ${s}`);
}
function TB(e, A, t, i) {
  var r, g, o;
  const s = {}, n = new Xg(new Qe(e, A, t - A), s, i).parse();
  return {
    glyphs: n.charStrings.objects,
    subrs: (g = (r = n.topDict.privateDict) == null ? void 0 : r.subrsIndex) == null ? void 0 : g.objects,
    gsubrs: (o = n.globalSubrIndex) == null ? void 0 : o.objects,
    isCFFCIDFont: n.isCIDFont,
    fdSelect: n.fdSelect,
    fdArray: n.fdArray
  };
}
function qB(e, A, t) {
  let i, s;
  t ? (i = 4, s = li) : (i = 2, s = (r, g) => 2 * Re(r, g));
  const a = [];
  let n = s(A, 0);
  for (let r = i; r < A.length; r += i) {
    const g = s(A, r);
    a.push(e.subarray(n, g)), n = g;
  }
  return a;
}
function kn(e, A) {
  const t = A.codePointAt(0);
  let i = 0, s = 0, a = e.length - 1;
  for (; s < a; ) {
    const n = s + a + 1 >> 1;
    t < e[n].start ? a = n - 1 : s = n;
  }
  return e[s].start <= t && t <= e[s].end && (i = e[s].idDelta + (e[s].ids ? e[s].ids[t - e[s].start] : t) & 65535), {
    charCode: t,
    glyphId: i
  };
}
function jc(e, A, t) {
  function i(c, l) {
    A.add("M", [c, l]);
  }
  function s(c, l) {
    A.add("L", [c, l]);
  }
  function a(c, l, h, C) {
    A.add("Q", [c, l, h, C]);
  }
  let n = 0;
  const r = N0(e, n);
  let g, o = 0, I = 0;
  if (n += 10, r < 0)
    do {
      g = Re(e, n);
      const c = Re(e, n + 2);
      n += 4;
      let l, h;
      g & 1 ? (g & 2 ? (l = N0(e, n), h = N0(e, n + 2)) : (l = Re(e, n), h = Re(e, n + 2)), n += 4) : g & 2 ? (l = aI(e, n++), h = aI(e, n++)) : (l = e[n++], h = e[n++]), g & 2 ? (o = l, I = h) : (o = 0, I = 0);
      let C = 1, B = 1, Q = 0, E = 0;
      g & 8 ? (C = B = Zi(e, n), n += 2) : g & 64 ? (C = Zi(e, n), B = Zi(e, n + 2), n += 4) : g & 128 && (C = Zi(e, n), Q = Zi(e, n + 2), E = Zi(e, n + 4), B = Zi(e, n + 6), n += 8);
      const f = t.glyphs[c];
      f && (A.save(), A.transform([C, Q, E, B, o, I]), jc(f, A, t), A.restore());
    } while (g & 32);
  else {
    const c = [];
    let l, h;
    for (l = 0; l < r; l++)
      c.push(Re(e, n)), n += 2;
    const C = Re(e, n);
    n += 2 + C;
    const B = c.at(-1) + 1, Q = [];
    for (; Q.length < B; ) {
      g = e[n++];
      let f = 1;
      for (g & 8 && (f += e[n++]); f-- > 0; )
        Q.push({
          flags: g
        });
    }
    for (l = 0; l < B; l++) {
      switch (Q[l].flags & 18) {
        case 0:
          o += N0(e, n), n += 2;
          break;
        case 2:
          o -= e[n++];
          break;
        case 18:
          o += e[n++];
          break;
      }
      Q[l].x = o;
    }
    for (l = 0; l < B; l++) {
      switch (Q[l].flags & 36) {
        case 0:
          I += N0(e, n), n += 2;
          break;
        case 4:
          I -= e[n++];
          break;
        case 36:
          I += e[n++];
          break;
      }
      Q[l].y = I;
    }
    let E = 0;
    for (n = 0; n < r; n++) {
      const f = c[n], d = Q.slice(E, f + 1);
      if (d[0].flags & 1)
        d.push(d[0]);
      else if (d.at(-1).flags & 1)
        d.unshift(d.at(-1));
      else {
        const u = {
          flags: 1,
          x: (d[0].x + d.at(-1).x) / 2,
          y: (d[0].y + d.at(-1).y) / 2
        };
        d.unshift(u), d.push(u);
      }
      for (i(d[0].x, d[0].y), l = 1, h = d.length; l < h; l++)
        d[l].flags & 1 ? s(d[l].x, d[l].y) : d[l + 1].flags & 1 ? (a(d[l].x, d[l].y, d[l + 1].x, d[l + 1].y), l++) : a(d[l].x, d[l].y, (d[l].x + d[l + 1].x) / 2, (d[l].y + d[l + 1].y) / 2);
      E = f + 1;
    }
  }
}
function Qg(e, A, t, i) {
  function s(l, h) {
    A.add("M", [l, h]);
  }
  function a(l, h) {
    A.add("L", [l, h]);
  }
  function n(l, h, C, B, Q, E) {
    A.add("C", [l, h, C, B, Q, E]);
  }
  const r = [];
  let g = 0, o = 0, I = 0;
  function c(l) {
    var C;
    let h = 0;
    for (; h < l.length; ) {
      let B = !1, Q = l[h++], E, f, d, u, x, m, p, D, F;
      switch (Q) {
        case 1:
          I += r.length >> 1, B = !0;
          break;
        case 3:
          I += r.length >> 1, B = !0;
          break;
        case 4:
          o += r.pop(), s(g, o), B = !0;
          break;
        case 5:
          for (; r.length > 0; )
            g += r.shift(), o += r.shift(), a(g, o);
          break;
        case 6:
          for (; r.length > 0 && (g += r.shift(), a(g, o), r.length !== 0); )
            o += r.shift(), a(g, o);
          break;
        case 7:
          for (; r.length > 0 && (o += r.shift(), a(g, o), r.length !== 0); )
            g += r.shift(), a(g, o);
          break;
        case 8:
          for (; r.length > 0; )
            E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o);
          break;
        case 10:
          if (D = r.pop(), F = null, t.isCFFCIDFont) {
            const y = t.fdSelect.getFDIndex(i);
            if (y >= 0 && y < t.fdArray.length) {
              const H = t.fdArray[y];
              let N;
              (C = H.privateDict) != null && C.subrsIndex && (N = H.privateDict.subrsIndex.objects), N && (D += Bg(N), F = N[D]);
            } else
              k("Invalid fd index for glyph index.");
          } else
            F = t.subrs[D + t.subrsBias];
          F && c(F);
          break;
        case 11:
          return;
        case 12:
          switch (Q = l[h++], Q) {
            case 34:
              E = g + r.shift(), f = E + r.shift(), x = o + r.shift(), g = f + r.shift(), n(E, o, f, x, g, x), E = g + r.shift(), f = E + r.shift(), g = f + r.shift(), n(E, x, f, o, g, o);
              break;
            case 35:
              E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o), E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o), r.pop();
              break;
            case 36:
              E = g + r.shift(), x = o + r.shift(), f = E + r.shift(), m = x + r.shift(), g = f + r.shift(), n(E, x, f, m, g, m), E = g + r.shift(), f = E + r.shift(), p = m + r.shift(), g = f + r.shift(), n(E, m, f, p, g, o);
              break;
            case 37:
              const y = g, H = o;
              E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o), E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f, o = u, Math.abs(g - y) > Math.abs(o - H) ? g += r.shift() : o += r.shift(), n(E, d, f, u, g, o);
              break;
            default:
              throw new v(`unknown operator: 12 ${Q}`);
          }
          break;
        case 14:
          if (r.length >= 4) {
            const y = r.pop(), H = r.pop();
            o = r.pop(), g = r.pop(), A.save(), A.translate(g, o);
            let N = kn(t.cmap, String.fromCharCode(t.glyphNameMap[Ei[y]]));
            Qg(t.glyphs[N.glyphId], A, t, N.glyphId), A.restore(), N = kn(t.cmap, String.fromCharCode(t.glyphNameMap[Ei[H]])), Qg(t.glyphs[N.glyphId], A, t, N.glyphId);
          }
          return;
        case 18:
          I += r.length >> 1, B = !0;
          break;
        case 19:
          I += r.length >> 1, h += I + 7 >> 3, B = !0;
          break;
        case 20:
          I += r.length >> 1, h += I + 7 >> 3, B = !0;
          break;
        case 21:
          o += r.pop(), g += r.pop(), s(g, o), B = !0;
          break;
        case 22:
          g += r.pop(), s(g, o), B = !0;
          break;
        case 23:
          I += r.length >> 1, B = !0;
          break;
        case 24:
          for (; r.length > 2; )
            E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o);
          g += r.shift(), o += r.shift(), a(g, o);
          break;
        case 25:
          for (; r.length > 6; )
            g += r.shift(), o += r.shift(), a(g, o);
          E = g + r.shift(), d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + r.shift(), n(E, d, f, u, g, o);
          break;
        case 26:
          for (r.length % 2 && (g += r.shift()); r.length > 0; )
            E = g, d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f, o = u + r.shift(), n(E, d, f, u, g, o);
          break;
        case 27:
          for (r.length % 2 && (o += r.shift()); r.length > 0; )
            E = g + r.shift(), d = o, f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u, n(E, d, f, u, g, o);
          break;
        case 28:
          r.push((l[h] << 24 | l[h + 1] << 16) >> 16), h += 2;
          break;
        case 29:
          D = r.pop() + t.gsubrsBias, F = t.gsubrs[D], F && c(F);
          break;
        case 30:
          for (; r.length > 0 && (E = g, d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + (r.length === 1 ? r.shift() : 0), n(E, d, f, u, g, o), r.length !== 0); )
            E = g + r.shift(), d = o, f = E + r.shift(), u = d + r.shift(), o = u + r.shift(), g = f + (r.length === 1 ? r.shift() : 0), n(E, d, f, u, g, o);
          break;
        case 31:
          for (; r.length > 0 && (E = g + r.shift(), d = o, f = E + r.shift(), u = d + r.shift(), o = u + r.shift(), g = f + (r.length === 1 ? r.shift() : 0), n(E, d, f, u, g, o), r.length !== 0); )
            E = g, d = o + r.shift(), f = E + r.shift(), u = d + r.shift(), g = f + r.shift(), o = u + (r.length === 1 ? r.shift() : 0), n(E, d, f, u, g, o);
          break;
        default:
          if (Q < 32)
            throw new v(`unknown operator: ${Q}`);
          Q < 247 ? r.push(Q - 139) : Q < 251 ? r.push((Q - 247) * 256 + l[h++] + 108) : Q < 255 ? r.push(-(Q - 251) * 256 - l[h++] - 108) : (r.push((l[h] << 24 | l[h + 1] << 16 | l[h + 2] << 8 | l[h + 3]) / 65536), h += 4);
          break;
      }
      B && (r.length = 0);
    }
  }
  c(e);
}
const nI = "";
class PB {
  constructor() {
    Me(this, "cmds", []);
    Me(this, "transformStack", []);
    Me(this, "currentTransform", [1, 0, 0, 1, 0, 0]);
  }
  add(A, t) {
    if (t) {
      const [i, s, a, n, r, g] = this.currentTransform;
      for (let o = 0, I = t.length; o < I; o += 2) {
        const c = t[o], l = t[o + 1];
        t[o] = i * c + a * l + r, t[o + 1] = s * c + n * l + g;
      }
      this.cmds.push(`${A}${t.join(" ")}`);
    } else
      this.cmds.push(A);
  }
  transform(A) {
    this.currentTransform = de.transform(this.currentTransform, A);
  }
  translate(A, t) {
    this.transform([1, 0, 0, 1, A, t]);
  }
  save() {
    this.transformStack.push(this.currentTransform.slice());
  }
  restore() {
    this.currentTransform = this.transformStack.pop() || [1, 0, 0, 1, 0, 0];
  }
  getSVG() {
    return this.cmds.join("");
  }
}
class Xc {
  constructor(A) {
    this.fontMatrix = A, this.compiledGlyphs = /* @__PURE__ */ Object.create(null), this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
  }
  getPathJs(A) {
    var n;
    const {
      charCode: t,
      glyphId: i
    } = kn(this.cmap, A);
    let s = this.compiledGlyphs[i], a;
    if (s === void 0) {
      try {
        s = this.compileGlyph(this.glyphs[i], i);
      } catch (r) {
        s = nI, a = r;
      }
      this.compiledGlyphs[i] = s;
    }
    if ((n = this.compiledCharCodeToGlyphId)[t] ?? (n[t] = i), a)
      throw a;
    return s;
  }
  compileGlyph(A, t) {
    if (!(A != null && A.length) || A[0] === 14)
      return nI;
    let i = this.fontMatrix;
    if (this.isCFFCIDFont) {
      const a = this.fdSelect.getFDIndex(t);
      a >= 0 && a < this.fdArray.length ? i = this.fdArray[a].getByName("FontMatrix") || o0 : k("Invalid fd index for glyph index.");
    }
    _e(at(i, 6), "Expected a valid fontMatrix.");
    const s = new PB();
    return s.transform(i.slice()), this.compileGlyphImpl(A, s, t), s.add("Z"), s.getSVG();
  }
  compileGlyphImpl() {
    WA("Children classes should implement this.");
  }
  hasBuiltPath(A) {
    const {
      charCode: t,
      glyphId: i
    } = kn(this.cmap, A);
    return this.compiledGlyphs[i] !== void 0 && this.compiledCharCodeToGlyphId[t] !== void 0;
  }
}
class WB extends Xc {
  constructor(A, t, i) {
    super(i || [488e-6, 0, 0, 488e-6, 0, 0]), this.glyphs = A, this.cmap = t;
  }
  compileGlyphImpl(A, t) {
    jc(A, t, this);
  }
}
class OB extends Xc {
  constructor(A, t, i) {
    super(i || [1e-3, 0, 0, 1e-3, 0, 0]), this.glyphs = A.glyphs, this.gsubrs = A.gsubrs || [], this.subrs = A.subrs || [], this.cmap = t, this.glyphNameMap = ti(), this.gsubrsBias = Bg(this.gsubrs), this.subrsBias = Bg(this.subrs), this.isCFFCIDFont = A.isCFFCIDFont, this.fdSelect = A.fdSelect, this.fdArray = A.fdArray;
  }
  compileGlyphImpl(A, t, i) {
    Qg(A, t, this, i);
  }
}
class VB {
  static create(A, t) {
    const i = new Uint8Array(A.data);
    let s, a, n, r, g, o;
    const I = Re(i, 4);
    for (let c = 0, l = 12; c < I; c++, l += 16) {
      const h = ct(i.subarray(l, l + 4)), C = li(i, l + 8), B = li(i, l + 12);
      switch (h) {
        case "cmap":
          s = vB(i, C);
          break;
        case "glyf":
          a = i.subarray(C, C + B);
          break;
        case "loca":
          n = i.subarray(C, C + B);
          break;
        case "head":
          o = Re(i, C + 18), g = Re(i, C + 50);
          break;
        case "CFF ":
          r = TB(i, C, C + B, t);
          break;
      }
    }
    if (a) {
      const c = o ? [1 / o, 0, 0, 1 / o, 0, 0] : A.fontMatrix;
      return new WB(qB(a, n, g), s, c);
    }
    return new OB(r, s, A.fontMatrix);
  }
}
const ZB = le(function(e) {
  e.Courier = 600, e["Courier-Bold"] = 600, e["Courier-BoldOblique"] = 600, e["Courier-Oblique"] = 600, e.Helvetica = le(function(A) {
    A.space = 278, A.exclam = 278, A.quotedbl = 355, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 667, A.quoteright = 222, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 278, A.semicolon = 278, A.less = 584, A.equal = 584, A.greater = 584, A.question = 556, A.at = 1015, A.A = 667, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 500, A.K = 667, A.L = 556, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 278, A.backslash = 278, A.bracketright = 278, A.asciicircum = 469, A.underscore = 556, A.quoteleft = 222, A.a = 556, A.b = 556, A.c = 500, A.d = 556, A.e = 556, A.f = 278, A.g = 556, A.h = 556, A.i = 222, A.j = 222, A.k = 500, A.l = 222, A.m = 833, A.n = 556, A.o = 556, A.p = 556, A.q = 556, A.r = 333, A.s = 500, A.t = 278, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 500, A.braceleft = 334, A.bar = 260, A.braceright = 334, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 191, A.quotedblleft = 333, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 537, A.bullet = 350, A.quotesinglbase = 222, A.quotedblbase = 333, A.quotedblright = 333, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 556, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 222, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 556, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 667, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 500, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 500, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 222, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 500, A.scedilla = 500, A.iacute = 278, A.lozenge = 471, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 556, A.Amacron = 667, A.rcaron = 333, A.ccedilla = 500, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 643, A.Umacron = 722, A.uring = 556, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 667, A.Abreve = 667, A.multiply = 584, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 500, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 260, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 333, A.omacron = 556, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 222, A.tcaron = 317, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 556, A.zacute = 500, A.iogonek = 222, A.Oacute = 778, A.oacute = 556, A.amacron = 556, A.sacute = 500, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 333, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 556, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 299, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 556, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 556, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 556, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 556, A.Ccaron = 722, A.ugrave = 556, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 556, A.Rcommaaccent = 722, A.Lcommaaccent = 556, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 500, A.minus = 584, A.Icircumflex = 278, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 584, A.odieresis = 556, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 556, A.eth = 556, A.zcaron = 500, A.ncommaaccent = 556, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), e["Helvetica-Bold"] = le(function(A) {
    A.space = 278, A.exclam = 333, A.quotedbl = 474, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 722, A.quoteright = 278, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 333, A.semicolon = 333, A.less = 584, A.equal = 584, A.greater = 584, A.question = 611, A.at = 975, A.A = 722, A.B = 722, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 556, A.K = 722, A.L = 611, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 584, A.underscore = 556, A.quoteleft = 278, A.a = 556, A.b = 611, A.c = 556, A.d = 611, A.e = 556, A.f = 333, A.g = 611, A.h = 611, A.i = 278, A.j = 278, A.k = 556, A.l = 278, A.m = 889, A.n = 611, A.o = 611, A.p = 611, A.q = 611, A.r = 389, A.s = 556, A.t = 333, A.u = 611, A.v = 556, A.w = 778, A.x = 556, A.y = 556, A.z = 500, A.braceleft = 389, A.bar = 280, A.braceright = 389, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 238, A.quotedblleft = 500, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 611, A.fl = 611, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 556, A.bullet = 350, A.quotesinglbase = 278, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 611, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 278, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 611, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 722, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 556, A.scommaaccent = 556, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 611, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 556, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 556, A.scedilla = 556, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 611, A.acircumflex = 556, A.Amacron = 722, A.rcaron = 389, A.ccedilla = 556, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 743, A.Umacron = 722, A.uring = 611, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 584, A.uacute = 611, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 556, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 556, A.nacute = 611, A.umacron = 611, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 280, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 611, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 389, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 556, A.zacute = 500, A.iogonek = 278, A.Oacute = 778, A.oacute = 611, A.amacron = 556, A.sacute = 556, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 611, A.twosuperior = 333, A.Odieresis = 778, A.mu = 611, A.igrave = 278, A.ohungarumlaut = 611, A.Eogonek = 667, A.dcroat = 611, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 400, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 611, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 611, A.ntilde = 611, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 611, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 611, A.Ccaron = 722, A.ugrave = 611, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 611, A.Rcommaaccent = 722, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 556, A.minus = 584, A.Icircumflex = 278, A.ncaron = 611, A.tcommaaccent = 333, A.logicalnot = 584, A.odieresis = 611, A.udieresis = 611, A.notequal = 549, A.gcommaaccent = 611, A.eth = 611, A.zcaron = 500, A.ncommaaccent = 611, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), e["Helvetica-BoldOblique"] = le(function(A) {
    A.space = 278, A.exclam = 333, A.quotedbl = 474, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 722, A.quoteright = 278, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 333, A.semicolon = 333, A.less = 584, A.equal = 584, A.greater = 584, A.question = 611, A.at = 975, A.A = 722, A.B = 722, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 556, A.K = 722, A.L = 611, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 584, A.underscore = 556, A.quoteleft = 278, A.a = 556, A.b = 611, A.c = 556, A.d = 611, A.e = 556, A.f = 333, A.g = 611, A.h = 611, A.i = 278, A.j = 278, A.k = 556, A.l = 278, A.m = 889, A.n = 611, A.o = 611, A.p = 611, A.q = 611, A.r = 389, A.s = 556, A.t = 333, A.u = 611, A.v = 556, A.w = 778, A.x = 556, A.y = 556, A.z = 500, A.braceleft = 389, A.bar = 280, A.braceright = 389, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 238, A.quotedblleft = 500, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 611, A.fl = 611, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 556, A.bullet = 350, A.quotesinglbase = 278, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 611, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 278, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 611, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 722, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 556, A.scommaaccent = 556, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 611, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 556, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 556, A.scedilla = 556, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 611, A.acircumflex = 556, A.Amacron = 722, A.rcaron = 389, A.ccedilla = 556, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 743, A.Umacron = 722, A.uring = 611, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 584, A.uacute = 611, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 556, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 556, A.nacute = 611, A.umacron = 611, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 280, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 611, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 389, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 556, A.zacute = 500, A.iogonek = 278, A.Oacute = 778, A.oacute = 611, A.amacron = 556, A.sacute = 556, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 611, A.twosuperior = 333, A.Odieresis = 778, A.mu = 611, A.igrave = 278, A.ohungarumlaut = 611, A.Eogonek = 667, A.dcroat = 611, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 400, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 611, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 611, A.ntilde = 611, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 611, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 611, A.Ccaron = 722, A.ugrave = 611, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 611, A.Rcommaaccent = 722, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 556, A.minus = 584, A.Icircumflex = 278, A.ncaron = 611, A.tcommaaccent = 333, A.logicalnot = 584, A.odieresis = 611, A.udieresis = 611, A.notequal = 549, A.gcommaaccent = 611, A.eth = 611, A.zcaron = 500, A.ncommaaccent = 611, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), e["Helvetica-Oblique"] = le(function(A) {
    A.space = 278, A.exclam = 278, A.quotedbl = 355, A.numbersign = 556, A.dollar = 556, A.percent = 889, A.ampersand = 667, A.quoteright = 222, A.parenleft = 333, A.parenright = 333, A.asterisk = 389, A.plus = 584, A.comma = 278, A.hyphen = 333, A.period = 278, A.slash = 278, A.zero = 556, A.one = 556, A.two = 556, A.three = 556, A.four = 556, A.five = 556, A.six = 556, A.seven = 556, A.eight = 556, A.nine = 556, A.colon = 278, A.semicolon = 278, A.less = 584, A.equal = 584, A.greater = 584, A.question = 556, A.at = 1015, A.A = 667, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 722, A.I = 278, A.J = 500, A.K = 667, A.L = 556, A.M = 833, A.N = 722, A.O = 778, A.P = 667, A.Q = 778, A.R = 722, A.S = 667, A.T = 611, A.U = 722, A.V = 667, A.W = 944, A.X = 667, A.Y = 667, A.Z = 611, A.bracketleft = 278, A.backslash = 278, A.bracketright = 278, A.asciicircum = 469, A.underscore = 556, A.quoteleft = 222, A.a = 556, A.b = 556, A.c = 500, A.d = 556, A.e = 556, A.f = 278, A.g = 556, A.h = 556, A.i = 222, A.j = 222, A.k = 500, A.l = 222, A.m = 833, A.n = 556, A.o = 556, A.p = 556, A.q = 556, A.r = 333, A.s = 500, A.t = 278, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 500, A.braceleft = 334, A.bar = 260, A.braceright = 334, A.asciitilde = 584, A.exclamdown = 333, A.cent = 556, A.sterling = 556, A.fraction = 167, A.yen = 556, A.florin = 556, A.section = 556, A.currency = 556, A.quotesingle = 191, A.quotedblleft = 333, A.guillemotleft = 556, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 556, A.dagger = 556, A.daggerdbl = 556, A.periodcentered = 278, A.paragraph = 537, A.bullet = 350, A.quotesinglbase = 222, A.quotedblbase = 333, A.quotedblright = 333, A.guillemotright = 556, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 611, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 370, A.Lslash = 556, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 365, A.ae = 889, A.dotlessi = 278, A.lslash = 222, A.oslash = 611, A.oe = 944, A.germandbls = 611, A.Idieresis = 278, A.eacute = 556, A.abreve = 556, A.uhungarumlaut = 556, A.ecaron = 556, A.Ydieresis = 667, A.divide = 584, A.Yacute = 667, A.Acircumflex = 667, A.aacute = 556, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 500, A.ecircumflex = 556, A.Uring = 722, A.Udieresis = 722, A.aogonek = 556, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 737, A.Emacron = 667, A.ccaron = 500, A.aring = 556, A.Ncommaaccent = 722, A.lacute = 222, A.agrave = 556, A.Tcommaaccent = 611, A.Cacute = 722, A.atilde = 556, A.Edotaccent = 667, A.scaron = 500, A.scedilla = 500, A.iacute = 278, A.lozenge = 471, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 556, A.Amacron = 667, A.rcaron = 333, A.ccedilla = 500, A.Zdotaccent = 611, A.Thorn = 667, A.Omacron = 778, A.Racute = 722, A.Sacute = 667, A.dcaron = 643, A.Umacron = 722, A.uring = 556, A.threesuperior = 333, A.Ograve = 778, A.Agrave = 667, A.Abreve = 667, A.multiply = 584, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 556, A.edieresis = 556, A.cacute = 500, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 278, A.plusminus = 584, A.brokenbar = 260, A.registered = 737, A.Gbreve = 778, A.Idotaccent = 278, A.summation = 600, A.Egrave = 667, A.racute = 333, A.omacron = 556, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 222, A.tcaron = 317, A.eogonek = 556, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 556, A.zacute = 500, A.iogonek = 222, A.Oacute = 778, A.oacute = 556, A.amacron = 556, A.sacute = 500, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 333, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 556, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 834, A.Scedilla = 667, A.lcaron = 299, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 1e3, A.edotaccent = 556, A.Igrave = 278, A.Imacron = 278, A.Lcaron = 556, A.onehalf = 834, A.lessequal = 549, A.ocircumflex = 556, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 556, A.gbreve = 556, A.onequarter = 834, A.Scaron = 667, A.Scommaaccent = 667, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 556, A.Ccaron = 722, A.ugrave = 556, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 556, A.Rcommaaccent = 722, A.Lcommaaccent = 556, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 778, A.zdotaccent = 500, A.Ecaron = 667, A.Iogonek = 278, A.kcommaaccent = 500, A.minus = 584, A.Icircumflex = 278, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 584, A.odieresis = 556, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 556, A.eth = 556, A.zcaron = 500, A.ncommaaccent = 556, A.onesuperior = 333, A.imacron = 278, A.Euro = 556;
  }), e.Symbol = le(function(A) {
    A.space = 250, A.exclam = 333, A.universal = 713, A.numbersign = 500, A.existential = 549, A.percent = 833, A.ampersand = 778, A.suchthat = 439, A.parenleft = 333, A.parenright = 333, A.asteriskmath = 500, A.plus = 549, A.comma = 250, A.minus = 549, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 278, A.semicolon = 278, A.less = 549, A.equal = 549, A.greater = 549, A.question = 444, A.congruent = 549, A.Alpha = 722, A.Beta = 667, A.Chi = 722, A.Delta = 612, A.Epsilon = 611, A.Phi = 763, A.Gamma = 603, A.Eta = 722, A.Iota = 333, A.theta1 = 631, A.Kappa = 722, A.Lambda = 686, A.Mu = 889, A.Nu = 722, A.Omicron = 722, A.Pi = 768, A.Theta = 741, A.Rho = 556, A.Sigma = 592, A.Tau = 611, A.Upsilon = 690, A.sigma1 = 439, A.Omega = 768, A.Xi = 645, A.Psi = 795, A.Zeta = 611, A.bracketleft = 333, A.therefore = 863, A.bracketright = 333, A.perpendicular = 658, A.underscore = 500, A.radicalex = 500, A.alpha = 631, A.beta = 549, A.chi = 549, A.delta = 494, A.epsilon = 439, A.phi = 521, A.gamma = 411, A.eta = 603, A.iota = 329, A.phi1 = 603, A.kappa = 549, A.lambda = 549, A.mu = 576, A.nu = 521, A.omicron = 549, A.pi = 549, A.theta = 521, A.rho = 549, A.sigma = 603, A.tau = 439, A.upsilon = 576, A.omega1 = 713, A.omega = 686, A.xi = 493, A.psi = 686, A.zeta = 494, A.braceleft = 480, A.bar = 200, A.braceright = 480, A.similar = 549, A.Euro = 750, A.Upsilon1 = 620, A.minute = 247, A.lessequal = 549, A.fraction = 167, A.infinity = 713, A.florin = 500, A.club = 753, A.diamond = 753, A.heart = 753, A.spade = 753, A.arrowboth = 1042, A.arrowleft = 987, A.arrowup = 603, A.arrowright = 987, A.arrowdown = 603, A.degree = 400, A.plusminus = 549, A.second = 411, A.greaterequal = 549, A.multiply = 549, A.proportional = 713, A.partialdiff = 494, A.bullet = 460, A.divide = 549, A.notequal = 549, A.equivalence = 549, A.approxequal = 549, A.ellipsis = 1e3, A.arrowvertex = 603, A.arrowhorizex = 1e3, A.carriagereturn = 658, A.aleph = 823, A.Ifraktur = 686, A.Rfraktur = 795, A.weierstrass = 987, A.circlemultiply = 768, A.circleplus = 768, A.emptyset = 823, A.intersection = 768, A.union = 768, A.propersuperset = 713, A.reflexsuperset = 713, A.notsubset = 713, A.propersubset = 713, A.reflexsubset = 713, A.element = 713, A.notelement = 713, A.angle = 768, A.gradient = 713, A.registerserif = 790, A.copyrightserif = 790, A.trademarkserif = 890, A.product = 823, A.radical = 549, A.dotmath = 250, A.logicalnot = 713, A.logicaland = 603, A.logicalor = 603, A.arrowdblboth = 1042, A.arrowdblleft = 987, A.arrowdblup = 603, A.arrowdblright = 987, A.arrowdbldown = 603, A.lozenge = 494, A.angleleft = 329, A.registersans = 790, A.copyrightsans = 790, A.trademarksans = 786, A.summation = 713, A.parenlefttp = 384, A.parenleftex = 384, A.parenleftbt = 384, A.bracketlefttp = 384, A.bracketleftex = 384, A.bracketleftbt = 384, A.bracelefttp = 494, A.braceleftmid = 494, A.braceleftbt = 494, A.braceex = 494, A.angleright = 329, A.integral = 274, A.integraltp = 686, A.integralex = 686, A.integralbt = 686, A.parenrighttp = 384, A.parenrightex = 384, A.parenrightbt = 384, A.bracketrighttp = 384, A.bracketrightex = 384, A.bracketrightbt = 384, A.bracerighttp = 494, A.bracerightmid = 494, A.bracerightbt = 494, A.apple = 790;
  }), e["Times-Roman"] = le(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 408, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 564, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 278, A.semicolon = 278, A.less = 564, A.equal = 564, A.greater = 564, A.question = 444, A.at = 921, A.A = 722, A.B = 667, A.C = 667, A.D = 722, A.E = 611, A.F = 556, A.G = 722, A.H = 722, A.I = 333, A.J = 389, A.K = 722, A.L = 611, A.M = 889, A.N = 722, A.O = 722, A.P = 556, A.Q = 722, A.R = 667, A.S = 556, A.T = 611, A.U = 722, A.V = 722, A.W = 944, A.X = 722, A.Y = 722, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 469, A.underscore = 500, A.quoteleft = 333, A.a = 444, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 333, A.g = 500, A.h = 500, A.i = 278, A.j = 278, A.k = 500, A.l = 278, A.m = 778, A.n = 500, A.o = 500, A.p = 500, A.q = 500, A.r = 333, A.s = 389, A.t = 278, A.u = 500, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 444, A.braceleft = 480, A.bar = 200, A.braceright = 480, A.asciitilde = 541, A.exclamdown = 333, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 180, A.quotedblleft = 444, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 453, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 444, A.quotedblright = 444, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 444, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 889, A.ordfeminine = 276, A.Lslash = 611, A.Oslash = 722, A.OE = 889, A.ordmasculine = 310, A.ae = 667, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 500, A.Idieresis = 333, A.eacute = 444, A.abreve = 444, A.uhungarumlaut = 500, A.ecaron = 444, A.Ydieresis = 722, A.divide = 564, A.Yacute = 722, A.Acircumflex = 722, A.aacute = 444, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 444, A.Uacute = 722, A.uogonek = 500, A.Edieresis = 611, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 760, A.Emacron = 611, A.ccaron = 444, A.aring = 444, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 444, A.Tcommaaccent = 611, A.Cacute = 667, A.atilde = 444, A.Edotaccent = 611, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 471, A.Rcaron = 667, A.Gcommaaccent = 722, A.ucircumflex = 500, A.acircumflex = 444, A.Amacron = 722, A.rcaron = 333, A.ccedilla = 444, A.Zdotaccent = 611, A.Thorn = 556, A.Omacron = 722, A.Racute = 667, A.Sacute = 556, A.dcaron = 588, A.Umacron = 722, A.uring = 500, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 722, A.Abreve = 722, A.multiply = 564, A.uacute = 500, A.Tcaron = 611, A.partialdiff = 476, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 611, A.adieresis = 444, A.edieresis = 444, A.cacute = 444, A.nacute = 500, A.umacron = 500, A.Ncaron = 722, A.Iacute = 333, A.plusminus = 564, A.brokenbar = 200, A.registered = 760, A.Gbreve = 722, A.Idotaccent = 333, A.summation = 600, A.Egrave = 611, A.racute = 333, A.omacron = 500, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 326, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 444, A.zacute = 444, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 444, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 500, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 611, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 344, A.Kcommaaccent = 722, A.Lacute = 611, A.trademark = 980, A.edotaccent = 444, A.Igrave = 333, A.Imacron = 333, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 500, A.Uhungarumlaut = 722, A.Eacute = 611, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 500, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 333, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 667, A.Lcommaaccent = 611, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 722, A.zdotaccent = 444, A.Ecaron = 611, A.Iogonek = 333, A.kcommaaccent = 500, A.minus = 564, A.Icircumflex = 333, A.ncaron = 500, A.tcommaaccent = 278, A.logicalnot = 564, A.odieresis = 500, A.udieresis = 500, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 444, A.ncommaaccent = 500, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), e["Times-Bold"] = le(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 555, A.numbersign = 500, A.dollar = 500, A.percent = 1e3, A.ampersand = 833, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 570, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 570, A.equal = 570, A.greater = 570, A.question = 500, A.at = 930, A.A = 722, A.B = 667, A.C = 722, A.D = 722, A.E = 667, A.F = 611, A.G = 778, A.H = 778, A.I = 389, A.J = 500, A.K = 778, A.L = 667, A.M = 944, A.N = 722, A.O = 778, A.P = 611, A.Q = 778, A.R = 722, A.S = 556, A.T = 667, A.U = 722, A.V = 722, A.W = 1e3, A.X = 722, A.Y = 722, A.Z = 667, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 581, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 556, A.c = 444, A.d = 556, A.e = 444, A.f = 333, A.g = 500, A.h = 556, A.i = 278, A.j = 333, A.k = 556, A.l = 278, A.m = 833, A.n = 556, A.o = 500, A.p = 556, A.q = 556, A.r = 444, A.s = 389, A.t = 333, A.u = 556, A.v = 500, A.w = 722, A.x = 500, A.y = 500, A.z = 444, A.braceleft = 394, A.bar = 220, A.braceright = 394, A.asciitilde = 520, A.exclamdown = 333, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 278, A.quotedblleft = 500, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 540, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 1e3, A.ordfeminine = 300, A.Lslash = 667, A.Oslash = 778, A.OE = 1e3, A.ordmasculine = 330, A.ae = 722, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 556, A.Idieresis = 389, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 556, A.ecaron = 444, A.Ydieresis = 722, A.divide = 570, A.Yacute = 722, A.Acircumflex = 722, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 500, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 747, A.Emacron = 667, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 667, A.Cacute = 722, A.atilde = 500, A.Edotaccent = 667, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 494, A.Rcaron = 722, A.Gcommaaccent = 778, A.ucircumflex = 556, A.acircumflex = 500, A.Amacron = 722, A.rcaron = 444, A.ccedilla = 444, A.Zdotaccent = 667, A.Thorn = 611, A.Omacron = 778, A.Racute = 722, A.Sacute = 556, A.dcaron = 672, A.Umacron = 722, A.uring = 556, A.threesuperior = 300, A.Ograve = 778, A.Agrave = 722, A.Abreve = 722, A.multiply = 570, A.uacute = 556, A.Tcaron = 667, A.partialdiff = 494, A.ydieresis = 500, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 389, A.plusminus = 570, A.brokenbar = 220, A.registered = 747, A.Gbreve = 778, A.Idotaccent = 389, A.summation = 600, A.Egrave = 667, A.racute = 444, A.omacron = 500, A.Zacute = 667, A.Zcaron = 667, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 722, A.lcommaaccent = 278, A.tcaron = 416, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 722, A.Adieresis = 722, A.egrave = 444, A.zacute = 444, A.iogonek = 278, A.Oacute = 778, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 778, A.Ugrave = 722, A.Delta = 612, A.thorn = 556, A.twosuperior = 300, A.Odieresis = 778, A.mu = 556, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 667, A.dcroat = 556, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 394, A.Kcommaaccent = 778, A.Lacute = 667, A.trademark = 1e3, A.edotaccent = 444, A.Igrave = 389, A.Imacron = 389, A.Lcaron = 667, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 778, A.degree = 400, A.ograve = 500, A.Ccaron = 722, A.ugrave = 556, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 444, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 722, A.Lcommaaccent = 667, A.Atilde = 722, A.Aogonek = 722, A.Aring = 722, A.Otilde = 778, A.zdotaccent = 444, A.Ecaron = 667, A.Iogonek = 389, A.kcommaaccent = 556, A.minus = 570, A.Icircumflex = 389, A.ncaron = 556, A.tcommaaccent = 333, A.logicalnot = 570, A.odieresis = 500, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 444, A.ncommaaccent = 556, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), e["Times-BoldItalic"] = le(function(A) {
    A.space = 250, A.exclam = 389, A.quotedbl = 555, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 570, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 570, A.equal = 570, A.greater = 570, A.question = 500, A.at = 832, A.A = 667, A.B = 667, A.C = 667, A.D = 722, A.E = 667, A.F = 667, A.G = 722, A.H = 778, A.I = 389, A.J = 500, A.K = 667, A.L = 611, A.M = 889, A.N = 722, A.O = 722, A.P = 611, A.Q = 722, A.R = 667, A.S = 556, A.T = 611, A.U = 722, A.V = 667, A.W = 889, A.X = 667, A.Y = 611, A.Z = 611, A.bracketleft = 333, A.backslash = 278, A.bracketright = 333, A.asciicircum = 570, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 333, A.g = 500, A.h = 556, A.i = 278, A.j = 278, A.k = 500, A.l = 278, A.m = 778, A.n = 556, A.o = 500, A.p = 500, A.q = 500, A.r = 389, A.s = 389, A.t = 278, A.u = 556, A.v = 444, A.w = 667, A.x = 500, A.y = 444, A.z = 389, A.braceleft = 348, A.bar = 220, A.braceright = 348, A.asciitilde = 570, A.exclamdown = 389, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 278, A.quotedblleft = 500, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 556, A.fl = 556, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 500, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 500, A.quotedblright = 500, A.guillemotright = 500, A.ellipsis = 1e3, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 1e3, A.AE = 944, A.ordfeminine = 266, A.Lslash = 611, A.Oslash = 722, A.OE = 944, A.ordmasculine = 300, A.ae = 722, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 722, A.germandbls = 500, A.Idieresis = 389, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 556, A.ecaron = 444, A.Ydieresis = 611, A.divide = 570, A.Yacute = 611, A.Acircumflex = 667, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 444, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 556, A.Edieresis = 667, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 747, A.Emacron = 667, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 722, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 611, A.Cacute = 667, A.atilde = 500, A.Edotaccent = 667, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 494, A.Rcaron = 667, A.Gcommaaccent = 722, A.ucircumflex = 556, A.acircumflex = 500, A.Amacron = 667, A.rcaron = 389, A.ccedilla = 444, A.Zdotaccent = 611, A.Thorn = 611, A.Omacron = 722, A.Racute = 667, A.Sacute = 556, A.dcaron = 608, A.Umacron = 722, A.uring = 556, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 667, A.Abreve = 667, A.multiply = 570, A.uacute = 556, A.Tcaron = 611, A.partialdiff = 494, A.ydieresis = 444, A.Nacute = 722, A.icircumflex = 278, A.Ecircumflex = 667, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 556, A.umacron = 556, A.Ncaron = 722, A.Iacute = 389, A.plusminus = 570, A.brokenbar = 220, A.registered = 747, A.Gbreve = 722, A.Idotaccent = 389, A.summation = 600, A.Egrave = 667, A.racute = 389, A.omacron = 500, A.Zacute = 611, A.Zcaron = 611, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 366, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 667, A.Adieresis = 667, A.egrave = 444, A.zacute = 389, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 576, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 667, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 556, A.lcaron = 382, A.Kcommaaccent = 667, A.Lacute = 611, A.trademark = 1e3, A.edotaccent = 444, A.Igrave = 389, A.Imacron = 389, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 556, A.Uhungarumlaut = 722, A.Eacute = 667, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 556, A.Scommaaccent = 556, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 556, A.radical = 549, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 722, A.otilde = 500, A.Rcommaaccent = 667, A.Lcommaaccent = 611, A.Atilde = 667, A.Aogonek = 667, A.Aring = 667, A.Otilde = 722, A.zdotaccent = 389, A.Ecaron = 667, A.Iogonek = 389, A.kcommaaccent = 500, A.minus = 606, A.Icircumflex = 389, A.ncaron = 556, A.tcommaaccent = 278, A.logicalnot = 606, A.odieresis = 500, A.udieresis = 556, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 389, A.ncommaaccent = 556, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), e["Times-Italic"] = le(function(A) {
    A.space = 250, A.exclam = 333, A.quotedbl = 420, A.numbersign = 500, A.dollar = 500, A.percent = 833, A.ampersand = 778, A.quoteright = 333, A.parenleft = 333, A.parenright = 333, A.asterisk = 500, A.plus = 675, A.comma = 250, A.hyphen = 333, A.period = 250, A.slash = 278, A.zero = 500, A.one = 500, A.two = 500, A.three = 500, A.four = 500, A.five = 500, A.six = 500, A.seven = 500, A.eight = 500, A.nine = 500, A.colon = 333, A.semicolon = 333, A.less = 675, A.equal = 675, A.greater = 675, A.question = 500, A.at = 920, A.A = 611, A.B = 611, A.C = 667, A.D = 722, A.E = 611, A.F = 611, A.G = 722, A.H = 722, A.I = 333, A.J = 444, A.K = 667, A.L = 556, A.M = 833, A.N = 667, A.O = 722, A.P = 611, A.Q = 722, A.R = 611, A.S = 500, A.T = 556, A.U = 722, A.V = 611, A.W = 833, A.X = 611, A.Y = 556, A.Z = 556, A.bracketleft = 389, A.backslash = 278, A.bracketright = 389, A.asciicircum = 422, A.underscore = 500, A.quoteleft = 333, A.a = 500, A.b = 500, A.c = 444, A.d = 500, A.e = 444, A.f = 278, A.g = 500, A.h = 500, A.i = 278, A.j = 278, A.k = 444, A.l = 278, A.m = 722, A.n = 500, A.o = 500, A.p = 500, A.q = 500, A.r = 389, A.s = 389, A.t = 278, A.u = 500, A.v = 444, A.w = 667, A.x = 444, A.y = 444, A.z = 389, A.braceleft = 400, A.bar = 275, A.braceright = 400, A.asciitilde = 541, A.exclamdown = 389, A.cent = 500, A.sterling = 500, A.fraction = 167, A.yen = 500, A.florin = 500, A.section = 500, A.currency = 500, A.quotesingle = 214, A.quotedblleft = 556, A.guillemotleft = 500, A.guilsinglleft = 333, A.guilsinglright = 333, A.fi = 500, A.fl = 500, A.endash = 500, A.dagger = 500, A.daggerdbl = 500, A.periodcentered = 250, A.paragraph = 523, A.bullet = 350, A.quotesinglbase = 333, A.quotedblbase = 556, A.quotedblright = 556, A.guillemotright = 500, A.ellipsis = 889, A.perthousand = 1e3, A.questiondown = 500, A.grave = 333, A.acute = 333, A.circumflex = 333, A.tilde = 333, A.macron = 333, A.breve = 333, A.dotaccent = 333, A.dieresis = 333, A.ring = 333, A.cedilla = 333, A.hungarumlaut = 333, A.ogonek = 333, A.caron = 333, A.emdash = 889, A.AE = 889, A.ordfeminine = 276, A.Lslash = 556, A.Oslash = 722, A.OE = 944, A.ordmasculine = 310, A.ae = 667, A.dotlessi = 278, A.lslash = 278, A.oslash = 500, A.oe = 667, A.germandbls = 500, A.Idieresis = 333, A.eacute = 444, A.abreve = 500, A.uhungarumlaut = 500, A.ecaron = 444, A.Ydieresis = 556, A.divide = 675, A.Yacute = 556, A.Acircumflex = 611, A.aacute = 500, A.Ucircumflex = 722, A.yacute = 444, A.scommaaccent = 389, A.ecircumflex = 444, A.Uring = 722, A.Udieresis = 722, A.aogonek = 500, A.Uacute = 722, A.uogonek = 500, A.Edieresis = 611, A.Dcroat = 722, A.commaaccent = 250, A.copyright = 760, A.Emacron = 611, A.ccaron = 444, A.aring = 500, A.Ncommaaccent = 667, A.lacute = 278, A.agrave = 500, A.Tcommaaccent = 556, A.Cacute = 667, A.atilde = 500, A.Edotaccent = 611, A.scaron = 389, A.scedilla = 389, A.iacute = 278, A.lozenge = 471, A.Rcaron = 611, A.Gcommaaccent = 722, A.ucircumflex = 500, A.acircumflex = 500, A.Amacron = 611, A.rcaron = 389, A.ccedilla = 444, A.Zdotaccent = 556, A.Thorn = 611, A.Omacron = 722, A.Racute = 611, A.Sacute = 500, A.dcaron = 544, A.Umacron = 722, A.uring = 500, A.threesuperior = 300, A.Ograve = 722, A.Agrave = 611, A.Abreve = 611, A.multiply = 675, A.uacute = 500, A.Tcaron = 556, A.partialdiff = 476, A.ydieresis = 444, A.Nacute = 667, A.icircumflex = 278, A.Ecircumflex = 611, A.adieresis = 500, A.edieresis = 444, A.cacute = 444, A.nacute = 500, A.umacron = 500, A.Ncaron = 667, A.Iacute = 333, A.plusminus = 675, A.brokenbar = 275, A.registered = 760, A.Gbreve = 722, A.Idotaccent = 333, A.summation = 600, A.Egrave = 611, A.racute = 389, A.omacron = 500, A.Zacute = 556, A.Zcaron = 556, A.greaterequal = 549, A.Eth = 722, A.Ccedilla = 667, A.lcommaaccent = 278, A.tcaron = 300, A.eogonek = 444, A.Uogonek = 722, A.Aacute = 611, A.Adieresis = 611, A.egrave = 444, A.zacute = 389, A.iogonek = 278, A.Oacute = 722, A.oacute = 500, A.amacron = 500, A.sacute = 389, A.idieresis = 278, A.Ocircumflex = 722, A.Ugrave = 722, A.Delta = 612, A.thorn = 500, A.twosuperior = 300, A.Odieresis = 722, A.mu = 500, A.igrave = 278, A.ohungarumlaut = 500, A.Eogonek = 611, A.dcroat = 500, A.threequarters = 750, A.Scedilla = 500, A.lcaron = 300, A.Kcommaaccent = 667, A.Lacute = 556, A.trademark = 980, A.edotaccent = 444, A.Igrave = 333, A.Imacron = 333, A.Lcaron = 611, A.onehalf = 750, A.lessequal = 549, A.ocircumflex = 500, A.ntilde = 500, A.Uhungarumlaut = 722, A.Eacute = 611, A.emacron = 444, A.gbreve = 500, A.onequarter = 750, A.Scaron = 500, A.Scommaaccent = 500, A.Ohungarumlaut = 722, A.degree = 400, A.ograve = 500, A.Ccaron = 667, A.ugrave = 500, A.radical = 453, A.Dcaron = 722, A.rcommaaccent = 389, A.Ntilde = 667, A.otilde = 500, A.Rcommaaccent = 611, A.Lcommaaccent = 556, A.Atilde = 611, A.Aogonek = 611, A.Aring = 611, A.Otilde = 722, A.zdotaccent = 389, A.Ecaron = 611, A.Iogonek = 333, A.kcommaaccent = 444, A.minus = 675, A.Icircumflex = 333, A.ncaron = 500, A.tcommaaccent = 278, A.logicalnot = 675, A.odieresis = 500, A.udieresis = 500, A.notequal = 549, A.gcommaaccent = 500, A.eth = 500, A.zcaron = 389, A.ncommaaccent = 500, A.onesuperior = 300, A.imacron = 278, A.Euro = 500;
  }), e.ZapfDingbats = le(function(A) {
    A.space = 278, A.a1 = 974, A.a2 = 961, A.a202 = 974, A.a3 = 980, A.a4 = 719, A.a5 = 789, A.a119 = 790, A.a118 = 791, A.a117 = 690, A.a11 = 960, A.a12 = 939, A.a13 = 549, A.a14 = 855, A.a15 = 911, A.a16 = 933, A.a105 = 911, A.a17 = 945, A.a18 = 974, A.a19 = 755, A.a20 = 846, A.a21 = 762, A.a22 = 761, A.a23 = 571, A.a24 = 677, A.a25 = 763, A.a26 = 760, A.a27 = 759, A.a28 = 754, A.a6 = 494, A.a7 = 552, A.a8 = 537, A.a9 = 577, A.a10 = 692, A.a29 = 786, A.a30 = 788, A.a31 = 788, A.a32 = 790, A.a33 = 793, A.a34 = 794, A.a35 = 816, A.a36 = 823, A.a37 = 789, A.a38 = 841, A.a39 = 823, A.a40 = 833, A.a41 = 816, A.a42 = 831, A.a43 = 923, A.a44 = 744, A.a45 = 723, A.a46 = 749, A.a47 = 790, A.a48 = 792, A.a49 = 695, A.a50 = 776, A.a51 = 768, A.a52 = 792, A.a53 = 759, A.a54 = 707, A.a55 = 708, A.a56 = 682, A.a57 = 701, A.a58 = 826, A.a59 = 815, A.a60 = 789, A.a61 = 789, A.a62 = 707, A.a63 = 687, A.a64 = 696, A.a65 = 689, A.a66 = 786, A.a67 = 787, A.a68 = 713, A.a69 = 791, A.a70 = 785, A.a71 = 791, A.a72 = 873, A.a73 = 761, A.a74 = 762, A.a203 = 762, A.a75 = 759, A.a204 = 759, A.a76 = 892, A.a77 = 892, A.a78 = 788, A.a79 = 784, A.a81 = 438, A.a82 = 138, A.a83 = 277, A.a84 = 415, A.a97 = 392, A.a98 = 392, A.a99 = 668, A.a100 = 668, A.a89 = 390, A.a90 = 390, A.a93 = 317, A.a94 = 317, A.a91 = 276, A.a92 = 276, A.a205 = 509, A.a85 = 509, A.a206 = 410, A.a86 = 410, A.a87 = 234, A.a88 = 234, A.a95 = 334, A.a96 = 334, A.a101 = 732, A.a102 = 544, A.a103 = 544, A.a104 = 910, A.a106 = 667, A.a107 = 760, A.a108 = 760, A.a112 = 776, A.a111 = 595, A.a110 = 694, A.a109 = 626, A.a120 = 788, A.a121 = 788, A.a122 = 788, A.a123 = 788, A.a124 = 788, A.a125 = 788, A.a126 = 788, A.a127 = 788, A.a128 = 788, A.a129 = 788, A.a130 = 788, A.a131 = 788, A.a132 = 788, A.a133 = 788, A.a134 = 788, A.a135 = 788, A.a136 = 788, A.a137 = 788, A.a138 = 788, A.a139 = 788, A.a140 = 788, A.a141 = 788, A.a142 = 788, A.a143 = 788, A.a144 = 788, A.a145 = 788, A.a146 = 788, A.a147 = 788, A.a148 = 788, A.a149 = 788, A.a150 = 788, A.a151 = 788, A.a152 = 788, A.a153 = 788, A.a154 = 788, A.a155 = 788, A.a156 = 788, A.a157 = 788, A.a158 = 788, A.a159 = 788, A.a160 = 894, A.a161 = 838, A.a163 = 1016, A.a164 = 458, A.a196 = 748, A.a165 = 924, A.a192 = 748, A.a166 = 918, A.a167 = 927, A.a168 = 928, A.a169 = 928, A.a170 = 834, A.a171 = 873, A.a172 = 828, A.a173 = 924, A.a162 = 924, A.a174 = 917, A.a175 = 930, A.a176 = 931, A.a177 = 463, A.a178 = 883, A.a179 = 836, A.a193 = 836, A.a180 = 867, A.a199 = 867, A.a181 = 696, A.a200 = 696, A.a182 = 874, A.a201 = 874, A.a183 = 760, A.a184 = 946, A.a197 = 771, A.a185 = 865, A.a194 = 771, A.a198 = 888, A.a186 = 967, A.a195 = 888, A.a187 = 831, A.a188 = 873, A.a189 = 927, A.a190 = 970, A.a191 = 918;
  });
}), jB = le(function(e) {
  e.Courier = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: -426
  }, e["Courier-Bold"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 439
  }, e["Courier-Oblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  }, e["Courier-BoldOblique"] = {
    ascent: 629,
    descent: -157,
    capHeight: 562,
    xHeight: 426
  }, e.Helvetica = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  }, e["Helvetica-Bold"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  }, e["Helvetica-Oblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 523
  }, e["Helvetica-BoldOblique"] = {
    ascent: 718,
    descent: -207,
    capHeight: 718,
    xHeight: 532
  }, e["Times-Roman"] = {
    ascent: 683,
    descent: -217,
    capHeight: 662,
    xHeight: 450
  }, e["Times-Bold"] = {
    ascent: 683,
    descent: -217,
    capHeight: 676,
    xHeight: 461
  }, e["Times-Italic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 653,
    xHeight: 441
  }, e["Times-BoldItalic"] = {
    ascent: 683,
    descent: -217,
    capHeight: 669,
    xHeight: 462
  }, e.Symbol = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  }, e.ZapfDingbats = {
    ascent: Math.NaN,
    descent: Math.NaN,
    capHeight: Math.NaN,
    xHeight: Math.NaN
  };
}), XB = 1, Wa = 2, Oa = 4, rI = 8, Qs = 16, Es = 32, _B = 64, fs = 1, Va = 2, zB = 8, $B = 32, AQ = 64, eQ = 128, Dr = 256;
class tQ {
  constructor({
    glyfTable: A,
    isGlyphLocationsLong: t,
    locaTable: i,
    numGlyphs: s
  }) {
    this.glyphs = [];
    const a = new DataView(i.buffer, i.byteOffset, i.byteLength), n = new DataView(A.buffer, A.byteOffset, A.byteLength), r = t ? 4 : 2;
    let g = t ? a.getUint32(0) : 2 * a.getUint16(0), o = 0;
    for (let I = 0; I < s; I++) {
      o += r;
      const c = t ? a.getUint32(o) : 2 * a.getUint16(o);
      if (c === g) {
        this.glyphs.push(new $s({}));
        continue;
      }
      const l = $s.parse(g, n);
      this.glyphs.push(l), g = c;
    }
  }
  getSize() {
    return this.glyphs.reduce((A, t) => {
      const i = t.getSize();
      return A + (i + 3 & -4);
    }, 0);
  }
  write() {
    const A = this.getSize(), t = new DataView(new ArrayBuffer(A)), i = A > 131070, s = i ? 4 : 2, a = new DataView(new ArrayBuffer((this.glyphs.length + 1) * s));
    i ? a.setUint32(0, 0) : a.setUint16(0, 0);
    let n = 0, r = 0;
    for (const g of this.glyphs)
      n += g.write(n, t), n = n + 3 & -4, r += s, i ? a.setUint32(r, n) : a.setUint16(r, n >> 1);
    return {
      isLocationLong: i,
      loca: new Uint8Array(a.buffer),
      glyf: new Uint8Array(t.buffer)
    };
  }
  scale(A) {
    for (let t = 0, i = this.glyphs.length; t < i; t++)
      this.glyphs[t].scale(A[t]);
  }
}
class $s {
  constructor({
    header: A = null,
    simple: t = null,
    composites: i = null
  }) {
    this.header = A, this.simple = t, this.composites = i;
  }
  static parse(A, t) {
    const [i, s] = $g.parse(A, t);
    if (A += i, s.numberOfContours < 0) {
      const n = [];
      for (; ; ) {
        const [r, g] = eo.parse(A, t);
        if (A += r, n.push(g), !(g.flags & $B))
          break;
      }
      return new $s({
        header: s,
        composites: n
      });
    }
    const a = Ao.parse(A, t, s.numberOfContours);
    return new $s({
      header: s,
      simple: a
    });
  }
  getSize() {
    if (!this.header)
      return 0;
    const A = this.simple ? this.simple.getSize() : this.composites.reduce((t, i) => t + i.getSize(), 0);
    return this.header.getSize() + A;
  }
  write(A, t) {
    if (!this.header)
      return 0;
    const i = A;
    if (A += this.header.write(A, t), this.simple)
      A += this.simple.write(A, t);
    else
      for (const s of this.composites)
        A += s.write(A, t);
    return A - i;
  }
  scale(A) {
    if (!this.header)
      return;
    const t = (this.header.xMin + this.header.xMax) / 2;
    if (this.header.scale(t, A), this.simple)
      this.simple.scale(t, A);
    else
      for (const i of this.composites)
        i.scale(t, A);
  }
}
class $g {
  constructor({
    numberOfContours: A,
    xMin: t,
    yMin: i,
    xMax: s,
    yMax: a
  }) {
    this.numberOfContours = A, this.xMin = t, this.yMin = i, this.xMax = s, this.yMax = a;
  }
  static parse(A, t) {
    return [10, new $g({
      numberOfContours: t.getInt16(A),
      xMin: t.getInt16(A + 2),
      yMin: t.getInt16(A + 4),
      xMax: t.getInt16(A + 6),
      yMax: t.getInt16(A + 8)
    })];
  }
  getSize() {
    return 10;
  }
  write(A, t) {
    return t.setInt16(A, this.numberOfContours), t.setInt16(A + 2, this.xMin), t.setInt16(A + 4, this.yMin), t.setInt16(A + 6, this.xMax), t.setInt16(A + 8, this.yMax), 10;
  }
  scale(A, t) {
    this.xMin = Math.round(A + (this.xMin - A) * t), this.xMax = Math.round(A + (this.xMax - A) * t);
  }
}
class iQ {
  constructor({
    flags: A,
    xCoordinates: t,
    yCoordinates: i
  }) {
    this.xCoordinates = t, this.yCoordinates = i, this.flags = A;
  }
}
class Ao {
  constructor({
    contours: A,
    instructions: t
  }) {
    this.contours = A, this.instructions = t;
  }
  static parse(A, t, i) {
    const s = [];
    for (let Q = 0; Q < i; Q++) {
      const E = t.getUint16(A);
      A += 2, s.push(E);
    }
    const a = s[i - 1] + 1, n = t.getUint16(A);
    A += 2;
    const r = new Uint8Array(t).slice(A, A + n);
    A += n;
    const g = [];
    for (let Q = 0; Q < a; A++, Q++) {
      let E = t.getUint8(A);
      if (g.push(E), E & rI) {
        const f = t.getUint8(++A);
        E ^= rI;
        for (let d = 0; d < f; d++)
          g.push(E);
        Q += f;
      }
    }
    const o = [];
    let I = [], c = [], l = [];
    const h = [];
    let C = 0, B = 0;
    for (let Q = 0; Q < a; Q++) {
      const E = g[Q];
      if (E & Wa) {
        const f = t.getUint8(A++);
        B += E & Qs ? f : -f, I.push(B);
      } else E & Qs || (B += t.getInt16(A), A += 2), I.push(B);
      s[C] === Q && (C++, o.push(I), I = []);
    }
    B = 0, C = 0;
    for (let Q = 0; Q < a; Q++) {
      const E = g[Q];
      if (E & Oa) {
        const f = t.getUint8(A++);
        B += E & Es ? f : -f, c.push(B);
      } else E & Es || (B += t.getInt16(A), A += 2), c.push(B);
      l.push(E & XB | E & _B), s[C] === Q && (I = o[C], C++, h.push(new iQ({
        flags: l,
        xCoordinates: I,
        yCoordinates: c
      })), c = [], l = []);
    }
    return new Ao({
      contours: h,
      instructions: r
    });
  }
  getSize() {
    let A = this.contours.length * 2 + 2 + this.instructions.length, t = 0, i = 0;
    for (const s of this.contours) {
      A += s.flags.length;
      for (let a = 0, n = s.xCoordinates.length; a < n; a++) {
        const r = s.xCoordinates[a], g = s.yCoordinates[a];
        let o = Math.abs(r - t);
        o > 255 ? A += 2 : o > 0 && (A += 1), t = r, o = Math.abs(g - i), o > 255 ? A += 2 : o > 0 && (A += 1), i = g;
      }
    }
    return A;
  }
  write(A, t) {
    const i = A, s = [], a = [], n = [];
    let r = 0, g = 0;
    for (const o of this.contours) {
      for (let I = 0, c = o.xCoordinates.length; I < c; I++) {
        let l = o.flags[I];
        const h = o.xCoordinates[I];
        let C = h - r;
        if (C === 0)
          l |= Qs, s.push(0);
        else {
          const Q = Math.abs(C);
          Q <= 255 ? (l |= C >= 0 ? Wa | Qs : Wa, s.push(Q)) : s.push(C);
        }
        r = h;
        const B = o.yCoordinates[I];
        if (C = B - g, C === 0)
          l |= Es, a.push(0);
        else {
          const Q = Math.abs(C);
          Q <= 255 ? (l |= C >= 0 ? Oa | Es : Oa, a.push(Q)) : a.push(C);
        }
        g = B, n.push(l);
      }
      t.setUint16(A, s.length - 1), A += 2;
    }
    t.setUint16(A, this.instructions.length), A += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, A), A += this.instructions.length);
    for (const o of n)
      t.setUint8(A++, o);
    for (let o = 0, I = s.length; o < I; o++) {
      const c = s[o], l = n[o];
      l & Wa ? t.setUint8(A++, c) : l & Qs || (t.setInt16(A, c), A += 2);
    }
    for (let o = 0, I = a.length; o < I; o++) {
      const c = a[o], l = n[o];
      l & Oa ? t.setUint8(A++, c) : l & Es || (t.setInt16(A, c), A += 2);
    }
    return A - i;
  }
  scale(A, t) {
    for (const i of this.contours)
      if (i.xCoordinates.length !== 0)
        for (let s = 0, a = i.xCoordinates.length; s < a; s++)
          i.xCoordinates[s] = Math.round(A + (i.xCoordinates[s] - A) * t);
  }
}
class eo {
  constructor({
    flags: A,
    glyphIndex: t,
    argument1: i,
    argument2: s,
    transf: a,
    instructions: n
  }) {
    this.flags = A, this.glyphIndex = t, this.argument1 = i, this.argument2 = s, this.transf = a, this.instructions = n;
  }
  static parse(A, t) {
    const i = A, s = [];
    let a = t.getUint16(A);
    const n = t.getUint16(A + 2);
    A += 4;
    let r, g;
    a & fs ? (a & Va ? (r = t.getInt16(A), g = t.getInt16(A + 2)) : (r = t.getUint16(A), g = t.getUint16(A + 2)), A += 4, a ^= fs) : (a & Va ? (r = t.getInt8(A), g = t.getInt8(A + 1)) : (r = t.getUint8(A), g = t.getUint8(A + 1)), A += 2), a & zB ? (s.push(t.getUint16(A)), A += 2) : a & AQ ? (s.push(t.getUint16(A), t.getUint16(A + 2)), A += 4) : a & eQ && (s.push(t.getUint16(A), t.getUint16(A + 2), t.getUint16(A + 4), t.getUint16(A + 6)), A += 8);
    let o = null;
    if (a & Dr) {
      const I = t.getUint16(A);
      A += 2, o = new Uint8Array(t).slice(A, A + I), A += I;
    }
    return [A - i, new eo({
      flags: a,
      glyphIndex: n,
      argument1: r,
      argument2: g,
      transf: s,
      instructions: o
    })];
  }
  getSize() {
    let A = 4 + this.transf.length * 2;
    return this.flags & Dr && (A += 2 + this.instructions.length), A += 2, this.flags & 2 ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (A += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (A += 2), A;
  }
  write(A, t) {
    const i = A;
    return this.flags & Va ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= fs) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= fs), t.setUint16(A, this.flags), t.setUint16(A + 2, this.glyphIndex), A += 4, this.flags & fs ? (this.flags & Va ? (t.setInt16(A, this.argument1), t.setInt16(A + 2, this.argument2)) : (t.setUint16(A, this.argument1), t.setUint16(A + 2, this.argument2)), A += 4) : (t.setUint8(A, this.argument1), t.setUint8(A + 1, this.argument2), A += 2), this.flags & Dr && (t.setUint16(A, this.instructions.length), A += 2, this.instructions.length && (new Uint8Array(t.buffer, 0, t.buffer.byteLength).set(this.instructions, A), A += this.instructions.length)), A - i;
  }
  scale(A, t) {
  }
}
function Za(e, A, t) {
  e[A] = t >> 8 & 255, e[A + 1] = t & 255;
}
function kr(e, A, t) {
  e[A] = t >> 24 & 255, e[A + 1] = t >> 16 & 255, e[A + 2] = t >> 8 & 255, e[A + 3] = t & 255;
}
function sQ(e, A, t) {
  if (t instanceof Uint8Array)
    e.set(t, A);
  else if (typeof t == "string")
    for (let i = 0, s = t.length; i < s; i++)
      e[A++] = t.charCodeAt(i) & 255;
  else
    for (const i of t)
      e[A++] = i & 255;
}
const gI = 12, oI = 16;
class Aa {
  constructor(A) {
    this.sfnt = A, this.tables = /* @__PURE__ */ Object.create(null);
  }
  static getSearchParams(A, t) {
    let i = 1, s = 0;
    for (; (i ^ A) > i; )
      i <<= 1, s++;
    const a = i * t;
    return {
      range: a,
      entry: s,
      rangeShift: t * A - a
    };
  }
  toArray() {
    let A = this.sfnt;
    const t = this.tables, i = Object.keys(t);
    i.sort();
    const s = i.length;
    let a, n, r, g, o, I = gI + s * oI;
    const c = [I];
    for (a = 0; a < s; a++) {
      g = t[i[a]];
      const C = (g.length + 3 & -4) >>> 0;
      I += C, c.push(I);
    }
    const l = new Uint8Array(I);
    for (a = 0; a < s; a++)
      g = t[i[a]], sQ(l, c[a], g);
    A === "true" && (A = qe(65536)), l[0] = A.charCodeAt(0) & 255, l[1] = A.charCodeAt(1) & 255, l[2] = A.charCodeAt(2) & 255, l[3] = A.charCodeAt(3) & 255, Za(l, 4, s);
    const h = Aa.getSearchParams(s, 16);
    for (Za(l, 6, h.range), Za(l, 8, h.entry), Za(l, 10, h.rangeShift), I = gI, a = 0; a < s; a++) {
      o = i[a], l[I] = o.charCodeAt(0) & 255, l[I + 1] = o.charCodeAt(1) & 255, l[I + 2] = o.charCodeAt(2) & 255, l[I + 3] = o.charCodeAt(3) & 255;
      let C = 0;
      for (n = c[a], r = c[a + 1]; n < r; n += 4) {
        const B = ce(l, n);
        C = C + B >>> 0;
      }
      kr(l, I + 4, C), kr(l, I + 8, c[a]), kr(l, I + 12, t[o].length), I += oI;
    }
    return l;
  }
  addTable(A, t) {
    if (A in this.tables)
      throw new Error("Table " + A + " already exists");
    this.tables[A] = t;
  }
}
const aQ = !1, tt = {
  vmoveto: [4],
  rlineto: [5],
  hlineto: [6],
  vlineto: [7],
  rrcurveto: [8],
  flex: [12, 35],
  endchar: [14],
  rmoveto: [21],
  hmoveto: [22],
  vhcurveto: [30],
  hvcurveto: [31]
};
class nQ {
  constructor() {
    this.width = 0, this.lsb = 0, this.flexing = !1, this.output = [], this.stack = [];
  }
  convert(A, t, i) {
    const s = A.length;
    let a = !1, n, r, g;
    for (let o = 0; o < s; o++) {
      let I = A[o];
      if (I < 32) {
        switch (I === 12 && (I = (I << 8) + A[++o]), I) {
          case 1: {
            this.stack = [];
            break;
          }
          case 3: {
            this.stack = [];
            break;
          }
          case 4:
            if (this.flexing) {
              if (this.stack.length < 1) {
                a = !0;
                break;
              }
              const B = this.stack.pop();
              this.stack.push(0, B);
              break;
            }
            a = this.executeCommand(1, tt.vmoveto);
            break;
          case 5:
            a = this.executeCommand(2, tt.rlineto);
            break;
          case 6:
            a = this.executeCommand(1, tt.hlineto);
            break;
          case 7:
            a = this.executeCommand(1, tt.vlineto);
            break;
          case 8:
            a = this.executeCommand(6, tt.rrcurveto);
            break;
          case 9:
            this.stack = [];
            break;
          case 10:
            if (this.stack.length < 1) {
              a = !0;
              break;
            }
            if (g = this.stack.pop(), !t[g]) {
              a = !0;
              break;
            }
            a = this.convert(t[g], t, i);
            break;
          case 11:
            return a;
          case 13:
            if (this.stack.length < 2) {
              a = !0;
              break;
            }
            n = this.stack.pop(), r = this.stack.pop(), this.lsb = r, this.width = n, this.stack.push(n, r), a = this.executeCommand(2, tt.hmoveto);
            break;
          case 14:
            this.output.push(tt.endchar[0]);
            break;
          case 21:
            if (this.flexing)
              break;
            a = this.executeCommand(2, tt.rmoveto);
            break;
          case 22:
            if (this.flexing) {
              this.stack.push(0);
              break;
            }
            a = this.executeCommand(1, tt.hmoveto);
            break;
          case 30:
            a = this.executeCommand(4, tt.vhcurveto);
            break;
          case 31:
            a = this.executeCommand(4, tt.hvcurveto);
            break;
          case 3072:
            this.stack = [];
            break;
          case 3073: {
            this.stack = [];
            break;
          }
          case 3074: {
            this.stack = [];
            break;
          }
          case 3078:
            if (i) {
              const B = this.stack.at(-5);
              this.seac = this.stack.splice(-4, 4), this.seac[0] += this.lsb - B, a = this.executeCommand(0, tt.endchar);
            } else
              a = this.executeCommand(4, tt.endchar);
            break;
          case 3079:
            if (this.stack.length < 4) {
              a = !0;
              break;
            }
            this.stack.pop(), n = this.stack.pop();
            const c = this.stack.pop();
            r = this.stack.pop(), this.lsb = r, this.width = n, this.stack.push(n, r, c), a = this.executeCommand(3, tt.rmoveto);
            break;
          case 3084:
            if (this.stack.length < 2) {
              a = !0;
              break;
            }
            const l = this.stack.pop(), h = this.stack.pop();
            this.stack.push(h / l);
            break;
          case 3088:
            if (this.stack.length < 2) {
              a = !0;
              break;
            }
            g = this.stack.pop();
            const C = this.stack.pop();
            if (g === 0 && C === 3) {
              const B = this.stack.splice(-17, 17);
              this.stack.push(B[2] + B[0], B[3] + B[1], B[4], B[5], B[6], B[7], B[8], B[9], B[10], B[11], B[12], B[13], B[14]), a = this.executeCommand(13, tt.flex, !0), this.flexing = !1, this.stack.push(B[15], B[16]);
            } else g === 1 && C === 0 && (this.flexing = !0);
            break;
          case 3089:
            break;
          case 3105:
            this.stack = [];
            break;
          default:
            k('Unknown type 1 charstring command of "' + I + '"');
            break;
        }
        if (a)
          break;
        continue;
      } else I <= 246 ? I -= 139 : I <= 250 ? I = (I - 247) * 256 + A[++o] + 108 : I <= 254 ? I = -((I - 251) * 256) - A[++o] - 108 : I = (A[++o] & 255) << 24 | (A[++o] & 255) << 16 | (A[++o] & 255) << 8 | (A[++o] & 255) << 0;
      this.stack.push(I);
    }
    return a;
  }
  executeCommand(A, t, i) {
    const s = this.stack.length;
    if (A > s)
      return !0;
    const a = s - A;
    for (let n = a; n < s; n++) {
      let r = this.stack[n];
      Number.isInteger(r) ? this.output.push(28, r >> 8 & 255, r & 255) : (r = 65536 * r | 0, this.output.push(255, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255));
    }
    return this.output.push(...t), i ? this.stack.splice(a, A) : this.stack.length = 0, !1;
  }
}
const II = 55665, rQ = 4330;
function zt(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function cI(e, A, t) {
  if (t >= e.length)
    return new Uint8Array(0);
  const i = 52845, s = 22719;
  let a = A | 0, n, r;
  for (n = 0; n < t; n++)
    a = (e[n] + a) * i + s & 65535;
  const g = e.length - t, o = new Uint8Array(g);
  for (n = t, r = 0; r < g; n++, r++) {
    const I = e[n];
    o[r] = I ^ a >> 8, a = (I + a) * i + s & 65535;
  }
  return o;
}
function gQ(e, A, t) {
  let a = A | 0;
  const n = e.length, r = n >>> 1, g = new Uint8Array(r);
  let o, I;
  for (o = 0, I = 0; o < n; o++) {
    const c = e[o];
    if (!zt(c))
      continue;
    o++;
    let l;
    for (; o < n && !zt(l = e[o]); )
      o++;
    if (o < n) {
      const h = parseInt(String.fromCharCode(c, l), 16);
      g[I++] = h ^ a >> 8, a = (h + a) * 52845 + 22719 & 65535;
    }
  }
  return g.slice(t, I);
}
function lI(e) {
  return e === 47 || e === 91 || e === 93 || e === 123 || e === 125 || e === 40 || e === 41;
}
class hI {
  constructor(A, t, i) {
    if (t) {
      const s = A.getBytes(), a = !((zt(s[0]) || mt(s[0])) && zt(s[1]) && zt(s[2]) && zt(s[3]) && zt(s[4]) && zt(s[5]) && zt(s[6]) && zt(s[7]));
      A = new Qe(a ? cI(s, II, 4) : gQ(s, II, 4));
    }
    this.seacAnalysisEnabled = !!i, this.stream = A, this.nextChar();
  }
  readNumberArray() {
    this.getToken();
    const A = [];
    for (; ; ) {
      const t = this.getToken();
      if (t === null || t === "]" || t === "}")
        break;
      A.push(parseFloat(t || 0));
    }
    return A;
  }
  readNumber() {
    const A = this.getToken();
    return parseFloat(A || 0);
  }
  readInt() {
    const A = this.getToken();
    return parseInt(A || 0, 10) | 0;
  }
  readBoolean() {
    return this.getToken() === "true" ? 1 : 0;
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  prevChar() {
    return this.stream.skip(-2), this.currentChar = this.stream.getByte();
  }
  getToken() {
    let A = !1, t = this.currentChar;
    for (; ; ) {
      if (t === -1)
        return null;
      if (A)
        (t === 10 || t === 13) && (A = !1);
      else if (t === 37)
        A = !0;
      else if (!mt(t))
        break;
      t = this.nextChar();
    }
    if (lI(t))
      return this.nextChar(), String.fromCharCode(t);
    let i = "";
    do
      i += String.fromCharCode(t), t = this.nextChar();
    while (t >= 0 && !mt(t) && !lI(t));
    return i;
  }
  readCharStrings(A, t) {
    return t === -1 ? A : cI(A, rQ, t);
  }
  extractFontProgram(A) {
    const t = this.stream, i = [], s = [], a = /* @__PURE__ */ Object.create(null);
    a.lenIV = 4;
    const n = {
      subrs: [],
      charstrings: [],
      properties: {
        privateData: a
      }
    };
    let r, g, o, I;
    for (; (r = this.getToken()) !== null; )
      if (r === "/")
        switch (r = this.getToken(), r) {
          case "CharStrings":
            for (this.getToken(), this.getToken(), this.getToken(), this.getToken(); r = this.getToken(), !(r === null || r === "end"); ) {
              if (r !== "/")
                continue;
              const l = this.getToken();
              g = this.readInt(), this.getToken(), o = g > 0 ? t.getBytes(g) : new Uint8Array(0), I = n.properties.privateData.lenIV;
              const h = this.readCharStrings(o, I);
              this.nextChar(), r = this.getToken(), r === "noaccess" ? this.getToken() : r === "/" && this.prevChar(), s.push({
                glyph: l,
                encoded: h
              });
            }
            break;
          case "Subrs":
            for (this.readInt(), this.getToken(); this.getToken() === "dup"; ) {
              const l = this.readInt();
              g = this.readInt(), this.getToken(), o = g > 0 ? t.getBytes(g) : new Uint8Array(0), I = n.properties.privateData.lenIV;
              const h = this.readCharStrings(o, I);
              this.nextChar(), r = this.getToken(), r === "noaccess" && this.getToken(), i[l] = h;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const c = this.readNumberArray();
            c.length > 0 && c.length % 2;
            break;
          case "StemSnapH":
          case "StemSnapV":
            n.properties.privateData[r] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            n.properties.privateData[r] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
            n.properties.privateData[r] = this.readNumber();
            break;
          case "ExpansionFactor":
            n.properties.privateData[r] = this.readNumber() || 0.06;
            break;
          case "ForceBold":
            n.properties.privateData[r] = this.readBoolean();
            break;
        }
    for (const {
      encoded: c,
      glyph: l
    } of s) {
      const h = new nQ(), C = h.convert(c, i, this.seacAnalysisEnabled);
      let B = h.output;
      C && (B = [14]);
      const Q = {
        glyphName: l,
        charstring: B,
        width: h.width,
        lsb: h.lsb,
        seac: h.seac
      };
      if (l === ".notdef" ? n.charstrings.unshift(Q) : n.charstrings.push(Q), A.builtInEncoding) {
        const E = A.builtInEncoding.indexOf(l);
        E > -1 && A.widths[E] === void 0 && E >= A.firstChar && E <= A.lastChar && (A.widths[E] = h.width);
      }
    }
    return n;
  }
  extractFontHeader(A) {
    let t;
    for (; (t = this.getToken()) !== null; )
      if (t === "/")
        switch (t = this.getToken(), t) {
          case "FontMatrix":
            const i = this.readNumberArray();
            A.fontMatrix = i;
            break;
          case "Encoding":
            const s = this.getToken();
            let a;
            if (!/^\d+$/.test(s))
              a = Xs(s);
            else {
              a = [];
              const r = parseInt(s, 10) | 0;
              this.getToken();
              for (let g = 0; g < r; g++) {
                for (t = this.getToken(); t !== "dup" && t !== "def"; )
                  if (t = this.getToken(), t === null)
                    return;
                if (t === "def")
                  break;
                const o = this.readInt();
                this.getToken();
                const I = this.getToken();
                a[o] = I, this.getToken();
              }
            }
            A.builtInEncoding = a;
            break;
          case "FontBBox":
            const n = this.readNumberArray();
            A.ascent = Math.max(n[3], n[1]), A.descent = Math.min(n[1], n[3]), A.ascentScaled = !0;
            break;
        }
  }
}
function CI(e, A, t) {
  const i = e.length, s = A.length, a = i - s;
  let n = t, r = !1;
  for (; n < a; ) {
    let g = 0;
    for (; g < s && e[n + g] === A[g]; )
      g++;
    if (g >= s) {
      for (n += g; n < i && mt(e[n]); )
        n++;
      r = !0;
      break;
    }
    n++;
  }
  return {
    found: r,
    length: n
  };
}
function oQ(e, A) {
  const t = [101, 101, 120, 101, 99], i = e.pos;
  let s, a, n;
  try {
    s = e.getBytes(A), a = s.length;
  } catch {
  }
  if (a === A && (n = CI(s, t, A - 2 * t.length), n.found && n.length === A))
    return {
      stream: new Qe(s),
      length: A
    };
  k('Invalid "Length1" property in Type1 font -- trying to recover.'), e.pos = i;
  const r = 2048;
  let g;
  for (; ; ) {
    const o = e.peekBytes(r);
    if (n = CI(o, t, 0), n.length === 0)
      break;
    if (e.pos += n.length, n.found) {
      g = e.pos - i;
      break;
    }
  }
  return e.pos = i, g ? {
    stream: new Qe(e.getBytes(g)),
    length: g
  } : (k('Unable to recover "Length1" property in Type1 font -- using as is.'), {
    stream: new Qe(e.getBytes(A)),
    length: A
  });
}
function IQ(e, A) {
  const t = e.getBytes();
  if (t.length === 0)
    throw new v("getEexecBlock - no font program found.");
  return {
    stream: new Qe(t),
    length: t.length
  };
}
class cQ {
  constructor(A, t, i) {
    let a = i.length1;
    i.length2;
    let n = t.peekBytes(6);
    const r = n[0] === 128 && n[1] === 1;
    r && (t.skip(6), a = n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2]);
    const g = oQ(t, a);
    new hI(g.stream, !1, V0).extractFontHeader(i), r && (n = t.getBytes(6), n[5] << 24 | n[4] << 16 | n[3] << 8 | n[2]);
    const I = IQ(t), l = new hI(I.stream, !0, V0).extractFontProgram(i);
    for (const Q in l.properties)
      i[Q] = l.properties[Q];
    const h = l.charstrings, C = this.getType2Charstrings(h), B = this.getType2Subrs(l.subrs);
    this.charstrings = h, this.data = this.wrap(A, C, this.charstrings, B, i), this.seacs = this.getSeacs(l.charstrings);
  }
  get numGlyphs() {
    return this.charstrings.length + 1;
  }
  getCharset() {
    const A = [".notdef"];
    for (const {
      glyphName: t
    } of this.charstrings)
      A.push(t);
    return A;
  }
  getGlyphMapping(A) {
    const t = this.charstrings;
    if (A.composite) {
      const r = /* @__PURE__ */ Object.create(null);
      for (let g = 0, o = t.length; g < o; g++) {
        const I = A.cMap.charCodeOf(g);
        r[I] = g + 1;
      }
      return r;
    }
    const i = [".notdef"];
    let s, a;
    for (a = 0; a < t.length; a++)
      i.push(t[a].glyphName);
    const n = A.builtInEncoding;
    if (n) {
      s = /* @__PURE__ */ Object.create(null);
      for (const r in n)
        a = i.indexOf(n[r]), a >= 0 && (s[r] = a);
    }
    return Vc(A, s, i);
  }
  hasGlyphId(A) {
    return A < 0 || A >= this.numGlyphs ? !1 : A === 0 ? !0 : this.charstrings[A - 1].charstring.length > 0;
  }
  getSeacs(A) {
    const t = [];
    for (let i = 0, s = A.length; i < s; i++) {
      const a = A[i];
      a.seac && (t[i + 1] = a.seac);
    }
    return t;
  }
  getType2Charstrings(A) {
    const t = [];
    for (const i of A)
      t.push(i.charstring);
    return t;
  }
  getType2Subrs(A) {
    let t = 0;
    const i = A.length;
    i < 1133 ? t = 107 : i < 33769 ? t = 1131 : t = 32768;
    const s = [];
    let a;
    for (a = 0; a < t; a++)
      s.push([11]);
    for (a = 0; a < i; a++)
      s.push(A[a]);
    return s;
  }
  wrap(A, t, i, s, a) {
    const n = new qc();
    n.header = new Pc(1, 0, 4, 4), n.names = [A];
    const r = new _s();
    r.setByName("version", 391), r.setByName("Notice", 392), r.setByName("FullName", 393), r.setByName("FamilyName", 394), r.setByName("Weight", 395), r.setByName("Encoding", null), r.setByName("FontMatrix", a.fontMatrix), r.setByName("FontBBox", a.bbox), r.setByName("charset", null), r.setByName("CharStrings", null), r.setByName("Private", null), n.topDict = r;
    const g = new _g();
    g.add("Version 0.11"), g.add("See original notice"), g.add(A), g.add(A), g.add("Medium"), n.strings = g, n.globalSubrIndex = new vi();
    const o = t.length, I = [".notdef"];
    let c, l;
    for (c = 0; c < o; c++) {
      const f = i[c].glyphName;
      Cn.indexOf(f) === -1 && g.add(f), I.push(f);
    }
    n.charset = new Rs(!1, 0, I);
    const h = new vi();
    for (h.add([139, 14]), c = 0; c < o; c++)
      h.add(t[c]);
    n.charStrings = h;
    const C = new zs();
    C.setByName("Subrs", null);
    const B = ["BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StemSnapH", "StemSnapV", "BlueShift", "BlueFuzz", "BlueScale", "LanguageGroup", "ExpansionFactor", "ForceBold", "StdHW", "StdVW"];
    for (c = 0, l = B.length; c < l; c++) {
      const f = B[c];
      if (!(f in a.privateData))
        continue;
      const d = a.privateData[f];
      if (Array.isArray(d))
        for (let u = d.length - 1; u > 0; u--)
          d[u] -= d[u - 1];
      C.setByName(f, d);
    }
    n.topDict.privateDict = C;
    const Q = new vi();
    for (c = 0, l = s.length; c < l; c++)
      Q.add(s[c]);
    return C.subrsIndex = Q, new ya(n).compile();
  }
}
const oi = [[57344, 63743], [1048576, 1114109]], A0 = 1e3, BI = ["ascent", "bbox", "black", "bold", "charProcOperatorList", "composite", "cssFontInfo", "data", "defaultVMetrics", "defaultWidth", "descent", "fallbackName", "fontMatrix", "isInvalidPDFjsFont", "isType3Font", "italic", "loadedName", "mimetype", "missingFile", "name", "remeasure", "subtype", "systemFontInfo", "type", "vertical"], lQ = ["cMap", "defaultEncoding", "differences", "isMonospace", "isSerifFont", "isSymbolicFont", "seacMap", "toFontChar", "toUnicode", "vmetrics", "widths"];
function Sr(e) {
  if (!e.fontMatrix || e.fontMatrix[0] === o0[0])
    return;
  const A = 1e-3 / e.fontMatrix[0], t = e.widths;
  for (const i in t)
    t[i] *= A;
  e.defaultWidth *= A;
}
function hQ(e, A, t) {
  if (e.isInternalFont || e.hasIncludedToUnicodeMap || e.hasEncoding || e.toUnicode instanceof Rt || !A || t.length === 0 || e.defaultEncoding === js)
    return;
  for (const n of t)
    if (!zc(n))
      return;
  const i = js, s = [], a = ti();
  for (const n in i) {
    const r = i[n];
    if (r === "")
      continue;
    const g = a[r];
    g !== void 0 && (s[n] = String.fromCharCode(g));
  }
  s.length > 0 && e.toUnicode.amend(s);
}
function CQ(e, A) {
  if (e.isInternalFont || e.hasIncludedToUnicodeMap || A === e.defaultEncoding || e.toUnicode instanceof Rt)
    return;
  const t = [], i = ti();
  for (const s in A) {
    if (e.hasEncoding && (e.baseEncodingName || e.differences[s] !== void 0))
      continue;
    const a = A[s], n = is(a, i);
    n !== -1 && (t[s] = String.fromCharCode(n));
  }
  t.length > 0 && e.toUnicode.amend(t);
}
function QI(e) {
  if (!e.fallbackToUnicode || e.toUnicode instanceof Rt)
    return;
  const A = [];
  for (const t in e.fallbackToUnicode)
    e.toUnicode.has(t) || (A[t] = e.fallbackToUnicode[t]);
  A.length > 0 && e.toUnicode.amend(A);
}
class BQ {
  constructor(A, t, i, s, a, n, r, g, o) {
    this.originalCharCode = A, this.fontChar = t, this.unicode = i, this.accent = s, this.width = a, this.vmetric = n, this.operatorListId = r, this.isSpace = g, this.isInFont = o;
  }
  get category() {
    return iA(this, "category", UB(this.unicode), !0);
  }
}
function ji(e, A) {
  return (e << 8) + A;
}
function us(e, A, t) {
  e[A + 1] = t, e[A] = t >>> 8;
}
function ft(e, A) {
  const t = (e << 8) + A;
  return t & 32768 ? t - 65536 : t;
}
function QQ(e, A, t) {
  e[A + 3] = t & 255, e[A + 2] = t >>> 8, e[A + 1] = t >>> 16, e[A] = t >>> 24;
}
function EQ(e, A, t, i) {
  return (e << 24) + (A << 16) + (t << 8) + i;
}
function Ae(e) {
  return String.fromCharCode(e >> 8 & 255, e & 255);
}
function Xi(e) {
  return e > 32767 ? e = 32767 : e < -32768 && (e = -32768), String.fromCharCode(e >> 8 & 255, e & 255);
}
function fQ(e) {
  const A = e.peekBytes(4);
  return ce(A, 0) === 65536 || ct(A) === "true";
}
function _c(e) {
  const A = e.peekBytes(4);
  return ct(A) === "ttcf";
}
function uQ(e) {
  const A = e.peekBytes(4);
  return ct(A) === "OTTO";
}
function dQ(e) {
  const A = e.peekBytes(2);
  return A[0] === 37 && A[1] === 33 || A[0] === 128 && A[1] === 1;
}
function xQ(e) {
  const A = e.peekBytes(4);
  return A[0] >= 1 && A[3] >= 1 && A[3] <= 4;
}
function mQ(e, {
  type: A,
  subtype: t,
  composite: i
}) {
  let s, a;
  return fQ(e) || _c(e) ? s = i ? "CIDFontType2" : "TrueType" : uQ(e) ? s = i ? "CIDFontType2" : "OpenType" : dQ(e) ? i ? s = "CIDFontType0" : s = A === "MMType1" ? "MMType1" : "Type1" : xQ(e) ? i ? (s = "CIDFontType0", a = "CIDFontType0C") : (s = A === "MMType1" ? "MMType1" : "Type1", a = "Type1C") : (k("getFontFileType: Unable to detect correct font file Type/Subtype."), s = A, a = t), [s, a];
}
function ja(e, A) {
  for (const t in A)
    e[+t] = A[t];
}
function Fr(e, A, t) {
  const i = [];
  let s;
  for (let a = 0, n = e.length; a < n; a++)
    s = is(e[a], A), s !== -1 && (i[a] = s);
  for (const a in t)
    s = is(t[a], A), s !== -1 && (i[+a] = s);
  return i;
}
function pQ(e) {
  return e.platform === 1 && e.encoding === 0 && e.language === 0;
}
function zc(e) {
  return e.platform === 3 && e.encoding === 1 && e.language === 1033;
}
function Rr(e, A, t = !1) {
  switch (A.length) {
    case 1:
      return A.charCodeAt(0);
    case 2:
      return A.charCodeAt(0) << 8 | A.charCodeAt(1);
  }
  const i = `Unsupported CID string (charCode ${e}): "${A}".`;
  if (t)
    throw new v(i);
  return k(i), A;
}
function EI(e, A, t, i) {
  const s = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map(), n = [], r = /* @__PURE__ */ new Set();
  let g = 0, I = oi[g][0], c = oi[g][1];
  const l = (h) => oi[0][0] <= h && h <= oi[0][1] || oi[1][0] <= h && h <= oi[1][1];
  for (const h in e) {
    let C = e[h];
    if (!A(C))
      continue;
    if (I > c) {
      if (g++, g >= oi.length) {
        k("Ran out of space in font private use area.");
        break;
      }
      I = oi[g][0], c = oi[g][1];
    }
    const B = I++;
    C === 0 && (C = t);
    let Q = i.get(h);
    typeof Q == "string" && (Q = Q.codePointAt(0)), Q && !l(Q) && !r.has(C) && (a.set(Q, C), r.add(C)), s[B] = C, n[h] = B;
  }
  return {
    toFontChar: n,
    charCodeToGlyphId: s,
    toUnicodeExtraMap: a,
    nextAvailableFontCharCode: I
  };
}
function yQ(e, A, t) {
  const i = [];
  for (const n in e)
    e[n] >= t || i.push({
      fontCharCode: n | 0,
      glyphId: e[n]
    });
  if (A)
    for (const [n, r] of A)
      r >= t || i.push({
        fontCharCode: n,
        glyphId: r
      });
  i.length === 0 && i.push({
    fontCharCode: 0,
    glyphId: 0
  }), i.sort(function(r, g) {
    return r.fontCharCode - g.fontCharCode;
  });
  const s = [], a = i.length;
  for (let n = 0; n < a; ) {
    const r = i[n].fontCharCode, g = [i[n].glyphId];
    ++n;
    let o = r;
    for (; n < a && o + 1 === i[n].fontCharCode && (g.push(i[n].glyphId), ++o, ++n, o !== 65535); )
      ;
    s.push([r, o, g]);
  }
  return s;
}
function fI(e, A, t) {
  const i = yQ(e, A, t), s = i.at(-1)[1] > 65535 ? 2 : 1;
  let a = "\0\0" + Ae(s) + "\0\0" + qe(4 + s * 8), n, r, g, o;
  for (n = i.length - 1; n >= 0 && !(i[n][0] <= 65535); --n)
    ;
  const I = n + 1;
  i[n][0] < 65535 && i[n][1] === 65535 && (i[n][1] = 65534);
  const c = i[n][1] < 65535 ? 1 : 0, l = I + c, h = Aa.getSearchParams(l, 2);
  let C = "", B = "", Q = "", E = "", f = "", d = 0, u, x, m, p;
  for (n = 0, r = I; n < r; n++) {
    u = i[n], x = u[0], m = u[1], C += Ae(x), B += Ae(m), p = u[2];
    let H = !0;
    for (g = 1, o = p.length; g < o; ++g)
      if (p[g] !== p[g - 1] + 1) {
        H = !1;
        break;
      }
    if (H) {
      const N = p[0];
      Q += Ae(N - x & 65535), E += Ae(0);
    } else {
      const N = (l - n) * 2 + d * 2;
      for (d += m - x + 1, Q += Ae(0), E += Ae(N), g = 0, o = p.length; g < o; ++g)
        f += Ae(p[g]);
    }
  }
  c > 0 && (B += "ÿÿ", C += "ÿÿ", Q += "\0", E += "\0\0");
  const D = "\0\0" + Ae(2 * l) + Ae(h.range) + Ae(h.entry) + Ae(h.rangeShift) + B + "\0\0" + C + Q + E + f;
  let F = "", y = "";
  if (s > 1) {
    for (a += `\0\0
` + qe(4 + s * 8 + 4 + D.length), F = "", n = 0, r = i.length; n < r; n++) {
      u = i[n], x = u[0], p = u[2];
      let H = p[0];
      for (g = 1, o = p.length; g < o; ++g)
        p[g] !== p[g - 1] + 1 && (m = u[0] + g - 1, F += qe(x) + qe(m) + qe(H), x = m + 1, H = p[g]);
      F += qe(x) + qe(u[1]) + qe(H);
    }
    y = "\0\f\0\0" + qe(F.length + 16) + "\0\0\0\0" + qe(F.length / 12);
  }
  return a + "\0" + Ae(D.length + 4) + D + y + F;
}
function wQ(e, A) {
  A.pos = (A.start || 0) + e.offset;
  const t = A.getUint16();
  A.skip(60);
  const i = A.getUint16();
  if (t < 4 && i & 768)
    return !1;
  const s = A.getUint16(), a = A.getUint16();
  return s > a || (A.skip(6), A.getUint16() === 0) ? !1 : (e.data[8] = e.data[9] = 0, !0);
}
function uI(e, A, t) {
  t || (t = {
    unitsPerEm: 0,
    yMax: 0,
    yMin: 0,
    ascent: 0,
    descent: 0
  });
  let i = 0, s = 0, a = 0, n = 0, r = null, g = 0, o = -1;
  if (A) {
    for (let E in A)
      if (E |= 0, (r > E || !r) && (r = E), g < E && (g = E), o = NB(E, o), o < 32)
        i |= 1 << o;
      else if (o < 64)
        s |= 1 << o - 32;
      else if (o < 96)
        a |= 1 << o - 64;
      else if (o < 123)
        n |= 1 << o - 96;
      else
        throw new v("Unicode ranges Bits > 123 are reserved for internal usage");
    g > 65535 && (g = 65535);
  } else
    r = 0, g = 255;
  const I = e.bbox || [0, 0, 0, 0], c = t.unitsPerEm || (e.fontMatrix ? 1 / Math.max(...e.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), l = e.ascentScaled ? 1 : c / A0, h = t.ascent || Math.round(l * (e.ascent || I[3]));
  let C = t.descent || Math.round(l * (e.descent || I[1]));
  C > 0 && e.descent > 0 && I[1] < 0 && (C = -C);
  const B = t.yMax || h, Q = -t.yMin || -C;
  return "\0$ô\0\0\0»\0\0\0»\0\0ß\x001\0\0\0\0" + String.fromCharCode(e.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + qe(i) + qe(s) + qe(a) + qe(n) + "*21*" + Ae(e.italicAngle ? 1 : 0) + Ae(r || e.firstChar) + Ae(g || e.lastChar) + Ae(h) + Ae(C) + "\0d" + Ae(B) + Ae(Q) + "\0\0\0\0\0\0\0\0" + Ae(e.xHeight) + Ae(e.capHeight) + Ae(0) + Ae(r || e.firstChar) + "\0";
}
function dI(e) {
  const A = Math.floor(e.italicAngle * 65536);
  return "\0\0\0" + qe(A) + "\0\0\0\0" + qe(e.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
}
function bQ(e) {
  return e.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
}
function Gr(e, A) {
  A || (A = [[], []]);
  const t = [A[0][0] || "Original licence", A[0][1] || e, A[0][2] || "Unknown", A[0][3] || "uniqueID", A[0][4] || e, A[0][5] || "Version 0.11", A[0][6] || bQ(e), A[0][7] || "Unknown", A[0][8] || "Unknown", A[0][9] || "Unknown"], i = [];
  let s, a, n, r, g;
  for (s = 0, a = t.length; s < a; s++) {
    g = A[1][s] || t[s];
    const Q = [];
    for (n = 0, r = g.length; n < r; n++)
      Q.push(Ae(g.charCodeAt(n)));
    i.push(Q.join(""));
  }
  const o = [t, i], I = ["\0", "\0"], c = ["\0\0", "\0"], l = ["\0\0", "	"], h = t.length * I.length;
  let C = "\0\0" + Ae(h) + Ae(h * 12 + 6), B = 0;
  for (s = 0, a = I.length; s < a; s++) {
    const Q = o[s];
    for (n = 0, r = Q.length; n < r; n++) {
      g = Q[n];
      const E = I[s] + c[s] + l[s] + Ae(n) + Ae(g.length) + Ae(B);
      C += E, B += g.length;
    }
  }
  return C += t.join("") + i.join(""), C;
}
class xI {
  constructor(A, t, i) {
    var o;
    this.name = A, this.psName = null, this.mimetype = null, this.disableFontFace = !1, this.loadedName = i.loadedName, this.isType3Font = i.isType3Font, this.missingFile = !1, this.cssFontInfo = i.cssFontInfo, this._charsCache = /* @__PURE__ */ Object.create(null), this._glyphCache = /* @__PURE__ */ Object.create(null);
    let s = !!(i.flags & vt.Serif);
    if (!s && !i.isSimulatedFlags) {
      const I = A.replaceAll(/[,_]/g, "-").split("-", 1)[0], c = zg();
      for (const l of I.split("+"))
        if (c[l]) {
          s = !0;
          break;
        }
    }
    this.isSerifFont = s, this.isSymbolicFont = !!(i.flags & vt.Symbolic), this.isMonospace = !!(i.flags & vt.FixedPitch);
    let {
      type: a,
      subtype: n
    } = i;
    this.type = a, this.subtype = n, this.systemFontInfo = i.systemFontInfo;
    const r = A.match(/^InvalidPDFjsFont_(.*)_\d+$/);
    if (this.isInvalidPDFjsFont = !!r, this.isInvalidPDFjsFont ? this.fallbackName = r[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif", (o = this.systemFontInfo) != null && o.guessFallback && (this.systemFontInfo.guessFallback = !1, this.systemFontInfo.css += `,${this.fallbackName}`), this.differences = i.differences, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.composite = i.composite, this.cMap = i.cMap, this.capHeight = i.capHeight / A0, this.ascent = i.ascent / A0, this.descent = i.descent / A0, this.lineHeight = this.ascent - this.descent, this.fontMatrix = i.fontMatrix, this.bbox = i.bbox, this.defaultEncoding = i.defaultEncoding, this.toUnicode = i.toUnicode, this.toFontChar = [], i.type === "Type3") {
      for (let I = 0; I < 256; I++)
        this.toFontChar[I] = this.differences[I] || i.defaultEncoding[I];
      return;
    }
    if (this.cidEncoding = i.cidEncoding || "", this.vertical = !!i.vertical, this.vertical && (this.vmetrics = i.vmetrics, this.defaultVMetrics = i.defaultVMetrics), !t || t.isEmpty) {
      t && k('Font file is empty in "' + A + '" (' + this.loadedName + ")"), this.fallbackToSystemFont(i);
      return;
    }
    [a, n] = mQ(t, i), (a !== this.type || n !== this.subtype) && vA(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${a}/${n}.`);
    let g;
    try {
      switch (a) {
        case "MMType1":
          vA("MMType1 font (" + A + "), falling back to Type1.");
        case "Type1":
        case "CIDFontType0":
          this.mimetype = "font/opentype";
          const I = n === "Type1C" || n === "CIDFontType0C" ? new br(t, i) : new cQ(A, t, i);
          Sr(i), g = this.convert(A, I, i);
          break;
        case "OpenType":
        case "TrueType":
        case "CIDFontType2":
          this.mimetype = "font/opentype", g = this.checkAndRepair(A, t, i), this.isOpenType && (Sr(i), a = "OpenType");
          break;
        default:
          throw new v(`Font ${a} is not supported`);
      }
    } catch (I) {
      k(I), this.fallbackToSystemFont(i);
      return;
    }
    QI(i), this.data = g, this.type = a, this.subtype = n, this.fontMatrix = i.fontMatrix, this.widths = i.widths, this.defaultWidth = i.defaultWidth, this.toUnicode = i.toUnicode, this.seacMap = i.seacMap;
  }
  get renderer() {
    const A = VB.create(this, V0);
    return iA(this, "renderer", A);
  }
  exportData(A = !1) {
    const t = A ? [...BI, ...lQ] : BI, i = /* @__PURE__ */ Object.create(null);
    let s, a;
    for (s of t)
      a = this[s], a !== void 0 && (i[s] = a);
    return i;
  }
  fallbackToSystemFont(A) {
    this.missingFile = !0;
    const {
      name: t,
      type: i
    } = this;
    let s = wa(t);
    const a = ir(), n = Zc(), r = !!a[s], g = !!(n[s] && a[n[s]]);
    s = a[s] || n[s] || s;
    const I = jB()[s];
    I && (isNaN(this.ascent) && (this.ascent = I.ascent / A0), isNaN(this.descent) && (this.descent = I.descent / A0), isNaN(this.capHeight) && (this.capHeight = I.capHeight / A0)), this.bold = /bold/gi.test(s), this.italic = /oblique|italic/gi.test(s), this.black = /Black/g.test(t);
    const c = /Narrow/g.test(t);
    if (this.remeasure = (!r || c) && Object.keys(this.widths).length > 0, (r || g) && i === "CIDFontType2" && this.cidEncoding.startsWith("Identity-")) {
      const l = A.cidToGidMap, h = [];
      if (ja(h, tI()), /Arial-?Black/i.test(t) ? ja(h, YB()) : /Calibri/i.test(t) && ja(h, KB()), l) {
        for (const C in h) {
          const B = h[C];
          l[B] !== void 0 && (h[+C] = l[B]);
        }
        l.length !== this.toUnicode.length && A.hasIncludedToUnicodeMap && this.toUnicode instanceof Rt && this.toUnicode.forEach(function(C, B) {
          const Q = h[C];
          l[Q] === void 0 && (h[+C] = B);
        });
      }
      this.toUnicode instanceof Rt || this.toUnicode.forEach(function(C, B) {
        h[+C] = B;
      }), this.toFontChar = h, this.toUnicode = new Gs(h);
    } else if (/Symbol/i.test(s))
      this.toFontChar = Fr(Zg, ti(), this.differences);
    else if (/Dingbats/i.test(s))
      this.toFontChar = Fr(jg, FB(), this.differences);
    else if (r || g) {
      const l = Fr(this.defaultEncoding, ti(), this.differences);
      i === "CIDFontType2" && !this.cidEncoding.startsWith("Identity-") && !(this.toUnicode instanceof Rt) && this.toUnicode.forEach(function(h, C) {
        l[+h] = C;
      }), this.toFontChar = l;
    } else {
      const l = ti(), h = [];
      this.toUnicode.forEach((C, B) => {
        if (!this.composite) {
          const Q = this.differences[C] || this.defaultEncoding[C], E = is(Q, l);
          E !== -1 && (B = E);
        }
        h[+C] = B;
      }), this.composite && this.toUnicode instanceof Rt && /Tahoma|Verdana/i.test(t) && ja(h, tI()), this.toFontChar = h;
    }
    QI(A), this.loadedName = s.split("-", 1)[0];
  }
  checkAndRepair(A, t, i) {
    var X, qA, IA;
    const s = ["OS/2", "cmap", "head", "hhea", "hmtx", "maxp", "name", "post", "loca", "glyf", "fpgm", "prep", "cvt ", "CFF "];
    function a(U, J) {
      const q = /* @__PURE__ */ Object.create(null);
      q["OS/2"] = null, q.cmap = null, q.head = null, q.hhea = null, q.hmtx = null, q.maxp = null, q.name = null, q.post = null;
      for (let Z = 0; Z < J; Z++) {
        const sA = n(U);
        s.includes(sA.tag) && sA.length !== 0 && (q[sA.tag] = sA);
      }
      return q;
    }
    function n(U) {
      const J = U.getString(4), q = U.getInt32() >>> 0, Z = U.getInt32() >>> 0, sA = U.getInt32() >>> 0, z = U.pos;
      U.pos = U.start || 0, U.skip(Z);
      const W = U.getBytes(sA);
      return U.pos = z, J === "head" && (W[8] = W[9] = W[10] = W[11] = 0, W[17] |= 32), {
        tag: J,
        checksum: q,
        length: sA,
        offset: Z,
        data: W
      };
    }
    function r(U) {
      return {
        version: U.getString(4),
        numTables: U.getUint16(),
        searchRange: U.getUint16(),
        entrySelector: U.getUint16(),
        rangeShift: U.getUint16()
      };
    }
    function g(U) {
      const J = U.getString(4);
      _e(J === "ttcf", "Must be a TrueType Collection font.");
      const q = U.getUint16(), Z = U.getUint16(), sA = U.getInt32() >>> 0, z = [];
      for (let M = 0; M < sA; M++)
        z.push(U.getInt32() >>> 0);
      const W = {
        ttcTag: J,
        majorVersion: q,
        minorVersion: Z,
        numFonts: sA,
        offsetTable: z
      };
      switch (q) {
        case 1:
          return W;
        case 2:
          return W.dsigTag = U.getInt32() >>> 0, W.dsigLength = U.getInt32() >>> 0, W.dsigOffset = U.getInt32() >>> 0, W;
      }
      throw new v(`Invalid TrueType Collection majorVersion: ${q}.`);
    }
    function o(U, J) {
      var W;
      const {
        numFonts: q,
        offsetTable: Z
      } = g(U), sA = J.split("+");
      let z;
      for (let M = 0; M < q; M++) {
        U.pos = (U.start || 0) + Z[M];
        const CA = r(U), EA = a(U, CA.numTables);
        if (!EA.name)
          throw new v('TrueType Collection font must contain a "name" table.');
        const [mA] = Q(EA.name);
        for (let QA = 0, uA = mA.length; QA < uA; QA++)
          for (let gA = 0, cA = mA[QA].length; gA < cA; gA++) {
            const wA = (W = mA[QA][gA]) == null ? void 0 : W.replaceAll(/\s/g, "");
            if (wA) {
              if (wA === J)
                return {
                  header: CA,
                  tables: EA
                };
              if (!(sA.length < 2))
                for (const rA of sA)
                  wA === rA && (z = {
                    name: rA,
                    header: CA,
                    tables: EA
                  });
            }
          }
      }
      if (z)
        return k(`TrueType Collection does not contain "${J}" font, falling back to "${z.name}" font instead.`), {
          header: z.header,
          tables: z.tables
        };
      throw new v(`TrueType Collection does not contain "${J}" font.`);
    }
    function I(U, J, q, Z) {
      if (!U)
        return k("No cmap table available."), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      let sA, z = (J.start || 0) + U.offset;
      J.pos = z, J.skip(2);
      const W = J.getUint16();
      let M, CA = !1;
      for (let cA = 0; cA < W; cA++) {
        const wA = J.getUint16(), rA = J.getUint16(), bA = J.getInt32() >>> 0;
        let NA = !1;
        if (!((M == null ? void 0 : M.platformId) === wA && (M == null ? void 0 : M.encodingId) === rA)) {
          if (wA === 0 && (rA === 0 || rA === 1 || rA === 3))
            NA = !0;
          else if (wA === 1 && rA === 0)
            NA = !0;
          else if (wA === 3 && rA === 1 && (Z || !M))
            NA = !0, q || (CA = !0);
          else if (q && wA === 3 && rA === 0) {
            NA = !0;
            let ue = !0;
            if (cA < W - 1) {
              const xA = J.peekBytes(2);
              ji(xA[0], xA[1]) < wA && (ue = !1);
            }
            ue && (CA = !0);
          }
          if (NA && (M = {
            platformId: wA,
            encodingId: rA,
            offset: bA
          }), CA)
            break;
        }
      }
      if (M && (J.pos = z + M.offset), !M || J.peekByte() === -1)
        return k("Could not find a preferred cmap table."), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      const EA = J.getUint16();
      let mA = !1;
      const QA = [];
      let uA, gA;
      if (EA === 0) {
        for (J.skip(4), uA = 0; uA < 256; uA++) {
          const cA = J.getByte();
          cA && QA.push({
            charCode: uA,
            glyphId: cA
          });
        }
        mA = !0;
      } else if (EA === 2) {
        J.skip(4);
        const cA = [];
        let wA = 0;
        for (let bA = 0; bA < 256; bA++) {
          const NA = J.getUint16() >> 3;
          cA.push(NA), wA = Math.max(NA, wA);
        }
        const rA = [];
        for (let bA = 0; bA <= wA; bA++)
          rA.push({
            firstCode: J.getUint16(),
            entryCount: J.getUint16(),
            idDelta: ft(J.getByte(), J.getByte()),
            idRangePos: J.pos + J.getUint16()
          });
        for (let bA = 0; bA < 256; bA++)
          if (cA[bA] === 0)
            J.pos = rA[0].idRangePos + 2 * bA, gA = J.getUint16(), QA.push({
              charCode: bA,
              glyphId: gA
            });
          else {
            const NA = rA[cA[bA]];
            for (uA = 0; uA < NA.entryCount; uA++) {
              const ue = (bA << 8) + uA + NA.firstCode;
              J.pos = NA.idRangePos + 2 * uA, gA = J.getUint16(), gA !== 0 && (gA = (gA + NA.idDelta) % 65536), QA.push({
                charCode: ue,
                glyphId: gA
              });
            }
          }
      } else if (EA === 4) {
        J.skip(4);
        const cA = J.getUint16() >> 1;
        J.skip(6);
        const wA = [];
        let rA;
        for (rA = 0; rA < cA; rA++)
          wA.push({
            end: J.getUint16()
          });
        for (J.skip(2), rA = 0; rA < cA; rA++)
          wA[rA].start = J.getUint16();
        for (rA = 0; rA < cA; rA++)
          wA[rA].delta = J.getUint16();
        let bA = 0, NA;
        for (rA = 0; rA < cA; rA++) {
          sA = wA[rA];
          const xA = J.getUint16();
          if (!xA) {
            sA.offsetIndex = -1;
            continue;
          }
          NA = (xA >> 1) - (cA - rA), sA.offsetIndex = NA, bA = Math.max(bA, NA + sA.end - sA.start + 1);
        }
        const ue = [];
        for (uA = 0; uA < bA; uA++)
          ue.push(J.getUint16());
        for (rA = 0; rA < cA; rA++) {
          sA = wA[rA], z = sA.start;
          const xA = sA.end, KA = sA.delta;
          for (NA = sA.offsetIndex, uA = z; uA <= xA; uA++)
            uA !== 65535 && (gA = NA < 0 ? uA : ue[NA + uA - z], gA = gA + KA & 65535, QA.push({
              charCode: uA,
              glyphId: gA
            }));
        }
      } else if (EA === 6) {
        J.skip(4);
        const cA = J.getUint16(), wA = J.getUint16();
        for (uA = 0; uA < wA; uA++) {
          gA = J.getUint16();
          const rA = cA + uA;
          QA.push({
            charCode: rA,
            glyphId: gA
          });
        }
      } else if (EA === 12) {
        J.skip(10);
        const cA = J.getInt32() >>> 0;
        for (uA = 0; uA < cA; uA++) {
          const wA = J.getInt32() >>> 0, rA = J.getInt32() >>> 0;
          let bA = J.getInt32() >>> 0;
          for (let NA = wA; NA <= rA; NA++)
            QA.push({
              charCode: NA,
              glyphId: bA++
            });
        }
      } else
        return k("cmap table has unsupported format: " + EA), {
          platformId: -1,
          encodingId: -1,
          mappings: [],
          hasShortCmap: !1
        };
      QA.sort(function(cA, wA) {
        return cA.charCode - wA.charCode;
      });
      for (let cA = 1; cA < QA.length; cA++)
        QA[cA - 1].charCode === QA[cA].charCode && (QA.splice(cA, 1), cA--);
      return {
        platformId: M.platformId,
        encodingId: M.encodingId,
        mappings: QA,
        hasShortCmap: mA
      };
    }
    function c(U, J, q, Z, sA, z) {
      if (!J) {
        q && (q.data = null);
        return;
      }
      U.pos = (U.start || 0) + J.offset, U.pos += 4, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2, U.pos += 2;
      const W = U.getUint16();
      U.pos += 8, U.pos += 2;
      let M = U.getUint16();
      W !== 0 && (ji(Z.data[44], Z.data[45]) & 2 || (J.data[22] = 0, J.data[23] = 0)), M > sA && (vA(`The numOfMetrics (${M}) should not be greater than the numGlyphs (${sA}).`), M = sA, J.data[34] = (M & 65280) >> 8, J.data[35] = M & 255);
      const EA = sA - M - (q.length - M * 4 >> 1);
      if (EA > 0) {
        const mA = new Uint8Array(q.length + EA * 2);
        mA.set(q.data), z && (mA[q.length] = q.data[2], mA[q.length + 1] = q.data[3]), q.data = mA;
      }
    }
    function l(U, J, q, Z, sA, z) {
      const W = {
        length: 0,
        sizeOfInstructions: 0
      };
      if (J < 0 || J >= U.length || q > U.length || q - J <= 12)
        return W;
      const M = U.subarray(J, q), CA = ft(M[2], M[3]), EA = ft(M[4], M[5]), mA = ft(M[6], M[7]), QA = ft(M[8], M[9]);
      CA > mA && (us(M, 2, mA), us(M, 6, CA)), EA > QA && (us(M, 4, QA), us(M, 8, EA));
      const uA = ft(M[0], M[1]);
      if (uA < 0)
        return uA < -1 || (Z.set(M, sA), W.length = M.length), W;
      let gA, cA = 10, wA = 0;
      for (gA = 0; gA < uA; gA++)
        wA = (M[cA] << 8 | M[cA + 1]) + 1, cA += 2;
      const rA = cA, bA = M[cA] << 8 | M[cA + 1];
      W.sizeOfInstructions = bA, cA += 2 + bA;
      const NA = cA;
      let ue = 0;
      for (gA = 0; gA < wA; gA++) {
        const KA = M[cA++];
        KA & 192 && (M[cA - 1] = KA & 63);
        let UA = 2;
        KA & 2 ? UA = 1 : KA & 16 && (UA = 0);
        let OA = 2;
        KA & 4 ? OA = 1 : KA & 32 && (OA = 0);
        const re = UA + OA;
        if (ue += re, KA & 8) {
          const Ve = M[cA++];
          Ve === 0 && (M[cA - 1] ^= 8), gA += Ve, ue += Ve * re;
        }
      }
      if (ue === 0)
        return W;
      let xA = cA + ue;
      return xA > M.length ? W : !z && bA > 0 ? (Z.set(M.subarray(0, rA), sA), Z.set([0, 0], sA + rA), Z.set(M.subarray(NA, xA), sA + rA + 2), xA -= bA, M.length - xA > 3 && (xA = xA + 3 & -4), W.length = xA, W) : M.length - xA > 3 ? (xA = xA + 3 & -4, Z.set(M.subarray(0, xA), sA), W.length = xA, W) : (Z.set(M, sA), W.length = M.length, W);
    }
    function h(U, J, q) {
      const Z = U.data, sA = EQ(Z[0], Z[1], Z[2], Z[3]);
      sA >> 16 !== 1 && (vA("Attempting to fix invalid version in head table: " + sA), Z[0] = 0, Z[1] = 1, Z[2] = 0, Z[3] = 0);
      const z = ji(Z[50], Z[51]);
      if (z < 0 || z > 1) {
        vA("Attempting to fix invalid indexToLocFormat in head table: " + z);
        const W = J + 1;
        if (q === W << 1)
          Z[50] = 0, Z[51] = 0;
        else if (q === W << 2)
          Z[50] = 0, Z[51] = 1;
        else
          throw new v("Could not fix indexToLocFormat: " + z);
      }
    }
    function C(U, J, q, Z, sA, z, W) {
      let M, CA, EA;
      Z ? (M = 4, CA = function(OA, re) {
        return OA[re] << 24 | OA[re + 1] << 16 | OA[re + 2] << 8 | OA[re + 3];
      }, EA = function(OA, re, Ve) {
        OA[re] = Ve >>> 24 & 255, OA[re + 1] = Ve >> 16 & 255, OA[re + 2] = Ve >> 8 & 255, OA[re + 3] = Ve & 255;
      }) : (M = 2, CA = function(OA, re) {
        return OA[re] << 9 | OA[re + 1] << 1;
      }, EA = function(OA, re, Ve) {
        OA[re] = Ve >> 9 & 255, OA[re + 1] = Ve >> 1 & 255;
      });
      const mA = z ? q + 1 : q, QA = M * (1 + mA), uA = new Uint8Array(QA);
      uA.set(U.data.subarray(0, QA)), U.data = uA;
      const gA = J.data, cA = gA.length, wA = new Uint8Array(cA);
      let rA, bA;
      const NA = [];
      for (rA = 0, bA = 0; rA < q + 1; rA++, bA += M) {
        let UA = CA(uA, bA);
        UA > cA && (UA = cA), NA.push({
          index: rA,
          offset: UA,
          endOffset: 0
        });
      }
      for (NA.sort((UA, OA) => UA.offset - OA.offset), rA = 0; rA < q; rA++)
        NA[rA].endOffset = NA[rA + 1].offset;
      for (NA.sort((UA, OA) => UA.index - OA.index), rA = 0; rA < q; rA++) {
        const {
          offset: UA,
          endOffset: OA
        } = NA[rA];
        if (UA !== 0 || OA !== 0)
          break;
        const re = NA[rA + 1].offset;
        if (re !== 0) {
          NA[rA].endOffset = re;
          break;
        }
      }
      const ue = NA.at(-2);
      ue.offset !== 0 && ue.endOffset === 0 && (ue.endOffset = cA);
      const xA = /* @__PURE__ */ Object.create(null);
      let KA = 0;
      for (EA(uA, 0, KA), rA = 0, bA = M; rA < q; rA++, bA += M) {
        const UA = l(gA, NA[rA].offset, NA[rA].endOffset, wA, KA, sA), OA = UA.length;
        OA === 0 && (xA[rA] = !0), UA.sizeOfInstructions > W && (W = UA.sizeOfInstructions), KA += OA, EA(uA, bA, KA);
      }
      if (KA === 0) {
        const UA = new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 0]);
        for (rA = 0, bA = M; rA < mA; rA++, bA += M)
          EA(uA, bA, UA.length);
        J.data = UA;
      } else if (z) {
        const UA = CA(uA, M);
        wA.length > UA + KA ? J.data = wA.subarray(0, UA + KA) : (J.data = new Uint8Array(UA + KA), J.data.set(wA.subarray(0, KA))), J.data.set(wA.subarray(0, UA), KA), EA(U.data, uA.length - M, KA + UA);
      } else
        J.data = wA.subarray(0, KA);
      return {
        missingGlyphs: xA,
        maxSizeOfInstructions: W
      };
    }
    function B(U, J, q) {
      const Z = (t.start || 0) + U.offset;
      t.pos = Z;
      const sA = U.length, z = Z + sA, W = t.getInt32();
      t.skip(28);
      let M, CA = !0, EA;
      switch (W) {
        case 65536:
          M = eI;
          break;
        case 131072:
          const mA = t.getUint16();
          if (mA !== q) {
            CA = !1;
            break;
          }
          const QA = [];
          for (EA = 0; EA < mA; ++EA) {
            const cA = t.getUint16();
            if (cA >= 32768) {
              CA = !1;
              break;
            }
            QA.push(cA);
          }
          if (!CA)
            break;
          const uA = [], gA = [];
          for (; t.pos < z; ) {
            const cA = t.getByte();
            for (gA.length = cA, EA = 0; EA < cA; ++EA)
              gA[EA] = String.fromCharCode(t.getByte());
            uA.push(gA.join(""));
          }
          for (M = [], EA = 0; EA < mA; ++EA) {
            const cA = QA[EA];
            if (cA < 258) {
              M.push(eI[cA]);
              continue;
            }
            M.push(uA[cA - 258]);
          }
          break;
        case 196608:
          break;
        default:
          k("Unknown/unsupported post table version " + W), CA = !1, J.defaultEncoding && (M = J.defaultEncoding);
          break;
      }
      return J.glyphNames = M, CA;
    }
    function Q(U) {
      const J = (t.start || 0) + U.offset;
      t.pos = J;
      const q = [[], []], Z = [], sA = U.length, z = J + sA;
      if (t.getUint16() !== 0 || sA < 6)
        return [q, Z];
      const CA = t.getUint16(), EA = t.getUint16(), mA = 12;
      let QA, uA;
      for (QA = 0; QA < CA && t.pos + mA <= z; QA++) {
        const gA = {
          platform: t.getUint16(),
          encoding: t.getUint16(),
          language: t.getUint16(),
          name: t.getUint16(),
          length: t.getUint16(),
          offset: t.getUint16()
        };
        (pQ(gA) || zc(gA)) && Z.push(gA);
      }
      for (QA = 0, uA = Z.length; QA < uA; QA++) {
        const gA = Z[QA];
        if (gA.length <= 0)
          continue;
        const cA = J + EA + gA.offset;
        if (cA + gA.length > z)
          continue;
        t.pos = cA;
        const wA = gA.name;
        if (gA.encoding) {
          let rA = "";
          for (let bA = 0, NA = gA.length; bA < NA; bA += 2)
            rA += String.fromCharCode(t.getUint16());
          q[1][wA] = rA;
        } else
          q[0][wA] = t.getString(gA.length);
      }
      return [q, Z];
    }
    const E = [0, 0, 0, 0, 0, 0, 0, 0, -2, -2, -2, -2, 0, 0, -2, -5, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, -1, -1, 1, -1, -999, 0, 1, 0, -1, -2, 0, -1, -2, -1, -1, 0, -1, -1, 0, 0, -999, -999, -1, -1, -1, -1, -2, -999, -2, -2, -999, 0, -2, -2, 0, 0, -2, 0, -2, 0, 0, 0, -2, -1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 0, -1, -1, 0, -999, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, -999, -999, -999, -999, -999, -1, -1, -2, -2, 0, 0, 0, 0, -1, -1, -999, -2, -2, 0, 0, -1, -2, -2, 0, 0, 0, -1, -1, -1, -2];
    function f(U, J) {
      let q = U.data, Z = 0, sA, z, W, M, CA, EA = 0, mA = 0;
      const QA = [], uA = [], gA = [];
      let cA = J.tooComplexToFollowFunctions, wA = !1, rA = 0, bA = 0;
      for (let ue = q.length; Z < ue; ) {
        const xA = q[Z++];
        if (xA === 64)
          if (z = q[Z++], wA || bA)
            Z += z;
          else
            for (sA = 0; sA < z; sA++)
              QA.push(q[Z++]);
        else if (xA === 65)
          if (z = q[Z++], wA || bA)
            Z += z * 2;
          else
            for (sA = 0; sA < z; sA++)
              W = q[Z++], QA.push(W << 8 | q[Z++]);
        else if ((xA & 248) === 176)
          if (z = xA - 176 + 1, wA || bA)
            Z += z;
          else
            for (sA = 0; sA < z; sA++)
              QA.push(q[Z++]);
        else if ((xA & 248) === 184)
          if (z = xA - 184 + 1, wA || bA)
            Z += z * 2;
          else
            for (sA = 0; sA < z; sA++)
              W = q[Z++], QA.push(ft(W, q[Z++]));
        else if (xA === 43 && !cA) {
          if (!wA && !bA) {
            if (M = QA.at(-1), isNaN(M))
              vA("TT: CALL empty stack (or invalid entry).");
            else if (J.functionsUsed[M] = !0, M in J.functionsStackDeltas) {
              const KA = QA.length + J.functionsStackDeltas[M];
              if (KA < 0) {
                k("TT: CALL invalid functions stack delta."), J.hintsValid = !1;
                return;
              }
              QA.length = KA;
            } else if (M in J.functionsDefined && !gA.includes(M)) {
              if (uA.push({
                data: q,
                i: Z,
                stackTop: QA.length - 1
              }), gA.push(M), CA = J.functionsDefined[M], !CA) {
                k("TT: CALL non-existent function"), J.hintsValid = !1;
                return;
              }
              q = CA.data, Z = CA.i;
            }
          }
        } else if (xA === 44 && !cA)
          (wA || bA) && (k("TT: nested FDEFs not allowed"), cA = !0), wA = !0, mA = Z, M = QA.pop(), J.functionsDefined[M] = {
            data: q,
            i: Z
          };
        else if (xA === 45)
          if (wA)
            wA = !1, EA = Z;
          else {
            if (CA = uA.pop(), !CA) {
              k("TT: ENDF bad stack"), J.hintsValid = !1;
              return;
            }
            M = gA.pop(), q = CA.data, Z = CA.i, J.functionsStackDeltas[M] = QA.length - CA.stackTop;
          }
        else if (xA === 137)
          (wA || bA) && (k("TT: nested IDEFs not allowed"), cA = !0), wA = !0, mA = Z;
        else if (xA === 88)
          ++rA;
        else if (xA === 27)
          bA = rA;
        else if (xA === 89)
          bA === rA && (bA = 0), --rA;
        else if (xA === 28 && !wA && !bA) {
          const KA = QA.at(-1);
          KA > 0 && (Z += KA - 1);
        }
        if (!wA && !bA) {
          let KA = 0;
          for (xA <= 142 ? KA = E[xA] : xA >= 192 && xA <= 223 ? KA = -1 : xA >= 224 && (KA = -2), xA >= 113 && xA <= 117 && (z = QA.pop(), isNaN(z) || (KA = -z * 2)); KA < 0 && QA.length > 0; )
            QA.pop(), KA++;
          for (; KA > 0; )
            QA.push(NaN), KA--;
        }
      }
      J.tooComplexToFollowFunctions = cA;
      const NA = [q];
      Z > q.length && NA.push(new Uint8Array(Z - q.length)), mA > EA && (k("TT: complementing a missing function tail"), NA.push(new Uint8Array([34, 45]))), u(U, NA);
    }
    function d(U, J) {
      if (!U.tooComplexToFollowFunctions) {
        if (U.functionsDefined.length > J) {
          k("TT: more functions defined than expected"), U.hintsValid = !1;
          return;
        }
        for (let q = 0, Z = U.functionsUsed.length; q < Z; q++) {
          if (q > J) {
            k("TT: invalid function id: " + q), U.hintsValid = !1;
            return;
          }
          if (U.functionsUsed[q] && !U.functionsDefined[q]) {
            k("TT: undefined function: " + q), U.hintsValid = !1;
            return;
          }
        }
      }
    }
    function u(U, J) {
      if (J.length > 1) {
        let q = 0, Z, sA;
        for (Z = 0, sA = J.length; Z < sA; Z++)
          q += J[Z].length;
        q = q + 3 & -4;
        const z = new Uint8Array(q);
        let W = 0;
        for (Z = 0, sA = J.length; Z < sA; Z++)
          z.set(J[Z], W), W += J[Z].length;
        U.data = z, U.length = q;
      }
    }
    function x(U, J, q, Z) {
      const sA = {
        functionsDefined: [],
        functionsUsed: [],
        functionsStackDeltas: [],
        tooComplexToFollowFunctions: !1,
        hintsValid: !0
      };
      if (U && f(U, sA), J && f(J, sA), U && d(sA, Z), q && q.length & 1) {
        const z = new Uint8Array(q.length + 1);
        z.set(q.data), q.data = z;
      }
      return sA.hintsValid;
    }
    t = new Qe(new Uint8Array(t.getBytes()));
    let m, p;
    if (_c(t)) {
      const U = o(t, this.name);
      m = U.header, p = U.tables;
    } else
      m = r(t), p = a(t, m.numTables);
    let D, F;
    const y = !p["CFF "];
    if (y) {
      if (!p.loca)
        throw new v('Required "loca" table is not found');
      p.glyf || (k('Required "glyf" table is not found -- trying to recover.'), p.glyf = {
        tag: "glyf",
        data: new Uint8Array(0)
      }), this.isOpenType = !1;
    } else {
      const U = i.composite && (((X = i.cidToGidMap) == null ? void 0 : X.length) > 0 || !(i.cMap instanceof O0));
      if (m.version === "OTTO" && !U || !p.head || !p.hhea || !p.maxp || !p.post)
        return F = new Qe(p["CFF "].data), D = new br(F, i), Sr(i), this.convert(A, D, i);
      delete p.glyf, delete p.loca, delete p.fpgm, delete p.prep, delete p["cvt "], this.isOpenType = !0;
    }
    if (!p.maxp)
      throw new v('Required "maxp" table is not found');
    t.pos = (t.start || 0) + p.maxp.offset;
    let H = t.getInt32();
    const N = t.getUint16();
    if (H !== 65536 && H !== 20480) {
      if (p.maxp.length === 6)
        H = 20480;
      else if (p.maxp.length >= 32)
        H = 65536;
      else
        throw new v('"maxp" table has a wrong version number');
      QQ(p.maxp.data, 0, H);
    }
    if (((qA = i.scaleFactors) == null ? void 0 : qA.length) === N && y) {
      const {
        scaleFactors: U
      } = i, J = ji(p.head.data[50], p.head.data[51]), q = new tQ({
        glyfTable: p.glyf.data,
        isGlyphLocationsLong: J,
        locaTable: p.loca.data,
        numGlyphs: N
      });
      q.scale(U);
      const {
        glyf: Z,
        loca: sA,
        isLocationLong: z
      } = q.write();
      p.glyf.data = Z, p.loca.data = sA, z !== !!J && (p.head.data[50] = 0, p.head.data[51] = z ? 1 : 0);
      const W = p.hmtx.data;
      for (let M = 0; M < N; M++) {
        const CA = 4 * M, EA = Math.round(U[M] * ji(W[CA], W[CA + 1]));
        W[CA] = EA >> 8 & 255, W[CA + 1] = EA & 255;
        const mA = Math.round(U[M] * ft(W[CA + 2], W[CA + 3]));
        us(W, CA + 2, mA);
      }
    }
    let T = N + 1, _ = !0;
    T > 65535 && (_ = !1, T = N, k("Not enough space in glyfs to duplicate first glyph."));
    let oA = 0, G = 0;
    H >= 65536 && p.maxp.length >= 32 && (t.pos += 8, t.getUint16() > 2 && (p.maxp.data[14] = 0, p.maxp.data[15] = 2), t.pos += 4, oA = t.getUint16(), t.pos += 4, G = t.getUint16()), p.maxp.data[4] = T >> 8, p.maxp.data[5] = T & 255;
    const S = x(p.fpgm, p.prep, p["cvt "], oA);
    if (S || (delete p.fpgm, delete p.prep, delete p["cvt "]), c(t, p.hhea, p.hmtx, p.head, T, _), !p.head)
      throw new v('Required "head" table is not found');
    h(p.head, N, y ? p.loca.length : 0);
    let tA = /* @__PURE__ */ Object.create(null);
    if (y) {
      const U = ji(p.head.data[50], p.head.data[51]), J = C(p.loca, p.glyf, N, U, S, _, G);
      tA = J.missingGlyphs, H >= 65536 && p.maxp.length >= 32 && (p.maxp.data[26] = J.maxSizeOfInstructions >> 8, p.maxp.data[27] = J.maxSizeOfInstructions & 255);
    }
    if (!p.hhea)
      throw new v('Required "hhea" table is not found');
    p.hhea.data[10] === 0 && p.hhea.data[11] === 0 && (p.hhea.data[10] = 255, p.hhea.data[11] = 255);
    const $ = {
      unitsPerEm: ji(p.head.data[18], p.head.data[19]),
      yMax: ft(p.head.data[42], p.head.data[43]),
      yMin: ft(p.head.data[38], p.head.data[39]),
      ascent: ft(p.hhea.data[4], p.hhea.data[5]),
      descent: ft(p.hhea.data[6], p.hhea.data[7]),
      lineGap: ft(p.hhea.data[8], p.hhea.data[9])
    };
    this.ascent = $.ascent / $.unitsPerEm, this.descent = $.descent / $.unitsPerEm, this.lineGap = $.lineGap / $.unitsPerEm, (IA = this.cssFontInfo) != null && IA.lineHeight ? (this.lineHeight = this.cssFontInfo.metrics.lineHeight, this.lineGap = this.cssFontInfo.metrics.lineGap) : this.lineHeight = this.ascent - this.descent + this.lineGap, p.post && B(p.post, i, N), p.post = {
      tag: "post",
      data: dI(i)
    };
    const hA = /* @__PURE__ */ Object.create(null);
    function yA(U) {
      return !tA[U];
    }
    if (i.composite) {
      const U = i.cidToGidMap || [], J = U.length === 0;
      i.cMap.forEach(function(q, Z) {
        if (typeof Z == "string" && (Z = Rr(q, Z, !0)), Z > 65535)
          throw new v("Max size of CID is 65,535");
        let sA = -1;
        J ? sA = Z : U[Z] !== void 0 && (sA = U[Z]), sA >= 0 && sA < N && yA(sA) && (hA[q] = sA);
      });
    } else {
      const U = I(p.cmap, t, this.isSymbolicFont, i.hasEncoding), J = U.platformId, q = U.encodingId, Z = U.mappings;
      let sA = [], z = !1;
      if (i.hasEncoding && (i.baseEncodingName === "MacRomanEncoding" || i.baseEncodingName === "WinAnsiEncoding") && (sA = Xs(i.baseEncodingName)), i.hasEncoding && !this.isSymbolicFont && (J === 3 && q === 1 || J === 1 && q === 0)) {
        const W = ti();
        for (let M = 0; M < 256; M++) {
          let CA;
          if (this.differences[M] !== void 0 ? CA = this.differences[M] : sA.length && sA[M] !== "" ? CA = sA[M] : CA = Ei[M], !CA)
            continue;
          const EA = Oc(CA, W);
          let mA;
          if (J === 3 && q === 1 ? mA = W[EA] : J === 1 && q === 0 && (mA = Vg.indexOf(EA)), mA === void 0) {
            if (!i.glyphNames && i.hasIncludedToUnicodeMap && !(this.toUnicode instanceof Rt)) {
              const QA = this.toUnicode.get(M);
              QA && (mA = QA.codePointAt(0));
            }
            if (mA === void 0)
              continue;
          }
          for (const QA of Z)
            if (QA.charCode === mA) {
              hA[M] = QA.glyphId;
              break;
            }
        }
      } else if (J === 0) {
        for (const W of Z)
          hA[W.charCode] = W.glyphId;
        z = !0;
      } else if (J === 3 && q === 0)
        for (const W of Z) {
          let M = W.charCode;
          M >= 61440 && M <= 61695 && (M &= 255), hA[M] = W.glyphId;
        }
      else
        for (const W of Z)
          hA[W.charCode] = W.glyphId;
      if (i.glyphNames && (sA.length || this.differences.length))
        for (let W = 0; W < 256; ++W) {
          if (!z && hA[W] !== void 0)
            continue;
          const M = this.differences[W] || sA[W];
          if (!M)
            continue;
          const CA = i.glyphNames.indexOf(M);
          CA > 0 && yA(CA) && (hA[W] = CA);
        }
    }
    hA.length === 0 && (hA[0] = 0);
    let pA = T - 1;
    if (_ || (pA = 0), !i.cssFontInfo) {
      const U = EI(hA, yA, pA, this.toUnicode);
      this.toFontChar = U.toFontChar, p.cmap = {
        tag: "cmap",
        data: fI(U.charCodeToGlyphId, U.toUnicodeExtraMap, T)
      }, (!p["OS/2"] || !wQ(p["OS/2"], t)) && (p["OS/2"] = {
        tag: "OS/2",
        data: uI(i, U.charCodeToGlyphId, $)
      });
    }
    if (!y)
      try {
        F = new Qe(p["CFF "].data), D = new Xg(F, i, V0).parse(), D.duplicateFirstGlyph();
        const J = new ya(D);
        p["CFF "].data = J.compile();
      } catch {
        k("Failed to compile font " + i.loadedName);
      }
    if (!p.name)
      p.name = {
        tag: "name",
        data: Gr(this.name)
      };
    else {
      const [U, J] = Q(p.name);
      p.name.data = Gr(A, U), this.psName = U[0][6] || null, i.composite || hQ(i, this.isSymbolicFont, J);
    }
    const DA = new Aa(m.version);
    for (const U in p)
      DA.addTable(U, p[U].data);
    return DA.toArray();
  }
  convert(A, t, i) {
    i.fixedPitch = !1, i.builtInEncoding && CQ(i, i.builtInEncoding);
    let s = 1;
    t instanceof br && (s = t.numGlyphs - 1);
    const a = t.getGlyphMapping(i);
    let n = null, r = a, g = null;
    i.cssFontInfo || (n = EI(a, t.hasGlyphId.bind(t), s, this.toUnicode), this.toFontChar = n.toFontChar, r = n.charCodeToGlyphId, g = n.toUnicodeExtraMap);
    const o = t.numGlyphs;
    function I(B, Q) {
      let E = null;
      for (const f in B)
        Q === B[f] && (E || (E = [])).push(f | 0);
      return E;
    }
    function c(B, Q) {
      for (const E in B)
        if (Q === B[E])
          return E | 0;
      return n.charCodeToGlyphId[n.nextAvailableFontCharCode] = Q, n.nextAvailableFontCharCode++;
    }
    const l = t.seacs;
    if (n && V0 && (l != null && l.length)) {
      const B = i.fontMatrix || o0, Q = t.getCharset(), E = /* @__PURE__ */ Object.create(null);
      for (let f in l) {
        f |= 0;
        const d = l[f], u = Ei[d[2]], x = Ei[d[3]], m = Q.indexOf(u), p = Q.indexOf(x);
        if (m < 0 || p < 0)
          continue;
        const D = {
          x: d[0] * B[0] + d[1] * B[2] + B[4],
          y: d[0] * B[1] + d[1] * B[3] + B[5]
        }, F = I(a, f);
        if (F)
          for (const y of F) {
            const H = n.charCodeToGlyphId, N = c(H, m), T = c(H, p);
            E[y] = {
              baseFontCharCode: N,
              accentFontCharCode: T,
              accentOffset: D
            };
          }
      }
      i.seacMap = E;
    }
    const h = i.fontMatrix ? 1 / Math.max(...i.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, C = new Aa("OTTO");
    return C.addTable("CFF ", t.data), C.addTable("OS/2", uI(i, r)), C.addTable("cmap", fI(r, g, o)), C.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<õ\0\0" + Xi(h) + "\0\0\0\0\v~'\0\0\0\0\v~'\0\0" + Xi(i.descent) + "ÿ" + Xi(i.ascent) + Ae(i.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0"), C.addTable("hhea", "\0\0\0" + Xi(i.ascent) + Xi(i.descent) + "\0\0ÿÿ\0\0\0\0\0\0" + Xi(i.capHeight) + Xi(Math.tan(i.italicAngle) * i.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + Ae(o)), C.addTable("hmtx", function() {
      const Q = t.charstrings, E = t.cff ? t.cff.widths : null;
      let f = "\0\0\0\0";
      for (let d = 1, u = o; d < u; d++) {
        let x = 0;
        if (Q) {
          const m = Q[d - 1];
          x = "width" in m ? m.width : 0;
        } else E && (x = Math.ceil(E[d] || 0));
        f += Ae(x) + Ae(0);
      }
      return f;
    }()), C.addTable("maxp", "\0\0P\0" + Ae(o)), C.addTable("name", Gr(A)), C.addTable("post", dI(i)), C.toArray();
  }
  get _spaceWidth() {
    const A = ["space", "minus", "one", "i", "I"];
    let t;
    for (const i of A) {
      if (i in this.widths) {
        t = this.widths[i];
        break;
      }
      const a = ti()[i];
      let n = 0;
      if (this.composite && this.cMap.contains(a) && (n = this.cMap.lookup(a), typeof n == "string" && (n = Rr(a, n))), !n && this.toUnicode && (n = this.toUnicode.charCodeOf(a)), n <= 0 && (n = a), t = this.widths[n], t)
        break;
    }
    return iA(this, "_spaceWidth", t || this.defaultWidth);
  }
  _charToGlyph(A, t = !1) {
    var h, C, B;
    let i = this._glyphCache[A];
    if ((i == null ? void 0 : i.isSpace) === t)
      return i;
    let s, a, n, r = A;
    (h = this.cMap) != null && h.contains(A) && (r = this.cMap.lookup(A), typeof r == "string" && (r = Rr(A, r))), a = this.widths[r], typeof a != "number" && (a = this.defaultWidth);
    const g = (C = this.vmetrics) == null ? void 0 : C[r];
    let o = this.toUnicode.get(A) || A;
    typeof o == "number" && (o = String.fromCharCode(o));
    let I = this.toFontChar[A] !== void 0;
    if (s = this.toFontChar[A] || A, this.missingFile) {
      const Q = this.differences[A] || this.defaultEncoding[A];
      (Q === ".notdef" || Q === "") && this.type === "Type1" && (s = 32, Q === "" && (a || (a = this._spaceWidth), o = String.fromCharCode(s))), s = GB(s);
    }
    this.isType3Font && (n = s);
    let c = null;
    if ((B = this.seacMap) != null && B[A]) {
      I = !0;
      const Q = this.seacMap[A];
      s = Q.baseFontCharCode, c = {
        fontChar: String.fromCodePoint(Q.accentFontCharCode),
        offset: Q.accentOffset
      };
    }
    let l = "";
    if (typeof s == "number" && (s <= 1114111 ? l = String.fromCodePoint(s) : k(`charToGlyph - invalid fontCharCode: ${s}`)), this.missingFile && this.vertical && l.length === 1) {
      const Q = HB()[l.charCodeAt(0)];
      Q && (l = o = String.fromCharCode(Q));
    }
    return i = new BQ(A, l, o, c, a, g, n, t, I), this._glyphCache[A] = i;
  }
  charsToGlyphs(A) {
    let t = this._charsCache[A];
    if (t)
      return t;
    if (t = [], this.cMap) {
      const i = /* @__PURE__ */ Object.create(null), s = A.length;
      let a = 0;
      for (; a < s; ) {
        this.cMap.readCharCode(A, a, i);
        const {
          charcode: n,
          length: r
        } = i;
        a += r;
        const g = this._charToGlyph(n, r === 1 && A.charCodeAt(a - 1) === 32);
        t.push(g);
      }
    } else
      for (let i = 0, s = A.length; i < s; ++i) {
        const a = A.charCodeAt(i), n = this._charToGlyph(a, a === 32);
        t.push(n);
      }
    return this._charsCache[A] = t;
  }
  getCharPositions(A) {
    const t = [];
    if (this.cMap) {
      const i = /* @__PURE__ */ Object.create(null);
      let s = 0;
      for (; s < A.length; ) {
        this.cMap.readCharCode(A, s, i);
        const a = i.length;
        t.push([s, s + a]), s += a;
      }
    } else
      for (let i = 0, s = A.length; i < s; ++i)
        t.push([i, i + 1]);
    return t;
  }
  get glyphCacheValues() {
    return Object.values(this._glyphCache);
  }
  encodeString(A) {
    const t = [], i = [], s = () => t.length % 2 === 1, a = this.toUnicode instanceof Rt ? (n) => this.toUnicode.charCodeOf(n) : (n) => this.toUnicode.charCodeOf(String.fromCodePoint(n));
    for (let n = 0, r = A.length; n < r; n++) {
      const g = A.codePointAt(n);
      if (g > 55295 && (g < 57344 || g > 65533) && n++, this.toUnicode) {
        const o = a(g);
        if (o !== -1) {
          s() && (t.push(i.join("")), i.length = 0);
          const I = this.cMap ? this.cMap.getCharCodeLength(o) : 1;
          for (let c = I - 1; c >= 0; c--)
            i.push(String.fromCharCode(o >> 8 * c & 255));
          continue;
        }
      }
      s() || (t.push(i.join("")), i.length = 0), i.push(String.fromCodePoint(g));
    }
    return t.push(i.join("")), t;
  }
}
class Nr {
  constructor(A) {
    this.error = A, this.loadedName = "g_font_error", this.missingFile = !0;
  }
  charsToGlyphs() {
    return [];
  }
  encodeString(A) {
    return [A];
  }
  exportData(A = !1) {
    return {
      error: this.error
    };
  }
}
const st = {
  FUNCTION_BASED: 1,
  AXIAL: 2,
  RADIAL: 3,
  FREE_FORM_MESH: 4,
  LATTICE_FORM_MESH: 5,
  COONS_PATCH_MESH: 6,
  TENSOR_PATCH_MESH: 7
};
class DQ {
  constructor() {
    WA("Cannot initialize Pattern.");
  }
  static parseShading(A, t, i, s, a) {
    const n = A instanceof JA ? A.dict : A, r = n.get("ShadingType");
    try {
      switch (r) {
        case st.AXIAL:
        case st.RADIAL:
          return new kQ(n, t, i, s, a);
        case st.FREE_FORM_MESH:
        case st.LATTICE_FORM_MESH:
        case st.COONS_PATCH_MESH:
        case st.TENSOR_PATCH_MESH:
          return new Eg(A, t, i, s, a);
        default:
          throw new v("Unsupported ShadingType: " + r);
      }
    } catch (g) {
      if (g instanceof oe)
        throw g;
      return k(g), new GQ();
    }
  }
}
class Z0 {
  getIR() {
    WA("Abstract method `getIR` called.");
  }
}
Me(Z0, "SMALL_NUMBER", 1e-6);
class kQ extends Z0 {
  constructor(A, t, i, s, a) {
    super(), this.shadingType = A.get("ShadingType");
    let n = 0;
    if (this.shadingType === st.AXIAL ? n = 4 : this.shadingType === st.RADIAL && (n = 6), this.coordsArr = A.getArray("Coords"), !at(this.coordsArr, n))
      throw new v("RadialAxialShading: Invalid /Coords array.");
    const r = LA.parse({
      cs: A.getRaw("CS") || A.getRaw("ColorSpace"),
      xref: t,
      resources: i,
      pdfFunctionFactory: s,
      localColorSpaceCache: a
    });
    this.bbox = ii(A.getArray("BBox"), null);
    let g = 0, o = 1;
    const I = A.getArray("Domain");
    at(I, 2) && ([g, o] = I);
    let c = !1, l = !1;
    const h = A.getArray("Extend");
    if (zh(h, 2) && ([c, l] = h), this.shadingType === st.RADIAL && (!c || !l)) {
      const [$, hA, yA, pA, DA, X] = this.coordsArr, qA = Math.hypot($ - pA, hA - DA);
      yA <= X + qA && X <= yA + qA && k("Unsupported radial gradient.");
    }
    this.extendStart = c, this.extendEnd = l;
    const C = A.getRaw("Function"), B = s.createFromArray(C), Q = 840, E = (o - g) / Q, f = this.colorStops = [];
    if (g >= o || E <= 0) {
      vA("Bad shading domain.");
      return;
    }
    const d = new Float32Array(r.numComps), u = new Float32Array(1);
    let x, m = 0;
    u[0] = g, B(u, 0, d, 0);
    let p = r.getRgb(d, 0);
    const D = de.makeHexColor(p[0], p[1], p[2]);
    f.push([0, D]);
    let F = 1;
    u[0] = g + E, B(u, 0, d, 0);
    let y = r.getRgb(d, 0), H = y[0] - p[0] + 1, N = y[1] - p[1] + 1, T = y[2] - p[2] + 1, _ = y[0] - p[0] - 1, oA = y[1] - p[1] - 1, G = y[2] - p[2] - 1;
    for (let $ = 2; $ < Q; $++) {
      u[0] = g + $ * E, B(u, 0, d, 0), x = r.getRgb(d, 0);
      const hA = $ - m;
      if (H = Math.min(H, (x[0] - p[0] + 1) / hA), N = Math.min(N, (x[1] - p[1] + 1) / hA), T = Math.min(T, (x[2] - p[2] + 1) / hA), _ = Math.max(_, (x[0] - p[0] - 1) / hA), oA = Math.max(oA, (x[1] - p[1] - 1) / hA), G = Math.max(G, (x[2] - p[2] - 1) / hA), !(_ <= H && oA <= N && G <= T)) {
        const pA = de.makeHexColor(y[0], y[1], y[2]);
        f.push([F / Q, pA]), H = x[0] - y[0] + 1, N = x[1] - y[1] + 1, T = x[2] - y[2] + 1, _ = x[0] - y[0] - 1, oA = x[1] - y[1] - 1, G = x[2] - y[2] - 1, m = F, p = y;
      }
      F = $, y = x;
    }
    const S = de.makeHexColor(y[0], y[1], y[2]);
    f.push([1, S]);
    let tA = "transparent";
    A.has("Background") && (x = r.getRgb(A.get("Background"), 0), tA = de.makeHexColor(x[0], x[1], x[2])), c || (f.unshift([0, tA]), f[1][0] += Z0.SMALL_NUMBER), l || (f.at(-1)[0] -= Z0.SMALL_NUMBER, f.push([1, tA])), this.colorStops = f;
  }
  getIR() {
    const {
      coordsArr: A,
      shadingType: t
    } = this;
    let i, s, a, n, r;
    return t === st.AXIAL ? (s = [A[0], A[1]], a = [A[2], A[3]], n = null, r = null, i = "axial") : t === st.RADIAL ? (s = [A[0], A[1]], a = [A[3], A[4]], n = A[2], r = A[5], i = "radial") : WA(`getPattern type unknown: ${t}`), ["RadialAxial", i, this.bbox, this.colorStops, s, a, n, r];
  }
}
class SQ {
  constructor(A, t) {
    this.stream = A, this.context = t, this.buffer = 0, this.bufferLength = 0;
    const i = t.numComps;
    this.tmpCompsBuf = new Float32Array(i);
    const s = t.colorSpace.numComps;
    this.tmpCsCompsBuf = t.colorFn ? new Float32Array(s) : this.tmpCompsBuf;
  }
  get hasData() {
    if (this.stream.end)
      return this.stream.pos < this.stream.end;
    if (this.bufferLength > 0)
      return !0;
    const A = this.stream.getByte();
    return A < 0 ? !1 : (this.buffer = A, this.bufferLength = 8, !0);
  }
  readBits(A) {
    let t = this.buffer, i = this.bufferLength;
    if (A === 32) {
      if (i === 0)
        return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
      t = t << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
      const s = this.stream.getByte();
      return this.buffer = s & (1 << i) - 1, (t << 8 - i | (s & 255) >> i) >>> 0;
    }
    if (A === 8 && i === 0)
      return this.stream.getByte();
    for (; i < A; )
      t = t << 8 | this.stream.getByte(), i += 8;
    return i -= A, this.bufferLength = i, this.buffer = t & (1 << i) - 1, t >> i;
  }
  align() {
    this.buffer = 0, this.bufferLength = 0;
  }
  readFlag() {
    return this.readBits(this.context.bitsPerFlag);
  }
  readCoordinate() {
    const A = this.context.bitsPerCoordinate, t = this.readBits(A), i = this.readBits(A), s = this.context.decode, a = A < 32 ? 1 / ((1 << A) - 1) : 23283064365386963e-26;
    return [t * a * (s[1] - s[0]) + s[0], i * a * (s[3] - s[2]) + s[2]];
  }
  readComponents() {
    const A = this.context.numComps, t = this.context.bitsPerComponent, i = t < 32 ? 1 / ((1 << t) - 1) : 23283064365386963e-26, s = this.context.decode, a = this.tmpCompsBuf;
    for (let r = 0, g = 4; r < A; r++, g += 2) {
      const o = this.readBits(t);
      a[r] = o * i * (s[g + 1] - s[g]) + s[g];
    }
    const n = this.tmpCsCompsBuf;
    return this.context.colorFn && this.context.colorFn(a, 0, n, 0), this.context.colorSpace.getRgb(n, 0);
  }
}
let Bn = /* @__PURE__ */ Object.create(null);
function FQ(e) {
  const A = [];
  for (let t = 0; t <= e; t++) {
    const i = t / e, s = 1 - i;
    A.push(new Float32Array([s ** 3, 3 * i * s ** 2, 3 * i ** 2 * s, i ** 3]));
  }
  return A;
}
function mI(e) {
  return Bn[e] || (Bn[e] = FQ(e));
}
function RQ() {
  Bn = /* @__PURE__ */ Object.create(null);
}
const Yt = class Yt extends Z0 {
  constructor(A, t, i, s, a) {
    if (super(), !(A instanceof JA))
      throw new v("Mesh data is not a stream");
    const n = A.dict;
    this.shadingType = n.get("ShadingType"), this.bbox = ii(n.getArray("BBox"), null);
    const r = LA.parse({
      cs: n.getRaw("CS") || n.getRaw("ColorSpace"),
      xref: t,
      resources: i,
      pdfFunctionFactory: s,
      localColorSpaceCache: a
    });
    this.background = n.has("Background") ? r.getRgb(n.get("Background"), 0) : null;
    const g = n.getRaw("Function"), o = g ? s.createFromArray(g) : null;
    this.coords = [], this.colors = [], this.figures = [];
    const I = {
      bitsPerCoordinate: n.get("BitsPerCoordinate"),
      bitsPerComponent: n.get("BitsPerComponent"),
      bitsPerFlag: n.get("BitsPerFlag"),
      decode: n.getArray("Decode"),
      colorFn: o,
      colorSpace: r,
      numComps: o ? 1 : r.numComps
    }, c = new SQ(A, I);
    let l = !1;
    switch (this.shadingType) {
      case st.FREE_FORM_MESH:
        this._decodeType4Shading(c);
        break;
      case st.LATTICE_FORM_MESH:
        const h = n.get("VerticesPerRow") | 0;
        if (h < 2)
          throw new v("Invalid VerticesPerRow");
        this._decodeType5Shading(c, h);
        break;
      case st.COONS_PATCH_MESH:
        this._decodeType6Shading(c), l = !0;
        break;
      case st.TENSOR_PATCH_MESH:
        this._decodeType7Shading(c), l = !0;
        break;
      default:
        WA("Unsupported mesh type.");
        break;
    }
    if (l) {
      this._updateBounds();
      for (let h = 0, C = this.figures.length; h < C; h++)
        this._buildFigureFromPatch(h);
    }
    this._updateBounds(), this._packData();
  }
  _decodeType4Shading(A) {
    const t = this.coords, i = this.colors, s = [];
    let a = 0;
    for (; A.hasData; ) {
      const n = A.readFlag(), r = A.readCoordinate(), g = A.readComponents();
      if (a === 0) {
        if (!(0 <= n && n <= 2))
          throw new v("Unknown type4 flag");
        switch (n) {
          case 0:
            a = 3;
            break;
          case 1:
            s.push(s.at(-2), s.at(-1)), a = 1;
            break;
          case 2:
            s.push(s.at(-3), s.at(-1)), a = 1;
            break;
        }
      }
      s.push(t.length), t.push(r), i.push(g), a--, A.align();
    }
    this.figures.push({
      type: "triangles",
      coords: new Int32Array(s),
      colors: new Int32Array(s)
    });
  }
  _decodeType5Shading(A, t) {
    const i = this.coords, s = this.colors, a = [];
    for (; A.hasData; ) {
      const n = A.readCoordinate(), r = A.readComponents();
      a.push(i.length), i.push(n), s.push(r);
    }
    this.figures.push({
      type: "lattice",
      coords: new Int32Array(a),
      colors: new Int32Array(a),
      verticesPerRow: t
    });
  }
  _decodeType6Shading(A) {
    const t = this.coords, i = this.colors, s = new Int32Array(16), a = new Int32Array(4);
    for (; A.hasData; ) {
      const n = A.readFlag();
      if (!(0 <= n && n <= 3))
        throw new v("Unknown type6 flag");
      const r = t.length;
      for (let h = 0, C = n !== 0 ? 8 : 12; h < C; h++)
        t.push(A.readCoordinate());
      const g = i.length;
      for (let h = 0, C = n !== 0 ? 2 : 4; h < C; h++)
        i.push(A.readComponents());
      let o, I, c, l;
      switch (n) {
        case 0:
          s[12] = r + 3, s[13] = r + 4, s[14] = r + 5, s[15] = r + 6, s[8] = r + 2, s[11] = r + 7, s[4] = r + 1, s[7] = r + 8, s[0] = r, s[1] = r + 11, s[2] = r + 10, s[3] = r + 9, a[2] = g + 1, a[3] = g + 2, a[0] = g, a[1] = g + 3;
          break;
        case 1:
          o = s[12], I = s[13], c = s[14], l = s[15], s[12] = l, s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = c, s[11] = r + 3, s[4] = I, s[7] = r + 4, s[0] = o, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, o = a[2], I = a[3], a[2] = I, a[3] = g, a[0] = o, a[1] = g + 1;
          break;
        case 2:
          o = s[15], I = s[11], s[12] = s[3], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[7], s[11] = r + 3, s[4] = I, s[7] = r + 4, s[0] = o, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, o = a[3], a[2] = a[1], a[3] = g, a[0] = o, a[1] = g + 1;
          break;
        case 3:
          s[12] = s[0], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[1], s[11] = r + 3, s[4] = s[2], s[7] = r + 4, s[0] = s[3], s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, a[2] = a[0], a[3] = g, a[0] = a[1], a[1] = g + 1;
          break;
      }
      s[5] = t.length, t.push([(-4 * t[s[0]][0] - t[s[15]][0] + 6 * (t[s[4]][0] + t[s[1]][0]) - 2 * (t[s[12]][0] + t[s[3]][0]) + 3 * (t[s[13]][0] + t[s[7]][0])) / 9, (-4 * t[s[0]][1] - t[s[15]][1] + 6 * (t[s[4]][1] + t[s[1]][1]) - 2 * (t[s[12]][1] + t[s[3]][1]) + 3 * (t[s[13]][1] + t[s[7]][1])) / 9]), s[6] = t.length, t.push([(-4 * t[s[3]][0] - t[s[12]][0] + 6 * (t[s[2]][0] + t[s[7]][0]) - 2 * (t[s[0]][0] + t[s[15]][0]) + 3 * (t[s[4]][0] + t[s[14]][0])) / 9, (-4 * t[s[3]][1] - t[s[12]][1] + 6 * (t[s[2]][1] + t[s[7]][1]) - 2 * (t[s[0]][1] + t[s[15]][1]) + 3 * (t[s[4]][1] + t[s[14]][1])) / 9]), s[9] = t.length, t.push([(-4 * t[s[12]][0] - t[s[3]][0] + 6 * (t[s[8]][0] + t[s[13]][0]) - 2 * (t[s[0]][0] + t[s[15]][0]) + 3 * (t[s[11]][0] + t[s[1]][0])) / 9, (-4 * t[s[12]][1] - t[s[3]][1] + 6 * (t[s[8]][1] + t[s[13]][1]) - 2 * (t[s[0]][1] + t[s[15]][1]) + 3 * (t[s[11]][1] + t[s[1]][1])) / 9]), s[10] = t.length, t.push([(-4 * t[s[15]][0] - t[s[0]][0] + 6 * (t[s[11]][0] + t[s[14]][0]) - 2 * (t[s[12]][0] + t[s[3]][0]) + 3 * (t[s[2]][0] + t[s[8]][0])) / 9, (-4 * t[s[15]][1] - t[s[0]][1] + 6 * (t[s[11]][1] + t[s[14]][1]) - 2 * (t[s[12]][1] + t[s[3]][1]) + 3 * (t[s[2]][1] + t[s[8]][1])) / 9]), this.figures.push({
        type: "patch",
        coords: new Int32Array(s),
        colors: new Int32Array(a)
      });
    }
  }
  _decodeType7Shading(A) {
    const t = this.coords, i = this.colors, s = new Int32Array(16), a = new Int32Array(4);
    for (; A.hasData; ) {
      const n = A.readFlag();
      if (!(0 <= n && n <= 3))
        throw new v("Unknown type7 flag");
      const r = t.length;
      for (let h = 0, C = n !== 0 ? 12 : 16; h < C; h++)
        t.push(A.readCoordinate());
      const g = i.length;
      for (let h = 0, C = n !== 0 ? 2 : 4; h < C; h++)
        i.push(A.readComponents());
      let o, I, c, l;
      switch (n) {
        case 0:
          s[12] = r + 3, s[13] = r + 4, s[14] = r + 5, s[15] = r + 6, s[8] = r + 2, s[9] = r + 13, s[10] = r + 14, s[11] = r + 7, s[4] = r + 1, s[5] = r + 12, s[6] = r + 15, s[7] = r + 8, s[0] = r, s[1] = r + 11, s[2] = r + 10, s[3] = r + 9, a[2] = g + 1, a[3] = g + 2, a[0] = g, a[1] = g + 3;
          break;
        case 1:
          o = s[12], I = s[13], c = s[14], l = s[15], s[12] = l, s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = c, s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = I, s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = o, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, o = a[2], I = a[3], a[2] = I, a[3] = g, a[0] = o, a[1] = g + 1;
          break;
        case 2:
          o = s[15], I = s[11], s[12] = s[3], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[7], s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = I, s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = o, s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, o = a[3], a[2] = a[1], a[3] = g, a[0] = o, a[1] = g + 1;
          break;
        case 3:
          s[12] = s[0], s[13] = r + 0, s[14] = r + 1, s[15] = r + 2, s[8] = s[1], s[9] = r + 9, s[10] = r + 10, s[11] = r + 3, s[4] = s[2], s[5] = r + 8, s[6] = r + 11, s[7] = r + 4, s[0] = s[3], s[1] = r + 7, s[2] = r + 6, s[3] = r + 5, a[2] = a[0], a[3] = g, a[0] = a[1], a[1] = g + 1;
          break;
      }
      this.figures.push({
        type: "patch",
        coords: new Int32Array(s),
        colors: new Int32Array(a)
      });
    }
  }
  _buildFigureFromPatch(A) {
    const t = this.figures[A];
    _e(t.type === "patch", "Unexpected patch mesh figure");
    const i = this.coords, s = this.colors, a = t.coords, n = t.colors, r = Math.min(i[a[0]][0], i[a[3]][0], i[a[12]][0], i[a[15]][0]), g = Math.min(i[a[0]][1], i[a[3]][1], i[a[12]][1], i[a[15]][1]), o = Math.max(i[a[0]][0], i[a[3]][0], i[a[12]][0], i[a[15]][0]), I = Math.max(i[a[0]][1], i[a[3]][1], i[a[12]][1], i[a[15]][1]);
    let c = Math.ceil((o - r) * Yt.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
    c = Math.max(Yt.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(Yt.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, c));
    let l = Math.ceil((I - g) * Yt.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
    l = Math.max(Yt.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(Yt.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, l));
    const h = c + 1, C = new Int32Array((l + 1) * h), B = new Int32Array((l + 1) * h);
    let Q = 0;
    const E = new Uint8Array(3), f = new Uint8Array(3), d = s[n[0]], u = s[n[1]], x = s[n[2]], m = s[n[3]], p = mI(l), D = mI(c);
    for (let F = 0; F <= l; F++) {
      E[0] = (d[0] * (l - F) + x[0] * F) / l | 0, E[1] = (d[1] * (l - F) + x[1] * F) / l | 0, E[2] = (d[2] * (l - F) + x[2] * F) / l | 0, f[0] = (u[0] * (l - F) + m[0] * F) / l | 0, f[1] = (u[1] * (l - F) + m[1] * F) / l | 0, f[2] = (u[2] * (l - F) + m[2] * F) / l | 0;
      for (let y = 0; y <= c; y++, Q++) {
        if ((F === 0 || F === l) && (y === 0 || y === c))
          continue;
        let H = 0, N = 0, T = 0;
        for (let oA = 0; oA <= 3; oA++)
          for (let G = 0; G <= 3; G++, T++) {
            const S = p[F][oA] * D[y][G];
            H += i[a[T]][0] * S, N += i[a[T]][1] * S;
          }
        C[Q] = i.length, i.push([H, N]), B[Q] = s.length;
        const _ = new Uint8Array(3);
        _[0] = (E[0] * (c - y) + f[0] * y) / c | 0, _[1] = (E[1] * (c - y) + f[1] * y) / c | 0, _[2] = (E[2] * (c - y) + f[2] * y) / c | 0, s.push(_);
      }
    }
    C[0] = a[0], B[0] = n[0], C[c] = a[3], B[c] = n[1], C[h * l] = a[12], B[h * l] = n[2], C[h * l + c] = a[15], B[h * l + c] = n[3], this.figures[A] = {
      type: "lattice",
      coords: C,
      colors: B,
      verticesPerRow: h
    };
  }
  _updateBounds() {
    let A = this.coords[0][0], t = this.coords[0][1], i = A, s = t;
    for (let a = 1, n = this.coords.length; a < n; a++) {
      const r = this.coords[a][0], g = this.coords[a][1];
      A = A > r ? r : A, t = t > g ? g : t, i = i < r ? r : i, s = s < g ? g : s;
    }
    this.bounds = [A, t, i, s];
  }
  _packData() {
    let A, t, i, s;
    const a = this.coords, n = new Float32Array(a.length * 2);
    for (A = 0, i = 0, t = a.length; A < t; A++) {
      const I = a[A];
      n[i++] = I[0], n[i++] = I[1];
    }
    this.coords = n;
    const r = this.colors, g = new Uint8Array(r.length * 3);
    for (A = 0, i = 0, t = r.length; A < t; A++) {
      const I = r[A];
      g[i++] = I[0], g[i++] = I[1], g[i++] = I[2];
    }
    this.colors = g;
    const o = this.figures;
    for (A = 0, t = o.length; A < t; A++) {
      const I = o[A], c = I.coords, l = I.colors;
      for (i = 0, s = c.length; i < s; i++)
        c[i] *= 2, l[i] *= 3;
    }
  }
  getIR() {
    const {
      bounds: A
    } = this;
    if (A[2] - A[0] === 0 || A[3] - A[1] === 0)
      throw new v(`Invalid MeshShading bounds: [${A}].`);
    return ["Mesh", this.shadingType, this.coords, this.colors, this.figures, A, this.bbox, this.background];
  }
};
Me(Yt, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3), Me(Yt, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20), Me(Yt, "TRIANGLE_DENSITY", 20);
let Eg = Yt;
class GQ extends Z0 {
  getIR() {
    return ["Dummy"];
  }
}
function pI(e, A, t) {
  const i = Ji(A.getArray("Matrix"), Wt), s = ii(A.getArray("BBox"), null);
  if (!s || s[2] - s[0] === 0 || s[3] - s[1] === 0)
    throw new v("Invalid getTilingPatternIR /BBox array.");
  const a = A.get("XStep");
  if (typeof a != "number")
    throw new v("Invalid getTilingPatternIR /XStep value.");
  const n = A.get("YStep");
  if (typeof n != "number")
    throw new v("Invalid getTilingPatternIR /YStep value.");
  const r = A.get("PaintType");
  if (!Number.isInteger(r))
    throw new v("Invalid getTilingPatternIR /PaintType value.");
  const g = A.get("TilingType");
  if (!Number.isInteger(g))
    throw new v("Invalid getTilingPatternIR /TilingType value.");
  return ["TilingPattern", t, e, i, s, a, n, r, g];
}
const NQ = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.54657, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.73293, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.9121, 0.86943, 0.79795, 0.88198, 0.77958, 0.70864, 0.81055, 0.90399, 0.88653, 0.96017, 0.82577, 0.77892, 0.78257, 0.97507, 1.54657, 0.97507, 0.85284, 0.89552, 0.90176, 0.88762, 0.8785, 0.75241, 0.8785, 0.90518, 0.95015, 0.77618, 0.8785, 0.88401, 0.91916, 0.86304, 0.88401, 0.91488, 0.8785, 0.8801, 0.8785, 0.8785, 0.91343, 0.7173, 1.04106, 0.8785, 0.85075, 0.95794, 0.82616, 0.85162, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.12401, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.73293, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.9121, 0.86943, 0.86943, 0.86943, 0.86943, 0.86943, 0.85284, 0.87508, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.88762, 0.8715, 0.75241, 0.90518, 0.90518, 0.90518, 0.90518, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.8785, 0.8801, 0.8801, 0.8801, 0.8801, 0.8801, 0.90747, 0.89049, 0.8785, 0.8785, 0.8785, 0.8785, 0.85162, 0.8785, 0.85162, 0.83908, 0.88762, 0.83908, 0.88762, 0.83908, 0.88762, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.73293, 0.75241, 0.87289, 0.83016, 0.88506, 0.93125, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.73133, 0.90518, 0.81921, 0.77618, 0.81921, 0.77618, 0.81921, 0.77618, 1, 1, 0.87356, 0.8785, 0.91075, 0.89608, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76229, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.79468, 0.91926, 0.88175, 0.70823, 0.94903, 0.9121, 0.8785, 1, 1, 0.9121, 0.8785, 0.87802, 0.88656, 0.8785, 0.86943, 0.8801, 0.86943, 0.8801, 0.86943, 0.8801, 0.87402, 0.89291, 0.77958, 0.91343, 1, 1, 0.77958, 0.91343, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 0.70864, 0.7173, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.90399, 0.8785, 0.96017, 0.95794, 0.77892, 0.85162, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.88762, 0.77539, 0.8715, 0.87508, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70674, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.06303, 0.83908, 0.80352, 0.57184, 0.6965, 0.56289, 0.82001, 0.56029, 0.81235, 1.02988, 0.83908, 0.7762, 0.68156, 0.80367, 0.73133, 0.78257, 0.87356, 0.86943, 0.95958, 0.75727, 0.89019, 1.04924, 0.9121, 0.7648, 0.86943, 0.87356, 0.79795, 0.78275, 0.81055, 0.77892, 0.9762, 0.82577, 0.99819, 0.84896, 0.95958, 0.77892, 0.96108, 1.01407, 0.89049, 1.02988, 0.94211, 0.96108, 0.8936, 0.84021, 0.87842, 0.96399, 0.79109, 0.89049, 1.00813, 1.02988, 0.86077, 0.87445, 0.92099, 0.84723, 0.86513, 0.8801, 0.75638, 0.85714, 0.78216, 0.79586, 0.87965, 0.94211, 0.97747, 0.78287, 0.97926, 0.84971, 1.02988, 0.94211, 0.8801, 0.94211, 0.84971, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90264, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90518, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90548, 1, 1, 1, 1, 1, 1, 0.96017, 0.95794, 0.96017, 0.95794, 0.96017, 0.95794, 0.77892, 0.85162, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.92794, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71143, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.93835, 0.83406, 0.91133, 0.84107, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90527, 1.81055, 0.90527, 1.81055, 1.31006, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], MQ = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, UQ = [1.3877, 1, 1, 1, 0.97801, 0.92482, 0.89552, 0.91133, 0.81988, 0.97566, 0.98152, 0.93548, 0.93548, 1.2798, 0.85284, 0.92794, 1, 0.96134, 1.56239, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.82845, 0.82845, 0.85284, 0.85284, 0.85284, 0.75859, 0.92138, 0.83908, 0.7762, 0.71805, 0.87289, 0.73133, 0.7514, 0.81921, 0.87356, 0.95958, 0.59526, 0.75727, 0.69225, 1.04924, 0.90872, 0.85938, 0.79795, 0.87068, 0.77958, 0.69766, 0.81055, 0.90399, 0.88653, 0.96068, 0.82577, 0.77892, 0.78257, 0.97507, 1.529, 0.97507, 0.85284, 0.89552, 0.90176, 0.94908, 0.86411, 0.74012, 0.86411, 0.88323, 0.95015, 0.86411, 0.86331, 0.88401, 0.91916, 0.86304, 0.88401, 0.9039, 0.86331, 0.86331, 0.86411, 0.86411, 0.90464, 0.70852, 1.04106, 0.86331, 0.84372, 0.95794, 0.82616, 0.84548, 0.79492, 0.88331, 1.69808, 0.88331, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.7801, 0.89552, 1.24487, 1.13254, 1.19129, 0.96839, 0.85284, 0.68787, 0.70645, 0.85592, 0.90747, 1.01466, 1.0088, 0.90323, 1, 1.07463, 1, 0.91056, 0.75806, 1.19118, 0.96839, 0.78864, 0.82845, 0.84133, 0.75859, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.83908, 0.77539, 0.71805, 0.73133, 0.73133, 0.73133, 0.73133, 0.95958, 0.95958, 0.95958, 0.95958, 0.88506, 0.90872, 0.85938, 0.85938, 0.85938, 0.85938, 0.85938, 0.85284, 0.87068, 0.90399, 0.90399, 0.90399, 0.90399, 0.77892, 0.79795, 0.90807, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.94908, 0.85887, 0.74012, 0.88323, 0.88323, 0.88323, 0.88323, 0.88401, 0.88401, 0.88401, 0.88401, 0.8785, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.86331, 0.90747, 0.89049, 0.86331, 0.86331, 0.86331, 0.86331, 0.84548, 0.86411, 0.84548, 0.83908, 0.94908, 0.83908, 0.94908, 0.83908, 0.94908, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.71805, 0.74012, 0.87289, 0.79538, 0.88506, 0.92726, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.73133, 0.88323, 0.81921, 0.86411, 0.81921, 0.86411, 0.81921, 0.86411, 1, 1, 0.87356, 0.86331, 0.91075, 0.8777, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.95958, 0.88401, 0.76467, 0.90167, 0.59526, 0.91916, 1, 1, 0.86304, 0.69225, 0.88401, 1, 1, 0.70424, 0.77312, 0.91926, 0.88175, 0.70823, 0.94903, 0.90872, 0.86331, 1, 1, 0.90872, 0.86331, 0.86906, 0.88116, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.85938, 0.86331, 0.87402, 0.86549, 0.77958, 0.90464, 1, 1, 0.77958, 0.90464, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 0.69766, 0.70852, 1, 1, 0.81055, 0.75841, 0.81055, 1.06452, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.90399, 0.86331, 0.96068, 0.95794, 0.77892, 0.84548, 0.77892, 0.78257, 0.79492, 0.78257, 0.79492, 0.78257, 0.79492, 0.9297, 0.56892, 0.83908, 0.94908, 0.77539, 0.85887, 0.87068, 0.89049, 1, 1, 0.81055, 1.04106, 1.20528, 1.20528, 1, 1.15543, 0.70088, 0.98387, 0.94721, 1.33431, 1.45894, 0.95161, 1.48387, 0.83908, 0.80352, 0.57118, 0.6965, 0.56347, 0.79179, 0.55853, 0.80346, 1.02988, 0.83908, 0.7762, 0.67174, 0.86036, 0.73133, 0.78257, 0.87356, 0.86441, 0.95958, 0.75727, 0.89019, 1.04924, 0.90872, 0.74889, 0.85938, 0.87891, 0.79795, 0.7957, 0.81055, 0.77892, 0.97447, 0.82577, 0.97466, 0.87179, 0.95958, 0.77892, 0.94252, 0.95612, 0.8753, 1.02988, 0.92733, 0.94252, 0.87411, 0.84021, 0.8728, 0.95612, 0.74081, 0.8753, 1.02189, 1.02988, 0.84814, 0.87445, 0.91822, 0.84723, 0.85668, 0.86331, 0.81344, 0.87581, 0.76422, 0.82046, 0.96057, 0.92733, 0.99375, 0.78022, 0.95452, 0.86015, 1.02988, 0.92733, 0.86331, 0.92733, 0.86015, 0.73133, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90631, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88323, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85174, 1, 1, 1, 1, 1, 1, 0.96068, 0.95794, 0.96068, 0.95794, 0.96068, 0.95794, 0.77892, 0.84548, 1, 1, 0.89552, 0.90527, 1, 0.90363, 0.92794, 0.92794, 0.92794, 0.89807, 0.87012, 0.87012, 0.87012, 0.89552, 0.89552, 1.42259, 0.71094, 1.06152, 1, 1, 1.03372, 1.03372, 0.97171, 1.4956, 2.2807, 0.92972, 0.83406, 0.91133, 0.83326, 0.91133, 1, 1, 1, 0.72021, 1, 1.23108, 0.83489, 0.88525, 0.88525, 0.81499, 0.90616, 1.81055, 0.90527, 1.81055, 1.3107, 1.53711, 0.94434, 1.08696, 1, 0.95018, 0.77192, 0.85284, 0.90747, 1.17534, 0.69825, 0.9716, 1.37077, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.08004, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90727, 0.90727, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], LQ = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, HQ = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39543, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.72346, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89249, 0.84118, 0.77452, 0.85374, 0.75186, 0.67789, 0.79776, 0.88844, 0.85066, 0.94309, 0.77818, 0.7306, 0.76659, 1.10369, 1.38313, 1.10369, 1.06139, 0.89552, 0.8739, 0.9245, 0.9245, 0.83203, 0.9245, 0.85865, 1.09842, 0.9245, 0.9245, 1.03297, 1.07692, 0.90918, 1.03297, 0.94959, 0.9245, 0.92274, 0.9245, 0.9245, 1.02933, 0.77832, 1.20562, 0.9245, 0.8916, 0.98986, 0.86621, 0.89453, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.16359, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.72346, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89249, 0.84118, 0.84118, 0.84118, 0.84118, 0.84118, 0.85284, 0.84557, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.9245, 0.84843, 0.83203, 0.85865, 0.85865, 0.85865, 0.85865, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.9245, 0.92274, 0.92274, 0.92274, 0.92274, 0.92274, 0.90747, 0.86651, 0.9245, 0.9245, 0.9245, 0.9245, 0.89453, 0.9245, 0.89453, 0.8675, 0.9245, 0.8675, 0.9245, 0.8675, 0.9245, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.72346, 0.83203, 0.85193, 0.8875, 0.86477, 0.99034, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.73206, 0.85865, 0.81105, 0.9245, 0.81105, 0.9245, 0.81105, 0.9245, 1, 1, 0.86275, 0.9245, 0.90872, 0.93591, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77896, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.9375, 0.98156, 0.93407, 0.77261, 1.11429, 0.89249, 0.9245, 1, 1, 0.89249, 0.9245, 0.92534, 0.86698, 0.9245, 0.84118, 0.92274, 0.84118, 0.92274, 0.84118, 0.92274, 0.8667, 0.86291, 0.75186, 1.02933, 1, 1, 0.75186, 1.02933, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 0.67789, 0.77832, 1, 1, 0.79776, 0.97655, 0.79776, 1.23023, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.88844, 0.9245, 0.94309, 0.98986, 0.7306, 0.89453, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.9245, 0.76318, 0.84843, 0.84557, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67009, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.8675, 0.90861, 0.6192, 0.7363, 0.64824, 0.82411, 0.56321, 0.85696, 1.23516, 0.8675, 0.81552, 0.7286, 0.84134, 0.73206, 0.76659, 0.86275, 0.84369, 0.90685, 0.77892, 0.85871, 1.02638, 0.89249, 0.75828, 0.84118, 0.85984, 0.77452, 0.76466, 0.79776, 0.7306, 0.90782, 0.77818, 0.903, 0.87291, 0.90685, 0.7306, 0.99058, 1.03667, 0.94635, 1.23516, 0.9849, 0.99058, 0.92393, 0.8916, 0.942, 1.03667, 0.75026, 0.94635, 1.0297, 1.23516, 0.90918, 0.94048, 0.98217, 0.89746, 0.84153, 0.92274, 0.82507, 0.88832, 0.84438, 0.88178, 1.03525, 0.9849, 1.00225, 0.78086, 0.97248, 0.89404, 1.23516, 0.9849, 0.92274, 0.9849, 0.89404, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89693, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.85865, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.90933, 1, 1, 1, 1, 1, 1, 0.94309, 0.98986, 0.94309, 0.98986, 0.94309, 0.98986, 0.7306, 0.89453, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.68994, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.97858, 0.82616, 0.91133, 0.83437, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90572, 1.81055, 0.90749, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85284, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], JQ = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, YQ = [1.3877, 1, 1, 1, 1.17223, 1.1293, 0.89552, 0.91133, 0.80395, 1.02269, 1.15601, 0.91056, 0.91056, 1.2798, 0.85284, 0.89807, 1, 0.90861, 1.39016, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.91133, 0.96309, 0.96309, 0.85284, 0.85284, 0.85284, 0.83319, 0.88071, 0.8675, 0.81552, 0.73834, 0.85193, 0.73206, 0.7522, 0.81105, 0.86275, 0.90685, 0.6377, 0.77892, 0.75593, 1.02638, 0.89385, 0.85122, 0.77452, 0.86503, 0.75186, 0.68887, 0.79776, 0.88844, 0.85066, 0.94258, 0.77818, 0.7306, 0.76659, 1.10369, 1.39016, 1.10369, 1.06139, 0.89552, 0.8739, 0.86128, 0.94469, 0.8457, 0.94469, 0.89464, 1.09842, 0.84636, 0.94469, 1.03297, 1.07692, 0.90918, 1.03297, 0.95897, 0.94469, 0.9482, 0.94469, 0.94469, 1.04692, 0.78223, 1.20562, 0.94469, 0.90332, 0.98986, 0.86621, 0.90527, 0.79004, 0.94152, 1.77256, 0.94152, 0.85284, 0.97801, 0.89552, 0.91133, 0.89552, 0.91133, 1.91729, 0.89552, 1.17889, 1.13254, 1.08707, 0.92098, 0.85284, 0.68787, 0.71353, 0.84737, 0.90747, 1.0088, 1.0044, 0.87683, 1, 1.09091, 1, 0.92229, 0.739, 1.15642, 0.92098, 0.76288, 0.80504, 0.80972, 0.75859, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.8675, 0.76318, 0.73834, 0.73206, 0.73206, 0.73206, 0.73206, 0.90685, 0.90685, 0.90685, 0.90685, 0.86477, 0.89385, 0.85122, 0.85122, 0.85122, 0.85122, 0.85122, 0.85284, 0.85311, 0.88844, 0.88844, 0.88844, 0.88844, 0.7306, 0.77452, 0.86331, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.86128, 0.8693, 0.8457, 0.89464, 0.89464, 0.89464, 0.89464, 0.82601, 0.82601, 0.82601, 0.82601, 0.94469, 0.94469, 0.9482, 0.9482, 0.9482, 0.9482, 0.9482, 0.90747, 0.86651, 0.94469, 0.94469, 0.94469, 0.94469, 0.90527, 0.94469, 0.90527, 0.8675, 0.86128, 0.8675, 0.86128, 0.8675, 0.86128, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.73834, 0.8457, 0.85193, 0.92454, 0.86477, 0.9921, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.73206, 0.89464, 0.81105, 0.84636, 0.81105, 0.84636, 0.81105, 0.84636, 1, 1, 0.86275, 0.94469, 0.90872, 0.95786, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 0.82601, 0.90685, 1.03297, 0.90685, 0.82601, 0.77741, 1.05611, 0.6377, 1.07692, 1, 1, 0.90918, 0.75593, 1.03297, 1, 1, 0.76032, 0.90452, 0.98156, 1.11842, 0.77261, 1.11429, 0.89385, 0.94469, 1, 1, 0.89385, 0.94469, 0.95877, 0.86901, 0.94469, 0.85122, 0.9482, 0.85122, 0.9482, 0.85122, 0.9482, 0.8667, 0.90016, 0.75186, 1.04692, 1, 1, 0.75186, 1.04692, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 0.68887, 0.78223, 1, 1, 0.79776, 0.92188, 0.79776, 1.23023, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.88844, 0.94469, 0.94258, 0.98986, 0.7306, 0.90527, 0.7306, 0.76659, 0.79004, 0.76659, 0.79004, 0.76659, 0.79004, 1.09231, 0.54873, 0.8675, 0.86128, 0.76318, 0.8693, 0.85311, 0.86651, 1, 1, 0.79776, 1.20562, 1.18622, 1.18622, 1, 1.1437, 0.67742, 0.96334, 0.93695, 1.35191, 1.40909, 0.95161, 1.48387, 0.86686, 0.90861, 0.62267, 0.74359, 0.65649, 0.85498, 0.56963, 0.88254, 1.23516, 0.8675, 0.81552, 0.75443, 0.84503, 0.73206, 0.76659, 0.86275, 0.85122, 0.90685, 0.77892, 0.85746, 1.02638, 0.89385, 0.75657, 0.85122, 0.86275, 0.77452, 0.74171, 0.79776, 0.7306, 0.95165, 0.77818, 0.89772, 0.88831, 0.90685, 0.7306, 0.98142, 1.02191, 0.96576, 1.23516, 0.99018, 0.98142, 0.9236, 0.89258, 0.94035, 1.02191, 0.78848, 0.96576, 0.9561, 1.23516, 0.90918, 0.92578, 0.95424, 0.89746, 0.83969, 0.9482, 0.80113, 0.89442, 0.85208, 0.86155, 0.98022, 0.99018, 1.00452, 0.81209, 0.99247, 0.89181, 1.23516, 0.99018, 0.9482, 0.99018, 0.89181, 0.73206, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.88844, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89464, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96766, 1, 1, 1, 1, 1, 1, 0.94258, 0.98986, 0.94258, 0.98986, 0.94258, 0.98986, 0.7306, 0.90527, 1, 1, 0.89552, 0.90527, 1, 0.90186, 1.12308, 1.12308, 1.12308, 1.12308, 1.2566, 1.2566, 1.2566, 0.89552, 0.89552, 1.42259, 0.69043, 1.03809, 1, 1, 1.0176, 1.0176, 1.11523, 1.4956, 2.01462, 0.99331, 0.82616, 0.91133, 0.84286, 0.91133, 1, 1, 1, 0.70508, 1, 1.23108, 0.79801, 0.84426, 0.84426, 0.774, 0.90527, 1.81055, 0.90527, 1.81055, 1.28809, 1.55469, 0.94434, 1.07806, 1, 0.97094, 0.7589, 0.85284, 0.90747, 1.19658, 0.69825, 0.97622, 1.33512, 0.90747, 0.90747, 0.85356, 0.90747, 0.90747, 1.44947, 0.85284, 0.8941, 0.8941, 0.70572, 0.8, 0.70572, 0.70572, 0.70572, 0.70572, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.99862, 0.99862, 1, 1, 1, 1, 1, 1.0336, 0.91027, 1, 1, 1, 0.99862, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05859, 1.05859, 1, 1, 1, 1.07185, 0.99413, 0.96334, 1.08065, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], KQ = {
  lineHeight: 1.2207,
  lineGap: 0.2207
}, vQ = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.03374, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.00042, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.03828, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00034, 0.99977, 1, 0.99997, 1.00026, 1.00078, 1.00036, 0.99973, 1.00013, 1.0006, 0.99977, 0.99977, 0.99988, 0.85148, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 1.00069, 1.00022, 0.99977, 1.00001, 0.99984, 1.00026, 1.00001, 1.00024, 1.00001, 0.9999, 1, 1.0006, 1.00001, 1.00041, 0.99962, 1.00026, 1.0006, 0.99995, 1.00041, 0.99942, 0.99973, 0.99927, 1.00082, 0.99902, 1.00026, 1.00087, 1.0006, 1.00069, 0.99973, 0.99867, 0.99973, 0.9993, 1.00026, 1.00049, 1.00056, 1, 0.99988, 0.99935, 0.99995, 0.99954, 1.00055, 0.99945, 1.00032, 1.0006, 0.99995, 1.00026, 0.99995, 1.00032, 1.00001, 1.00008, 0.99971, 1.00019, 0.9994, 1.00001, 1.0006, 1.00044, 0.99973, 1.00023, 1.00047, 1, 0.99942, 0.99561, 0.99989, 1.00035, 0.99977, 1.00035, 0.99977, 1.00019, 0.99944, 1.00001, 1.00021, 0.99926, 1.00035, 1.00035, 0.99942, 1.00048, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.99989, 1.00057, 1.00001, 0.99936, 1.00052, 1.00012, 0.99996, 1.00043, 1, 1.00035, 0.9994, 0.99976, 1.00035, 0.99973, 1.00052, 1.00041, 1.00119, 1.00037, 0.99973, 1.00002, 0.99986, 1.00041, 1.00041, 0.99902, 0.9996, 1.00034, 0.99999, 1.00026, 0.99999, 1.00026, 0.99973, 1.00052, 0.99973, 1, 0.99973, 1.00041, 1.00075, 0.9994, 1.0003, 0.99999, 1, 1.00041, 0.99955, 1, 0.99915, 0.99973, 0.99973, 1.00026, 1.00119, 0.99955, 0.99973, 1.0006, 0.99911, 1.0006, 1.00026, 0.99972, 1.00026, 0.99902, 1.00041, 0.99973, 0.99999, 1, 1, 1.00038, 1.0005, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 1.00047, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], TQ = {
  lineHeight: 1.2,
  lineGap: 0.2
}, qQ = [0.76116, 1, 1, 1.0006, 0.99998, 0.99974, 0.99973, 0.99973, 0.99982, 0.99977, 1.00087, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.00003, 1.00003, 1.00003, 1.00026, 0.9999, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 0.99973, 0.99977, 1.00026, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 0.99998, 1.0006, 0.99998, 1.00003, 0.99973, 0.99998, 0.99973, 1.00026, 0.99973, 1.00026, 0.99973, 0.99998, 1.00026, 1.00026, 1.0006, 1.0006, 0.99973, 1.0006, 0.99982, 1.00026, 1.00026, 1.00026, 1.00026, 0.99959, 0.99973, 0.99998, 1.00026, 0.99973, 1.00022, 0.99973, 0.99973, 1, 0.99959, 1.00077, 0.99959, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.00077, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.99973, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 0.99977, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 1.06409, 1.00026, 1.00026, 1.00026, 1.00026, 1.00026, 0.99973, 1.00026, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 1.0044, 0.99977, 1.00026, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99971, 0.99973, 0.99973, 1.0006, 0.99977, 0.99973, 0.99973, 1.00026, 1.0006, 1.00026, 1.0006, 1.00026, 1.01011, 1.00026, 0.99999, 1.00026, 1.0006, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.9993, 0.9998, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1.00022, 1.00026, 1, 1.00016, 0.99977, 0.99959, 0.99977, 0.99959, 0.99977, 0.99959, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00026, 0.99998, 1.00026, 0.8121, 1.00026, 0.99998, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 0.99977, 1.00026, 1.00016, 1.00022, 1.00001, 0.99973, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 1.0006, 0.99973, 0.99977, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 0.99973, 1.00026, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99977, 1, 1, 1.00026, 0.99969, 0.99972, 0.99981, 0.9998, 1.0006, 0.99977, 0.99977, 1.00022, 0.91155, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 0.99977, 1.00001, 0.99999, 0.99977, 0.99966, 1.00022, 1.00032, 1.00001, 0.99944, 1.00026, 1.00001, 0.99968, 1.00001, 1.00047, 1, 1.0006, 1.00001, 0.99981, 1.00101, 1.00026, 1.0006, 0.99948, 0.99981, 1.00064, 0.99973, 0.99942, 1.00101, 1.00061, 1.00026, 1.00069, 1.0006, 1.00014, 0.99973, 1.01322, 0.99973, 1.00065, 1.00026, 1.00012, 0.99923, 1, 1.00064, 1.00076, 0.99948, 1.00055, 1.00063, 1.00007, 0.99943, 1.0006, 0.99948, 1.00026, 0.99948, 0.99943, 1.00001, 1.00001, 1.00029, 1.00038, 1.00035, 1.00001, 1.0006, 1.0006, 0.99973, 0.99978, 1.00001, 1.00057, 0.99989, 0.99967, 0.99964, 0.99967, 0.99977, 0.99999, 0.99977, 1.00038, 0.99977, 1.00001, 0.99973, 1.00066, 0.99967, 0.99967, 1.00041, 0.99998, 0.99999, 0.99977, 1.00022, 0.99967, 1.00001, 0.99977, 1.00026, 0.99964, 1.00031, 1.00001, 0.99999, 0.99999, 1, 1.00023, 1, 1, 0.99999, 1.00035, 1.00001, 0.99999, 0.99973, 0.99977, 0.99999, 1.00058, 0.99973, 0.99973, 0.99955, 0.9995, 1.00026, 1.00026, 1.00032, 0.99989, 1.00034, 0.99999, 1.00026, 1.00026, 1.00026, 0.99973, 0.45998, 0.99973, 1.00026, 0.99973, 1.00001, 0.99999, 0.99982, 0.99994, 0.99996, 1, 1.00042, 1.00044, 1.00029, 1.00023, 0.99973, 0.99973, 1.00026, 0.99949, 1.00002, 0.99973, 1.0006, 1.0006, 1.0006, 0.99975, 1.00026, 1.00026, 1.00032, 0.98685, 0.99973, 1.00026, 1, 1, 0.99966, 1.00044, 1.00016, 1.00022, 1.00016, 1.00022, 1.00016, 1.00022, 1.00001, 0.99973, 1, 1, 0.99973, 1, 1, 0.99955, 1.0006, 1.0006, 1.0006, 1.0006, 1, 1, 1, 0.99973, 0.99973, 0.99972, 1, 1, 1.00106, 0.99999, 0.99998, 0.99998, 0.99999, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1, 0.99973, 0.99971, 0.99978, 1, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00098, 1, 1, 1, 1.00049, 1, 1, 0.99972, 1, 1.20985, 1.39713, 1.00003, 1.00031, 1.00015, 1, 0.99561, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.99972, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], PQ = {
  lineHeight: 1.35,
  lineGap: 0.2
}, WQ = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.0288, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 0.99946, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.06311, 0.99973, 1.00024, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00041, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.89547, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 1.00001, 1, 1.00054, 0.99977, 1.00084, 1.00007, 0.99973, 1.00013, 0.99924, 1.00001, 1.00001, 0.99945, 0.91221, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00001, 0.99999, 0.99977, 0.99933, 1.00022, 1.00054, 1.00001, 1.00065, 1.00026, 1.00001, 1.0001, 1.00001, 1.00052, 1, 1.0006, 1.00001, 0.99945, 0.99897, 0.99968, 0.99924, 1.00036, 0.99945, 0.99949, 1, 1.0006, 0.99897, 0.99918, 0.99968, 0.99911, 0.99924, 1, 0.99962, 1.01487, 1, 1.0005, 0.99973, 1.00012, 1.00043, 1, 0.99995, 0.99994, 1.00036, 0.99947, 1.00019, 1.00063, 1.00025, 0.99924, 1.00036, 0.99973, 1.00036, 1.00025, 1.00001, 1.00001, 1.00027, 1.0001, 1.00068, 1.00001, 1.0006, 1.0006, 1, 1.00008, 0.99957, 0.99972, 0.9994, 0.99954, 0.99975, 1.00051, 1.00001, 1.00019, 1.00001, 1.0001, 0.99986, 1.00001, 1.00001, 1.00038, 0.99954, 0.99954, 0.9994, 1.00066, 0.99999, 0.99977, 1.00022, 1.00054, 1.00001, 0.99977, 1.00026, 0.99975, 1.0001, 1.00001, 0.99993, 0.9995, 0.99955, 1.00016, 0.99978, 0.99974, 1.00019, 1.00022, 0.99955, 1.00053, 0.99973, 1.00089, 1.00005, 0.99967, 1.00048, 0.99973, 1.00002, 1.00034, 0.99973, 0.99973, 0.99964, 1.00006, 1.00066, 0.99947, 0.99973, 0.98894, 0.99973, 1, 0.44898, 1, 0.99946, 1, 1.00039, 1.00082, 0.99991, 0.99991, 0.99985, 1.00022, 1.00023, 1.00061, 1.00006, 0.99966, 0.99973, 0.99973, 0.99973, 1.00019, 1.0008, 1, 0.99924, 0.99924, 0.99924, 0.99983, 1.00044, 0.99973, 0.99964, 0.98332, 1, 0.99973, 1, 1, 0.99962, 0.99895, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 1.00423, 0.99925, 0.99999, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1.00049, 1, 1.00245, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 1.00003, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 0.99998, 0.99998, 0.99998, 0.99998, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], OQ = {
  lineHeight: 1.35,
  lineGap: 0.2
}, VQ = [0.76116, 1, 1, 1.0006, 1.0006, 1.00006, 0.99973, 0.99973, 0.99982, 1.00001, 1.00043, 0.99998, 0.99998, 0.99959, 1.00003, 1.0006, 0.99998, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1, 1.00003, 1.00003, 1.00003, 0.99973, 0.99987, 1.00001, 1.00001, 0.99977, 0.99977, 1.00001, 1.00026, 1.00022, 0.99977, 1.0006, 1, 1.00001, 0.99973, 0.99999, 0.99977, 1.00022, 1.00001, 1.00022, 0.99977, 1.00001, 1.00026, 0.99977, 1.00001, 1.00016, 1.00001, 1.00001, 1.00026, 1.0006, 1.0006, 1.0006, 0.99949, 0.99973, 0.99998, 0.99973, 0.99973, 1, 0.99973, 0.99973, 1.0006, 0.99973, 0.99973, 0.99924, 0.99924, 1, 0.99924, 0.99999, 0.99973, 0.99973, 0.99973, 0.99973, 0.99998, 1, 1.0006, 0.99973, 1, 0.99977, 1, 1, 1, 1.00005, 1.0009, 1.00005, 1.00003, 0.99998, 0.99973, 0.99973, 0.99973, 0.99973, 1.0009, 0.99973, 0.99998, 1.00025, 0.99968, 0.99973, 1.00003, 1.00025, 0.60299, 1.00024, 1.06409, 1, 1, 0.99998, 1, 0.9998, 1.0006, 0.99998, 1, 0.99936, 0.99973, 1.00002, 1.00002, 1.00002, 1.00026, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1.00001, 1, 0.99977, 1.00001, 1.00001, 1.00001, 1.00001, 1.0006, 1.0006, 1.0006, 1.0006, 0.99977, 0.99977, 1.00022, 1.00022, 1.00022, 1.00022, 1.00022, 1.00003, 1.00022, 0.99977, 0.99977, 0.99977, 0.99977, 1.00001, 1.00001, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99982, 1, 0.99973, 0.99973, 0.99973, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 0.99973, 1.06409, 1.00026, 0.99973, 0.99973, 0.99973, 0.99973, 1, 0.99973, 1, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1, 0.99977, 1.04596, 0.99977, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00001, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 1.0006, 0.99924, 1.0006, 1.0006, 1.00019, 1.00034, 1, 0.99924, 1.00001, 1, 1, 0.99973, 0.99924, 0.99973, 0.99924, 0.99973, 1.02572, 0.99973, 1.00005, 0.99973, 0.99924, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99999, 0.9998, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1.00022, 0.99973, 1, 1.00016, 0.99977, 0.99998, 0.99977, 0.99998, 0.99977, 0.99998, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00001, 1, 1.00026, 1.0006, 1.00026, 0.84533, 1.00026, 1.0006, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 0.99977, 0.99973, 1.00016, 0.99977, 1.00001, 1, 1.00001, 1.00026, 1, 1.00026, 1, 1.00026, 1, 0.99924, 0.99973, 1.00001, 0.99973, 1, 0.99982, 1.00022, 1.00026, 1.00001, 1, 1.00026, 1.0006, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99928, 1, 0.99977, 1.00013, 1.00055, 0.99947, 0.99945, 0.99941, 0.99924, 1.00001, 1.00001, 1.0004, 0.91621, 1.00001, 1.00026, 0.99977, 1.00022, 1.0006, 1.00001, 1.00005, 0.99999, 0.99977, 1.00015, 1.00022, 0.99977, 1.00001, 0.99973, 1.00026, 1.00001, 1.00019, 1.00001, 0.99946, 1, 1.0006, 1.00001, 0.99978, 1.00045, 0.99973, 0.99924, 1.00023, 0.99978, 0.99966, 1, 1.00065, 1.00045, 1.00019, 0.99973, 0.99973, 0.99924, 1, 1, 0.96499, 1, 1.00055, 0.99973, 1.00008, 1.00027, 1, 0.9997, 0.99995, 1.00023, 0.99933, 1.00019, 1.00015, 1.00031, 0.99924, 1.00023, 0.99973, 1.00023, 1.00031, 1.00001, 0.99928, 1.00029, 1.00092, 1.00035, 1.00001, 1.0006, 1.0006, 1, 0.99988, 0.99975, 1, 1.00082, 0.99561, 0.9996, 1.00035, 1.00001, 0.99962, 1.00001, 1.00092, 0.99964, 1.00001, 0.99963, 0.99999, 1.00035, 1.00035, 1.00082, 0.99962, 0.99999, 0.99977, 1.00022, 1.00035, 1.00001, 0.99977, 1.00026, 0.9996, 0.99967, 1.00001, 1.00034, 1.00074, 1.00054, 1.00053, 1.00063, 0.99971, 0.99962, 1.00035, 0.99975, 0.99977, 0.99973, 1.00043, 0.99953, 1.0007, 0.99915, 0.99973, 1.00008, 0.99892, 1.00073, 1.00073, 1.00114, 0.99915, 1.00073, 0.99955, 0.99973, 1.00092, 0.99973, 1, 0.99998, 1, 1.0003, 1, 1.00043, 1.00001, 0.99969, 1.0003, 1, 1.00035, 1.00001, 0.9995, 1, 1.00092, 0.99973, 0.99973, 0.99973, 1.0007, 0.9995, 1, 0.99924, 1.0006, 0.99924, 0.99972, 1.00062, 0.99973, 1.00114, 1.00073, 1, 0.99955, 1, 1, 1.00047, 0.99968, 1.00016, 0.99977, 1.00016, 0.99977, 1.00016, 0.99977, 1.00001, 1, 1, 1, 0.99973, 1, 1, 0.99955, 0.99924, 0.99924, 0.99924, 0.99924, 0.99998, 0.99998, 0.99998, 0.99973, 0.99973, 0.99972, 1, 1, 1.00267, 0.99999, 0.99998, 0.99998, 1, 0.99998, 1.66475, 1, 0.99973, 0.99973, 1.00023, 0.99973, 0.99971, 0.99925, 1.00023, 1, 0.99991, 0.99984, 1.00002, 1.00002, 1.00002, 1.00002, 1, 1, 1, 1, 1, 1, 1, 0.96329, 1, 1.20985, 1.39713, 1.00003, 0.8254, 1.00015, 1, 1.00035, 1.00027, 1.00031, 1.00031, 0.99915, 1.00031, 1.00031, 0.99999, 1.00003, 0.99999, 0.99999, 1.41144, 1.6, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.41144, 1.40579, 1.40579, 1.36625, 0.99999, 1, 0.99861, 0.99861, 1, 1.00026, 1.00026, 1.00026, 1.00026, 0.95317, 0.99999, 0.99999, 0.99999, 0.99999, 1.40483, 1, 0.99977, 1.00054, 1, 1, 0.99953, 0.99962, 1.00042, 0.9995, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ZQ = {
  lineHeight: 1.2,
  lineGap: 0.2
}, ds = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 719, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 785, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 385, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 465, 722, 333, 853, 906, 474, 825, 927, 838, 278, 722, 722, 601, 719, 667, 611, 722, 778, 278, 722, 667, 833, 722, 644, 778, 722, 667, 600, 611, 667, 821, 667, 809, 802, 278, 667, 615, 451, 611, 278, 582, 615, 610, 556, 606, 475, 460, 611, 541, 278, 558, 556, 612, 556, 445, 611, 766, 619, 520, 684, 446, 582, 715, 576, 753, 845, 278, 582, 611, 582, 845, 667, 669, 885, 567, 711, 667, 278, 276, 556, 1094, 1062, 875, 610, 722, 622, 719, 722, 719, 722, 567, 712, 667, 904, 626, 719, 719, 610, 702, 833, 722, 778, 719, 667, 722, 611, 622, 854, 667, 730, 703, 1005, 1019, 870, 979, 719, 711, 1031, 719, 556, 618, 615, 417, 635, 556, 709, 497, 615, 615, 500, 635, 740, 604, 611, 604, 611, 556, 490, 556, 875, 556, 615, 581, 833, 844, 729, 854, 615, 552, 854, 583, 556, 556, 611, 417, 552, 556, 278, 281, 278, 969, 906, 611, 500, 615, 556, 604, 778, 611, 487, 447, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1094, 556, 885, 489, 1115, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], xs = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], ms = [365, 0, 333, 278, 333, 474, 556, 556, 889, 722, 238, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 333, 333, 584, 584, 584, 611, 975, 722, 722, 722, 722, 667, 611, 778, 722, 278, 556, 722, 611, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 333, 278, 333, 584, 556, 333, 556, 611, 556, 611, 556, 333, 611, 611, 278, 278, 556, 278, 889, 611, 611, 611, 611, 389, 556, 333, 611, 556, 778, 556, 556, 500, 389, 280, 389, 584, 333, 556, 556, 556, 556, 280, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 556, 278, 333, 333, 365, 556, 834, 834, 834, 611, 722, 722, 722, 722, 722, 722, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 556, 556, 556, 556, 556, 278, 278, 278, 278, 611, 611, 611, 611, 611, 611, 611, 549, 611, 611, 611, 611, 611, 556, 611, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 740, 722, 611, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 611, 778, 611, 778, 611, 778, 611, 722, 611, 722, 611, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 782, 556, 556, 278, 722, 556, 556, 611, 278, 611, 278, 611, 396, 611, 479, 611, 278, 722, 611, 722, 611, 722, 611, 708, 723, 611, 778, 611, 778, 611, 778, 611, 1e3, 944, 722, 389, 722, 389, 722, 389, 667, 556, 667, 556, 667, 556, 667, 556, 611, 333, 611, 479, 611, 333, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 722, 611, 944, 778, 667, 556, 667, 611, 500, 611, 500, 611, 500, 278, 556, 722, 556, 1e3, 889, 778, 611, 667, 556, 611, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 722, 333, 854, 906, 473, 844, 930, 847, 278, 722, 722, 610, 671, 667, 611, 722, 778, 278, 722, 667, 833, 722, 657, 778, 718, 667, 590, 611, 667, 822, 667, 829, 781, 278, 667, 620, 479, 611, 278, 591, 620, 621, 556, 610, 479, 492, 611, 558, 278, 566, 556, 603, 556, 450, 611, 712, 605, 532, 664, 409, 591, 704, 578, 773, 834, 278, 591, 611, 591, 834, 667, 667, 886, 614, 719, 667, 278, 278, 556, 1094, 1042, 854, 622, 719, 677, 719, 722, 708, 722, 614, 722, 667, 927, 643, 719, 719, 615, 687, 833, 722, 778, 719, 667, 722, 611, 677, 781, 667, 729, 708, 979, 989, 854, 1e3, 708, 719, 1042, 729, 556, 619, 604, 534, 618, 556, 736, 510, 611, 611, 507, 622, 740, 604, 611, 611, 611, 556, 889, 556, 885, 556, 646, 583, 889, 935, 707, 854, 594, 552, 865, 589, 556, 556, 611, 469, 563, 556, 278, 278, 278, 969, 906, 611, 507, 619, 556, 611, 778, 611, 575, 467, 944, 778, 944, 778, 944, 778, 667, 556, 333, 333, 556, 1e3, 1e3, 552, 278, 278, 278, 278, 500, 500, 500, 556, 556, 350, 1e3, 1e3, 240, 479, 333, 333, 604, 333, 167, 396, 556, 556, 1104, 556, 885, 516, 1146, 1e3, 768, 600, 834, 834, 834, 834, 999, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 722, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 611, 611, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 333, 333, 333, 333, 333, 333, 333, 333], ps = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], ys = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 625, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 733, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 281, 556, 400, 556, 222, 722, 556, 722, 556, 722, 556, 615, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 354, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 789, 846, 389, 794, 865, 775, 222, 667, 667, 570, 671, 667, 611, 722, 778, 278, 667, 667, 833, 722, 648, 778, 725, 667, 600, 611, 667, 837, 667, 831, 761, 278, 667, 570, 439, 555, 222, 550, 570, 571, 500, 556, 439, 463, 555, 542, 222, 500, 492, 548, 500, 447, 556, 670, 573, 486, 603, 374, 550, 652, 546, 728, 779, 222, 550, 556, 550, 779, 667, 667, 843, 544, 708, 667, 278, 278, 500, 1066, 982, 844, 589, 715, 639, 724, 667, 651, 667, 544, 704, 667, 917, 614, 715, 715, 589, 686, 833, 722, 778, 725, 667, 722, 611, 639, 795, 667, 727, 673, 920, 923, 805, 886, 651, 694, 1022, 682, 556, 562, 522, 493, 553, 556, 688, 465, 556, 556, 472, 564, 686, 550, 556, 556, 556, 500, 833, 500, 835, 500, 572, 518, 830, 851, 621, 736, 526, 492, 752, 534, 556, 556, 556, 378, 496, 500, 222, 222, 222, 910, 828, 556, 472, 565, 500, 556, 778, 556, 492, 339, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1083, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 998, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 584, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], ws = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], bs = [365, 0, 333, 278, 278, 355, 556, 556, 889, 667, 191, 333, 333, 389, 584, 278, 333, 278, 278, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 278, 278, 584, 584, 584, 556, 1015, 667, 667, 722, 722, 667, 611, 778, 722, 278, 500, 667, 556, 833, 722, 778, 667, 778, 722, 667, 611, 722, 667, 944, 667, 667, 611, 278, 278, 278, 469, 556, 333, 556, 556, 500, 556, 556, 278, 556, 556, 222, 222, 500, 222, 833, 556, 556, 556, 556, 333, 500, 278, 556, 500, 722, 500, 500, 500, 334, 260, 334, 584, 333, 556, 556, 556, 556, 260, 556, 333, 737, 370, 556, 584, 737, 552, 400, 549, 333, 333, 333, 576, 537, 278, 333, 333, 365, 556, 834, 834, 834, 611, 667, 667, 667, 667, 667, 667, 1e3, 722, 667, 667, 667, 667, 278, 278, 278, 278, 722, 722, 778, 778, 778, 778, 778, 584, 778, 722, 722, 722, 722, 667, 667, 611, 556, 556, 556, 556, 556, 556, 889, 500, 556, 556, 556, 556, 278, 278, 278, 278, 556, 556, 556, 556, 556, 556, 556, 549, 611, 556, 556, 556, 556, 500, 556, 500, 667, 556, 667, 556, 667, 556, 722, 500, 722, 500, 722, 500, 722, 500, 722, 615, 722, 556, 667, 556, 667, 556, 667, 556, 667, 556, 667, 556, 778, 556, 778, 556, 778, 556, 778, 556, 722, 556, 722, 556, 278, 278, 278, 278, 278, 278, 278, 222, 278, 278, 735, 444, 500, 222, 667, 500, 500, 556, 222, 556, 222, 556, 292, 556, 334, 556, 222, 722, 556, 722, 556, 722, 556, 604, 723, 556, 778, 556, 778, 556, 778, 556, 1e3, 944, 722, 333, 722, 333, 722, 333, 667, 500, 667, 500, 667, 500, 667, 500, 611, 278, 611, 375, 611, 278, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 722, 556, 944, 722, 667, 500, 667, 611, 500, 611, 500, 611, 500, 222, 556, 667, 556, 1e3, 889, 778, 611, 667, 500, 611, 278, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 333, 667, 278, 784, 838, 384, 774, 855, 752, 222, 667, 667, 551, 668, 667, 611, 722, 778, 278, 667, 668, 833, 722, 650, 778, 722, 667, 618, 611, 667, 798, 667, 835, 748, 278, 667, 578, 446, 556, 222, 547, 578, 575, 500, 557, 446, 441, 556, 556, 222, 500, 500, 576, 500, 448, 556, 690, 569, 482, 617, 395, 547, 648, 525, 713, 781, 222, 547, 556, 547, 781, 667, 667, 865, 542, 719, 667, 278, 278, 500, 1057, 1010, 854, 583, 722, 635, 719, 667, 656, 667, 542, 677, 667, 923, 604, 719, 719, 583, 656, 833, 722, 778, 719, 667, 722, 611, 635, 760, 667, 740, 667, 917, 938, 792, 885, 656, 719, 1010, 722, 556, 573, 531, 365, 583, 556, 669, 458, 559, 559, 438, 583, 688, 552, 556, 542, 556, 500, 458, 500, 823, 500, 573, 521, 802, 823, 625, 719, 521, 510, 750, 542, 556, 556, 556, 365, 510, 500, 222, 278, 222, 906, 812, 556, 438, 559, 500, 552, 778, 556, 489, 411, 944, 722, 944, 722, 944, 722, 667, 500, 333, 333, 556, 1e3, 1e3, 552, 222, 222, 222, 222, 333, 333, 333, 556, 556, 350, 1e3, 1e3, 188, 354, 333, 333, 500, 333, 167, 365, 556, 556, 1094, 556, 885, 323, 1073, 1e3, 768, 600, 834, 834, 834, 834, 1e3, 500, 1e3, 500, 1e3, 500, 500, 494, 612, 823, 713, 584, 549, 713, 979, 719, 274, 549, 549, 583, 549, 549, 604, 584, 604, 604, 708, 625, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 708, 729, 604, 604, 354, 354, 1e3, 990, 990, 990, 990, 494, 604, 604, 604, 604, 354, 1021, 1052, 917, 750, 750, 531, 656, 594, 510, 500, 750, 750, 500, 500, 333, 333, 333, 333, 333, 333, 333, 333, 222, 222, 294, 294, 324, 324, 316, 328, 398, 285], Ds = [-1, -1, -1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 402, 506, 507, 508, 509, 510, 511, 536, 537, 538, 539, 710, 711, 713, 728, 729, 730, 731, 732, 733, 900, 901, 902, 903, 904, 905, 906, 908, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1138, 1139, 1168, 1169, 7808, 7809, 7810, 7811, 7812, 7813, 7922, 7923, 8208, 8209, 8211, 8212, 8213, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8224, 8225, 8226, 8230, 8240, 8242, 8243, 8249, 8250, 8252, 8254, 8260, 8319, 8355, 8356, 8359, 8364, 8453, 8467, 8470, 8482, 8486, 8494, 8539, 8540, 8541, 8542, 8592, 8593, 8594, 8595, 8596, 8597, 8616, 8706, 8710, 8719, 8721, 8722, 8730, 8734, 8735, 8745, 8747, 8776, 8800, 8801, 8804, 8805, 8962, 8976, 8992, 8993, 9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9552, 9553, 9554, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 9632, 9633, 9642, 9643, 9644, 9650, 9658, 9660, 9668, 9674, 9675, 9679, 9688, 9689, 9702, 9786, 9787, 9788, 9792, 9794, 9824, 9827, 9829, 9830, 9834, 9835, 9836, 61441, 61442, 61445, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], jQ = [1.36898, 1, 1, 0.72706, 0.80479, 0.83734, 0.98894, 0.99793, 0.9897, 0.93884, 0.86209, 0.94292, 0.94292, 1.16661, 1.02058, 0.93582, 0.96694, 0.93582, 1.19137, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.99793, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.72851, 0.78966, 0.90838, 0.83637, 0.82391, 0.96376, 0.80061, 0.86275, 0.8768, 0.95407, 1.0258, 0.73901, 0.85022, 0.83655, 1.0156, 0.95546, 0.92179, 0.87107, 0.92179, 0.82114, 0.8096, 0.89713, 0.94438, 0.95353, 0.94083, 0.91905, 0.90406, 0.9446, 0.94292, 1.18777, 0.94292, 1.02058, 0.89903, 0.90088, 0.94938, 0.97898, 0.81093, 0.97571, 0.94938, 1.024, 0.9577, 0.95933, 0.98621, 1.0474, 0.97455, 0.98981, 0.9672, 0.95933, 0.9446, 0.97898, 0.97407, 0.97646, 0.78036, 1.10208, 0.95442, 0.95298, 0.97579, 0.9332, 0.94039, 0.938, 0.80687, 1.01149, 0.80687, 1.02058, 0.80479, 0.99793, 0.99793, 0.99793, 0.99793, 1.01149, 1.00872, 0.90088, 0.91882, 1.0213, 0.8361, 1.02058, 0.62295, 0.54324, 0.89022, 1.08595, 1, 1, 0.90088, 1, 0.97455, 0.93582, 0.90088, 1, 1.05686, 0.8361, 0.99642, 0.99642, 0.99642, 0.72851, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.90838, 0.868, 0.82391, 0.80061, 0.80061, 0.80061, 0.80061, 1.0258, 1.0258, 1.0258, 1.0258, 0.97484, 0.95546, 0.92179, 0.92179, 0.92179, 0.92179, 0.92179, 1.02058, 0.92179, 0.94438, 0.94438, 0.94438, 0.94438, 0.90406, 0.86958, 0.98225, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.94938, 0.9031, 0.81093, 0.94938, 0.94938, 0.94938, 0.94938, 0.98621, 0.98621, 0.98621, 0.98621, 0.93969, 0.95933, 0.9446, 0.9446, 0.9446, 0.9446, 0.9446, 1.08595, 0.9446, 0.95442, 0.95442, 0.95442, 0.95442, 0.94039, 0.97898, 0.94039, 0.90838, 0.94938, 0.90838, 0.94938, 0.90838, 0.94938, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.82391, 0.81093, 0.96376, 0.84313, 0.97484, 0.97571, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.80061, 0.94938, 0.8768, 0.9577, 0.8768, 0.9577, 0.8768, 0.9577, 1, 1, 0.95407, 0.95933, 0.97069, 0.95933, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 1.0258, 0.98621, 0.887, 1.01591, 0.73901, 1.0474, 1, 1, 0.97455, 0.83655, 0.98981, 1, 1, 0.83655, 0.73977, 0.83655, 0.73903, 0.84638, 1.033, 0.95546, 0.95933, 1, 1, 0.95546, 0.95933, 0.8271, 0.95417, 0.95933, 0.92179, 0.9446, 0.92179, 0.9446, 0.92179, 0.9446, 0.936, 0.91964, 0.82114, 0.97646, 1, 1, 0.82114, 0.97646, 0.8096, 0.78036, 0.8096, 0.78036, 1, 1, 0.8096, 0.78036, 1, 1, 0.89713, 0.77452, 0.89713, 1.10208, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94438, 0.95442, 0.94083, 0.97579, 0.90406, 0.94039, 0.90406, 0.9446, 0.938, 0.9446, 0.938, 0.9446, 0.938, 1, 0.99793, 0.90838, 0.94938, 0.868, 0.9031, 0.92179, 0.9446, 1, 1, 0.89713, 1.10208, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90989, 0.9358, 0.91945, 0.83181, 0.75261, 0.87992, 0.82976, 0.96034, 0.83689, 0.97268, 1.0078, 0.90838, 0.83637, 0.8019, 0.90157, 0.80061, 0.9446, 0.95407, 0.92436, 1.0258, 0.85022, 0.97153, 1.0156, 0.95546, 0.89192, 0.92179, 0.92361, 0.87107, 0.96318, 0.89713, 0.93704, 0.95638, 0.91905, 0.91709, 0.92796, 1.0258, 0.93704, 0.94836, 1.0373, 0.95933, 1.0078, 0.95871, 0.94836, 0.96174, 0.92601, 0.9498, 0.98607, 0.95776, 0.95933, 1.05453, 1.0078, 0.98275, 0.9314, 0.95617, 0.91701, 1.05993, 0.9446, 0.78367, 0.9553, 1, 0.86832, 1.0128, 0.95871, 0.99394, 0.87548, 0.96361, 0.86774, 1.0078, 0.95871, 0.9446, 0.95871, 0.86774, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.94083, 0.97579, 0.94083, 0.97579, 0.94083, 0.97579, 0.90406, 0.94039, 0.96694, 1, 0.89903, 1, 1, 1, 0.93582, 0.93582, 0.93582, 1, 0.908, 0.908, 0.918, 0.94219, 0.94219, 0.96544, 1, 1.285, 1, 1, 0.81079, 0.81079, 1, 1, 0.74854, 1, 1, 1, 1, 0.99793, 1, 1, 1, 0.65, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.17173, 1, 0.80535, 0.76169, 1.02058, 1.0732, 1.05486, 1, 1, 1.30692, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.16161, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], XQ = {
  lineHeight: 1.2,
  lineGap: 0.2
}, _Q = [1.36898, 1, 1, 0.66227, 0.80779, 0.81625, 0.97276, 0.97276, 0.97733, 0.92222, 0.83266, 0.94292, 0.94292, 1.16148, 1.02058, 0.93582, 0.96694, 0.93582, 1.17337, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.97276, 0.78076, 0.78076, 1.02058, 1.02058, 1.02058, 0.71541, 0.76813, 0.85576, 0.80591, 0.80729, 0.94299, 0.77512, 0.83655, 0.86523, 0.92222, 0.98621, 0.71743, 0.81698, 0.79726, 0.98558, 0.92222, 0.90637, 0.83809, 0.90637, 0.80729, 0.76463, 0.86275, 0.90699, 0.91605, 0.9154, 0.85308, 0.85458, 0.90531, 0.94292, 1.21296, 0.94292, 1.02058, 0.89903, 1.18616, 0.99613, 0.91677, 0.78216, 0.91677, 0.90083, 0.98796, 0.9135, 0.92168, 0.95381, 0.98981, 0.95298, 0.95381, 0.93459, 0.92168, 0.91513, 0.92004, 0.91677, 0.95077, 0.748, 1.04502, 0.91677, 0.92061, 0.94236, 0.89544, 0.89364, 0.9, 0.80687, 0.8578, 0.80687, 1.02058, 0.80779, 0.97276, 0.97276, 0.97276, 0.97276, 0.8578, 0.99973, 1.18616, 0.91339, 1.08074, 0.82891, 1.02058, 0.55509, 0.71526, 0.89022, 1.08595, 1, 1, 1.18616, 1, 0.96736, 0.93582, 1.18616, 1, 1.04864, 0.82711, 0.99043, 0.99043, 0.99043, 0.71541, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.85576, 0.845, 0.80729, 0.77512, 0.77512, 0.77512, 0.77512, 0.98621, 0.98621, 0.98621, 0.98621, 0.95961, 0.92222, 0.90637, 0.90637, 0.90637, 0.90637, 0.90637, 1.02058, 0.90251, 0.90699, 0.90699, 0.90699, 0.90699, 0.85458, 0.83659, 0.94951, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.99613, 0.85811, 0.78216, 0.90083, 0.90083, 0.90083, 0.90083, 0.95381, 0.95381, 0.95381, 0.95381, 0.9135, 0.92168, 0.91513, 0.91513, 0.91513, 0.91513, 0.91513, 1.08595, 0.91677, 0.91677, 0.91677, 0.91677, 0.91677, 0.89364, 0.92332, 0.89364, 0.85576, 0.99613, 0.85576, 0.99613, 0.85576, 0.99613, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.80729, 0.78216, 0.94299, 0.76783, 0.95961, 0.91677, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.77512, 0.90083, 0.86523, 0.9135, 0.86523, 0.9135, 0.86523, 0.9135, 1, 1, 0.92222, 0.92168, 0.92222, 0.92168, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.98621, 0.95381, 0.86036, 0.97096, 0.71743, 0.98981, 1, 1, 0.95298, 0.79726, 0.95381, 1, 1, 0.79726, 0.6894, 0.79726, 0.74321, 0.81691, 1.0006, 0.92222, 0.92168, 1, 1, 0.92222, 0.92168, 0.79464, 0.92098, 0.92168, 0.90637, 0.91513, 0.90637, 0.91513, 0.90637, 0.91513, 0.909, 0.87514, 0.80729, 0.95077, 1, 1, 0.80729, 0.95077, 0.76463, 0.748, 0.76463, 0.748, 1, 1, 0.76463, 0.748, 1, 1, 0.86275, 0.72651, 0.86275, 1.04502, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.90699, 0.91677, 0.9154, 0.94236, 0.85458, 0.89364, 0.85458, 0.90531, 0.9, 0.90531, 0.9, 0.90531, 0.9, 1, 0.97276, 0.85576, 0.99613, 0.845, 0.85811, 0.90251, 0.91677, 1, 1, 0.86275, 1.04502, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.18616, 1.00899, 1.30628, 0.85576, 0.80178, 0.66862, 0.7927, 0.69323, 0.88127, 0.72459, 0.89711, 0.95381, 0.85576, 0.80591, 0.7805, 0.94729, 0.77512, 0.90531, 0.92222, 0.90637, 0.98621, 0.81698, 0.92655, 0.98558, 0.92222, 0.85359, 0.90637, 0.90976, 0.83809, 0.94523, 0.86275, 0.83509, 0.93157, 0.85308, 0.83392, 0.92346, 0.98621, 0.83509, 0.92886, 0.91324, 0.92168, 0.95381, 0.90646, 0.92886, 0.90557, 0.86847, 0.90276, 0.91324, 0.86842, 0.92168, 0.99531, 0.95381, 0.9224, 0.85408, 0.92699, 0.86847, 1.0051, 0.91513, 0.80487, 0.93481, 1, 0.88159, 1.05214, 0.90646, 0.97355, 0.81539, 0.89398, 0.85923, 0.95381, 0.90646, 0.91513, 0.90646, 0.85923, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9154, 0.94236, 0.9154, 0.94236, 0.9154, 0.94236, 0.85458, 0.89364, 0.96694, 1, 0.89903, 1, 1, 1, 0.91782, 0.91782, 0.91782, 1, 0.896, 0.896, 0.896, 0.9332, 0.9332, 0.95973, 1, 1.26, 1, 1, 0.80479, 0.80178, 1, 1, 0.85633, 1, 1, 1, 1, 0.97276, 1, 1, 1, 0.698, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.14542, 1, 0.79199, 0.78694, 1.02058, 1.03493, 1.05486, 1, 1, 1.23026, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.20006, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], zQ = {
  lineHeight: 1.2,
  lineGap: 0.2
}, $Q = [1.36898, 1, 1, 0.65507, 0.84943, 0.85639, 0.88465, 0.88465, 0.86936, 0.88307, 0.86948, 0.85283, 0.85283, 1.06383, 1.02058, 0.75945, 0.9219, 0.75945, 1.17337, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.88465, 0.75945, 0.75945, 1.02058, 1.02058, 1.02058, 0.69046, 0.70926, 0.85158, 0.77812, 0.76852, 0.89591, 0.70466, 0.76125, 0.80094, 0.86822, 0.83864, 0.728, 0.77212, 0.79475, 0.93637, 0.87514, 0.8588, 0.76013, 0.8588, 0.72421, 0.69866, 0.77598, 0.85991, 0.80811, 0.87832, 0.78112, 0.77512, 0.8562, 1.0222, 1.18417, 1.0222, 1.27014, 0.89903, 1.15012, 0.93859, 0.94399, 0.846, 0.94399, 0.81453, 1.0186, 0.94219, 0.96017, 1.03075, 1.02175, 0.912, 1.03075, 0.96998, 0.96017, 0.93859, 0.94399, 0.94399, 0.95493, 0.746, 1.12658, 0.94578, 0.91, 0.979, 0.882, 0.882, 0.83, 0.85034, 0.83537, 0.85034, 1.02058, 0.70869, 0.88465, 0.88465, 0.88465, 0.88465, 0.83537, 0.90083, 1.15012, 0.9161, 0.94565, 0.73541, 1.02058, 0.53609, 0.69353, 0.79519, 1.08595, 1, 1, 1.15012, 1, 0.91974, 0.75945, 1.15012, 1, 0.9446, 0.73361, 0.9005, 0.9005, 0.9005, 0.62864, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.85158, 0.773, 0.76852, 0.70466, 0.70466, 0.70466, 0.70466, 0.83864, 0.83864, 0.83864, 0.83864, 0.90561, 0.87514, 0.8588, 0.8588, 0.8588, 0.8588, 0.8588, 1.02058, 0.85751, 0.85991, 0.85991, 0.85991, 0.85991, 0.77512, 0.76013, 0.88075, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 0.8075, 0.846, 0.81453, 0.81453, 0.81453, 0.81453, 0.82424, 0.82424, 0.82424, 0.82424, 0.9278, 0.96017, 0.93859, 0.93859, 0.93859, 0.93859, 0.93859, 1.08595, 0.8562, 0.94578, 0.94578, 0.94578, 0.94578, 0.882, 0.94578, 0.882, 0.85158, 0.93859, 0.85158, 0.93859, 0.85158, 0.93859, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.76852, 0.846, 0.89591, 0.8544, 0.90561, 0.94399, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.70466, 0.81453, 0.80094, 0.94219, 0.80094, 0.94219, 0.80094, 0.94219, 1, 1, 0.86822, 0.96017, 0.86822, 0.96017, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 0.82424, 0.83864, 1.03075, 0.83864, 0.82424, 0.81402, 1.02738, 0.728, 1.02175, 1, 1, 0.912, 0.79475, 1.03075, 1, 1, 0.79475, 0.83911, 0.79475, 0.66266, 0.80553, 1.06676, 0.87514, 0.96017, 1, 1, 0.87514, 0.96017, 0.86865, 0.87396, 0.96017, 0.8588, 0.93859, 0.8588, 0.93859, 0.8588, 0.93859, 0.867, 0.84759, 0.72421, 0.95493, 1, 1, 0.72421, 0.95493, 0.69866, 0.746, 0.69866, 0.746, 1, 1, 0.69866, 0.746, 1, 1, 0.77598, 0.88417, 0.77598, 1.12658, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.85991, 0.94578, 0.87832, 0.979, 0.77512, 0.882, 0.77512, 0.8562, 0.83, 0.8562, 0.83, 0.8562, 0.83, 1, 0.88465, 0.85158, 0.93859, 0.773, 0.8075, 0.85751, 0.8562, 1, 1, 0.77598, 1.12658, 1.15012, 1.15012, 1.15012, 1.15012, 1.15012, 1.15313, 1.15012, 1.15012, 1.15012, 1.08106, 1.03901, 0.85158, 0.77025, 0.62264, 0.7646, 0.65351, 0.86026, 0.69461, 0.89947, 1.03075, 0.85158, 0.77812, 0.76449, 0.88836, 0.70466, 0.8562, 0.86822, 0.8588, 0.83864, 0.77212, 0.85308, 0.93637, 0.87514, 0.82352, 0.8588, 0.85701, 0.76013, 0.89058, 0.77598, 0.8156, 0.82565, 0.78112, 0.77899, 0.89386, 0.83864, 0.8156, 0.9486, 0.92388, 0.96186, 1.03075, 0.91123, 0.9486, 0.93298, 0.878, 0.93942, 0.92388, 0.84596, 0.96186, 0.95119, 1.03075, 0.922, 0.88787, 0.95829, 0.88, 0.93559, 0.93859, 0.78815, 0.93758, 1, 0.89217, 1.03737, 0.91123, 0.93969, 0.77487, 0.85769, 0.86799, 1.03075, 0.91123, 0.93859, 0.91123, 0.86799, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87832, 0.979, 0.87832, 0.979, 0.87832, 0.979, 0.77512, 0.882, 0.9219, 1, 0.89903, 1, 1, 1, 0.87321, 0.87321, 0.87321, 1, 1.027, 1.027, 1.027, 0.86847, 0.86847, 0.79121, 1, 1.124, 1, 1, 0.73572, 0.73572, 1, 1, 0.85034, 1, 1, 1, 1, 0.88465, 1, 1, 1, 0.669, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04828, 1, 0.74948, 0.75187, 1.02058, 0.98391, 1.02119, 1, 1, 1.06233, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05233, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], A1 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, e1 = [1.36898, 1, 1, 0.76305, 0.82784, 0.94935, 0.89364, 0.92241, 0.89073, 0.90706, 0.98472, 0.85283, 0.85283, 1.0664, 1.02058, 0.74505, 0.9219, 0.74505, 1.23456, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.92241, 0.74505, 0.74505, 1.02058, 1.02058, 1.02058, 0.73002, 0.72601, 0.91755, 0.8126, 0.80314, 0.92222, 0.73764, 0.79726, 0.83051, 0.90284, 0.86023, 0.74, 0.8126, 0.84869, 0.96518, 0.91115, 0.8858, 0.79761, 0.8858, 0.74498, 0.73914, 0.81363, 0.89591, 0.83659, 0.89633, 0.85608, 0.8111, 0.90531, 1.0222, 1.22736, 1.0222, 1.27014, 0.89903, 0.90088, 0.86667, 1.0231, 0.896, 1.01411, 0.90083, 1.05099, 1.00512, 0.99793, 1.05326, 1.09377, 0.938, 1.06226, 1.00119, 0.99793, 0.98714, 1.0231, 1.01231, 0.98196, 0.792, 1.19137, 0.99074, 0.962, 1.01915, 0.926, 0.942, 0.856, 0.85034, 0.92006, 0.85034, 1.02058, 0.69067, 0.92241, 0.92241, 0.92241, 0.92241, 0.92006, 0.9332, 0.90088, 0.91882, 0.93484, 0.75339, 1.02058, 0.56866, 0.54324, 0.79519, 1.08595, 1, 1, 0.90088, 1, 0.95325, 0.74505, 0.90088, 1, 0.97198, 0.75339, 0.91009, 0.91009, 0.91009, 0.66466, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.91755, 0.788, 0.80314, 0.73764, 0.73764, 0.73764, 0.73764, 0.86023, 0.86023, 0.86023, 0.86023, 0.92915, 0.91115, 0.8858, 0.8858, 0.8858, 0.8858, 0.8858, 1.02058, 0.8858, 0.89591, 0.89591, 0.89591, 0.89591, 0.8111, 0.79611, 0.89713, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86667, 0.86936, 0.896, 0.90083, 0.90083, 0.90083, 0.90083, 0.84224, 0.84224, 0.84224, 0.84224, 0.97276, 0.99793, 0.98714, 0.98714, 0.98714, 0.98714, 0.98714, 1.08595, 0.89876, 0.99074, 0.99074, 0.99074, 0.99074, 0.942, 1.0231, 0.942, 0.91755, 0.86667, 0.91755, 0.86667, 0.91755, 0.86667, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.80314, 0.896, 0.92222, 0.93372, 0.92915, 1.01411, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.73764, 0.90083, 0.83051, 1.00512, 0.83051, 1.00512, 0.83051, 1.00512, 1, 1, 0.90284, 0.99793, 0.90976, 0.99793, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 0.84224, 0.86023, 1.05326, 0.86023, 0.84224, 0.82873, 1.07469, 0.74, 1.09377, 1, 1, 0.938, 0.84869, 1.06226, 1, 1, 0.84869, 0.83704, 0.84869, 0.81441, 0.85588, 1.08927, 0.91115, 0.99793, 1, 1, 0.91115, 0.99793, 0.91887, 0.90991, 0.99793, 0.8858, 0.98714, 0.8858, 0.98714, 0.8858, 0.98714, 0.894, 0.91434, 0.74498, 0.98196, 1, 1, 0.74498, 0.98196, 0.73914, 0.792, 0.73914, 0.792, 1, 1, 0.73914, 0.792, 1, 1, 0.81363, 0.904, 0.81363, 1.19137, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89591, 0.99074, 0.89633, 1.01915, 0.8111, 0.942, 0.8111, 0.90531, 0.856, 0.90531, 0.856, 0.90531, 0.856, 1, 0.92241, 0.91755, 0.86667, 0.788, 0.86936, 0.8858, 0.89876, 1, 1, 0.81363, 1.19137, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90088, 0.90388, 1.03901, 0.92138, 0.78105, 0.7154, 0.86169, 0.80513, 0.94007, 0.82528, 0.98612, 1.06226, 0.91755, 0.8126, 0.81884, 0.92819, 0.73764, 0.90531, 0.90284, 0.8858, 0.86023, 0.8126, 0.91172, 0.96518, 0.91115, 0.83089, 0.8858, 0.87791, 0.79761, 0.89297, 0.81363, 0.88157, 0.89992, 0.85608, 0.81992, 0.94307, 0.86023, 0.88157, 0.95308, 0.98699, 0.99793, 1.06226, 0.95817, 0.95308, 0.97358, 0.928, 0.98088, 0.98699, 0.92761, 0.99793, 0.96017, 1.06226, 0.986, 0.944, 0.95978, 0.938, 0.96705, 0.98714, 0.80442, 0.98972, 1, 0.89762, 1.04552, 0.95817, 0.99007, 0.87064, 0.91879, 0.88888, 1.06226, 0.95817, 0.98714, 0.95817, 0.88888, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.89633, 1.01915, 0.89633, 1.01915, 0.89633, 1.01915, 0.8111, 0.942, 0.9219, 1, 0.89903, 1, 1, 1, 0.93173, 0.93173, 0.93173, 1, 1.06304, 1.06304, 1.06904, 0.89903, 0.89903, 0.80549, 1, 1.156, 1, 1, 0.76575, 0.76575, 1, 1, 0.72458, 1, 1, 1, 1, 0.92241, 1, 1, 1, 0.619, 1, 1.36145, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.07257, 1, 0.74705, 0.71119, 1.02058, 1.024, 1.02119, 1, 1, 1.1536, 1.08595, 1.08595, 1, 1.08595, 1.08595, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.05638, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], t1 = {
  lineHeight: 1.2,
  lineGap: 0.2
}, i1 = [1.76738, 1, 1, 0.99297, 0.9824, 1.04016, 1.06497, 1.03424, 0.97529, 1.17647, 1.23203, 1.1085, 1.1085, 1.16939, 1.2107, 0.9754, 1.21408, 0.9754, 1.59578, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 1.03424, 0.81378, 0.81378, 1.2107, 1.2107, 1.2107, 0.71703, 0.97847, 0.97363, 0.88776, 0.8641, 1.02096, 0.79795, 0.85132, 0.914, 1.06085, 1.1406, 0.8007, 0.89858, 0.83693, 1.14889, 1.09398, 0.97489, 0.92094, 0.97489, 0.90399, 0.84041, 0.95923, 1.00135, 1, 1.06467, 0.98243, 0.90996, 0.99361, 1.1085, 1.56942, 1.1085, 1.2107, 0.74627, 0.94282, 0.96752, 1.01519, 0.86304, 1.01359, 0.97278, 1.15103, 1.01359, 0.98561, 1.02285, 1.02285, 1.00527, 1.02285, 1.0302, 0.99041, 1.0008, 1.01519, 1.01359, 1.02258, 0.79104, 1.16862, 0.99041, 0.97454, 1.02511, 0.99298, 0.96752, 0.95801, 0.94856, 1.16579, 0.94856, 1.2107, 0.9824, 1.03424, 1.03424, 1, 1.03424, 1.16579, 0.8727, 1.3871, 1.18622, 1.10818, 1.04478, 1.2107, 1.18622, 0.75155, 0.94994, 1.28826, 1.21408, 1.21408, 0.91056, 1, 0.91572, 0.9754, 0.64663, 1.18328, 1.24866, 1.04478, 1.14169, 1.15749, 1.17389, 0.71703, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.93506, 0.8641, 0.79795, 0.79795, 0.79795, 0.79795, 1.1406, 1.1406, 1.1406, 1.1406, 1.02096, 1.09398, 0.97426, 0.97426, 0.97426, 0.97426, 0.97426, 1.2107, 0.97489, 1.00135, 1.00135, 1.00135, 1.00135, 0.90996, 0.92094, 1.02798, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.96752, 0.93136, 0.86304, 0.97278, 0.97278, 0.97278, 0.97278, 1.02285, 1.02285, 1.02285, 1.02285, 0.97122, 0.99041, 1, 1, 1, 1, 1, 1.28826, 1.0008, 0.99041, 0.99041, 0.99041, 0.99041, 0.96752, 1.01519, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.97363, 0.96752, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 0.8641, 0.86304, 1.02096, 1.03057, 1.02096, 1.03517, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.79795, 0.97278, 0.914, 1.01359, 0.914, 1.01359, 0.914, 1.01359, 1, 1, 1.06085, 0.98561, 1.06085, 1.00879, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 1.1406, 1.02285, 0.97138, 1.08692, 0.8007, 1.02285, 1, 1, 1.00527, 0.83693, 1.02285, 1, 1, 0.83693, 0.9455, 0.83693, 0.90418, 0.83693, 1.13005, 1.09398, 0.99041, 1, 1, 1.09398, 0.99041, 0.96692, 1.09251, 0.99041, 0.97489, 1.0008, 0.97489, 1.0008, 0.97489, 1.0008, 0.93994, 0.97931, 0.90399, 1.02258, 1, 1, 0.90399, 1.02258, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 0.84041, 0.79104, 1, 1, 0.95923, 1.07034, 0.95923, 1.16862, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.00135, 0.99041, 1.06467, 1.02511, 0.90996, 0.96752, 0.90996, 0.99361, 0.95801, 0.99361, 0.95801, 0.99361, 0.95801, 1.07733, 1.03424, 0.97363, 0.96752, 0.93506, 0.93136, 0.97489, 1.0008, 1, 1, 0.95923, 1.16862, 1.15103, 1.15103, 1.01173, 1.03959, 0.75953, 0.81378, 0.79912, 1.15103, 1.21994, 0.95161, 0.87815, 1.01149, 0.81525, 0.7676, 0.98167, 1.01134, 1.02546, 0.84097, 1.03089, 1.18102, 0.97363, 0.88776, 0.85134, 0.97826, 0.79795, 0.99361, 1.06085, 0.97489, 1.1406, 0.89858, 1.0388, 1.14889, 1.09398, 0.86039, 0.97489, 1.0595, 0.92094, 0.94793, 0.95923, 0.90996, 0.99346, 0.98243, 1.02112, 0.95493, 1.1406, 0.90996, 1.03574, 1.02597, 1.0008, 1.18102, 1.06628, 1.03574, 1.0192, 1.01932, 1.00886, 0.97531, 1.0106, 1.0008, 1.13189, 1.18102, 1.02277, 0.98683, 1.0016, 0.99561, 1.07237, 1.0008, 0.90434, 0.99921, 0.93803, 0.8965, 1.23085, 1.06628, 1.04983, 0.96268, 1.0499, 0.98439, 1.18102, 1.06628, 1.0008, 1.06628, 0.98439, 0.79795, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09466, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.97278, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.02065, 1, 1, 1, 1, 1, 1, 1.06467, 1.02511, 1.06467, 1.02511, 1.06467, 1.02511, 0.90996, 0.96752, 1, 1.21408, 0.89903, 1, 1, 0.75155, 1.04394, 1.04394, 1.04394, 1.04394, 0.98633, 0.98633, 0.98633, 0.73047, 0.73047, 1.20642, 0.91211, 1.25635, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.12454, 0.93503, 1.03424, 1.19687, 1.03424, 1, 1, 1, 0.771, 1, 1, 1.15749, 1.15749, 1.15749, 1.10948, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.16897, 1, 0.96085, 0.90137, 1.2107, 1.18416, 1.13973, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21172, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18874, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.09193, 1.09193, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], s1 = {
  lineHeight: 1.33008,
  lineGap: 0
}, a1 = [1.76738, 1, 1, 0.98946, 1.03959, 1.04016, 1.02809, 1.036, 0.97639, 1.10953, 1.23203, 1.11144, 1.11144, 1.16939, 1.21237, 0.9754, 1.21261, 0.9754, 1.59754, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 1.036, 0.81378, 0.81378, 1.21237, 1.21237, 1.21237, 0.73541, 0.97847, 0.97363, 0.89723, 0.87897, 1.0426, 0.79429, 0.85292, 0.91149, 1.05815, 1.1406, 0.79631, 0.90128, 0.83853, 1.04396, 1.10615, 0.97552, 0.94436, 0.97552, 0.88641, 0.80527, 0.96083, 1.00135, 1, 1.06777, 0.9817, 0.91142, 0.99361, 1.11144, 1.57293, 1.11144, 1.21237, 0.74627, 1.31818, 1.06585, 0.97042, 0.83055, 0.97042, 0.93503, 1.1261, 0.97042, 0.97922, 1.14236, 0.94552, 1.01054, 1.14236, 1.02471, 0.97922, 0.94165, 0.97042, 0.97042, 1.0276, 0.78929, 1.1261, 0.97922, 0.95874, 1.02197, 0.98507, 0.96752, 0.97168, 0.95107, 1.16579, 0.95107, 1.21237, 1.03959, 1.036, 1.036, 1, 1.036, 1.16579, 0.87357, 1.31818, 1.18754, 1.26781, 1.05356, 1.21237, 1.18622, 0.79487, 0.94994, 1.29004, 1.24047, 1.24047, 1.31818, 1, 0.91484, 0.9754, 1.31818, 1.1349, 1.24866, 1.05356, 1.13934, 1.15574, 1.17389, 0.73541, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.97363, 0.94385, 0.87897, 0.79429, 0.79429, 0.79429, 0.79429, 1.1406, 1.1406, 1.1406, 1.1406, 1.0426, 1.10615, 0.97552, 0.97552, 0.97552, 0.97552, 0.97552, 1.21237, 0.97552, 1.00135, 1.00135, 1.00135, 1.00135, 0.91142, 0.94436, 0.98721, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 1.06585, 0.96705, 0.83055, 0.93503, 0.93503, 0.93503, 0.93503, 1.14236, 1.14236, 1.14236, 1.14236, 0.93125, 0.97922, 0.94165, 0.94165, 0.94165, 0.94165, 0.94165, 1.29004, 0.94165, 0.97922, 0.97922, 0.97922, 0.97922, 0.96752, 0.97042, 0.96752, 0.97363, 1.06585, 0.97363, 1.06585, 0.97363, 1.06585, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 0.87897, 0.83055, 1.0426, 1.0033, 1.0426, 0.97042, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.79429, 0.93503, 0.91149, 0.97042, 0.91149, 0.97042, 0.91149, 0.97042, 1, 1, 1.05815, 0.97922, 1.05815, 0.97922, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 1.1406, 1.14236, 0.97441, 1.04302, 0.79631, 1.01582, 1, 1, 1.01054, 0.83853, 1.14236, 1, 1, 0.83853, 1.09125, 0.83853, 0.90418, 0.83853, 1.19508, 1.10615, 0.97922, 1, 1, 1.10615, 0.97922, 1.01034, 1.10466, 0.97922, 0.97552, 0.94165, 0.97552, 0.94165, 0.97552, 0.94165, 0.91602, 0.91981, 0.88641, 1.0276, 1, 1, 0.88641, 1.0276, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 0.80527, 0.78929, 1, 1, 0.96083, 1.05403, 0.95923, 1.16862, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.00135, 0.97922, 1.06777, 1.02197, 0.91142, 0.96752, 0.91142, 0.99361, 0.97168, 0.99361, 0.97168, 0.99361, 0.97168, 1.23199, 1.036, 0.97363, 1.06585, 0.94385, 0.96705, 0.97552, 0.94165, 1, 1, 0.96083, 1.1261, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 1.31818, 0.95161, 1.27126, 1.00811, 0.83284, 0.77702, 0.99137, 0.95253, 1.0347, 0.86142, 1.07205, 1.14236, 0.97363, 0.89723, 0.86869, 1.09818, 0.79429, 0.99361, 1.05815, 0.97552, 1.1406, 0.90128, 1.06662, 1.04396, 1.10615, 0.84918, 0.97552, 1.04694, 0.94436, 0.98015, 0.96083, 0.91142, 1.00356, 0.9817, 1.01945, 0.98999, 1.1406, 0.91142, 1.04961, 0.9898, 1.00639, 1.14236, 1.07514, 1.04961, 0.99607, 1.02897, 1.008, 0.9898, 0.95134, 1.00639, 1.11121, 1.14236, 1.00518, 0.97981, 1.02186, 1, 1.08578, 0.94165, 0.99314, 0.98387, 0.93028, 0.93377, 1.35125, 1.07514, 1.10687, 0.93491, 1.04232, 1.00351, 1.14236, 1.07514, 0.94165, 1.07514, 1.00351, 0.79429, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.09097, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.93503, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.96609, 1, 1, 1, 1, 1, 1, 1.06777, 1.02197, 1.06777, 1.02197, 1.06777, 1.02197, 0.91142, 0.96752, 1, 1.21261, 0.89903, 1, 1, 0.75155, 1.04745, 1.04745, 1.04745, 1.04394, 0.98633, 0.98633, 0.98633, 0.72959, 0.72959, 1.20502, 0.91406, 1.26514, 1.222, 1.02956, 1.03372, 1.03372, 0.96039, 1.24633, 1, 1.09125, 0.93327, 1.03336, 1.16541, 1.036, 1, 1, 1, 0.771, 1, 1, 1.15574, 1.15574, 1.15574, 1.15574, 0.86364, 0.94434, 0.86279, 0.94434, 0.86224, 1, 1, 1.16798, 1, 0.96085, 0.90068, 1.21237, 1.18416, 1.13904, 0.69825, 0.9716, 2.10339, 1.29004, 1.29004, 1.21339, 1.29004, 1.29004, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18775, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.13269, 1.13269, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], n1 = {
  lineHeight: 1.33008,
  lineGap: 0
}, r1 = [1.76738, 1, 1, 0.98946, 1.14763, 1.05365, 1.06234, 0.96927, 0.92586, 1.15373, 1.18414, 0.91349, 0.91349, 1.07403, 1.17308, 0.78383, 1.20088, 0.78383, 1.42531, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78383, 0.78383, 1.17308, 1.17308, 1.17308, 0.77349, 0.94565, 0.94729, 0.85944, 0.88506, 0.9858, 0.74817, 0.80016, 0.88449, 0.98039, 0.95782, 0.69238, 0.89898, 0.83231, 0.98183, 1.03989, 0.96924, 0.86237, 0.96924, 0.80595, 0.74524, 0.86091, 0.95402, 0.94143, 0.98448, 0.8858, 0.83089, 0.93285, 1.0949, 1.39016, 1.0949, 1.45994, 0.74627, 1.04839, 0.97454, 0.97454, 0.87207, 0.97454, 0.87533, 1.06151, 0.97454, 1.00176, 1.16484, 1.08132, 0.98047, 1.16484, 1.02989, 1.01054, 0.96225, 0.97454, 0.97454, 1.06598, 0.79004, 1.16344, 1.00351, 0.94629, 0.9973, 0.91016, 0.96777, 0.9043, 0.91082, 0.92481, 0.91082, 1.17308, 0.95748, 0.96927, 0.96927, 1, 0.96927, 0.92481, 0.80597, 1.04839, 1.23393, 1.1781, 0.9245, 1.17308, 1.20808, 0.63218, 0.94261, 1.24822, 1.09971, 1.09971, 1.04839, 1, 0.85273, 0.78032, 1.04839, 1.09971, 1.22326, 0.9245, 1.09836, 1.13525, 1.15222, 0.70424, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.94729, 0.85498, 0.88506, 0.74817, 0.74817, 0.74817, 0.74817, 0.95782, 0.95782, 0.95782, 0.95782, 0.9858, 1.03989, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.17308, 0.96924, 0.95402, 0.95402, 0.95402, 0.95402, 0.83089, 0.86237, 0.88409, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.97454, 0.92916, 0.87207, 0.87533, 0.87533, 0.87533, 0.87533, 0.93146, 0.93146, 0.93146, 0.93146, 0.93854, 1.01054, 0.96225, 0.96225, 0.96225, 0.96225, 0.96225, 1.24822, 0.8761, 1.00351, 1.00351, 1.00351, 1.00351, 0.96777, 0.97454, 0.96777, 0.94729, 0.97454, 0.94729, 0.97454, 0.94729, 0.97454, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.88506, 0.87207, 0.9858, 0.95391, 0.9858, 0.97454, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.74817, 0.87533, 0.88449, 0.97454, 0.88449, 0.97454, 0.88449, 0.97454, 1, 1, 0.98039, 1.00176, 0.98039, 1.00176, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 0.93146, 0.95782, 1.16484, 0.95782, 0.93146, 0.84421, 1.12761, 0.69238, 1.08132, 1, 1, 0.98047, 0.83231, 1.16484, 1, 1, 0.84723, 1.04861, 0.84723, 0.78755, 0.83231, 1.23736, 1.03989, 1.01054, 1, 1, 1.03989, 1.01054, 0.9857, 1.03849, 1.01054, 0.96924, 0.96225, 0.96924, 0.96225, 0.96924, 0.96225, 0.92383, 0.90171, 0.80595, 1.06598, 1, 1, 0.80595, 1.06598, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 0.74524, 0.79004, 1, 1, 0.86091, 1.02759, 0.85771, 1.16344, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.95402, 1.00351, 0.98448, 0.9973, 0.83089, 0.96777, 0.83089, 0.93285, 0.9043, 0.93285, 0.9043, 0.93285, 0.9043, 1.31868, 0.96927, 0.94729, 0.97454, 0.85498, 0.92916, 0.96924, 0.8761, 1, 1, 0.86091, 1.16344, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 1.04839, 0.81965, 0.81965, 0.94729, 0.78032, 0.71022, 0.90883, 0.84171, 0.99877, 0.77596, 1.05734, 1.2, 0.94729, 0.85944, 0.82791, 0.9607, 0.74817, 0.93285, 0.98039, 0.96924, 0.95782, 0.89898, 0.98316, 0.98183, 1.03989, 0.78614, 0.96924, 0.97642, 0.86237, 0.86075, 0.86091, 0.83089, 0.90082, 0.8858, 0.97296, 1.01284, 0.95782, 0.83089, 1.0976, 1.04, 1.03342, 1.2, 1.0675, 1.0976, 0.98205, 1.03809, 1.05097, 1.04, 0.95364, 1.03342, 1.05401, 1.2, 1.02148, 1.0119, 1.04724, 1.0127, 1.02732, 0.96225, 0.8965, 0.97783, 0.93574, 0.94818, 1.30679, 1.0675, 1.11826, 0.99821, 1.0557, 1.0326, 1.2, 1.0675, 0.96225, 1.0675, 1.0326, 0.74817, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03754, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.87533, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.98705, 1, 1, 1, 1, 1, 1, 0.98448, 0.9973, 0.98448, 0.9973, 0.98448, 0.9973, 0.83089, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 0.94945, 0.94945, 0.94945, 0.94945, 1.12317, 1.12317, 1.12317, 0.67603, 0.67603, 1.15621, 0.73584, 1.21191, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87709, 0.96927, 1.01473, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.09836, 1.09836, 1.09836, 1.01522, 0.86321, 0.94434, 0.8649, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86438, 1.17308, 1.18416, 1.14589, 0.69825, 0.97622, 1.96791, 1.24822, 1.24822, 1.17308, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.17984, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10742, 1.10742, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], g1 = {
  lineHeight: 1.33008,
  lineGap: 0
}, o1 = [1.76738, 1, 1, 0.98594, 1.02285, 1.10454, 1.06234, 0.96927, 0.92037, 1.19985, 1.2046, 0.90616, 0.90616, 1.07152, 1.1714, 0.78032, 1.20088, 0.78032, 1.40246, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.96927, 0.78032, 0.78032, 1.1714, 1.1714, 1.1714, 0.80597, 0.94084, 0.96706, 0.85944, 0.85734, 0.97093, 0.75842, 0.79936, 0.88198, 0.9831, 0.95782, 0.71387, 0.86969, 0.84636, 1.07796, 1.03584, 0.96924, 0.83968, 0.96924, 0.82826, 0.79649, 0.85771, 0.95132, 0.93119, 0.98965, 0.88433, 0.8287, 0.93365, 1.08612, 1.3638, 1.08612, 1.45786, 0.74627, 0.80499, 0.91484, 1.05707, 0.92383, 1.05882, 0.9403, 1.12654, 1.05882, 1.01756, 1.09011, 1.09011, 0.99414, 1.09011, 1.034, 1.01756, 1.05356, 1.05707, 1.05882, 1.04399, 0.84863, 1.21968, 1.01756, 0.95801, 1.00068, 0.91797, 0.96777, 0.9043, 0.90351, 0.92105, 0.90351, 1.1714, 0.85337, 0.96927, 0.96927, 0.99912, 0.96927, 0.92105, 0.80597, 1.2434, 1.20808, 1.05937, 0.90957, 1.1714, 1.20808, 0.75155, 0.94261, 1.24644, 1.09971, 1.09971, 0.84751, 1, 0.85273, 0.78032, 0.61584, 1.05425, 1.17914, 0.90957, 1.08665, 1.11593, 1.14169, 0.73381, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.96706, 0.86035, 0.85734, 0.75842, 0.75842, 0.75842, 0.75842, 0.95782, 0.95782, 0.95782, 0.95782, 0.97093, 1.03584, 0.96924, 0.96924, 0.96924, 0.96924, 0.96924, 1.1714, 0.96924, 0.95132, 0.95132, 0.95132, 0.95132, 0.8287, 0.83968, 0.89049, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.91484, 0.93575, 0.92383, 0.9403, 0.9403, 0.9403, 0.9403, 0.8717, 0.8717, 0.8717, 0.8717, 1.00527, 1.01756, 1.05356, 1.05356, 1.05356, 1.05356, 1.05356, 1.24644, 0.95923, 1.01756, 1.01756, 1.01756, 1.01756, 0.96777, 1.05707, 0.96777, 0.96706, 0.91484, 0.96706, 0.91484, 0.96706, 0.91484, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.85734, 0.92383, 0.97093, 1.0969, 0.97093, 1.05882, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.75842, 0.9403, 0.88198, 1.05882, 0.88198, 1.05882, 0.88198, 1.05882, 1, 1, 0.9831, 1.01756, 0.9831, 1.01756, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 0.8717, 0.95782, 1.09011, 0.95782, 0.8717, 0.84784, 1.11551, 0.71387, 1.09011, 1, 1, 0.99414, 0.84636, 1.09011, 1, 1, 0.84636, 1.0536, 0.84636, 0.94298, 0.84636, 1.23297, 1.03584, 1.01756, 1, 1, 1.03584, 1.01756, 1.00323, 1.03444, 1.01756, 0.96924, 1.05356, 0.96924, 1.05356, 0.96924, 1.05356, 0.93066, 0.98293, 0.82826, 1.04399, 1, 1, 0.82826, 1.04399, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 0.79649, 0.84863, 1, 1, 0.85771, 1.17318, 0.85771, 1.21968, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.95132, 1.01756, 0.98965, 1.00068, 0.8287, 0.96777, 0.8287, 0.93365, 0.9043, 0.93365, 0.9043, 0.93365, 0.9043, 1.08571, 0.96927, 0.96706, 0.91484, 0.86035, 0.93575, 0.96924, 0.95923, 1, 1, 0.85771, 1.21968, 1.11437, 1.11437, 0.93109, 0.91202, 0.60411, 0.84164, 0.55572, 1.01173, 0.97361, 0.81818, 0.81818, 0.96635, 0.78032, 0.72727, 0.92366, 0.98601, 1.03405, 0.77968, 1.09799, 1.2, 0.96706, 0.85944, 0.85638, 0.96491, 0.75842, 0.93365, 0.9831, 0.96924, 0.95782, 0.86969, 0.94152, 1.07796, 1.03584, 0.78437, 0.96924, 0.98715, 0.83968, 0.83491, 0.85771, 0.8287, 0.94492, 0.88433, 0.9287, 1.0098, 0.95782, 0.8287, 1.0625, 0.98248, 1.03424, 1.2, 1.01071, 1.0625, 0.95246, 1.03809, 1.04912, 0.98248, 1.00221, 1.03424, 1.05443, 1.2, 1.04785, 0.99609, 1.00169, 1.05176, 0.99346, 1.05356, 0.9087, 1.03004, 0.95542, 0.93117, 1.23362, 1.01071, 1.07831, 1.02512, 1.05205, 1.03502, 1.2, 1.01071, 1.05356, 1.01071, 1.03502, 0.75842, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.03719, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9403, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.04021, 1, 1, 1, 1, 1, 1, 0.98965, 1.00068, 0.98965, 1.00068, 0.98965, 1.00068, 0.8287, 0.96777, 1, 1.20088, 0.89903, 1, 1, 0.75155, 1.03077, 1.03077, 1.03077, 1.03077, 1.13196, 1.13196, 1.13196, 0.67428, 0.67428, 1.16039, 0.73291, 1.20996, 1.22135, 1.06483, 0.94868, 0.94868, 0.95996, 1.24633, 1, 1.07497, 0.87796, 0.96927, 1.01518, 0.96927, 1, 1, 1, 0.77295, 1, 1, 1.10539, 1.10539, 1.11358, 1.06967, 0.86279, 0.94434, 0.86279, 0.94434, 0.86182, 1, 1, 1.083, 1, 0.91578, 0.86507, 1.1714, 1.18416, 1.14589, 0.69825, 0.97622, 1.9697, 1.24822, 1.24822, 1.17238, 1.24822, 1.24822, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.42603, 1, 0.99862, 0.99862, 1, 0.87025, 0.87025, 0.87025, 0.87025, 1.18083, 1.42603, 1, 1.42603, 1.42603, 0.99862, 1, 1, 1, 1, 1, 1.2886, 1.04315, 1.15296, 1.34163, 1, 1, 1, 1.10938, 1.10938, 1, 1, 1, 1.05425, 1.09971, 1.09971, 1.09971, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], I1 = {
  lineHeight: 1.33008,
  lineGap: 0
}, c1 = le(function(e) {
  e["MyriadPro-Regular"] = e["PdfJS-Fallback-Regular"] = {
    name: "LiberationSans-Regular",
    factors: e1,
    baseWidths: bs,
    baseMapping: Ds,
    metrics: t1
  }, e["MyriadPro-Bold"] = e["PdfJS-Fallback-Bold"] = {
    name: "LiberationSans-Bold",
    factors: jQ,
    baseWidths: ds,
    baseMapping: xs,
    metrics: XQ
  }, e["MyriadPro-It"] = e["MyriadPro-Italic"] = e["PdfJS-Fallback-Italic"] = {
    name: "LiberationSans-Italic",
    factors: $Q,
    baseWidths: ys,
    baseMapping: ws,
    metrics: A1
  }, e["MyriadPro-BoldIt"] = e["MyriadPro-BoldItalic"] = e["PdfJS-Fallback-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: _Q,
    baseWidths: ms,
    baseMapping: ps,
    metrics: zQ
  }, e.ArialMT = e.Arial = e["Arial-Regular"] = {
    name: "LiberationSans-Regular",
    baseWidths: bs,
    baseMapping: Ds
  }, e["Arial-BoldMT"] = e["Arial-Bold"] = {
    name: "LiberationSans-Bold",
    baseWidths: ds,
    baseMapping: xs
  }, e["Arial-ItalicMT"] = e["Arial-Italic"] = {
    name: "LiberationSans-Italic",
    baseWidths: ys,
    baseMapping: ws
  }, e["Arial-BoldItalicMT"] = e["Arial-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    baseWidths: ms,
    baseMapping: ps
  }, e["Calibri-Regular"] = {
    name: "LiberationSans-Regular",
    factors: YQ,
    baseWidths: bs,
    baseMapping: Ds,
    metrics: KQ
  }, e["Calibri-Bold"] = {
    name: "LiberationSans-Bold",
    factors: NQ,
    baseWidths: ds,
    baseMapping: xs,
    metrics: MQ
  }, e["Calibri-Italic"] = {
    name: "LiberationSans-Italic",
    factors: HQ,
    baseWidths: ys,
    baseMapping: ws,
    metrics: JQ
  }, e["Calibri-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: UQ,
    baseWidths: ms,
    baseMapping: ps,
    metrics: LQ
  }, e["Segoeui-Regular"] = {
    name: "LiberationSans-Regular",
    factors: o1,
    baseWidths: bs,
    baseMapping: Ds,
    metrics: I1
  }, e["Segoeui-Bold"] = {
    name: "LiberationSans-Bold",
    factors: i1,
    baseWidths: ds,
    baseMapping: xs,
    metrics: s1
  }, e["Segoeui-Italic"] = {
    name: "LiberationSans-Italic",
    factors: r1,
    baseWidths: ys,
    baseMapping: ws,
    metrics: g1
  }, e["Segoeui-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: a1,
    baseWidths: ms,
    baseMapping: ps,
    metrics: n1
  }, e["Helvetica-Regular"] = e.Helvetica = {
    name: "LiberationSans-Regular",
    factors: VQ,
    baseWidths: bs,
    baseMapping: Ds,
    metrics: ZQ
  }, e["Helvetica-Bold"] = {
    name: "LiberationSans-Bold",
    factors: vQ,
    baseWidths: ds,
    baseMapping: xs,
    metrics: TQ
  }, e["Helvetica-Italic"] = {
    name: "LiberationSans-Italic",
    factors: WQ,
    baseWidths: ys,
    baseMapping: ws,
    metrics: OQ
  }, e["Helvetica-BoldItalic"] = {
    name: "LiberationSans-BoldItalic",
    factors: qQ,
    baseWidths: ms,
    baseMapping: ps,
    metrics: PQ
  };
});
function to(e) {
  const A = wa(e);
  return c1()[A];
}
function l1(e) {
  const A = to(e);
  if (!A)
    return null;
  const {
    baseWidths: t,
    baseMapping: i,
    factors: s
  } = A, a = s ? t.map((o, I) => o * s[I]) : t;
  let n = -2, r;
  const g = [];
  for (const [o, I] of i.map((c, l) => [c, l]).sort(([c], [l]) => c - l))
    o !== -1 && (o === n + 1 ? (r.push(a[I]), n += 1) : (n = o, r = [a[I]], g.push(o, r)));
  return g;
}
function $c(e) {
  const A = l1(e), t = new R(null);
  t.set("BaseFont", L.get(e)), t.set("Type", L.get("Font")), t.set("Subtype", L.get("CIDFontType2")), t.set("Encoding", L.get("Identity-H")), t.set("CIDToGIDMap", L.get("Identity")), t.set("W", A), t.set("FirstChar", A[0]), t.set("LastChar", A.at(-2) + A.at(-1).length - 1);
  const i = new R(null);
  t.set("FontDescriptor", i);
  const s = new R(null);
  return s.set("Ordering", "Identity"), s.set("Registry", "Adobe"), s.set("Supplement", 0), t.set("CIDSystemInfo", s), t;
}
class h1 {
  constructor(A) {
    this.lexer = A, this.operators = [], this.token = null, this.prev = null;
  }
  nextToken() {
    this.prev = this.token, this.token = this.lexer.getToken();
  }
  accept(A) {
    return this.token.type === A ? (this.nextToken(), !0) : !1;
  }
  expect(A) {
    if (this.accept(A))
      return !0;
    throw new v(`Unexpected symbol: found ${this.token.type} expected ${A}.`);
  }
  parse() {
    return this.nextToken(), this.expect(Xe.LBRACE), this.parseBlock(), this.expect(Xe.RBRACE), this.operators;
  }
  parseBlock() {
    for (; ; )
      if (this.accept(Xe.NUMBER))
        this.operators.push(this.prev.value);
      else if (this.accept(Xe.OPERATOR))
        this.operators.push(this.prev.value);
      else if (this.accept(Xe.LBRACE))
        this.parseCondition();
      else
        return;
  }
  parseCondition() {
    const A = this.operators.length;
    if (this.operators.push(null, null), this.parseBlock(), this.expect(Xe.RBRACE), this.accept(Xe.IF))
      this.operators[A] = this.operators.length, this.operators[A + 1] = "jz";
    else if (this.accept(Xe.LBRACE)) {
      const t = this.operators.length;
      this.operators.push(null, null);
      const i = this.operators.length;
      this.parseBlock(), this.expect(Xe.RBRACE), this.expect(Xe.IFELSE), this.operators[t] = this.operators.length, this.operators[t + 1] = "j", this.operators[A] = i, this.operators[A + 1] = "jz";
    } else
      throw new v("PS Function: error parsing conditional.");
  }
}
const Xe = {
  LBRACE: 0,
  RBRACE: 1,
  NUMBER: 2,
  OPERATOR: 3,
  IF: 4,
  IFELSE: 5
};
class dt {
  static get opCache() {
    return iA(this, "opCache", /* @__PURE__ */ Object.create(null));
  }
  constructor(A, t) {
    this.type = A, this.value = t;
  }
  static getOperator(A) {
    var t;
    return (t = dt.opCache)[A] || (t[A] = new dt(Xe.OPERATOR, A));
  }
  static get LBRACE() {
    return iA(this, "LBRACE", new dt(Xe.LBRACE, "{"));
  }
  static get RBRACE() {
    return iA(this, "RBRACE", new dt(Xe.RBRACE, "}"));
  }
  static get IF() {
    return iA(this, "IF", new dt(Xe.IF, "IF"));
  }
  static get IFELSE() {
    return iA(this, "IFELSE", new dt(Xe.IFELSE, "IFELSE"));
  }
}
class C1 {
  constructor(A) {
    this.stream = A, this.nextChar(), this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  getToken() {
    let A = !1, t = this.currentChar;
    for (; ; ) {
      if (t < 0)
        return Le;
      if (A)
        (t === 10 || t === 13) && (A = !1);
      else if (t === 37)
        A = !0;
      else if (!mt(t))
        break;
      t = this.nextChar();
    }
    switch (t | 0) {
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 43:
      case 45:
      case 46:
        return new dt(Xe.NUMBER, this.getNumber());
      case 123:
        return this.nextChar(), dt.LBRACE;
      case 125:
        return this.nextChar(), dt.RBRACE;
    }
    const i = this.strBuf;
    for (i.length = 0, i[0] = String.fromCharCode(t); (t = this.nextChar()) >= 0 && (t >= 65 && t <= 90 || t >= 97 && t <= 122); )
      i.push(String.fromCharCode(t));
    const s = i.join("");
    switch (s.toLowerCase()) {
      case "if":
        return dt.IF;
      case "ifelse":
        return dt.IFELSE;
      default:
        return dt.getOperator(s);
    }
  }
  getNumber() {
    let A = this.currentChar;
    const t = this.strBuf;
    for (t.length = 0, t[0] = String.fromCharCode(A); (A = this.nextChar()) >= 0 && (A >= 48 && A <= 57 || A === 45 || A === 46); )
      t.push(String.fromCharCode(A));
    const i = parseFloat(t.join(""));
    if (isNaN(i))
      throw new v(`Invalid floating point number: ${i}`);
    return i;
  }
}
class cs {
  constructor(A) {
    this._onlyRefs = (A == null ? void 0 : A.onlyRefs) === !0, this._onlyRefs || (this._nameRefMap = /* @__PURE__ */ new Map(), this._imageMap = /* @__PURE__ */ new Map()), this._imageCache = new ot();
  }
  getByName(A) {
    this._onlyRefs && WA("Should not call `getByName` method.");
    const t = this._nameRefMap.get(A);
    return t ? this.getByRef(t) : this._imageMap.get(A) || null;
  }
  getByRef(A) {
    return this._imageCache.get(A) || null;
  }
  set(A, t, i) {
    WA("Abstract method `set` called.");
  }
}
class yI extends cs {
  set(A, t = null, i) {
    if (typeof A != "string")
      throw new Error('LocalImageCache.set - expected "name" argument.');
    if (t) {
      if (this._imageCache.has(t))
        return;
      this._nameRefMap.set(A, t), this._imageCache.put(t, i);
      return;
    }
    this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class Al extends cs {
  set(A = null, t = null, i) {
    if (typeof A != "string" && !t)
      throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
    if (t) {
      if (this._imageCache.has(t))
        return;
      A !== null && this._nameRefMap.set(A, t), this._imageCache.put(t, i);
      return;
    }
    this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class B1 extends cs {
  constructor(A) {
    super({
      onlyRefs: !0
    });
  }
  set(A = null, t, i) {
    if (!t)
      throw new Error('LocalFunctionCache.set - expected "ref" argument.');
    this._imageCache.has(t) || this._imageCache.put(t, i);
  }
}
class wI extends cs {
  set(A, t = null, i) {
    if (typeof A != "string")
      throw new Error('LocalGStateCache.set - expected "name" argument.');
    if (t) {
      if (this._imageCache.has(t))
        return;
      this._nameRefMap.set(A, t), this._imageCache.put(t, i);
      return;
    }
    this._imageMap.has(A) || this._imageMap.set(A, i);
  }
}
class Q1 extends cs {
  constructor(A) {
    super({
      onlyRefs: !0
    });
  }
  set(A = null, t, i) {
    if (!t)
      throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
    this._imageCache.has(t) || this._imageCache.put(t, i);
  }
}
class E1 extends cs {
  constructor(A) {
    super({
      onlyRefs: !0
    });
  }
  set(A = null, t, i) {
    if (!t)
      throw new Error('RegionalImageCache.set - expected "ref" argument.');
    this._imageCache.has(t) || this._imageCache.put(t, i);
  }
}
var z0, f0, el, ug;
const ci = class ci {
  constructor() {
    ZA(this, f0);
    ZA(this, z0, new Ne());
    this._refCache = new ot(), this._imageCache = new ot();
  }
  shouldCache(A, t) {
    let i = this._refCache.get(A);
    return i || (i = /* @__PURE__ */ new Set(), this._refCache.put(A, i)), i.add(t), !(i.size < ci.NUM_PAGES_THRESHOLD || !this._imageCache.has(A) && PA(this, f0, ug));
  }
  addDecodeFailed(A) {
    PA(this, z0).put(A);
  }
  hasDecodeFailed(A) {
    return PA(this, z0).has(A);
  }
  addByteSize(A, t) {
    const i = this._imageCache.get(A);
    i && (i.byteSize || (i.byteSize = t));
  }
  getData(A, t) {
    const i = this._refCache.get(A);
    if (!i || i.size < ci.NUM_PAGES_THRESHOLD)
      return null;
    const s = this._imageCache.get(A);
    return s ? (i.add(t), s) : null;
  }
  setData(A, t) {
    if (!this._refCache.has(A))
      throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
    if (!this._imageCache.has(A)) {
      if (PA(this, f0, ug)) {
        k("GlobalImageCache.setData - cache limit reached.");
        return;
      }
      this._imageCache.put(A, t);
    }
  }
  clear(A = !1) {
    A || (PA(this, z0).clear(), this._refCache.clear()), this._imageCache.clear();
  }
};
z0 = new WeakMap(), f0 = new WeakSet(), el = function() {
  let A = 0;
  for (const t of this._imageCache)
    A += t.byteSize;
  return A;
}, ug = function() {
  return !(this._imageCache.size < ci.MIN_IMAGES_TO_CACHE || PA(this, f0, el) < ci.MAX_BYTE_SIZE);
}, Me(ci, "NUM_PAGES_THRESHOLD", 2), Me(ci, "MIN_IMAGES_TO_CACHE", 10), Me(ci, "MAX_BYTE_SIZE", 5 * Uh);
let fg = ci;
class tl {
  constructor({
    xref: A,
    isEvalSupported: t = !0
  }) {
    this.xref = A, this.isEvalSupported = t !== !1;
  }
  create(A) {
    const t = this.getCached(A);
    if (t)
      return t;
    const i = bI.parse({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fn: A instanceof nA ? this.xref.fetch(A) : A
    });
    return this._cache(A, i), i;
  }
  createFromArray(A) {
    const t = this.getCached(A);
    if (t)
      return t;
    const i = bI.parseArray({
      xref: this.xref,
      isEvalSupported: this.isEvalSupported,
      fnObj: A instanceof nA ? this.xref.fetch(A) : A
    });
    return this._cache(A, i), i;
  }
  getCached(A) {
    var i;
    let t;
    if (A instanceof nA ? t = A : A instanceof R ? t = A.objId : A instanceof JA && (t = (i = A.dict) == null ? void 0 : i.objId), t) {
      const s = this._localFunctionCache.getByRef(t);
      if (s)
        return s;
    }
    return null;
  }
  _cache(A, t) {
    var s;
    if (!t)
      throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
    let i;
    A instanceof nA ? i = A : A instanceof R ? i = A.objId : A instanceof JA && (i = (s = A.dict) == null ? void 0 : s.objId), i && this._localFunctionCache.set(null, i, t);
  }
  get _localFunctionCache() {
    return iA(this, "_localFunctionCache", new B1());
  }
}
function bt(e) {
  return Array.isArray(e) ? at(e, null) ? e : e.map((A) => +A) : null;
}
class bI {
  static getSampleArray(A, t, i, s) {
    let a, n, r = 1;
    for (a = 0, n = A.length; a < n; a++)
      r *= A[a];
    r *= t;
    const g = new Array(r);
    let o = 0, I = 0;
    const c = 1 / (2 ** i - 1), l = s.getBytes((r * i + 7) / 8);
    let h = 0;
    for (a = 0; a < r; a++) {
      for (; o < i; )
        I <<= 8, I |= l[h++], o += 8;
      o -= i, g[a] = (I >> o) * c, I &= (1 << o) - 1;
    }
    return g;
  }
  static parse({
    xref: A,
    isEvalSupported: t,
    fn: i
  }) {
    const s = i.dict || i;
    switch (s.get("FunctionType")) {
      case 0:
        return this.constructSampled({
          xref: A,
          isEvalSupported: t,
          fn: i,
          dict: s
        });
      case 1:
        break;
      case 2:
        return this.constructInterpolated({
          xref: A,
          isEvalSupported: t,
          dict: s
        });
      case 3:
        return this.constructStiched({
          xref: A,
          isEvalSupported: t,
          dict: s
        });
      case 4:
        return this.constructPostScript({
          xref: A,
          isEvalSupported: t,
          fn: i,
          dict: s
        });
    }
    throw new v("Unknown type of function");
  }
  static parseArray({
    xref: A,
    isEvalSupported: t,
    fnObj: i
  }) {
    if (!Array.isArray(i))
      return this.parse({
        xref: A,
        isEvalSupported: t,
        fn: i
      });
    const s = [];
    for (const a of i)
      s.push(this.parse({
        xref: A,
        isEvalSupported: t,
        fn: A.fetchIfRef(a)
      }));
    return function(a, n, r, g) {
      for (let o = 0, I = s.length; o < I; o++)
        s[o](a, n, r, g + o);
    };
  }
  static constructSampled({
    xref: A,
    isEvalSupported: t,
    fn: i,
    dict: s
  }) {
    function a(E) {
      const f = E.length, d = [];
      let u = 0;
      for (let x = 0; x < f; x += 2)
        d[u++] = [E[x], E[x + 1]];
      return d;
    }
    function n(E, f, d, u, x) {
      return u + (E - f) * ((x - u) / (d - f));
    }
    let r = bt(s.getArray("Domain")), g = bt(s.getArray("Range"));
    if (!r || !g)
      throw new v("No domain or range");
    const o = r.length / 2, I = g.length / 2;
    r = a(r), g = a(g);
    const c = bt(s.getArray("Size")), l = s.get("BitsPerSample"), h = s.get("Order") || 1;
    h !== 1 && vA("No support for cubic spline interpolation: " + h);
    let C = bt(s.getArray("Encode"));
    if (C)
      C = a(C);
    else {
      C = [];
      for (let E = 0; E < o; ++E)
        C.push([0, c[E] - 1]);
    }
    let B = bt(s.getArray("Decode"));
    B = B ? a(B) : g;
    const Q = this.getSampleArray(c, I, l, i);
    return function(f, d, u, x) {
      const m = 1 << o, p = new Float64Array(m), D = new Uint32Array(m);
      let F, y;
      for (y = 0; y < m; y++)
        p[y] = 1;
      let H = I, N = 1;
      for (F = 0; F < o; ++F) {
        const T = r[F][0], _ = r[F][1], oA = Math.min(Math.max(f[d + F], T), _);
        let G = n(oA, T, _, C[F][0], C[F][1]);
        const S = c[F];
        G = Math.min(Math.max(G, 0), S - 1);
        const tA = G < S - 1 ? Math.floor(G) : G - 1, $ = tA + 1 - G, hA = G - tA, yA = tA * H, pA = yA + H;
        for (y = 0; y < m; y++)
          y & N ? (p[y] *= hA, D[y] += pA) : (p[y] *= $, D[y] += yA);
        H *= S, N <<= 1;
      }
      for (y = 0; y < I; ++y) {
        let T = 0;
        for (F = 0; F < m; F++)
          T += Q[D[F] + y] * p[F];
        T = n(T, 0, 1, B[y][0], B[y][1]), u[x + y] = Math.min(Math.max(T, g[y][0]), g[y][1]);
      }
    };
  }
  static constructInterpolated({
    xref: A,
    isEvalSupported: t,
    dict: i
  }) {
    const s = bt(i.getArray("C0")) || [0], a = bt(i.getArray("C1")) || [1], n = i.get("N"), r = [];
    for (let o = 0, I = s.length; o < I; ++o)
      r.push(a[o] - s[o]);
    const g = r.length;
    return function(I, c, l, h) {
      const C = n === 1 ? I[c] : I[c] ** n;
      for (let B = 0; B < g; ++B)
        l[h + B] = s[B] + C * r[B];
    };
  }
  static constructStiched({
    xref: A,
    isEvalSupported: t,
    dict: i
  }) {
    const s = bt(i.getArray("Domain"));
    if (!s)
      throw new v("No domain");
    if (s.length / 2 !== 1)
      throw new v("Bad domain for stiched function");
    const n = [];
    for (const I of i.get("Functions"))
      n.push(this.parse({
        xref: A,
        isEvalSupported: t,
        fn: A.fetchIfRef(I)
      }));
    const r = bt(i.getArray("Bounds")), g = bt(i.getArray("Encode")), o = new Float32Array(1);
    return function(c, l, h, C) {
      const Q = function(D, F, y) {
        return D > y ? D = y : D < F && (D = F), D;
      }(c[l], s[0], s[1]), E = r.length;
      let f;
      for (f = 0; f < E && !(Q < r[f]); ++f)
        ;
      let d = s[0];
      f > 0 && (d = r[f - 1]);
      let u = s[1];
      f < r.length && (u = r[f]);
      const x = g[2 * f], m = g[2 * f + 1];
      o[0] = d === u ? x : x + (Q - d) * (m - x) / (u - d), n[f](o, 0, h, C);
    };
  }
  static constructPostScript({
    xref: A,
    isEvalSupported: t,
    fn: i,
    dict: s
  }) {
    const a = bt(s.getArray("Domain")), n = bt(s.getArray("Range"));
    if (!a)
      throw new v("No domain.");
    if (!n)
      throw new v("No range.");
    const r = new C1(i), o = new h1(r).parse();
    if (t && ht.isEvalSupported) {
      const E = new w1().compile(o, a, n);
      if (E)
        return new Function("src", "srcOffset", "dest", "destOffset", E);
    }
    vA("Unable to compile PS function");
    const I = n.length >> 1, c = a.length >> 1, l = new f1(o), h = /* @__PURE__ */ Object.create(null);
    let B = 2048 * 4;
    const Q = new Float32Array(c);
    return function(f, d, u, x) {
      let m, p, D = "";
      const F = Q;
      for (m = 0; m < c; m++)
        p = f[d + m], F[m] = p, D += p + "_";
      const y = h[D];
      if (y !== void 0) {
        u.set(y, x);
        return;
      }
      const H = new Float32Array(I), N = l.execute(F), T = N.length - I;
      for (m = 0; m < I; m++) {
        p = N[T + m];
        let _ = n[m * 2];
        p < _ ? p = _ : (_ = n[m * 2 + 1], p > _ && (p = _)), H[m] = p;
      }
      B > 0 && (B--, h[D] = H), u.set(H, x);
    };
  }
}
function Mr(e) {
  let A;
  if (e instanceof R)
    A = e;
  else if (e instanceof JA)
    A = e.dict;
  else
    return !1;
  return A.has("FunctionType");
}
const qs = class qs {
  constructor(A) {
    this.stack = A ? Array.from(A) : [];
  }
  push(A) {
    if (this.stack.length >= qs.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    this.stack.push(A);
  }
  pop() {
    if (this.stack.length <= 0)
      throw new Error("PostScript function stack underflow.");
    return this.stack.pop();
  }
  copy(A) {
    if (this.stack.length + A >= qs.MAX_STACK_SIZE)
      throw new Error("PostScript function stack overflow.");
    const t = this.stack;
    for (let i = t.length - A, s = A - 1; s >= 0; s--, i++)
      t.push(t[i]);
  }
  index(A) {
    this.push(this.stack[this.stack.length - A - 1]);
  }
  roll(A, t) {
    const i = this.stack, s = i.length - A, a = i.length - 1, n = s + (t - Math.floor(t / A) * A);
    for (let r = s, g = a; r < g; r++, g--) {
      const o = i[r];
      i[r] = i[g], i[g] = o;
    }
    for (let r = s, g = n - 1; r < g; r++, g--) {
      const o = i[r];
      i[r] = i[g], i[g] = o;
    }
    for (let r = n, g = a; r < g; r++, g--) {
      const o = i[r];
      i[r] = i[g], i[g] = o;
    }
  }
};
Me(qs, "MAX_STACK_SIZE", 100);
let dg = qs;
class f1 {
  constructor(A) {
    this.operators = A;
  }
  execute(A) {
    const t = new dg(A);
    let i = 0;
    const s = this.operators, a = s.length;
    let n, r, g;
    for (; i < a; ) {
      if (n = s[i++], typeof n == "number") {
        t.push(n);
        continue;
      }
      switch (n) {
        case "jz":
          g = t.pop(), r = t.pop(), r || (i = g);
          break;
        case "j":
          r = t.pop(), i = r;
          break;
        case "abs":
          r = t.pop(), t.push(Math.abs(r));
          break;
        case "add":
          g = t.pop(), r = t.pop(), t.push(r + g);
          break;
        case "and":
          g = t.pop(), r = t.pop(), typeof r == "boolean" && typeof g == "boolean" ? t.push(r && g) : t.push(r & g);
          break;
        case "atan":
          g = t.pop(), r = t.pop(), r = Math.atan2(r, g) / Math.PI * 180, r < 0 && (r += 360), t.push(r);
          break;
        case "bitshift":
          g = t.pop(), r = t.pop(), r > 0 ? t.push(r << g) : t.push(r >> g);
          break;
        case "ceiling":
          r = t.pop(), t.push(Math.ceil(r));
          break;
        case "copy":
          r = t.pop(), t.copy(r);
          break;
        case "cos":
          r = t.pop(), t.push(Math.cos(r % 360 / 180 * Math.PI));
          break;
        case "cvi":
          r = t.pop() | 0, t.push(r);
          break;
        case "cvr":
          break;
        case "div":
          g = t.pop(), r = t.pop(), t.push(r / g);
          break;
        case "dup":
          t.copy(1);
          break;
        case "eq":
          g = t.pop(), r = t.pop(), t.push(r === g);
          break;
        case "exch":
          t.roll(2, 1);
          break;
        case "exp":
          g = t.pop(), r = t.pop(), t.push(r ** g);
          break;
        case "false":
          t.push(!1);
          break;
        case "floor":
          r = t.pop(), t.push(Math.floor(r));
          break;
        case "ge":
          g = t.pop(), r = t.pop(), t.push(r >= g);
          break;
        case "gt":
          g = t.pop(), r = t.pop(), t.push(r > g);
          break;
        case "idiv":
          g = t.pop(), r = t.pop(), t.push(r / g | 0);
          break;
        case "index":
          r = t.pop(), t.index(r);
          break;
        case "le":
          g = t.pop(), r = t.pop(), t.push(r <= g);
          break;
        case "ln":
          r = t.pop(), t.push(Math.log(r));
          break;
        case "log":
          r = t.pop(), t.push(Math.log10(r));
          break;
        case "lt":
          g = t.pop(), r = t.pop(), t.push(r < g);
          break;
        case "mod":
          g = t.pop(), r = t.pop(), t.push(r % g);
          break;
        case "mul":
          g = t.pop(), r = t.pop(), t.push(r * g);
          break;
        case "ne":
          g = t.pop(), r = t.pop(), t.push(r !== g);
          break;
        case "neg":
          r = t.pop(), t.push(-r);
          break;
        case "not":
          r = t.pop(), typeof r == "boolean" ? t.push(!r) : t.push(~r);
          break;
        case "or":
          g = t.pop(), r = t.pop(), typeof r == "boolean" && typeof g == "boolean" ? t.push(r || g) : t.push(r | g);
          break;
        case "pop":
          t.pop();
          break;
        case "roll":
          g = t.pop(), r = t.pop(), t.roll(r, g);
          break;
        case "round":
          r = t.pop(), t.push(Math.round(r));
          break;
        case "sin":
          r = t.pop(), t.push(Math.sin(r % 360 / 180 * Math.PI));
          break;
        case "sqrt":
          r = t.pop(), t.push(Math.sqrt(r));
          break;
        case "sub":
          g = t.pop(), r = t.pop(), t.push(r - g);
          break;
        case "true":
          t.push(!0);
          break;
        case "truncate":
          r = t.pop(), r = r < 0 ? Math.ceil(r) : Math.floor(r), t.push(r);
          break;
        case "xor":
          g = t.pop(), r = t.pop(), typeof r == "boolean" && typeof g == "boolean" ? t.push(r !== g) : t.push(r ^ g);
          break;
        default:
          throw new v(`Unknown operator ${n}`);
      }
    }
    return t.stack;
  }
}
class ls {
  constructor(A) {
    this.type = A;
  }
  visit(A) {
    WA("abstract method");
  }
}
class u1 extends ls {
  constructor(A, t, i) {
    super("args"), this.index = A, this.min = t, this.max = i;
  }
  visit(A) {
    A.visitArgument(this);
  }
}
class I0 extends ls {
  constructor(A) {
    super("literal"), this.number = A, this.min = A, this.max = A;
  }
  visit(A) {
    A.visitLiteral(this);
  }
}
class io extends ls {
  constructor(A, t, i, s, a) {
    super("binary"), this.op = A, this.arg1 = t, this.arg2 = i, this.min = s, this.max = a;
  }
  visit(A) {
    A.visitBinaryOperation(this);
  }
}
class d1 extends ls {
  constructor(A, t) {
    super("max"), this.arg = A, this.min = A.min, this.max = t;
  }
  visit(A) {
    A.visitMin(this);
  }
}
class DI extends ls {
  constructor(A, t, i) {
    super("var"), this.index = A, this.min = t, this.max = i;
  }
  visit(A) {
    A.visitVariable(this);
  }
}
class kI extends ls {
  constructor(A, t) {
    super("definition"), this.variable = A, this.arg = t;
  }
  visit(A) {
    A.visitVariableDefinition(this);
  }
}
class SI {
  constructor() {
    this.parts = [];
  }
  visitArgument(A) {
    this.parts.push("Math.max(", A.min, ", Math.min(", A.max, ", src[srcOffset + ", A.index, "]))");
  }
  visitVariable(A) {
    this.parts.push("v", A.index);
  }
  visitLiteral(A) {
    this.parts.push(A.number);
  }
  visitBinaryOperation(A) {
    this.parts.push("("), A.arg1.visit(this), this.parts.push(" ", A.op, " "), A.arg2.visit(this), this.parts.push(")");
  }
  visitVariableDefinition(A) {
    this.parts.push("var "), A.variable.visit(this), this.parts.push(" = "), A.arg.visit(this), this.parts.push(";");
  }
  visitMin(A) {
    this.parts.push("Math.min("), A.arg.visit(this), this.parts.push(", ", A.max, ")");
  }
  toString() {
    return this.parts.join("");
  }
}
function x1(e, A) {
  return A.type === "literal" && A.number === 0 ? e : e.type === "literal" && e.number === 0 ? A : A.type === "literal" && e.type === "literal" ? new I0(e.number + A.number) : new io("+", e, A, e.min + A.min, e.max + A.max);
}
function m1(e, A) {
  if (A.type === "literal") {
    if (A.number === 0)
      return new I0(0);
    if (A.number === 1)
      return e;
    if (e.type === "literal")
      return new I0(e.number * A.number);
  }
  if (e.type === "literal") {
    if (e.number === 0)
      return new I0(0);
    if (e.number === 1)
      return A;
  }
  const t = Math.min(e.min * A.min, e.min * A.max, e.max * A.min, e.max * A.max), i = Math.max(e.min * A.min, e.min * A.max, e.max * A.min, e.max * A.max);
  return new io("*", e, A, t, i);
}
function p1(e, A) {
  if (A.type === "literal") {
    if (A.number === 0)
      return e;
    if (e.type === "literal")
      return new I0(e.number - A.number);
  }
  return A.type === "binary" && A.op === "-" && e.type === "literal" && e.number === 1 && A.arg1.type === "literal" && A.arg1.number === 1 ? A.arg2 : new io("-", e, A, e.min - A.max, e.max - A.min);
}
function y1(e, A) {
  return e.min >= A ? new I0(A) : e.max <= A ? e : new d1(e, A);
}
class w1 {
  compile(A, t, i) {
    const s = [], a = [], n = t.length >> 1, r = i.length >> 1;
    let g = 0, o, I, c, l, h, C, B, Q;
    for (let f = 0; f < n; f++)
      s.push(new u1(f, t[f * 2], t[f * 2 + 1]));
    for (let f = 0, d = A.length; f < d; f++) {
      if (Q = A[f], typeof Q == "number") {
        s.push(new I0(Q));
        continue;
      }
      switch (Q) {
        case "add":
          if (s.length < 2)
            return null;
          l = s.pop(), c = s.pop(), s.push(x1(c, l));
          break;
        case "cvr":
          if (s.length < 1)
            return null;
          break;
        case "mul":
          if (s.length < 2)
            return null;
          l = s.pop(), c = s.pop(), s.push(m1(c, l));
          break;
        case "sub":
          if (s.length < 2)
            return null;
          l = s.pop(), c = s.pop(), s.push(p1(c, l));
          break;
        case "exch":
          if (s.length < 2)
            return null;
          h = s.pop(), C = s.pop(), s.push(h, C);
          break;
        case "pop":
          if (s.length < 1)
            return null;
          s.pop();
          break;
        case "index":
          if (s.length < 1 || (c = s.pop(), c.type !== "literal") || (o = c.number, o < 0 || !Number.isInteger(o) || s.length < o))
            return null;
          if (h = s[s.length - o - 1], h.type === "literal" || h.type === "var") {
            s.push(h);
            break;
          }
          B = new DI(g++, h.min, h.max), s[s.length - o - 1] = B, s.push(B), a.push(new kI(B, h));
          break;
        case "dup":
          if (s.length < 1)
            return null;
          if (typeof A[f + 1] == "number" && A[f + 2] === "gt" && A[f + 3] === f + 7 && A[f + 4] === "jz" && A[f + 5] === "pop" && A[f + 6] === A[f + 1]) {
            c = s.pop(), s.push(y1(c, A[f + 1])), f += 6;
            break;
          }
          if (h = s.at(-1), h.type === "literal" || h.type === "var") {
            s.push(h);
            break;
          }
          B = new DI(g++, h.min, h.max), s[s.length - 1] = B, s.push(B), a.push(new kI(B, h));
          break;
        case "roll":
          if (s.length < 2 || (l = s.pop(), c = s.pop(), l.type !== "literal" || c.type !== "literal") || (I = l.number, o = c.number, o <= 0 || !Number.isInteger(o) || !Number.isInteger(I) || s.length < o))
            return null;
          if (I = (I % o + o) % o, I === 0)
            break;
          s.push(...s.splice(s.length - o, o - I));
          break;
        default:
          return null;
      }
    }
    if (s.length !== r)
      return null;
    const E = [];
    for (const f of a) {
      const d = new SI();
      f.visit(d), E.push(d.toString());
    }
    for (let f = 0, d = s.length; f < d; f++) {
      const u = s[f], x = new SI();
      u.visit(x);
      const m = i[f * 2], p = i[f * 2 + 1], D = [x.toString()];
      m > u.min && (D.unshift("Math.max(", m, ", "), D.push(")")), p < u.max && (D.unshift("Math.min(", p, ", "), D.push(")")), D.unshift("dest[destOffset + ", f, "] = "), D.push(";"), E.push(D.join(""));
    }
    return E.join(`
`);
  }
}
const b1 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "ON", "ON", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "ON", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "ON", "ON", "ON", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "ON", "ET", "ET", "ET", "ET", "ON", "ON", "ON", "ON", "L", "ON", "ON", "BN", "ON", "ON", "ET", "ET", "EN", "EN", "ON", "L", "ON", "ON", "ON", "EN", "L", "ON", "ON", "ON", "ON", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "ON", "L", "L", "L", "L", "L", "L", "L", "L"], D1 = ["AN", "AN", "AN", "AN", "AN", "AN", "ON", "ON", "AL", "ET", "ET", "AL", "CS", "AL", "ON", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "ON", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "ON", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL"];
function FI(e) {
  return (e & 1) !== 0;
}
function k1(e) {
  return (e & 1) === 0;
}
function S1(e, A, t) {
  let i, s;
  for (i = A, s = e.length; i < s; ++i)
    if (e[i] !== t)
      return i;
  return i;
}
function F1(e, A, t, i) {
  for (let s = A; s < t; ++s)
    e[s] = i;
}
function RI(e, A, t) {
  for (let i = A, s = t - 1; i < s; ++i, --s) {
    const a = e[i];
    e[i] = e[s], e[s] = a;
  }
}
function Ur(e, A, t = !1) {
  let i = "ltr";
  return t ? i = "ttb" : A || (i = "rtl"), {
    str: e,
    dir: i
  };
}
const Di = [], _A = [];
function il(e, A = -1, t = !1) {
  let i = !0;
  const s = e.length;
  if (s === 0 || t)
    return Ur(e, i, t);
  Di.length = s, _A.length = s;
  let a = 0, n, r;
  for (n = 0; n < s; ++n) {
    Di[n] = e.charAt(n);
    const E = e.charCodeAt(n);
    let f = "L";
    E <= 255 ? f = b1[E] : 1424 <= E && E <= 1524 ? f = "R" : 1536 <= E && E <= 1791 ? (f = D1[E & 255], f || k("Bidi: invalid Unicode character " + E.toString(16))) : (1792 <= E && E <= 2220 || 64336 <= E && E <= 65023 || 65136 <= E && E <= 65279) && (f = "AL"), (f === "R" || f === "AL" || f === "AN") && a++, _A[n] = f;
  }
  if (a === 0)
    return i = !0, Ur(e, i);
  A === -1 && (a / s < 0.3 && s > 4 ? (i = !0, A = 0) : (i = !1, A = 1));
  const g = [];
  for (n = 0; n < s; ++n)
    g[n] = A;
  const o = FI(A) ? "R" : "L", I = o, c = I;
  let l = I;
  for (n = 0; n < s; ++n)
    _A[n] === "NSM" ? _A[n] = l : l = _A[n];
  l = I;
  let h;
  for (n = 0; n < s; ++n)
    h = _A[n], h === "EN" ? _A[n] = l === "AL" ? "AN" : "EN" : (h === "R" || h === "L" || h === "AL") && (l = h);
  for (n = 0; n < s; ++n)
    h = _A[n], h === "AL" && (_A[n] = "R");
  for (n = 1; n < s - 1; ++n)
    _A[n] === "ES" && _A[n - 1] === "EN" && _A[n + 1] === "EN" && (_A[n] = "EN"), _A[n] === "CS" && (_A[n - 1] === "EN" || _A[n - 1] === "AN") && _A[n + 1] === _A[n - 1] && (_A[n] = _A[n - 1]);
  for (n = 0; n < s; ++n)
    if (_A[n] === "EN") {
      for (let E = n - 1; E >= 0 && _A[E] === "ET"; --E)
        _A[E] = "EN";
      for (let E = n + 1; E < s && _A[E] === "ET"; ++E)
        _A[E] = "EN";
    }
  for (n = 0; n < s; ++n)
    h = _A[n], (h === "WS" || h === "ES" || h === "ET" || h === "CS") && (_A[n] = "ON");
  for (l = I, n = 0; n < s; ++n)
    h = _A[n], h === "EN" ? _A[n] = l === "L" ? "L" : "EN" : (h === "R" || h === "L") && (l = h);
  for (n = 0; n < s; ++n)
    if (_A[n] === "ON") {
      const E = S1(_A, n + 1, "ON");
      let f = I;
      n > 0 && (f = _A[n - 1]);
      let d = c;
      E + 1 < s && (d = _A[E + 1]), f !== "L" && (f = "R"), d !== "L" && (d = "R"), f === d && F1(_A, n, E, f), n = E - 1;
    }
  for (n = 0; n < s; ++n)
    _A[n] === "ON" && (_A[n] = o);
  for (n = 0; n < s; ++n)
    h = _A[n], k1(g[n]) ? h === "R" ? g[n] += 1 : (h === "AN" || h === "EN") && (g[n] += 2) : (h === "L" || h === "AN" || h === "EN") && (g[n] += 1);
  let C = -1, B = 99, Q;
  for (n = 0, r = g.length; n < r; ++n)
    Q = g[n], C < Q && (C = Q), B > Q && FI(Q) && (B = Q);
  for (Q = C; Q >= B; --Q) {
    let E = -1;
    for (n = 0, r = g.length; n < r; ++n)
      g[n] < Q ? E >= 0 && (RI(Di, E, n), E = -1) : E < 0 && (E = n);
    E >= 0 && RI(Di, E, g.length);
  }
  for (n = 0, r = Di.length; n < r; ++n) {
    const E = Di[n];
    (E === "<" || E === ">") && (Di[n] = "");
  }
  return Ur(Di.join(""), i);
}
const e0 = {
  style: "normal",
  weight: "normal"
}, t0 = {
  style: "normal",
  weight: "bold"
}, i0 = {
  style: "italic",
  weight: "normal"
}, s0 = {
  style: "italic",
  weight: "bold"
}, Hs = /* @__PURE__ */ new Map([["Times-Roman", {
  local: ["Times New Roman", "Times-Roman", "Times", "Liberation Serif", "Nimbus Roman", "Nimbus Roman L", "Tinos", "Thorndale", "TeX Gyre Termes", "FreeSerif", "Linux Libertine O", "Libertinus Serif", "DejaVu Serif", "Bitstream Vera Serif", "Ubuntu"],
  style: e0,
  ultimate: "serif"
}], ["Times-Bold", {
  alias: "Times-Roman",
  style: t0,
  ultimate: "serif"
}], ["Times-Italic", {
  alias: "Times-Roman",
  style: i0,
  ultimate: "serif"
}], ["Times-BoldItalic", {
  alias: "Times-Roman",
  style: s0,
  ultimate: "serif"
}], ["Helvetica", {
  local: ["Helvetica", "Helvetica Neue", "Arial", "Arial Nova", "Liberation Sans", "Arimo", "Nimbus Sans", "Nimbus Sans L", "A030", "TeX Gyre Heros", "FreeSans", "DejaVu Sans", "Albany", "Bitstream Vera Sans", "Arial Unicode MS", "Microsoft Sans Serif", "Apple Symbols", "Cantarell"],
  path: "LiberationSans-Regular.ttf",
  style: e0,
  ultimate: "sans-serif"
}], ["Helvetica-Bold", {
  alias: "Helvetica",
  path: "LiberationSans-Bold.ttf",
  style: t0,
  ultimate: "sans-serif"
}], ["Helvetica-Oblique", {
  alias: "Helvetica",
  path: "LiberationSans-Italic.ttf",
  style: i0,
  ultimate: "sans-serif"
}], ["Helvetica-BoldOblique", {
  alias: "Helvetica",
  path: "LiberationSans-BoldItalic.ttf",
  style: s0,
  ultimate: "sans-serif"
}], ["Courier", {
  local: ["Courier", "Courier New", "Liberation Mono", "Nimbus Mono", "Nimbus Mono L", "Cousine", "Cumberland", "TeX Gyre Cursor", "FreeMono", "Linux Libertine Mono O", "Libertinus Mono"],
  style: e0,
  ultimate: "monospace"
}], ["Courier-Bold", {
  alias: "Courier",
  style: t0,
  ultimate: "monospace"
}], ["Courier-Oblique", {
  alias: "Courier",
  style: i0,
  ultimate: "monospace"
}], ["Courier-BoldOblique", {
  alias: "Courier",
  style: s0,
  ultimate: "monospace"
}], ["ArialBlack", {
  local: ["Arial Black"],
  style: {
    style: "normal",
    weight: "900"
  },
  fallback: "Helvetica-Bold"
}], ["ArialBlack-Bold", {
  alias: "ArialBlack"
}], ["ArialBlack-Italic", {
  alias: "ArialBlack",
  style: {
    style: "italic",
    weight: "900"
  },
  fallback: "Helvetica-BoldOblique"
}], ["ArialBlack-BoldItalic", {
  alias: "ArialBlack-Italic"
}], ["ArialNarrow", {
  local: ["Arial Narrow", "Liberation Sans Narrow", "Helvetica Condensed", "Nimbus Sans Narrow", "TeX Gyre Heros Cn"],
  style: e0,
  fallback: "Helvetica"
}], ["ArialNarrow-Bold", {
  alias: "ArialNarrow",
  style: t0,
  fallback: "Helvetica-Bold"
}], ["ArialNarrow-Italic", {
  alias: "ArialNarrow",
  style: i0,
  fallback: "Helvetica-Oblique"
}], ["ArialNarrow-BoldItalic", {
  alias: "ArialNarrow",
  style: s0,
  fallback: "Helvetica-BoldOblique"
}], ["Calibri", {
  local: ["Calibri", "Carlito"],
  style: e0,
  fallback: "Helvetica"
}], ["Calibri-Bold", {
  alias: "Calibri",
  style: t0,
  fallback: "Helvetica-Bold"
}], ["Calibri-Italic", {
  alias: "Calibri",
  style: i0,
  fallback: "Helvetica-Oblique"
}], ["Calibri-BoldItalic", {
  alias: "Calibri",
  style: s0,
  fallback: "Helvetica-BoldOblique"
}], ["Wingdings", {
  local: ["Wingdings", "URW Dingbats"],
  style: e0
}], ["Wingdings-Regular", {
  alias: "Wingdings"
}], ["Wingdings-Bold", {
  alias: "Wingdings"
}]]), R1 = /* @__PURE__ */ new Map([["Arial-Black", "ArialBlack"]]);
function G1(e) {
  switch (e) {
    case t0:
      return "Bold";
    case i0:
      return "Italic";
    case s0:
      return "Bold Italic";
    default:
      if ((e == null ? void 0 : e.weight) === "bold")
        return "Bold";
      if ((e == null ? void 0 : e.style) === "italic")
        return "Italic";
  }
  return "";
}
function GI(e) {
  const A = /* @__PURE__ */ new Set(["thin", "extralight", "ultralight", "demilight", "semilight", "light", "book", "regular", "normal", "medium", "demibold", "semibold", "bold", "extrabold", "ultrabold", "black", "heavy", "extrablack", "ultrablack", "roman", "italic", "oblique", "ultracondensed", "extracondensed", "condensed", "semicondensed", "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded", "bolditalic"]);
  return e.split(/[- ,+]+/g).filter((t) => !A.has(t.toLowerCase())).join(" ");
}
function xg({
  alias: e,
  local: A,
  path: t,
  fallback: i,
  style: s,
  ultimate: a
}, n, r, g = !0, o = !0, I = "") {
  const c = {
    style: null,
    ultimate: null
  };
  if (A) {
    const l = I ? ` ${I}` : "";
    for (const h of A)
      n.push(`local(${h}${l})`);
  }
  if (e) {
    const l = Hs.get(e), h = I || G1(s);
    Object.assign(c, xg(l, n, r, g && !i, o && !t, h));
  }
  if (s && (c.style = s), a && (c.ultimate = a), g && i) {
    const l = Hs.get(i), {
      ultimate: h
    } = xg(l, n, r, g, o && !t, I);
    c.ultimate || (c.ultimate = h);
  }
  return o && t && r && n.push(`url(${r}${t})`), c;
}
function NI(e, A, t, i, s, a) {
  if (i.startsWith("InvalidPDFjsFont_"))
    return null;
  (a === "TrueType" || a === "Type1") && /^[A-Z]{6}\+/.test(i) && (i = i.slice(7)), i = wa(i);
  const n = i;
  let r = e.get(n);
  if (r)
    return r;
  let g = Hs.get(i);
  if (!g) {
    for (const [Q, E] of R1)
      if (i.startsWith(Q)) {
        i = `${E}${i.substring(Q.length)}`, g = Hs.get(i);
        break;
      }
  }
  let o = !1;
  g || (g = Hs.get(s), o = !0);
  const I = `${A.getDocId()}_s${A.createFontId()}`;
  if (!g) {
    if (!zr(i))
      return k(`Cannot substitute the font because of its name: ${i}`), e.set(n, null), null;
    const Q = /bold/gi.test(i), E = /oblique|italic/gi.test(i), f = Q && E && s0 || Q && t0 || E && i0 || e0;
    return r = {
      css: `"${GI(i)}",${I}`,
      guessFallback: !0,
      loadedName: I,
      baseFontName: i,
      src: `local(${i})`,
      style: f
    }, e.set(n, r), r;
  }
  const c = [];
  o && zr(i) && c.push(`local(${i})`);
  const {
    style: l,
    ultimate: h
  } = xg(g, c, t), C = h === null, B = C ? "" : `,${h}`;
  return r = {
    css: `"${GI(i)}",${I}${B}`,
    guessFallback: C,
    loadedName: I,
    baseFontName: i,
    src: c.join(","),
    style: l
  }, e.set(n, r), r;
}
const MI = 2048, N1 = 65537, UI = 128;
var kt, Ea, Zn, sl;
const Gi = class Gi {
  constructor(A, t) {
    ZA(this, Zn);
    this._imgData = A, this._isMask = t;
  }
  static get canUseImageDecoder() {
    return iA(this, "canUseImageDecoder", PA(this, Ea) ? ImageDecoder.isTypeSupported("image/bmp") : Promise.resolve(!1));
  }
  static needsToBeResized(A, t) {
    if (A <= PA(this, kt) && t <= PA(this, kt))
      return !1;
    const {
      MAX_DIM: i
    } = this;
    if (A > i || t > i)
      return !0;
    const s = A * t;
    if (this._hasMaxArea)
      return s > this.MAX_AREA;
    if (s < PA(this, kt) ** 2)
      return !1;
    if (this._areGoodDims(A, t))
      return wt(this, kt, Math.max(PA(this, kt), Math.floor(Math.sqrt(A * t)))), !1;
    wt(this, kt, this._guessMax(PA(this, kt), i, UI, 0));
    const a = this.MAX_AREA = PA(this, kt) ** 2;
    return s > a;
  }
  static get MAX_DIM() {
    return iA(this, "MAX_DIM", this._guessMax(MI, N1, 0, 1));
  }
  static get MAX_AREA() {
    return this._hasMaxArea = !0, iA(this, "MAX_AREA", this._guessMax(PA(this, kt), this.MAX_DIM, UI, 0) ** 2);
  }
  static set MAX_AREA(A) {
    A >= 0 && (this._hasMaxArea = !0, iA(this, "MAX_AREA", A));
  }
  static setOptions({
    canvasMaxAreaInBytes: A = -1,
    isImageDecoderSupported: t = !1
  }) {
    this._hasMaxArea || (this.MAX_AREA = A >> 2), wt(this, Ea, t);
  }
  static _areGoodDims(A, t) {
    try {
      const i = new OffscreenCanvas(A, t), s = i.getContext("2d");
      s.fillRect(0, 0, 1, 1);
      const a = s.getImageData(0, 0, 1, 1).data[3];
      return i.width = i.height = 1, a !== 0;
    } catch {
      return !1;
    }
  }
  static _guessMax(A, t, i, s) {
    for (; A + i + 1 < t; ) {
      const a = Math.floor((A + t) / 2), n = s || a;
      this._areGoodDims(a, n) ? A = a : t = a;
    }
    return A;
  }
  static async createImage(A, t = !1) {
    return new Gi(A, t)._createImage();
  }
  async _createImage() {
    const {
      _imgData: A
    } = this, {
      width: t,
      height: i
    } = A;
    if (t * i * 4 > jr) {
      const f = BA(this, Zn, sl).call(this);
      if (f)
        return f;
    }
    const s = this._encodeBMP();
    let a, n;
    await Gi.canUseImageDecoder ? (a = new ImageDecoder({
      data: s,
      type: "image/bmp",
      preferAnimation: !1,
      transfer: [s.buffer]
    }), n = a.decode().catch((f) => (k(`BMP image decoding failed: ${f}`), createImageBitmap(new Blob([this._encodeBMP().buffer], {
      type: "image/bmp"
    })))).finally(() => {
      a.close();
    })) : n = createImageBitmap(new Blob([s.buffer], {
      type: "image/bmp"
    }));
    const {
      MAX_AREA: r,
      MAX_DIM: g
    } = Gi, o = Math.max(t / g, i / g, Math.sqrt(t * i / r)), I = Math.max(o, 2), c = Math.round(10 * (o + 1.25)) / 10 / I, l = Math.floor(Math.log2(c)), h = new Array(l + 2).fill(2);
    h[0] = I, h.splice(-1, 1, c / (1 << l));
    let C = t, B = i;
    const Q = await n;
    let E = Q.image || Q;
    for (const f of h) {
      const d = C, u = B;
      C = Math.floor(C / f) - 1, B = Math.floor(B / f) - 1;
      const x = new OffscreenCanvas(C, B);
      x.getContext("2d").drawImage(E, 0, 0, d, u, 0, 0, C, B), E.close(), E = x.transferToImageBitmap();
    }
    return A.data = null, A.bitmap = E, A.width = C, A.height = B, A;
  }
  _encodeBMP() {
    const {
      width: A,
      height: t,
      kind: i
    } = this._imgData;
    let s = this._imgData.data, a, n = new Uint8Array(0), r = n, g = 0;
    switch (i) {
      case Ue.GRAYSCALE_1BPP: {
        a = 1, n = new Uint8Array(this._isMask ? [255, 255, 255, 255, 0, 0, 0, 0] : [0, 0, 0, 0, 255, 255, 255, 255]);
        const B = A + 7 >> 3, Q = B + 3 & -4;
        if (B !== Q) {
          const E = new Uint8Array(Q * t);
          let f = 0;
          for (let d = 0, u = t * B; d < u; d += B, f += Q)
            E.set(s.subarray(d, d + B), f);
          s = E;
        }
        break;
      }
      case Ue.RGB_24BPP: {
        if (a = 24, A & 3) {
          const B = 3 * A, Q = B + 3 & -4, E = Q - B, f = new Uint8Array(Q * t);
          let d = 0;
          for (let u = 0, x = t * B; u < x; u += B) {
            const m = s.subarray(u, u + B);
            for (let p = 0; p < B; p += 3)
              f[d++] = m[p + 2], f[d++] = m[p + 1], f[d++] = m[p];
            d += E;
          }
          s = f;
        } else
          for (let B = 0, Q = s.length; B < Q; B += 3) {
            const E = s[B];
            s[B] = s[B + 2], s[B + 2] = E;
          }
        break;
      }
      case Ue.RGBA_32BPP:
        a = 32, g = 3, r = new Uint8Array(68);
        const C = new DataView(r.buffer);
        ht.isLittleEndian ? (C.setUint32(0, 255, !0), C.setUint32(4, 65280, !0), C.setUint32(8, 16711680, !0), C.setUint32(12, 4278190080, !0)) : (C.setUint32(0, 4278190080, !0), C.setUint32(4, 16711680, !0), C.setUint32(8, 65280, !0), C.setUint32(12, 255, !0));
        break;
      default:
        throw new Error("invalid format");
    }
    let o = 0;
    const I = 40 + r.length, c = 14 + I + n.length + s.length, l = new Uint8Array(c), h = new DataView(l.buffer);
    return h.setUint16(o, 19778, !0), o += 2, h.setUint32(o, c, !0), o += 4, h.setUint32(o, 0, !0), o += 4, h.setUint32(o, 14 + I + n.length, !0), o += 4, h.setUint32(o, I, !0), o += 4, h.setInt32(o, A, !0), o += 4, h.setInt32(o, -t, !0), o += 4, h.setUint16(o, 1, !0), o += 2, h.setUint16(o, a, !0), o += 2, h.setUint32(o, g, !0), o += 4, h.setUint32(o, 0, !0), o += 4, h.setInt32(o, 0, !0), o += 4, h.setInt32(o, 0, !0), o += 4, h.setUint32(o, n.length / 4, !0), o += 4, h.setUint32(o, 0, !0), o += 4, l.set(r, o), o += r.length, l.set(n, o), o += n.length, l.set(s, o), l;
  }
};
kt = new WeakMap(), Ea = new WeakMap(), Zn = new WeakSet(), sl = function() {
  const {
    _imgData: A
  } = this, {
    data: t,
    width: i,
    height: s,
    kind: a
  } = A, n = i * s * 4, r = Math.ceil(Math.log2(n / jr)), g = i >> r, o = s >> r;
  let I, c = s;
  try {
    I = new Uint8Array(n);
  } catch {
    let u = Math.floor(Math.log2(n + 1));
    for (; ; )
      try {
        I = new Uint8Array(2 ** u - 1);
        break;
      } catch {
        u -= 1;
      }
    c = Math.floor((2 ** u - 1) / (i * 4));
    const x = i * c * 4;
    x < I.length && (I = new Uint8Array(x));
  }
  const l = new Uint32Array(I.buffer), h = new Uint32Array(g * o);
  let C = 0, B = 0;
  const Q = Math.ceil(s / c), E = s % c === 0 ? s : s % c;
  for (let u = 0; u < Q; u++) {
    const x = u < Q - 1 ? c : E;
    ({
      srcPos: C
    } = Lc({
      kind: a,
      src: t,
      dest: l,
      width: i,
      height: x,
      inverseDecode: this._isMask,
      srcPos: C
    }));
    for (let m = 0, p = x >> r; m < p; m++) {
      const D = l.subarray((m << r) * i);
      for (let F = 0; F < g; F++)
        h[B++] = D[F << r];
    }
  }
  if (Gi.needsToBeResized(g, o))
    return A.data = h, A.width = g, A.height = o, A.kind = Ue.RGBA_32BPP, null;
  const f = new OffscreenCanvas(g, o);
  return f.getContext("2d", {
    willReadFrequently: !0
  }).putImageData(new ImageData(new Uint8ClampedArray(h.buffer), g, o), 0, 0), A.data = null, A.bitmap = f.transferToImageBitmap(), A.width = g, A.height = o, A;
}, ZA(Gi, kt, MI), ZA(Gi, Ea, ht.isImageDecoderSupported);
let $t = Gi;
const LI = 3285377520, Dt = 4294901760, _t = 65535;
class M1 {
  constructor(A) {
    this.h1 = A ? A & 4294967295 : LI, this.h2 = A ? A & 4294967295 : LI;
  }
  update(A) {
    let t, i;
    if (typeof A == "string") {
      t = new Uint8Array(A.length * 2), i = 0;
      for (let B = 0, Q = A.length; B < Q; B++) {
        const E = A.charCodeAt(B);
        E <= 255 ? t[i++] = E : (t[i++] = E >>> 8, t[i++] = E & 255);
      }
    } else if (ArrayBuffer.isView(A))
      t = A.slice(), i = t.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const s = i >> 2, a = i - s * 4, n = new Uint32Array(t.buffer, 0, s);
    let r = 0, g = 0, o = this.h1, I = this.h2;
    const c = 3432918353, l = 461845907, h = c & _t, C = l & _t;
    for (let B = 0; B < s; B++)
      B & 1 ? (r = n[B], r = r * c & Dt | r * h & _t, r = r << 15 | r >>> 17, r = r * l & Dt | r * C & _t, o ^= r, o = o << 13 | o >>> 19, o = o * 5 + 3864292196) : (g = n[B], g = g * c & Dt | g * h & _t, g = g << 15 | g >>> 17, g = g * l & Dt | g * C & _t, I ^= g, I = I << 13 | I >>> 19, I = I * 5 + 3864292196);
    switch (r = 0, a) {
      case 3:
        r ^= t[s * 4 + 2] << 16;
      case 2:
        r ^= t[s * 4 + 1] << 8;
      case 1:
        r ^= t[s * 4], r = r * c & Dt | r * h & _t, r = r << 15 | r >>> 17, r = r * l & Dt | r * C & _t, s & 1 ? o ^= r : I ^= r;
    }
    this.h1 = o, this.h2 = I;
  }
  hexdigest() {
    let A = this.h1, t = this.h2;
    return A ^= t >>> 1, A = A * 3981806797 & Dt | A * 36045 & _t, t = t * 4283543511 & Dt | ((t << 16 | A >>> 16) * 2950163797 & Dt) >>> 16, A ^= t >>> 1, A = A * 444984403 & Dt | A * 60499 & _t, t = t * 3301882366 & Dt | ((t << 16 | A >>> 16) * 3120437893 & Dt) >>> 16, A ^= t >>> 1, (A >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
  }
}
function sr(e, A, t, i, s) {
  let a = e;
  for (let n = 0, r = A.length - 1; n < r; n++) {
    const g = A[n];
    a = a[g] || (a[g] = []);
  }
  a[A.at(-1)] = {
    checkFn: t,
    iterateFn: i,
    processFn: s
  };
}
const ss = [];
sr(ss, [w.save, w.transform, w.paintInlineImageXObject, w.restore], null, function(A, t) {
  const i = A.fnArray, s = A.iCurr - 3, a = (t - s) % 4;
  switch (a) {
    case 0:
      return i[t] === w.save;
    case 1:
      return i[t] === w.transform;
    case 2:
      return i[t] === w.paintInlineImageXObject;
    case 3:
      return i[t] === w.restore;
  }
  throw new Error(`iterateInlineImageGroup - invalid pos: ${a}`);
}, function(A, t) {
  const r = A.fnArray, g = A.argsArray, o = A.iCurr, I = o - 3, c = o - 2, l = o - 1, h = Math.min(Math.floor((t - I) / 4), 200);
  if (h < 10)
    return t - (t - I) % 4;
  let C = 0;
  const B = [];
  let Q = 0, E = 1, f = 1;
  for (let D = 0; D < h; D++) {
    const F = g[c + (D << 2)], y = g[l + (D << 2)][0];
    E + y.width > 1e3 && (C = Math.max(C, E), f += Q + 2 * 1, E = 0, Q = 0), B.push({
      transform: F,
      x: E,
      y: f,
      w: y.width,
      h: y.height
    }), E += y.width + 2 * 1, Q = Math.max(Q, y.height);
  }
  const d = Math.max(C, E) + 1, u = f + Q + 1, x = new Uint8Array(d * u * 4), m = d << 2;
  for (let D = 0; D < h; D++) {
    const F = g[l + (D << 2)][0].data, y = B[D].w << 2;
    let H = 0, N = B[D].x + B[D].y * d << 2;
    x.set(F.subarray(0, y), N - m);
    for (let T = 0, _ = B[D].h; T < _; T++)
      x.set(F.subarray(H, H + y), N), H += y, N += m;
    for (x.set(F.subarray(H - y, H), N); N >= 0; )
      F[N - 4] = F[N], F[N - 3] = F[N + 1], F[N - 2] = F[N + 2], F[N - 1] = F[N + 3], F[N + y] = F[N + y - 4], F[N + y + 1] = F[N + y - 3], F[N + y + 2] = F[N + y - 2], F[N + y + 3] = F[N + y - 1], N -= m;
  }
  const p = {
    width: d,
    height: u
  };
  if (A.isOffscreenCanvasSupported) {
    const D = new OffscreenCanvas(d, u);
    D.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(x.buffer), d, u), 0, 0), p.bitmap = D.transferToImageBitmap(), p.data = null;
  } else
    p.kind = Ue.RGBA_32BPP, p.data = x;
  return r.splice(I, h * 4, w.paintInlineImageXObjectGroup), g.splice(I, h * 4, [p, B]), I + 1;
});
sr(ss, [w.save, w.transform, w.paintImageMaskXObject, w.restore], null, function(A, t) {
  const i = A.fnArray, s = A.iCurr - 3, a = (t - s) % 4;
  switch (a) {
    case 0:
      return i[t] === w.save;
    case 1:
      return i[t] === w.transform;
    case 2:
      return i[t] === w.paintImageMaskXObject;
    case 3:
      return i[t] === w.restore;
  }
  throw new Error(`iterateImageMaskGroup - invalid pos: ${a}`);
}, function(A, t) {
  const n = A.fnArray, r = A.argsArray, g = A.iCurr, o = g - 3, I = g - 2, c = g - 1;
  let l = Math.floor((t - o) / 4);
  if (l < 10)
    return t - (t - o) % 4;
  let h = !1, C, B;
  const Q = r[c][0], E = r[I][0], f = r[I][1], d = r[I][2], u = r[I][3];
  if (f === d) {
    h = !0, C = I + 4;
    let x = c + 4;
    for (let m = 1; m < l; m++, C += 4, x += 4)
      if (B = r[C], r[x][0] !== Q || B[0] !== E || B[1] !== f || B[2] !== d || B[3] !== u) {
        m < 10 ? h = !1 : l = m;
        break;
      }
  }
  if (h) {
    l = Math.min(l, 1e3);
    const x = new Float32Array(l * 2);
    C = I;
    for (let m = 0; m < l; m++, C += 4)
      B = r[C], x[m << 1] = B[4], x[(m << 1) + 1] = B[5];
    n.splice(o, l * 4, w.paintImageMaskXObjectRepeat), r.splice(o, l * 4, [Q, E, f, d, u, x]);
  } else {
    l = Math.min(l, 100);
    const x = [];
    for (let m = 0; m < l; m++) {
      B = r[I + (m << 2)];
      const p = r[c + (m << 2)][0];
      x.push({
        data: p.data,
        width: p.width,
        height: p.height,
        interpolate: p.interpolate,
        count: p.count,
        transform: B
      });
    }
    n.splice(o, l * 4, w.paintImageMaskXObjectGroup), r.splice(o, l * 4, [x]);
  }
  return o + 1;
});
sr(ss, [w.save, w.transform, w.paintImageXObject, w.restore], function(e) {
  const A = e.argsArray, t = e.iCurr - 2;
  return A[t][1] === 0 && A[t][2] === 0;
}, function(A, t) {
  const i = A.fnArray, s = A.argsArray, a = A.iCurr - 3, n = (t - a) % 4;
  switch (n) {
    case 0:
      return i[t] === w.save;
    case 1:
      if (i[t] !== w.transform)
        return !1;
      const r = A.iCurr - 2, g = s[r][0], o = s[r][3];
      return !(s[t][0] !== g || s[t][1] !== 0 || s[t][2] !== 0 || s[t][3] !== o);
    case 2:
      if (i[t] !== w.paintImageXObject)
        return !1;
      const I = A.iCurr - 1, c = s[I][0];
      return s[t][0] === c;
    case 3:
      return i[t] === w.restore;
  }
  throw new Error(`iterateImageGroup - invalid pos: ${n}`);
}, function(e, A) {
  const s = e.fnArray, a = e.argsArray, n = e.iCurr, r = n - 3, g = n - 2, o = n - 1, I = a[o][0], c = a[g][0], l = a[g][3], h = Math.min(Math.floor((A - r) / 4), 1e3);
  if (h < 3)
    return A - (A - r) % 4;
  const C = new Float32Array(h * 2);
  let B = g;
  for (let E = 0; E < h; E++, B += 4) {
    const f = a[B];
    C[E << 1] = f[4], C[(E << 1) + 1] = f[5];
  }
  const Q = [I, c, l, C];
  return s.splice(r, h * 4, w.paintImageXObjectRepeat), a.splice(r, h * 4, Q), r + 1;
});
sr(ss, [w.beginText, w.setFont, w.setTextMatrix, w.showText, w.endText], null, function(A, t) {
  const i = A.fnArray, s = A.argsArray, a = A.iCurr - 4, n = (t - a) % 5;
  switch (n) {
    case 0:
      return i[t] === w.beginText;
    case 1:
      return i[t] === w.setFont;
    case 2:
      return i[t] === w.setTextMatrix;
    case 3:
      if (i[t] !== w.showText)
        return !1;
      const r = A.iCurr - 3, g = s[r][0], o = s[r][1];
      return !(s[t][0] !== g || s[t][1] !== o);
    case 4:
      return i[t] === w.endText;
  }
  throw new Error(`iterateShowTextGroup - invalid pos: ${n}`);
}, function(e, A) {
  const s = e.fnArray, a = e.argsArray, n = e.iCurr, r = n - 4, g = n - 3, o = n - 2, I = n - 1, c = n, l = a[g][0], h = a[g][1];
  let C = Math.min(Math.floor((A - r) / 5), 1e3);
  if (C < 3)
    return A - (A - r) % 5;
  let B = r;
  r >= 4 && s[r - 4] === s[g] && s[r - 3] === s[o] && s[r - 2] === s[I] && s[r - 1] === s[c] && a[r - 4][0] === l && a[r - 4][1] === h && (C++, B -= 5);
  let Q = B + 4;
  for (let E = 1; E < C; E++)
    s.splice(Q, 3), a.splice(Q, 3), Q += 2;
  return Q + 1;
});
class al {
  constructor(A) {
    this.queue = A;
  }
  _optimize() {
  }
  push(A, t) {
    this.queue.fnArray.push(A), this.queue.argsArray.push(t), this._optimize();
  }
  flush() {
  }
  reset() {
  }
}
class U1 extends al {
  constructor(A) {
    super(A), this.state = null, this.context = {
      iCurr: 0,
      fnArray: A.fnArray,
      argsArray: A.argsArray,
      isOffscreenCanvasSupported: !1
    }, this.match = null, this.lastProcessed = 0;
  }
  set isOffscreenCanvasSupported(A) {
    this.context.isOffscreenCanvasSupported = A;
  }
  _optimize() {
    const A = this.queue.fnArray;
    let t = this.lastProcessed, i = A.length, s = this.state, a = this.match;
    if (!s && !a && t + 1 === i && !ss[A[t]]) {
      this.lastProcessed = i;
      return;
    }
    const n = this.context;
    for (; t < i; ) {
      if (a) {
        if ((0, a.iterateFn)(n, t)) {
          t++;
          continue;
        }
        if (t = (0, a.processFn)(n, t + 1), i = A.length, a = null, s = null, t >= i)
          break;
      }
      if (s = (s || ss)[A[t]], !s || Array.isArray(s)) {
        t++;
        continue;
      }
      if (n.iCurr = t, t++, s.checkFn && !(0, s.checkFn)(n)) {
        s = null;
        continue;
      }
      a = s, s = null;
    }
    this.state = s, this.match = a, this.lastProcessed = t;
  }
  flush() {
    for (; this.match; ) {
      const A = this.queue.fnArray.length;
      this.lastProcessed = (0, this.match.processFn)(this.context, A), this.match = null, this.state = null, this._optimize();
    }
  }
  reset() {
    this.state = null, this.match = null, this.lastProcessed = 0;
  }
}
const Ni = class Ni {
  constructor(A = 0, t) {
    this._streamSink = t, this.fnArray = [], this.argsArray = [], this.optimizer = t && !(A & it.OPLIST) ? new U1(this) : new al(this), this.dependencies = /* @__PURE__ */ new Set(), this._totalLength = 0, this.weight = 0, this._resolved = t ? null : Promise.resolve();
  }
  set isOffscreenCanvasSupported(A) {
    this.optimizer.isOffscreenCanvasSupported = A;
  }
  get length() {
    return this.argsArray.length;
  }
  get ready() {
    return this._resolved || this._streamSink.ready;
  }
  get totalLength() {
    return this._totalLength + this.length;
  }
  addOp(A, t) {
    this.optimizer.push(A, t), this.weight++, this._streamSink && (this.weight >= Ni.CHUNK_SIZE ? this.flush() : this.weight >= Ni.CHUNK_SIZE_ABOUT && (A === w.restore || A === w.endText) && this.flush());
  }
  addImageOps(A, t, i, s = !1) {
    s && (this.addOp(w.save), this.addOp(w.setGState, [[["SMask", !1]]])), i !== void 0 && this.addOp(w.beginMarkedContentProps, ["OC", i]), this.addOp(A, t), i !== void 0 && this.addOp(w.endMarkedContent, []), s && this.addOp(w.restore);
  }
  addDependency(A) {
    this.dependencies.has(A) || (this.dependencies.add(A), this.addOp(w.dependency, [A]));
  }
  addDependencies(A) {
    for (const t of A)
      this.addDependency(t);
  }
  addOpList(A) {
    if (!(A instanceof Ni)) {
      k('addOpList - ignoring invalid "opList" parameter.');
      return;
    }
    for (const t of A.dependencies)
      this.dependencies.add(t);
    for (let t = 0, i = A.length; t < i; t++)
      this.addOp(A.fnArray[t], A.argsArray[t]);
  }
  getIR() {
    return {
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      length: this.length
    };
  }
  get _transfers() {
    var a;
    const A = [], {
      fnArray: t,
      argsArray: i,
      length: s
    } = this;
    for (let n = 0; n < s; n++)
      switch (t[n]) {
        case w.paintInlineImageXObject:
        case w.paintInlineImageXObjectGroup:
        case w.paintImageMaskXObject:
          const r = i[n][0];
          !r.cached && ((a = r.data) == null ? void 0 : a.buffer) instanceof ArrayBuffer && A.push(r.data.buffer);
          break;
      }
    return A;
  }
  flush(A = !1, t = null) {
    this.optimizer.flush();
    const i = this.length;
    this._totalLength += i, this._streamSink.enqueue({
      fnArray: this.fnArray,
      argsArray: this.argsArray,
      lastChunk: A,
      separateAnnots: t,
      length: i
    }, 1, this._transfers), this.dependencies.clear(), this.fnArray.length = 0, this.argsArray.length = 0, this.weight = 0, this.optimizer.reset();
  }
};
Me(Ni, "CHUNK_SIZE", 1e3), Me(Ni, "CHUNK_SIZE_ABOUT", Ni.CHUNK_SIZE - 5);
let lt = Ni;
function L1(e, A, t, i) {
  return e = A + e * t, e < 0 ? e = 0 : e > i && (e = i), e;
}
function HI(e, A, t, i, s, a) {
  const n = s * a;
  let r;
  A <= 8 ? r = new Uint8Array(n) : A <= 16 ? r = new Uint16Array(n) : r = new Uint32Array(n);
  const g = t / s, o = i / a;
  let I, c, l, h = 0, C;
  const B = new Uint16Array(s), Q = t;
  for (I = 0; I < s; I++)
    B[I] = Math.floor(I * g);
  for (I = 0; I < a; I++)
    for (l = Math.floor(I * o) * Q, c = 0; c < s; c++)
      C = l + B[c], r[h++] = e[C];
  return r;
}
var fa, mg;
const K0 = class K0 {
  constructor({
    xref: A,
    res: t,
    image: i,
    isInline: s = !1,
    smask: a = null,
    mask: n = null,
    isMask: r = !1,
    pdfFunctionFactory: g,
    localColorSpaceCache: o
  }) {
    ZA(this, fa);
    var Q, E;
    this.image = i;
    const I = i.dict, c = I.get("F", "Filter");
    let l;
    if (c instanceof L)
      l = c.name;
    else if (Array.isArray(c)) {
      const f = A.fetchIfRef(c[0]);
      f instanceof L && (l = f.name);
    }
    switch (l) {
      case "JPXDecode":
        ({
          width: i.width,
          height: i.height,
          componentsCount: i.numComps,
          bitsPerComponent: i.bitsPerComponent
        } = tr.parseImageProperties(i.stream)), i.stream.reset(), this.jpxDecoderOptions = {
          numComponents: 0,
          isIndexedColormap: !1,
          smaskInData: I.has("SMaskInData")
        };
        break;
      case "JBIG2Decode":
        i.bitsPerComponent = 1, i.numComps = 1;
        break;
    }
    let h = I.get("W", "Width"), C = I.get("H", "Height");
    if (Number.isInteger(i.width) && i.width > 0 && Number.isInteger(i.height) && i.height > 0 && (i.width !== h || i.height !== C) && (k("PDFImage - using the Width/Height of the image data, rather than the image dictionary."), h = i.width, C = i.height), h < 1 || C < 1)
      throw new v(`Invalid image width: ${h} or height: ${C}`);
    this.width = h, this.height = C, this.interpolate = I.get("I", "Interpolate"), this.imageMask = I.get("IM", "ImageMask") || !1, this.matte = I.get("Matte") || !1;
    let B = i.bitsPerComponent;
    if (!B && (B = I.get("BPC", "BitsPerComponent"), !B))
      if (this.imageMask)
        B = 1;
      else
        throw new v(`Bits per component missing in image: ${this.imageMask}`);
    if (this.bpc = B, !this.imageMask) {
      let f = I.getRaw("CS") || I.getRaw("ColorSpace");
      const d = !!f;
      if (d)
        (Q = this.jpxDecoderOptions) != null && Q.smaskInData && (f = L.get("DeviceRGBA"));
      else if (this.jpxDecoderOptions)
        f = L.get("DeviceRGBA");
      else
        switch (i.numComps) {
          case 1:
            f = L.get("DeviceGray");
            break;
          case 3:
            f = L.get("DeviceRGB");
            break;
          case 4:
            f = L.get("DeviceCMYK");
            break;
          default:
            throw new Error(`Images with ${i.numComps} color components not supported.`);
        }
      this.colorSpace = LA.parse({
        cs: f,
        xref: A,
        resources: s ? t : null,
        pdfFunctionFactory: g,
        localColorSpaceCache: o
      }), this.numComps = this.colorSpace.numComps, this.jpxDecoderOptions && (this.jpxDecoderOptions.numComponents = d ? this.numComp : 0, this.jpxDecoderOptions.isIndexedColormap = this.colorSpace.name === "Indexed");
    }
    if (this.decode = I.getArray("D", "Decode"), this.needsDecode = !1, this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, B) || r && !LA.isDefaultDecode(this.decode, 1))) {
      this.needsDecode = !0;
      const f = (1 << B) - 1;
      this.decodeCoefficients = [], this.decodeAddends = [];
      const d = ((E = this.colorSpace) == null ? void 0 : E.name) === "Indexed";
      for (let u = 0, x = 0; u < this.decode.length; u += 2, ++x) {
        const m = this.decode[u], p = this.decode[u + 1];
        this.decodeCoefficients[x] = d ? (p - m) / f : p - m, this.decodeAddends[x] = d ? m : f * m;
      }
    }
    a ? this.smask = new K0({
      xref: A,
      res: t,
      image: a,
      isInline: s,
      pdfFunctionFactory: g,
      localColorSpaceCache: o
    }) : n && (n instanceof JA ? n.dict.get("IM", "ImageMask") ? this.mask = new K0({
      xref: A,
      res: t,
      image: n,
      isInline: s,
      isMask: !0,
      pdfFunctionFactory: g,
      localColorSpaceCache: o
    }) : k("Ignoring /Mask in image without /ImageMask.") : this.mask = n);
  }
  static async buildImage({
    xref: A,
    res: t,
    image: i,
    isInline: s = !1,
    pdfFunctionFactory: a,
    localColorSpaceCache: n
  }) {
    const r = i;
    let g = null, o = null;
    const I = i.dict.get("SMask"), c = i.dict.get("Mask");
    return I ? I instanceof JA ? g = I : k("Unsupported /SMask format.") : c && (c instanceof JA || Array.isArray(c) ? o = c : k("Unsupported /Mask format.")), new K0({
      xref: A,
      res: t,
      image: r,
      isInline: s,
      smask: g,
      mask: o,
      pdfFunctionFactory: a,
      localColorSpaceCache: n
    });
  }
  static createRawMask({
    imgArray: A,
    width: t,
    height: i,
    imageIsFromDecodeStream: s,
    inverseDecode: a,
    interpolate: n
  }) {
    const r = (t + 7 >> 3) * i, g = A.byteLength, o = r === g;
    let I, c;
    if (s && (!a || o) ? I = A : a ? (I = new Uint8Array(r), I.set(A), I.fill(255, g)) : I = new Uint8Array(A), a)
      for (c = 0; c < g; c++)
        I[c] ^= 255;
    return {
      data: I,
      width: t,
      height: i,
      interpolate: n
    };
  }
  static async createMask({
    imgArray: A,
    width: t,
    height: i,
    imageIsFromDecodeStream: s,
    inverseDecode: a,
    interpolate: n,
    isOffscreenCanvasSupported: r = !1
  }) {
    const g = t === 1 && i === 1 && a === (A.length === 0 || !!(A[0] & 128));
    if (g)
      return {
        isSingleOpaquePixel: g
      };
    if (r) {
      if ($t.needsToBeResized(t, i)) {
        const h = new Uint8ClampedArray(t * i * 4);
        return gg({
          src: A,
          dest: h,
          width: t,
          height: i,
          nonBlackColor: 0,
          inverseDecode: a
        }), $t.createImage({
          kind: Ue.RGBA_32BPP,
          data: h,
          width: t,
          height: i,
          interpolate: n
        });
      }
      const o = new OffscreenCanvas(t, i), I = o.getContext("2d"), c = I.createImageData(t, i);
      gg({
        src: A,
        dest: c.data,
        width: t,
        height: i,
        nonBlackColor: 0,
        inverseDecode: a
      }), I.putImageData(c, 0, 0);
      const l = o.transferToImageBitmap();
      return {
        data: null,
        width: t,
        height: i,
        interpolate: n,
        bitmap: l
      };
    }
    return this.createRawMask({
      imgArray: A,
      width: t,
      height: i,
      inverseDecode: a,
      imageIsFromDecodeStream: s,
      interpolate: n
    });
  }
  get drawWidth() {
    var A, t;
    return Math.max(this.width, ((A = this.smask) == null ? void 0 : A.width) || 0, ((t = this.mask) == null ? void 0 : t.width) || 0);
  }
  get drawHeight() {
    var A, t;
    return Math.max(this.height, ((A = this.smask) == null ? void 0 : A.height) || 0, ((t = this.mask) == null ? void 0 : t.height) || 0);
  }
  decodeBuffer(A) {
    const t = this.bpc, i = this.numComps, s = this.decodeAddends, a = this.decodeCoefficients, n = (1 << t) - 1;
    let r, g;
    if (t === 1) {
      for (r = 0, g = A.length; r < g; r++)
        A[r] = +!A[r];
      return;
    }
    let o = 0;
    for (r = 0, g = this.width * this.height; r < g; r++)
      for (let I = 0; I < i; I++)
        A[o] = L1(A[o], s[I], a[I], n), o++;
  }
  getComponents(A) {
    const t = this.bpc;
    if (t === 8)
      return A;
    const i = this.width, s = this.height, a = this.numComps, n = i * s * a;
    let r = 0, g;
    t <= 8 ? g = new Uint8Array(n) : t <= 16 ? g = new Uint16Array(n) : g = new Uint32Array(n);
    const o = i * a, I = (1 << t) - 1;
    let c = 0, l, h;
    if (t === 1) {
      let C, B, Q;
      for (let E = 0; E < s; E++) {
        for (B = c + (o & -8), Q = c + o; c < B; )
          h = A[r++], g[c] = h >> 7 & 1, g[c + 1] = h >> 6 & 1, g[c + 2] = h >> 5 & 1, g[c + 3] = h >> 4 & 1, g[c + 4] = h >> 3 & 1, g[c + 5] = h >> 2 & 1, g[c + 6] = h >> 1 & 1, g[c + 7] = h & 1, c += 8;
        if (c < Q)
          for (h = A[r++], C = 128; c < Q; )
            g[c++] = +!!(h & C), C >>= 1;
      }
    } else {
      let C = 0;
      for (h = 0, c = 0, l = n; c < l; ++c) {
        for (c % o === 0 && (h = 0, C = 0); C < t; )
          h = h << 8 | A[r++], C += 8;
        const B = C - t;
        let Q = h >> B;
        Q < 0 ? Q = 0 : Q > I && (Q = I), g[c] = Q, h &= (1 << B) - 1, C = B;
      }
    }
    return g;
  }
  async fillOpacity(A, t, i, s, a) {
    const n = this.smask, r = this.mask;
    let g, o, I, c, l, h;
    if (n)
      o = n.width, I = n.height, g = new Uint8ClampedArray(o * I), await n.fillGrayBuffer(g), (o !== t || I !== i) && (g = HI(g, n.bpc, o, I, t, i));
    else if (r)
      if (r instanceof K0) {
        for (o = r.width, I = r.height, g = new Uint8ClampedArray(o * I), r.numComps = 1, await r.fillGrayBuffer(g), c = 0, l = o * I; c < l; ++c)
          g[c] = 255 - g[c];
        (o !== t || I !== i) && (g = HI(g, r.bpc, o, I, t, i));
      } else if (Array.isArray(r)) {
        g = new Uint8ClampedArray(t * i);
        const C = this.numComps;
        for (c = 0, l = t * i; c < l; ++c) {
          let B = 0;
          const Q = c * C;
          for (h = 0; h < C; ++h) {
            const E = a[Q + h], f = h * 2;
            if (E < r[f] || E > r[f + 1]) {
              B = 255;
              break;
            }
          }
          g[c] = B;
        }
      } else
        throw new v("Unknown mask format.");
    if (g)
      for (c = 0, h = 3, l = t * s; c < l; ++c, h += 4)
        A[h] = g[c];
    else
      for (c = 0, h = 3, l = t * s; c < l; ++c, h += 4)
        A[h] = 255;
  }
  undoPreblend(A, t, i) {
    var I;
    const s = (I = this.smask) == null ? void 0 : I.matte;
    if (!s)
      return;
    const a = this.colorSpace.getRgb(s, 0), n = a[0], r = a[1], g = a[2], o = t * i * 4;
    for (let c = 0; c < o; c += 4) {
      const l = A[c + 3];
      if (l === 0) {
        A[c] = 255, A[c + 1] = 255, A[c + 2] = 255;
        continue;
      }
      const h = 255 / l;
      A[c] = (A[c] - n) * h + n, A[c + 1] = (A[c + 1] - r) * h + r, A[c + 2] = (A[c + 2] - g) * h + g;
    }
  }
  async createImageData(A = !1, t = !1) {
    const i = this.drawWidth, s = this.drawHeight, a = {
      width: i,
      height: s,
      interpolate: this.interpolate,
      kind: 0,
      data: null
    }, n = this.numComps, r = this.width, g = this.height, o = this.bpc, I = r * n * o + 7 >> 3, c = t && $t.needsToBeResized(i, s);
    if (!this.smask && !this.mask && this.colorSpace.name === "DeviceRGBA") {
      a.kind = Ue.RGBA_32BPP;
      const x = a.data = await this.getImageBytes(g * r * 4, {});
      return t ? c ? $t.createImage(a, !1) : this.createBitmap(Ue.RGBA_32BPP, i, s, x) : a;
    }
    if (!A) {
      let x;
      if (this.colorSpace.name === "DeviceGray" && o === 1 ? x = Ue.GRAYSCALE_1BPP : this.colorSpace.name === "DeviceRGB" && o === 8 && !this.needsDecode && (x = Ue.RGB_24BPP), x && !this.smask && !this.mask && i === r && s === g) {
        const m = await BA(this, fa, mg).call(this, r, g);
        if (m)
          return m;
        const p = await this.getImageBytes(g * I, {});
        if (t)
          return c ? $t.createImage({
            data: p,
            kind: x,
            width: i,
            height: s,
            interpolate: this.interpolate
          }, this.needsDecode) : this.createBitmap(x, r, g, p);
        if (a.kind = x, a.data = p, this.needsDecode) {
          _e(x === Ue.GRAYSCALE_1BPP, "PDFImage.createImageData: The image must be grayscale.");
          const D = a.data;
          for (let F = 0, y = D.length; F < y; F++)
            D[F] ^= 255;
        }
        return a;
      }
      if (this.image instanceof ts && !this.smask && !this.mask && !this.needsDecode) {
        let m = g * I;
        if (t && !c) {
          let p = !1;
          switch (this.colorSpace.name) {
            case "DeviceGray":
              m *= 4, p = !0;
              break;
            case "DeviceRGB":
              m = m / 3 * 4, p = !0;
              break;
            case "DeviceCMYK":
              p = !0;
              break;
          }
          if (p) {
            const D = await BA(this, fa, mg).call(this, i, s);
            if (D)
              return D;
            const F = await this.getImageBytes(m, {
              drawWidth: i,
              drawHeight: s,
              forceRGBA: !0
            });
            return this.createBitmap(Ue.RGBA_32BPP, i, s, F);
          }
        } else
          switch (this.colorSpace.name) {
            case "DeviceGray":
              m *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              return a.kind = Ue.RGB_24BPP, a.data = await this.getImageBytes(m, {
                drawWidth: i,
                drawHeight: s,
                forceRGB: !0
              }), c ? $t.createImage(a) : a;
          }
      }
    }
    const l = await this.getImageBytes(g * I, {
      internal: !0
    }), h = 0 | l.length / I * s / g, C = this.getComponents(l);
    let B, Q, E, f, d, u;
    if (t && !c && (E = new OffscreenCanvas(i, s), f = E.getContext("2d"), d = f.createImageData(i, s), u = d.data), a.kind = Ue.RGBA_32BPP, !A && !this.smask && !this.mask ? (!t || c ? (a.kind = Ue.RGB_24BPP, u = new Uint8ClampedArray(i * s * 3), B = 0) : (new Uint32Array(u.buffer).fill(ht.isLittleEndian ? 4278190080 : 255), B = 1), Q = !1) : ((!t || c) && (u = new Uint8ClampedArray(i * s * 4)), B = 1, Q = !0, await this.fillOpacity(u, i, s, h, C)), this.needsDecode && this.decodeBuffer(C), this.colorSpace.fillRgb(u, r, g, i, s, h, o, C, B), Q && this.undoPreblend(u, i, h), t && !c) {
      f.putImageData(d, 0, 0);
      const x = E.transferToImageBitmap();
      return {
        data: null,
        width: i,
        height: s,
        bitmap: x,
        interpolate: this.interpolate
      };
    }
    return a.data = u, c ? $t.createImage(a) : a;
  }
  async fillGrayBuffer(A) {
    const t = this.numComps;
    if (t !== 1)
      throw new v(`Reading gray scale from a color image: ${t}`);
    const i = this.width, s = this.height, a = this.bpc, n = i * t * a + 7 >> 3, r = await this.getImageBytes(s * n, {
      internal: !0
    }), g = this.getComponents(r);
    let o, I;
    if (a === 1) {
      if (I = i * s, this.needsDecode)
        for (o = 0; o < I; ++o)
          A[o] = g[o] - 1 & 255;
      else
        for (o = 0; o < I; ++o)
          A[o] = -g[o] & 255;
      return;
    }
    this.needsDecode && this.decodeBuffer(g), I = i * s;
    const c = 255 / ((1 << a) - 1);
    for (o = 0; o < I; ++o)
      A[o] = c * g[o];
  }
  createBitmap(A, t, i, s) {
    const a = new OffscreenCanvas(t, i), n = a.getContext("2d");
    let r;
    A === Ue.RGBA_32BPP ? r = new ImageData(s, t, i) : (r = n.createImageData(t, i), Lc({
      kind: A,
      src: s,
      dest: new Uint32Array(r.data.buffer),
      width: t,
      height: i,
      inverseDecode: this.needsDecode
    })), n.putImageData(r, 0, 0);
    const g = a.transferToImageBitmap();
    return {
      data: null,
      width: t,
      height: i,
      bitmap: g,
      interpolate: this.interpolate
    };
  }
  async getImageBytes(A, {
    drawWidth: t,
    drawHeight: i,
    forceRGBA: s = !1,
    forceRGB: a = !1,
    internal: n = !1
  }) {
    this.image.reset(), this.image.drawWidth = t || this.width, this.image.drawHeight = i || this.height, this.image.forceRGBA = !!s, this.image.forceRGB = !!a;
    const r = await this.image.getImageData(A, this.jpxDecoderOptions);
    return n || this.image instanceof $e ? r : (_e(r instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.'), new Uint8Array(r));
  }
};
fa = new WeakSet(), mg = async function(A, t) {
  const i = await this.image.getTransferableImage();
  return i ? {
    data: null,
    width: A,
    height: t,
    bitmap: i,
    interpolate: this.interpolate
  } : null;
};
let L0 = K0;
const nl = Object.freeze({
  maxImageSize: -1,
  disableFontFace: !1,
  ignoreErrors: !1,
  isEvalSupported: !0,
  isOffscreenCanvasSupported: !1,
  isImageDecoderSupported: !1,
  canvasMaxAreaInBytes: -1,
  fontExtraProperties: !1,
  useSystemFonts: !0,
  cMapUrl: null,
  standardFontDataUrl: null
}), JI = {
  TILING: 1,
  SHADING: 2
}, H1 = 10, YI = Promise.resolve();
function rl(e, A = !1) {
  if (Array.isArray(e)) {
    for (const t of e) {
      const i = rl(t, !0);
      if (i)
        return i;
    }
    return k(`Unsupported blend mode Array: ${e}`), "source-over";
  }
  if (!(e instanceof L))
    return A ? null : "source-over";
  switch (e.name) {
    case "Normal":
    case "Compatible":
      return "source-over";
    case "Multiply":
      return "multiply";
    case "Screen":
      return "screen";
    case "Overlay":
      return "overlay";
    case "Darken":
      return "darken";
    case "Lighten":
      return "lighten";
    case "ColorDodge":
      return "color-dodge";
    case "ColorBurn":
      return "color-burn";
    case "HardLight":
      return "hard-light";
    case "SoftLight":
      return "soft-light";
    case "Difference":
      return "difference";
    case "Exclusion":
      return "exclusion";
    case "Hue":
      return "hue";
    case "Saturation":
      return "saturation";
    case "Color":
      return "color";
    case "Luminosity":
      return "luminosity";
  }
  return A ? null : (k(`Unsupported blend mode: ${e.name}`), "source-over");
}
function Lr(e, A) {
  var t;
  A.objId && e.addDependency(A.objId), e.addImageOps(A.fn, A.args, A.optionalContent, A.hasMask), A.fn === w.paintImageMaskXObject && ((t = A.args[0]) == null ? void 0 : t.count) > 0 && A.args[0].count++;
}
const v0 = class v0 {
  constructor() {
    this.reset();
  }
  check() {
    return ++this.checked < v0.CHECK_TIME_EVERY ? !1 : (this.checked = 0, this.endTime <= Date.now());
  }
  reset() {
    this.endTime = Date.now() + v0.TIME_SLOT_DURATION_MS, this.checked = 0;
  }
};
Me(v0, "TIME_SLOT_DURATION_MS", 20), Me(v0, "CHECK_TIME_EVERY", 100);
let Sn = v0;
var ua, pg;
const jn = class jn {
  constructor({
    xref: A,
    handler: t,
    pageIndex: i,
    idFactory: s,
    fontCache: a,
    builtInCMapCache: n,
    standardFontDataCache: r,
    globalImageCache: g,
    systemFontCache: o,
    options: I = null
  }) {
    ZA(this, ua);
    this.xref = A, this.handler = t, this.pageIndex = i, this.idFactory = s, this.fontCache = a, this.builtInCMapCache = n, this.standardFontDataCache = r, this.globalImageCache = g, this.systemFontCache = o, this.options = I || nl, this.type3FontRefs = null, this._regionalImageCache = new E1(), this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this), $t.setOptions(this.options), ts.setOptions(this.options);
  }
  get _pdfFunctionFactory() {
    const A = new tl({
      xref: this.xref,
      isEvalSupported: this.options.isEvalSupported
    });
    return iA(this, "_pdfFunctionFactory", A);
  }
  get parsingType3Font() {
    return !!this.type3FontRefs;
  }
  clone(A = null) {
    const t = Object.create(this);
    return t.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, A), t;
  }
  hasBlendModes(A, t) {
    if (!(A instanceof R) || A.objId && t.has(A.objId))
      return !1;
    const i = new Ne(t);
    A.objId && i.put(A.objId);
    const s = [A], a = this.xref;
    for (; s.length; ) {
      const n = s.shift(), r = n.get("ExtGState");
      if (r instanceof R)
        for (let o of r.getRawValues()) {
          if (o instanceof nA) {
            if (i.has(o))
              continue;
            try {
              o = a.fetch(o);
            } catch (c) {
              i.put(o), vA(`hasBlendModes - ignoring ExtGState: "${c}".`);
              continue;
            }
          }
          if (!(o instanceof R))
            continue;
          o.objId && i.put(o.objId);
          const I = o.get("BM");
          if (I instanceof L) {
            if (I.name !== "Normal")
              return !0;
            continue;
          }
          if (I !== void 0 && Array.isArray(I)) {
            for (const c of I)
              if (c instanceof L && c.name !== "Normal")
                return !0;
          }
        }
      const g = n.get("XObject");
      if (g instanceof R)
        for (let o of g.getRawValues()) {
          if (o instanceof nA) {
            if (i.has(o))
              continue;
            try {
              o = a.fetch(o);
            } catch (c) {
              i.put(o), vA(`hasBlendModes - ignoring XObject: "${c}".`);
              continue;
            }
          }
          if (!(o instanceof JA))
            continue;
          o.dict.objId && i.put(o.dict.objId);
          const I = o.dict.get("Resources");
          I instanceof R && (I.objId && i.has(I.objId) || (s.push(I), I.objId && i.put(I.objId)));
        }
    }
    for (const n of i)
      t.put(n);
    return !1;
  }
  async fetchBuiltInCMap(A) {
    const t = this.builtInCMapCache.get(A);
    if (t)
      return t;
    let i;
    return this.options.cMapUrl !== null ? i = {
      cMapData: await BA(this, ua, pg).call(this, `${this.options.cMapUrl}${A}.bcmap`),
      isCompressed: !0
    } : i = await this.handler.sendWithPromise("FetchBuiltInCMap", {
      name: A
    }), this.builtInCMapCache.set(A, i), i;
  }
  async fetchStandardFontData(A) {
    const t = this.standardFontDataCache.get(A);
    if (t)
      return new Qe(t);
    if (this.options.useSystemFonts && A !== "Symbol" && A !== "ZapfDingbats")
      return null;
    const i = JB(), s = i[A];
    let a;
    try {
      this.options.standardFontDataUrl !== null ? a = await BA(this, ua, pg).call(this, `${this.options.standardFontDataUrl}${s}`) : a = await this.handler.sendWithPromise("FetchStandardFontData", {
        filename: s
      });
    } catch (n) {
      return k(n), null;
    }
    return this.standardFontDataCache.set(A, a), new Qe(a);
  }
  async buildFormXObject(A, t, i, s, a, n, r) {
    const g = t.dict, o = Ji(g.getArray("Matrix"), null), I = ii(g.getArray("BBox"), null);
    let c, l;
    g.has("OC") && (c = await this.parseMarkedContentProps(g.get("OC"), A)), c !== void 0 && s.addOp(w.beginMarkedContentProps, ["OC", c]);
    const h = g.get("Group");
    if (h) {
      l = {
        matrix: o,
        bbox: I,
        smask: i,
        isolated: !1,
        knockout: !1
      };
      const B = h.get("S");
      let Q = null;
      if (xe(B, "Transparency") && (l.isolated = h.get("I") || !1, l.knockout = h.get("K") || !1, h.has("CS"))) {
        const E = h.getRaw("CS"), f = LA.getCached(E, this.xref, r);
        f ? Q = f : Q = await this.parseColorSpace({
          cs: E,
          resources: A,
          localColorSpaceCache: r
        });
      }
      i != null && i.backdrop && (Q || (Q = LA.singletons.rgb), i.backdrop = Q.getRgb(i.backdrop, 0)), s.addOp(w.beginGroup, [l]);
    }
    const C = h ? [o, null] : [o, I];
    s.addOp(w.paintFormXObjectBegin, C), await this.getOperatorList({
      stream: t,
      task: a,
      resources: g.get("Resources") || A,
      operatorList: s,
      initialState: n
    }), s.addOp(w.paintFormXObjectEnd, []), h && s.addOp(w.endGroup, [l]), c !== void 0 && s.addOp(w.endMarkedContent, []);
  }
  _sendImgData(A, t, i = !1) {
    const s = t ? [t.bitmap || t.data.buffer] : null;
    return this.parsingType3Font || i ? this.handler.send("commonobj", [A, "Image", t], s) : this.handler.send("obj", [A, this.pageIndex, "Image", t], s);
  }
  async buildPaintImageXObject({
    resources: A,
    image: t,
    isInline: i = !1,
    operatorList: s,
    cacheKey: a,
    localImageCache: n,
    localColorSpaceCache: r
  }) {
    const g = t.dict, o = g.objId, I = g.get("W", "Width"), c = g.get("H", "Height");
    if (!(I && typeof I == "number") || !(c && typeof c == "number")) {
      k("Image dimensions are missing, or not numbers.");
      return;
    }
    const l = this.options.maxImageSize;
    if (l !== -1 && I * c > l) {
      const x = "Image exceeded maximum allowed size and was removed.";
      if (this.options.ignoreErrors) {
        k(x);
        return;
      }
      throw new Error(x);
    }
    let h;
    g.has("OC") && (h = await this.parseMarkedContentProps(g.get("OC"), A));
    const C = g.get("IM", "ImageMask") || !1;
    let B, Q;
    if (C) {
      const x = g.get("I", "Interpolate"), m = I + 7 >> 3, p = t.getBytes(m * c), D = g.getArray("D", "Decode");
      if (this.parsingType3Font) {
        if (B = L0.createRawMask({
          imgArray: p,
          width: I,
          height: c,
          imageIsFromDecodeStream: t instanceof $e,
          inverseDecode: (D == null ? void 0 : D[0]) > 0,
          interpolate: x
        }), B.cached = !!a, Q = [B], s.addImageOps(w.paintImageMaskXObject, Q, h), a) {
          const y = {
            fn: w.paintImageMaskXObject,
            args: Q,
            optionalContent: h
          };
          n.set(a, o, y), o && this._regionalImageCache.set(null, o, y);
        }
        return;
      }
      if (B = await L0.createMask({
        imgArray: p,
        width: I,
        height: c,
        imageIsFromDecodeStream: t instanceof $e,
        inverseDecode: (D == null ? void 0 : D[0]) > 0,
        interpolate: x,
        isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
      }), B.isSingleOpaquePixel) {
        if (s.addImageOps(w.paintSolidColorImageMask, [], h), a) {
          const y = {
            fn: w.paintSolidColorImageMask,
            args: [],
            optionalContent: h
          };
          n.set(a, o, y), o && this._regionalImageCache.set(null, o, y);
        }
        return;
      }
      const F = `mask_${this.idFactory.createObjId()}`;
      if (s.addDependency(F), B.dataLen = B.bitmap ? B.width * B.height * 4 : B.data.length, this._sendImgData(F, B), Q = [{
        data: F,
        width: B.width,
        height: B.height,
        interpolate: B.interpolate,
        count: 1
      }], s.addImageOps(w.paintImageMaskXObject, Q, h), a) {
        const y = {
          objId: F,
          fn: w.paintImageMaskXObject,
          args: Q,
          optionalContent: h
        };
        n.set(a, o, y), o && this._regionalImageCache.set(null, o, y);
      }
      return;
    }
    const E = 200, f = g.has("SMask") || g.has("Mask");
    if (i && I + c < E && !f) {
      try {
        B = await new L0({
          xref: this.xref,
          res: A,
          image: t,
          isInline: i,
          pdfFunctionFactory: this._pdfFunctionFactory,
          localColorSpaceCache: r
        }).createImageData(!0, !1), s.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported, s.addImageOps(w.paintInlineImageXObject, [B], h);
      } catch (x) {
        const m = `Unable to decode inline image: "${x}".`;
        if (!this.options.ignoreErrors)
          throw new Error(m);
        k(m);
      }
      return;
    }
    let d = `img_${this.idFactory.createObjId()}`, u = !1;
    if (this.parsingType3Font ? d = `${this.idFactory.getDocId()}_type3_${d}` : a && o && (u = this.globalImageCache.shouldCache(o, this.pageIndex), u && (_e(!i, "Cannot cache an inline image globally."), d = `${this.idFactory.getDocId()}_${d}`)), s.addDependency(d), Q = [d, I, c], s.addImageOps(w.paintImageXObject, Q, h, f), u) {
      if (this.globalImageCache.hasDecodeFailed(o)) {
        this.globalImageCache.setData(o, {
          objId: d,
          fn: w.paintImageXObject,
          args: Q,
          optionalContent: h,
          hasMask: f,
          byteSize: 0
        }), this._sendImgData(d, null, u);
        return;
      }
      if (I * c > 25e4 || f) {
        const x = await this.handler.sendWithPromise("commonobj", [d, "CopyLocalImage", {
          imageRef: o
        }]);
        if (x) {
          this.globalImageCache.setData(o, {
            objId: d,
            fn: w.paintImageXObject,
            args: Q,
            optionalContent: h,
            hasMask: f,
            byteSize: 0
          }), this.globalImageCache.addByteSize(o, x);
          return;
        }
      }
    }
    if (L0.buildImage({
      xref: this.xref,
      res: A,
      image: t,
      isInline: i,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache: r
    }).then(async (x) => (B = await x.createImageData(!1, this.options.isOffscreenCanvasSupported), B.dataLen = B.bitmap ? B.width * B.height * 4 : B.data.length, B.ref = o, u && this.globalImageCache.addByteSize(o, B.dataLen), this._sendImgData(d, B, u))).catch((x) => (k(`Unable to decode image "${d}": "${x}".`), o && this.globalImageCache.addDecodeFailed(o), this._sendImgData(d, null, u))), a) {
      const x = {
        objId: d,
        fn: w.paintImageXObject,
        args: Q,
        optionalContent: h,
        hasMask: f
      };
      n.set(a, o, x), o && (this._regionalImageCache.set(null, o, x), u && this.globalImageCache.setData(o, {
        objId: d,
        fn: w.paintImageXObject,
        args: Q,
        optionalContent: h,
        hasMask: f,
        byteSize: 0
      }));
    }
  }
  handleSMask(A, t, i, s, a, n) {
    const r = A.get("G"), g = {
      subtype: A.get("S").name,
      backdrop: A.get("BC")
    }, o = A.get("TR");
    if (Mr(o)) {
      const I = this._pdfFunctionFactory.create(o), c = new Uint8Array(256), l = new Float32Array(1);
      for (let h = 0; h < 256; h++)
        l[0] = h / 255, I(l, 0, l, 0), c[h] = l[0] * 255 | 0;
      g.transferMap = c;
    }
    return this.buildFormXObject(t, r, g, i, s, a.state.clone(), n);
  }
  handleTransferFunction(A) {
    let t;
    if (Array.isArray(A))
      t = A;
    else if (Mr(A))
      t = [A];
    else
      return null;
    const i = [];
    let s = 0, a = 0;
    for (const n of t) {
      const r = this.xref.fetchIfRef(n);
      if (s++, xe(r, "Identity")) {
        i.push(null);
        continue;
      } else if (!Mr(r))
        return null;
      const g = this._pdfFunctionFactory.create(r), o = new Uint8Array(256), I = new Float32Array(1);
      for (let c = 0; c < 256; c++)
        I[0] = c / 255, g(I, 0, I, 0), o[c] = I[0] * 255 | 0;
      i.push(o), a++;
    }
    return !(s === 1 || s === 4) || a === 0 ? null : i;
  }
  handleTilingType(A, t, i, s, a, n, r, g) {
    const o = new lt(), I = R.merge({
      xref: this.xref,
      dictArray: [a.get("Resources"), i]
    });
    return this.getOperatorList({
      stream: s,
      task: r,
      resources: I,
      operatorList: o
    }).then(function() {
      const c = o.getIR(), l = pI(c, a, t);
      n.addDependencies(o.dependencies), n.addOp(A, l), a.objId && g.set(null, a.objId, {
        operatorListIR: c,
        dict: a
      });
    }).catch((c) => {
      if (!(c instanceof Te)) {
        if (this.options.ignoreErrors) {
          k(`handleTilingType - ignoring pattern: "${c}".`);
          return;
        }
        throw c;
      }
    });
  }
  async handleSetFont(A, t, i, s, a, n, r = null, g = null) {
    const o = (t == null ? void 0 : t[0]) instanceof L ? t[0].name : null;
    let I = await this.loadFont(o, i, A, r, g);
    if (I.font.isType3Font)
      try {
        await I.loadType3Data(this, A, a), s.addDependencies(I.type3Dependencies);
      } catch (c) {
        I = new Xa({
          loadedName: "g_font_error",
          font: new Nr(`Type3 font load error: ${c}`),
          dict: I.font,
          evaluatorOptions: this.options
        });
      }
    return n.font = I.font, I.send(this.handler), I.loadedName;
  }
  handleText(A, t) {
    const i = t.font, s = i.charsToGlyphs(A);
    return i.data && (t.textRenderingMode & Cc.ADD_TO_PATH_FLAG || t.fillColorSpace.name === "Pattern" || i.disableFontFace || this.options.disableFontFace) && jn.buildFontPaths(i, s, this.handler, this.options), s;
  }
  ensureStateFont(A) {
    if (A.font)
      return;
    const t = new v("Missing setFont (Tf) operator before text rendering operator.");
    if (this.options.ignoreErrors) {
      k(`ensureStateFont: "${t}".`);
      return;
    }
    throw t;
  }
  async setGState({
    resources: A,
    gState: t,
    operatorList: i,
    cacheKey: s,
    task: a,
    stateManager: n,
    localGStateCache: r,
    localColorSpaceCache: g
  }) {
    const o = t.objId;
    let I = !0;
    const c = [];
    let l = Promise.resolve();
    for (const h of t.getKeys()) {
      const C = t.get(h);
      switch (h) {
        case "Type":
          break;
        case "LW":
        case "LC":
        case "LJ":
        case "ML":
        case "D":
        case "RI":
        case "FL":
        case "CA":
        case "ca":
          c.push([h, C]);
          break;
        case "Font":
          I = !1, l = l.then(() => this.handleSetFont(A, null, C[0], i, a, n.state).then(function(Q) {
            i.addDependency(Q), c.push([h, [Q, C[1]]]);
          }));
          break;
        case "BM":
          c.push([h, rl(C)]);
          break;
        case "SMask":
          if (xe(C, "None")) {
            c.push([h, !1]);
            break;
          }
          C instanceof R ? (I = !1, l = l.then(() => this.handleSMask(C, A, i, a, n, g)), c.push([h, !0])) : k("Unsupported SMask type");
          break;
        case "TR":
          const B = this.handleTransferFunction(C);
          c.push([h, B]);
          break;
        case "OP":
        case "op":
        case "OPM":
        case "BG":
        case "BG2":
        case "UCR":
        case "UCR2":
        case "TR2":
        case "HT":
        case "SM":
        case "SA":
        case "AIS":
        case "TK":
          vA("graphic state operator " + h);
          break;
        default:
          vA("Unknown graphic state operator " + h);
          break;
      }
    }
    await l, c.length > 0 && i.addOp(w.setGState, [c]), I && r.set(s, o, c);
  }
  loadFont(A, t, i, s = null, a = null) {
    var B;
    const n = async () => new Xa({
      loadedName: "g_font_error",
      font: new Nr(`Font "${A}" is not available.`),
      dict: t,
      evaluatorOptions: this.options
    });
    let r;
    if (t)
      t instanceof nA && (r = t);
    else {
      const Q = i.get("Font");
      Q && (r = Q.getRaw(A));
    }
    if (r) {
      if ((B = this.type3FontRefs) != null && B.has(r))
        return n();
      if (this.fontCache.has(r))
        return this.fontCache.get(r);
      try {
        t = this.xref.fetchIfRef(r);
      } catch (Q) {
        k(`loadFont - lookup failed: "${Q}".`);
      }
    }
    if (!(t instanceof R)) {
      if (!this.options.ignoreErrors && !this.parsingType3Font)
        return k(`Font "${A}" is not available.`), n();
      k(`Font "${A}" is not available -- attempting to fallback to a default font.`), t = s || jn.fallbackFontDict;
    }
    if (t.cacheKey && this.fontCache.has(t.cacheKey))
      return this.fontCache.get(t.cacheKey);
    const {
      promise: g,
      resolve: o
    } = Promise.withResolvers();
    let I;
    try {
      I = this.preEvaluateFont(t), I.cssFontInfo = a;
    } catch (Q) {
      return k(`loadFont - preEvaluateFont failed: "${Q}".`), n();
    }
    const {
      descriptor: c,
      hash: l
    } = I, h = r instanceof nA;
    let C;
    if (l && c instanceof R) {
      const Q = c.fontAliases || (c.fontAliases = /* @__PURE__ */ Object.create(null));
      if (Q[l]) {
        const E = Q[l].aliasRef;
        if (h && E && this.fontCache.has(E))
          return this.fontCache.putAlias(r, E), this.fontCache.get(r);
      } else
        Q[l] = {
          fontID: this.idFactory.createFontId()
        };
      h && (Q[l].aliasRef = r), C = Q[l].fontID;
    } else
      C = this.idFactory.createFontId();
    return _e(C == null ? void 0 : C.startsWith("f"), 'The "fontID" must be (correctly) defined.'), h ? this.fontCache.put(r, g) : (t.cacheKey = `cacheKey_${C}`, this.fontCache.put(t.cacheKey, g)), t.loadedName = `${this.idFactory.getDocId()}_${C}`, this.translateFont(I).then((Q) => {
      o(new Xa({
        loadedName: t.loadedName,
        font: Q,
        dict: t,
        evaluatorOptions: this.options
      }));
    }).catch((Q) => {
      k(`loadFont - translateFont failed: "${Q}".`), o(new Xa({
        loadedName: t.loadedName,
        font: new Nr(Q instanceof Error ? Q.message : Q),
        dict: t,
        evaluatorOptions: this.options
      }));
    }), g;
  }
  buildPath(A, t, i, s = !1) {
    const a = A.length - 1;
    if (i || (i = []), a < 0 || A.fnArray[a] !== w.constructPath) {
      s && (k(`Encountered path operator "${t}" inside of a text object.`), A.addOp(w.save, null));
      let n;
      switch (t) {
        case w.rectangle:
          const r = i[0] + i[2], g = i[1] + i[3];
          n = [Math.min(i[0], r), Math.min(i[1], g), Math.max(i[0], r), Math.max(i[1], g)];
          break;
        case w.moveTo:
        case w.lineTo:
          n = [i[0], i[1], i[0], i[1]];
          break;
        default:
          n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          break;
      }
      A.addOp(w.constructPath, [[t], i, n]), s && A.addOp(w.restore, null);
    } else {
      const n = A.argsArray[a];
      n[0].push(t), n[1].push(...i);
      const r = n[2];
      switch (t) {
        case w.rectangle:
          const g = i[0] + i[2], o = i[1] + i[3];
          r[0] = Math.min(r[0], i[0], g), r[1] = Math.min(r[1], i[1], o), r[2] = Math.max(r[2], i[0], g), r[3] = Math.max(r[3], i[1], o);
          break;
        case w.moveTo:
        case w.lineTo:
          r[0] = Math.min(r[0], i[0]), r[1] = Math.min(r[1], i[1]), r[2] = Math.max(r[2], i[0]), r[3] = Math.max(r[3], i[1]);
          break;
      }
    }
  }
  parseColorSpace({
    cs: A,
    resources: t,
    localColorSpaceCache: i
  }) {
    return LA.parseAsync({
      cs: A,
      xref: this.xref,
      resources: t,
      pdfFunctionFactory: this._pdfFunctionFactory,
      localColorSpaceCache: i
    }).catch((s) => {
      if (s instanceof Te)
        return null;
      if (this.options.ignoreErrors)
        return k(`parseColorSpace - ignoring ColorSpace: "${s}".`), null;
      throw s;
    });
  }
  parseShading({
    shading: A,
    resources: t,
    localColorSpaceCache: i,
    localShadingPatternCache: s
  }) {
    let a = s.get(A);
    if (a)
      return a;
    let n;
    try {
      n = DQ.parseShading(A, this.xref, t, this._pdfFunctionFactory, i).getIR();
    } catch (r) {
      if (r instanceof Te)
        return null;
      if (this.options.ignoreErrors)
        return k(`parseShading - ignoring shading: "${r}".`), s.set(A, null), null;
      throw r;
    }
    return a = `pattern_${this.idFactory.createObjId()}`, this.parsingType3Font && (a = `${this.idFactory.getDocId()}_type3_${a}`), s.set(A, a), this.parsingType3Font ? this.handler.send("commonobj", [a, "Pattern", n]) : this.handler.send("obj", [a, this.pageIndex, "Pattern", n]), a;
  }
  handleColorN(A, t, i, s, a, n, r, g, o, I) {
    const c = i.pop();
    if (c instanceof L) {
      const l = a.getRaw(c.name), h = l instanceof nA && o.getByRef(l);
      if (h)
        try {
          const B = s.base ? s.base.getRgb(i, 0) : null, Q = pI(h.operatorListIR, h.dict, B);
          A.addOp(t, Q);
          return;
        } catch {
        }
      const C = this.xref.fetchIfRef(l);
      if (C) {
        const B = C instanceof JA ? C.dict : C, Q = B.get("PatternType");
        if (Q === JI.TILING) {
          const E = s.base ? s.base.getRgb(i, 0) : null;
          return this.handleTilingType(t, E, n, C, B, A, r, o);
        } else if (Q === JI.SHADING) {
          const E = B.get("Shading"), f = this.parseShading({
            shading: E,
            resources: n,
            localColorSpaceCache: g,
            localShadingPatternCache: I
          });
          if (f) {
            const d = Ji(B.getArray("Matrix"), null);
            A.addOp(t, ["Shading", f, d]);
          }
          return;
        }
        throw new v(`Unknown PatternType: ${Q}`);
      }
    }
    throw new v(`Unknown PatternName: ${c}`);
  }
  _parseVisibilityExpression(A, t, i) {
    if (++t > 10) {
      k("Visibility expression is too deeply nested");
      return;
    }
    const a = A.length, n = this.xref.fetchIfRef(A[0]);
    if (a < 2 || !(n instanceof L)) {
      k("Invalid visibility expression");
      return;
    }
    switch (n.name) {
      case "And":
      case "Or":
      case "Not":
        i.push(n.name);
        break;
      default:
        k(`Invalid operator ${n.name} in visibility expression`);
        return;
    }
    for (let r = 1; r < a; r++) {
      const g = A[r], o = this.xref.fetchIfRef(g);
      if (Array.isArray(o)) {
        const I = [];
        i.push(I), this._parseVisibilityExpression(o, t, I);
      } else g instanceof nA && i.push(g.toString());
    }
  }
  async parseMarkedContentProps(A, t) {
    var a;
    let i;
    if (A instanceof L)
      i = t.get("Properties").get(A.name);
    else if (A instanceof R)
      i = A;
    else
      throw new v("Optional content properties malformed.");
    const s = (a = i.get("Type")) == null ? void 0 : a.name;
    if (s === "OCG")
      return {
        type: s,
        id: i.objId
      };
    if (s === "OCMD") {
      const n = i.get("VE");
      if (Array.isArray(n)) {
        const g = [];
        if (this._parseVisibilityExpression(n, 0, g), g.length > 0)
          return {
            type: "OCMD",
            expression: g
          };
      }
      const r = i.get("OCGs");
      if (Array.isArray(r) || r instanceof R) {
        const g = [];
        if (Array.isArray(r))
          for (const o of r)
            g.push(o.toString());
        else
          g.push(r.objId);
        return {
          type: s,
          ids: g,
          policy: i.get("P") instanceof L ? i.get("P").name : null,
          expression: null
        };
      } else if (r instanceof nA)
        return {
          type: s,
          id: r.toString()
        };
    }
    return null;
  }
  getOperatorList({
    stream: A,
    task: t,
    resources: i,
    operatorList: s,
    initialState: a = null,
    fallbackFontDict: n = null
  }) {
    if (i || (i = R.empty), a || (a = new gl()), !s)
      throw new Error('getOperatorList: missing "operatorList" parameter');
    const r = this, g = this.xref;
    let o = !1;
    const I = new yI(), c = new Al(), l = new wI(), h = new Q1(), C = /* @__PURE__ */ new Map(), B = i.get("XObject") || R.empty, Q = i.get("Pattern") || R.empty, E = new Qn(a), f = new as(A, g, E), d = new Sn();
    function u(x) {
      for (let m = 0, p = f.savedStatesDepth; m < p; m++)
        s.addOp(w.restore, []);
    }
    return new Promise(function x(m, p) {
      const D = function(G) {
        Promise.all([G, s.ready]).then(function() {
          try {
            x(m, p);
          } catch (S) {
            p(S);
          }
        }, p);
      };
      t.ensureNotTerminated(), d.reset();
      const F = {};
      let y, H, N, T, _, oA;
      for (; !(y = d.check()) && (F.args = null, !!f.read(F)); ) {
        let G = F.args, S = F.fn;
        switch (S | 0) {
          case w.paintXObject:
            if (oA = G[0] instanceof L, _ = G[0].name, oA) {
              const X = I.getByName(_);
              if (X) {
                Lr(s, X), G = null;
                continue;
              }
            }
            D(new Promise(function(X, qA) {
              if (!oA)
                throw new v("XObject must be referred to by name.");
              let IA = B.getRaw(_);
              if (IA instanceof nA) {
                const J = I.getByRef(IA) || r._regionalImageCache.getByRef(IA);
                if (J) {
                  Lr(s, J), X();
                  return;
                }
                const q = r.globalImageCache.getData(IA, r.pageIndex);
                if (q) {
                  s.addDependency(q.objId), s.addImageOps(q.fn, q.args, q.optionalContent, q.hasMask), X();
                  return;
                }
                IA = g.fetch(IA);
              }
              if (!(IA instanceof JA))
                throw new v("XObject should be a stream");
              const U = IA.dict.get("Subtype");
              if (!(U instanceof L))
                throw new v("XObject should have a Name subtype");
              if (U.name === "Form") {
                E.save(), r.buildFormXObject(i, IA, null, s, t, E.state.clone(), c).then(function() {
                  E.restore(), X();
                }, qA);
                return;
              } else if (U.name === "Image") {
                r.buildPaintImageXObject({
                  resources: i,
                  image: IA,
                  operatorList: s,
                  cacheKey: _,
                  localImageCache: I,
                  localColorSpaceCache: c
                }).then(X, qA);
                return;
              } else if (U.name === "PS")
                vA("Ignored XObject subtype PS");
              else
                throw new v(`Unhandled XObject subtype ${U.name}`);
              X();
            }).catch(function(X) {
              if (!(X instanceof Te)) {
                if (r.options.ignoreErrors) {
                  k(`getOperatorList - ignoring XObject: "${X}".`);
                  return;
                }
                throw X;
              }
            }));
            return;
          case w.setFont:
            const tA = G[1];
            D(r.handleSetFont(i, G, null, s, t, E.state, n).then(function(X) {
              s.addDependency(X), s.addOp(w.setFont, [X, tA]);
            }));
            return;
          case w.beginText:
            o = !0;
            break;
          case w.endText:
            o = !1;
            break;
          case w.endInlineImage:
            const $ = G[0].cacheKey;
            if ($) {
              const X = I.getByName($);
              if (X) {
                Lr(s, X), G = null;
                continue;
              }
            }
            D(r.buildPaintImageXObject({
              resources: i,
              image: G[0],
              isInline: !0,
              operatorList: s,
              cacheKey: $,
              localImageCache: I,
              localColorSpaceCache: c
            }));
            return;
          case w.showText:
            if (!E.state.font) {
              r.ensureStateFont(E.state);
              continue;
            }
            G[0] = r.handleText(G[0], E.state);
            break;
          case w.showSpacedText:
            if (!E.state.font) {
              r.ensureStateFont(E.state);
              continue;
            }
            const hA = [], yA = E.state;
            for (const X of G[0])
              typeof X == "string" ? hA.push(...r.handleText(X, yA)) : typeof X == "number" && hA.push(X);
            G[0] = hA, S = w.showText;
            break;
          case w.nextLineShowText:
            if (!E.state.font) {
              r.ensureStateFont(E.state);
              continue;
            }
            s.addOp(w.nextLine), G[0] = r.handleText(G[0], E.state), S = w.showText;
            break;
          case w.nextLineSetSpacingShowText:
            if (!E.state.font) {
              r.ensureStateFont(E.state);
              continue;
            }
            s.addOp(w.nextLine), s.addOp(w.setWordSpacing, [G.shift()]), s.addOp(w.setCharSpacing, [G.shift()]), G[0] = r.handleText(G[0], E.state), S = w.showText;
            break;
          case w.setTextRenderingMode:
            E.state.textRenderingMode = G[0];
            break;
          case w.setFillColorSpace: {
            const X = LA.getCached(G[0], g, c);
            if (X) {
              E.state.fillColorSpace = X;
              continue;
            }
            D(r.parseColorSpace({
              cs: G[0],
              resources: i,
              localColorSpaceCache: c
            }).then(function(qA) {
              E.state.fillColorSpace = qA || LA.singletons.gray;
            }));
            return;
          }
          case w.setStrokeColorSpace: {
            const X = LA.getCached(G[0], g, c);
            if (X) {
              E.state.strokeColorSpace = X;
              continue;
            }
            D(r.parseColorSpace({
              cs: G[0],
              resources: i,
              localColorSpaceCache: c
            }).then(function(qA) {
              E.state.strokeColorSpace = qA || LA.singletons.gray;
            }));
            return;
          }
          case w.setFillColor:
            T = E.state.fillColorSpace, G = T.getRgb(G, 0), S = w.setFillRGBColor;
            break;
          case w.setStrokeColor:
            T = E.state.strokeColorSpace, G = T.getRgb(G, 0), S = w.setStrokeRGBColor;
            break;
          case w.setFillGray:
            E.state.fillColorSpace = LA.singletons.gray, G = LA.singletons.gray.getRgb(G, 0), S = w.setFillRGBColor;
            break;
          case w.setStrokeGray:
            E.state.strokeColorSpace = LA.singletons.gray, G = LA.singletons.gray.getRgb(G, 0), S = w.setStrokeRGBColor;
            break;
          case w.setFillCMYKColor:
            E.state.fillColorSpace = LA.singletons.cmyk, G = LA.singletons.cmyk.getRgb(G, 0), S = w.setFillRGBColor;
            break;
          case w.setStrokeCMYKColor:
            E.state.strokeColorSpace = LA.singletons.cmyk, G = LA.singletons.cmyk.getRgb(G, 0), S = w.setStrokeRGBColor;
            break;
          case w.setFillRGBColor:
            E.state.fillColorSpace = LA.singletons.rgb, G = LA.singletons.rgb.getRgb(G, 0);
            break;
          case w.setStrokeRGBColor:
            E.state.strokeColorSpace = LA.singletons.rgb, G = LA.singletons.rgb.getRgb(G, 0);
            break;
          case w.setFillColorN:
            if (T = E.state.patternFillColorSpace, !T) {
              if (at(G, null)) {
                G = LA.singletons.gray.getRgb(G, 0), S = w.setFillRGBColor;
                break;
              }
              G = [], S = w.setFillTransparent;
              break;
            }
            if (T.name === "Pattern") {
              D(r.handleColorN(s, w.setFillColorN, G, T, Q, i, t, c, h, C));
              return;
            }
            G = T.getRgb(G, 0), S = w.setFillRGBColor;
            break;
          case w.setStrokeColorN:
            if (T = E.state.patternStrokeColorSpace, !T) {
              if (at(G, null)) {
                G = LA.singletons.gray.getRgb(G, 0), S = w.setStrokeRGBColor;
                break;
              }
              G = [], S = w.setStrokeTransparent;
              break;
            }
            if (T.name === "Pattern") {
              D(r.handleColorN(s, w.setStrokeColorN, G, T, Q, i, t, c, h, C));
              return;
            }
            G = T.getRgb(G, 0), S = w.setStrokeRGBColor;
            break;
          case w.shadingFill:
            let pA;
            try {
              const X = i.get("Shading");
              if (!X)
                throw new v("No shading resource found");
              if (pA = X.get(G[0].name), !pA)
                throw new v("No shading object found");
            } catch (X) {
              if (X instanceof Te)
                continue;
              if (r.options.ignoreErrors) {
                k(`getOperatorList - ignoring Shading: "${X}".`);
                continue;
              }
              throw X;
            }
            const DA = r.parseShading({
              shading: pA,
              resources: i,
              localColorSpaceCache: c,
              localShadingPatternCache: C
            });
            if (!DA)
              continue;
            G = [DA], S = w.shadingFill;
            break;
          case w.setGState:
            if (oA = G[0] instanceof L, _ = G[0].name, oA) {
              const X = l.getByName(_);
              if (X) {
                X.length > 0 && s.addOp(w.setGState, [X]), G = null;
                continue;
              }
            }
            D(new Promise(function(X, qA) {
              if (!oA)
                throw new v("GState must be referred to by name.");
              const IA = i.get("ExtGState");
              if (!(IA instanceof R))
                throw new v("ExtGState should be a dictionary.");
              const U = IA.get(_);
              if (!(U instanceof R))
                throw new v("GState should be a dictionary.");
              r.setGState({
                resources: i,
                gState: U,
                operatorList: s,
                cacheKey: _,
                task: t,
                stateManager: E,
                localGStateCache: l,
                localColorSpaceCache: c
              }).then(X, qA);
            }).catch(function(X) {
              if (!(X instanceof Te)) {
                if (r.options.ignoreErrors) {
                  k(`getOperatorList - ignoring ExtGState: "${X}".`);
                  return;
                }
                throw X;
              }
            }));
            return;
          case w.moveTo:
          case w.lineTo:
          case w.curveTo:
          case w.curveTo2:
          case w.curveTo3:
          case w.closePath:
          case w.rectangle:
            r.buildPath(s, S, G, o);
            continue;
          case w.markPoint:
          case w.markPointProps:
          case w.beginCompat:
          case w.endCompat:
            continue;
          case w.beginMarkedContentProps:
            if (!(G[0] instanceof L)) {
              k(`Expected name for beginMarkedContentProps arg0=${G[0]}`), s.addOp(w.beginMarkedContentProps, ["OC", null]);
              continue;
            }
            if (G[0].name === "OC") {
              D(r.parseMarkedContentProps(G[1], i).then((X) => {
                s.addOp(w.beginMarkedContentProps, ["OC", X]);
              }).catch((X) => {
                if (!(X instanceof Te)) {
                  if (r.options.ignoreErrors) {
                    k(`getOperatorList - ignoring beginMarkedContentProps: "${X}".`), s.addOp(w.beginMarkedContentProps, ["OC", null]);
                    return;
                  }
                  throw X;
                }
              }));
              return;
            }
            G = [G[0].name, G[1] instanceof R ? G[1].get("MCID") : null];
            break;
          case w.beginMarkedContent:
          case w.endMarkedContent:
          default:
            if (G !== null) {
              for (H = 0, N = G.length; H < N && !(G[H] instanceof R); H++)
                ;
              if (H < N) {
                k("getOperatorList - ignoring operator: " + S);
                continue;
              }
            }
        }
        s.addOp(S, G);
      }
      if (y) {
        D(YI);
        return;
      }
      u(), m();
    }).catch((x) => {
      if (!(x instanceof Te)) {
        if (this.options.ignoreErrors) {
          k(`getOperatorList - ignoring errors during "${t.name}" task: "${x}".`), u();
          return;
        }
        throw x;
      }
    });
  }
  getTextContent({
    stream: A,
    task: t,
    resources: i,
    stateManager: s = null,
    includeMarkedContent: a = !1,
    sink: n,
    seenStyles: r = /* @__PURE__ */ new Set(),
    viewBox: g,
    lang: o = null,
    markedContentData: I = null,
    disableNormalization: c = !1,
    keepWhiteSpace: l = !1
  }) {
    i || (i = R.empty), s || (s = new Qn(new J1())), a && (I || (I = {
      level: 0
    }));
    const h = {
      items: [],
      styles: /* @__PURE__ */ Object.create(null),
      lang: o
    }, C = {
      initialized: !1,
      str: [],
      totalWidth: 0,
      totalHeight: 0,
      width: 0,
      height: 0,
      vertical: !1,
      prevTransform: null,
      textAdvanceScale: 0,
      spaceInFlowMin: 0,
      spaceInFlowMax: 0,
      trackingSpaceMin: 1 / 0,
      negativeSpaceMax: -1 / 0,
      notASpace: -1 / 0,
      transform: null,
      fontName: null,
      hasEOL: !1
    }, B = [" ", " "];
    let Q = 0;
    function E(z) {
      const W = (Q + 1) % 2, M = B[Q] !== " " && B[W] === " ";
      return B[Q] = z, Q = W, !l && M;
    }
    function f() {
      return !l && B[Q] !== " " && B[(Q + 1) % 2] === " ";
    }
    function d() {
      B[0] = B[1] = " ", Q = 0;
    }
    const u = 0.102, x = 0.03, m = -0.2, p = 0.102, D = 0.6, F = 0.25, y = this, H = this.xref, N = [];
    let T = null;
    const _ = new yI(), oA = new wI(), G = new as(A, H, s);
    let S;
    function tA({
      width: z = 0,
      height: W = 0,
      transform: M = C.prevTransform,
      fontName: CA = C.fontName
    }) {
      h.items.push({
        str: " ",
        dir: "ltr",
        width: z,
        height: W,
        transform: M,
        fontName: CA,
        hasEOL: !1
      });
    }
    function $() {
      const z = S.font, W = [S.fontSize * S.textHScale, 0, 0, S.fontSize, 0, S.textRise];
      if (z.isType3Font && (S.fontSize <= 1 || z.isCharBBox) && !B0(S.fontMatrix, o0)) {
        const M = z.bbox[3] - z.bbox[1];
        M > 0 && (W[3] *= M * S.fontMatrix[3]);
      }
      return de.transform(S.ctm, de.transform(S.textMatrix, W));
    }
    function hA() {
      if (C.initialized)
        return C;
      const {
        font: z,
        loadedName: W
      } = S;
      if (!r.has(W) && (r.add(W), h.styles[W] = {
        fontFamily: z.fallbackName,
        ascent: z.ascent,
        descent: z.descent,
        vertical: z.vertical
      }, y.options.fontExtraProperties && z.systemFontInfo)) {
        const QA = h.styles[W];
        QA.fontSubstitution = z.systemFontInfo.css, QA.fontSubstitutionLoadedName = z.systemFontInfo.loadedName;
      }
      C.fontName = W;
      const M = C.transform = $();
      z.vertical ? (C.width = C.totalWidth = Math.hypot(M[0], M[1]), C.height = C.totalHeight = 0, C.vertical = !0) : (C.width = C.totalWidth = 0, C.height = C.totalHeight = Math.hypot(M[2], M[3]), C.vertical = !1);
      const CA = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]), EA = Math.hypot(S.ctm[0], S.ctm[1]);
      C.textAdvanceScale = EA * CA;
      const {
        fontSize: mA
      } = S;
      return C.trackingSpaceMin = mA * u, C.notASpace = mA * x, C.negativeSpaceMax = mA * m, C.spaceInFlowMin = mA * p, C.spaceInFlowMax = mA * D, C.hasEOL = !1, C.initialized = !0, C;
    }
    function yA() {
      if (!C.initialized)
        return;
      const z = Math.hypot(S.textLineMatrix[0], S.textLineMatrix[1]), M = Math.hypot(S.ctm[0], S.ctm[1]) * z;
      M !== C.textAdvanceScale && (C.vertical ? (C.totalHeight += C.height * C.textAdvanceScale, C.height = 0) : (C.totalWidth += C.width * C.textAdvanceScale, C.width = 0), C.textAdvanceScale = M);
    }
    function pA(z) {
      let W = z.str.join("");
      c || (W = Ph(W));
      const M = il(W, -1, z.vertical);
      return {
        str: M.str,
        dir: M.dir,
        width: Math.abs(z.totalWidth),
        height: Math.abs(z.totalHeight),
        transform: z.transform,
        fontName: z.fontName,
        hasEOL: z.hasEOL
      };
    }
    async function DA(z, W) {
      const M = await y.loadFont(z, W, i);
      if (M.font.isType3Font)
        try {
          await M.loadType3Data(y, i, t);
        } catch {
        }
      S.loadedName = M.loadedName, S.font = M.font, S.fontMatrix = M.font.fontMatrix || o0;
    }
    function X(z, W, M) {
      const CA = Math.hypot(M[0], M[1]);
      return [(M[0] * z + M[1] * W) / CA, (M[2] * z + M[3] * W) / CA];
    }
    function qA(z) {
      var wA;
      const W = $();
      let M = W[4], CA = W[5];
      if ((wA = S.font) != null && wA.vertical) {
        if (M < g[0] || M > g[2] || CA + z < g[1] || CA > g[3])
          return !1;
      } else if (M + z < g[0] || M > g[2] || CA < g[1] || CA > g[3])
        return !1;
      if (!S.font || !C.prevTransform)
        return !0;
      let EA = C.prevTransform[4], mA = C.prevTransform[5];
      if (EA === M && mA === CA)
        return !0;
      let QA = -1;
      switch (W[0] && W[1] === 0 && W[2] === 0 ? QA = W[0] > 0 ? 0 : 180 : W[1] && W[0] === 0 && W[3] === 0 && (QA = W[1] > 0 ? 90 : 270), QA) {
        case 0:
          break;
        case 90:
          [M, CA] = [CA, M], [EA, mA] = [mA, EA];
          break;
        case 180:
          [M, CA, EA, mA] = [-M, -CA, -EA, -mA];
          break;
        case 270:
          [M, CA] = [-CA, -M], [EA, mA] = [-mA, -EA];
          break;
        default:
          [M, CA] = X(M, CA, W), [EA, mA] = X(EA, mA, C.prevTransform);
      }
      if (S.font.vertical) {
        const rA = (mA - CA) / C.textAdvanceScale, bA = M - EA, NA = Math.sign(C.height);
        return rA < NA * C.negativeSpaceMax ? Math.abs(bA) > 0.5 * C.width ? (U(), !0) : (d(), q(), !0) : Math.abs(bA) > C.width ? (U(), !0) : (rA <= NA * C.notASpace && d(), rA <= NA * C.trackingSpaceMin ? f() ? (d(), q(), tA({
          height: Math.abs(rA)
        })) : C.height += rA : J(rA, C.prevTransform, NA) || (C.str.length === 0 ? (d(), tA({
          height: Math.abs(rA)
        })) : C.height += rA), Math.abs(bA) > C.width * F && q(), !0);
      }
      const uA = (M - EA) / C.textAdvanceScale, gA = CA - mA, cA = Math.sign(C.width);
      return uA < cA * C.negativeSpaceMax ? Math.abs(gA) > 0.5 * C.height ? (U(), !0) : (d(), q(), !0) : Math.abs(gA) > C.height ? (U(), !0) : (uA <= cA * C.notASpace && d(), uA <= cA * C.trackingSpaceMin ? f() ? (d(), q(), tA({
        width: Math.abs(uA)
      })) : C.width += uA : J(uA, C.prevTransform, cA) || (C.str.length === 0 ? (d(), tA({
        width: Math.abs(uA)
      })) : C.width += uA), Math.abs(gA) > C.height * F && q(), !0);
    }
    function IA({
      chars: z,
      extraSpacing: W
    }) {
      const M = S.font;
      if (!z) {
        const mA = S.charSpacing + W;
        mA && (M.vertical ? S.translateTextMatrix(0, -mA) : S.translateTextMatrix(mA * S.textHScale, 0)), l && qA(0);
        return;
      }
      const CA = M.charsToGlyphs(z), EA = S.fontMatrix[0] * S.fontSize;
      for (let mA = 0, QA = CA.length; mA < QA; mA++) {
        const uA = CA[mA], {
          category: gA
        } = uA;
        if (gA.isInvisibleFormatMark)
          continue;
        let cA = S.charSpacing + (mA + 1 === QA ? W : 0), wA = uA.width;
        M.vertical && (wA = uA.vmetric ? uA.vmetric[0] : -wA);
        let rA = wA * EA;
        if (!l && gA.isWhitespace) {
          M.vertical ? (cA += -rA + S.wordSpacing, S.translateTextMatrix(0, -cA)) : (cA += rA + S.wordSpacing, S.translateTextMatrix(cA * S.textHScale, 0)), E(" ");
          continue;
        }
        if (!gA.isZeroWidthDiacritic && !qA(rA)) {
          M.vertical ? S.translateTextMatrix(0, rA) : S.translateTextMatrix(rA * S.textHScale, 0);
          continue;
        }
        const bA = hA();
        gA.isZeroWidthDiacritic && (rA = 0), M.vertical ? (S.translateTextMatrix(0, rA), rA = Math.abs(rA), bA.height += rA) : (rA *= S.textHScale, S.translateTextMatrix(rA, 0), bA.width += rA), rA && (bA.prevTransform = $());
        const NA = uA.unicode;
        E(NA) && bA.str.push(" "), bA.str.push(NA), cA && (M.vertical ? S.translateTextMatrix(0, -cA) : S.translateTextMatrix(cA * S.textHScale, 0));
      }
    }
    function U() {
      d(), C.initialized ? (C.hasEOL = !0, q()) : h.items.push({
        str: "",
        dir: "ltr",
        width: 0,
        height: 0,
        transform: $(),
        fontName: S.loadedName,
        hasEOL: !0
      });
    }
    function J(z, W, M) {
      if (M * C.spaceInFlowMin <= z && z <= M * C.spaceInFlowMax)
        return C.initialized && (d(), C.str.push(" ")), !1;
      const CA = C.fontName;
      let EA = 0;
      return C.vertical && (EA = z, z = 0), q(), d(), tA({
        width: Math.abs(z),
        height: Math.abs(EA),
        transform: W || $(),
        fontName: CA
      }), !0;
    }
    function q() {
      !C.initialized || !C.str || (C.vertical ? C.totalHeight += C.height * C.textAdvanceScale : C.totalWidth += C.width * C.textAdvanceScale, h.items.push(pA(C)), C.initialized = !1, C.str.length = 0);
    }
    function Z(z = !1) {
      const W = h.items.length;
      W !== 0 && (z && W < H1 || (n.enqueue(h, W), h.items = [], h.styles = /* @__PURE__ */ Object.create(null)));
    }
    const sA = new Sn();
    return new Promise(function z(W, M) {
      const CA = function(cA) {
        Z(!0), Promise.all([cA, n.ready]).then(function() {
          try {
            z(W, M);
          } catch (wA) {
            M(wA);
          }
        }, M);
      };
      t.ensureNotTerminated(), sA.reset();
      const EA = {};
      let mA, QA, uA, gA = [];
      for (; !(mA = sA.check()) && (gA.length = 0, EA.args = gA, !!G.read(EA)); ) {
        const cA = S;
        S = s.state;
        const wA = EA.fn;
        switch (gA = EA.args, wA | 0) {
          case w.setFont:
            const rA = gA[0].name, bA = gA[1];
            if (S.font && rA === S.fontName && bA === S.fontSize)
              break;
            q(), S.fontName = rA, S.fontSize = bA, CA(DA(rA, null));
            return;
          case w.setTextRise:
            S.textRise = gA[0];
            break;
          case w.setHScale:
            S.textHScale = gA[0] / 100;
            break;
          case w.setLeading:
            S.leading = gA[0];
            break;
          case w.moveText:
            S.translateTextLineMatrix(gA[0], gA[1]), S.textMatrix = S.textLineMatrix.slice();
            break;
          case w.setLeadingMoveText:
            S.leading = -gA[1], S.translateTextLineMatrix(gA[0], gA[1]), S.textMatrix = S.textLineMatrix.slice();
            break;
          case w.nextLine:
            S.carriageReturn();
            break;
          case w.setTextMatrix:
            S.setTextMatrix(gA[0], gA[1], gA[2], gA[3], gA[4], gA[5]), S.setTextLineMatrix(gA[0], gA[1], gA[2], gA[3], gA[4], gA[5]), yA();
            break;
          case w.setCharSpacing:
            S.charSpacing = gA[0];
            break;
          case w.setWordSpacing:
            S.wordSpacing = gA[0];
            break;
          case w.beginText:
            S.textMatrix = Wt.slice(), S.textLineMatrix = Wt.slice();
            break;
          case w.showSpacedText:
            if (!s.state.font) {
              y.ensureStateFont(s.state);
              continue;
            }
            const NA = (S.font.vertical ? 1 : -1) * S.fontSize / 1e3, ue = gA[0];
            for (let xA = 0, KA = ue.length; xA < KA; xA++) {
              const UA = ue[xA];
              if (typeof UA == "string")
                N.push(UA);
              else if (typeof UA == "number" && UA !== 0) {
                const OA = N.join("");
                N.length = 0, IA({
                  chars: OA,
                  extraSpacing: UA * NA
                });
              }
            }
            if (N.length > 0) {
              const xA = N.join("");
              N.length = 0, IA({
                chars: xA,
                extraSpacing: 0
              });
            }
            break;
          case w.showText:
            if (!s.state.font) {
              y.ensureStateFont(s.state);
              continue;
            }
            IA({
              chars: gA[0],
              extraSpacing: 0
            });
            break;
          case w.nextLineShowText:
            if (!s.state.font) {
              y.ensureStateFont(s.state);
              continue;
            }
            S.carriageReturn(), IA({
              chars: gA[0],
              extraSpacing: 0
            });
            break;
          case w.nextLineSetSpacingShowText:
            if (!s.state.font) {
              y.ensureStateFont(s.state);
              continue;
            }
            S.wordSpacing = gA[0], S.charSpacing = gA[1], S.carriageReturn(), IA({
              chars: gA[2],
              extraSpacing: 0
            });
            break;
          case w.paintXObject:
            if (q(), T ?? (T = i.get("XObject") || R.empty), uA = gA[0] instanceof L, QA = gA[0].name, uA && _.getByName(QA))
              break;
            CA(new Promise(function(xA, KA) {
              if (!uA)
                throw new v("XObject must be referred to by name.");
              let UA = T.getRaw(QA);
              if (UA instanceof nA) {
                if (_.getByRef(UA)) {
                  xA();
                  return;
                }
                if (y.globalImageCache.getData(UA, y.pageIndex)) {
                  xA();
                  return;
                }
                UA = H.fetch(UA);
              }
              if (!(UA instanceof JA))
                throw new v("XObject should be a stream");
              const OA = UA.dict.get("Subtype");
              if (!(OA instanceof L))
                throw new v("XObject should have a Name subtype");
              if (OA.name !== "Form") {
                _.set(QA, UA.dict.objId, !0), xA();
                return;
              }
              const re = s.state.clone(), Ve = new Qn(re), d0 = Ji(UA.dict.getArray("Matrix"), null);
              d0 && Ve.transform(d0), Z();
              const Ga = {
                enqueueInvoked: !1,
                enqueue(yi, Er) {
                  this.enqueueInvoked = !0, n.enqueue(yi, Er);
                },
                get desiredSize() {
                  return n.desiredSize;
                },
                get ready() {
                  return n.ready;
                }
              };
              y.getTextContent({
                stream: UA,
                task: t,
                resources: UA.dict.get("Resources") || i,
                stateManager: Ve,
                includeMarkedContent: a,
                sink: Ga,
                seenStyles: r,
                viewBox: g,
                lang: o,
                markedContentData: I,
                disableNormalization: c,
                keepWhiteSpace: l
              }).then(function() {
                Ga.enqueueInvoked || _.set(QA, UA.dict.objId, !0), xA();
              }, KA);
            }).catch(function(xA) {
              if (!(xA instanceof Te)) {
                if (y.options.ignoreErrors) {
                  k(`getTextContent - ignoring XObject: "${xA}".`);
                  return;
                }
                throw xA;
              }
            }));
            return;
          case w.setGState:
            if (uA = gA[0] instanceof L, QA = gA[0].name, uA && oA.getByName(QA))
              break;
            CA(new Promise(function(xA, KA) {
              if (!uA)
                throw new v("GState must be referred to by name.");
              const UA = i.get("ExtGState");
              if (!(UA instanceof R))
                throw new v("ExtGState should be a dictionary.");
              const OA = UA.get(QA);
              if (!(OA instanceof R))
                throw new v("GState should be a dictionary.");
              const re = OA.get("Font");
              if (!re) {
                oA.set(QA, OA.objId, !0), xA();
                return;
              }
              q(), S.fontName = null, S.fontSize = re[1], DA(null, re[0]).then(xA, KA);
            }).catch(function(xA) {
              if (!(xA instanceof Te)) {
                if (y.options.ignoreErrors) {
                  k(`getTextContent - ignoring ExtGState: "${xA}".`);
                  return;
                }
                throw xA;
              }
            }));
            return;
          case w.beginMarkedContent:
            q(), a && (I.level++, h.items.push({
              type: "beginMarkedContent",
              tag: gA[0] instanceof L ? gA[0].name : null
            }));
            break;
          case w.beginMarkedContentProps:
            if (q(), a) {
              I.level++;
              let xA = null;
              gA[1] instanceof R && (xA = gA[1].get("MCID")), h.items.push({
                type: "beginMarkedContentProps",
                id: Number.isInteger(xA) ? `${y.idFactory.getPageObjId()}_mc${xA}` : null,
                tag: gA[0] instanceof L ? gA[0].name : null
              });
            }
            break;
          case w.endMarkedContent:
            if (q(), a) {
              if (I.level === 0)
                break;
              I.level--, h.items.push({
                type: "endMarkedContent"
              });
            }
            break;
          case w.restore:
            cA && (cA.font !== S.font || cA.fontSize !== S.fontSize || cA.fontName !== S.fontName) && q();
            break;
        }
        if (h.items.length >= n.desiredSize) {
          mA = !0;
          break;
        }
      }
      if (mA) {
        CA(YI);
        return;
      }
      q(), Z(), W();
    }).catch((z) => {
      if (!(z instanceof Te)) {
        if (this.options.ignoreErrors) {
          k(`getTextContent - ignoring errors during "${t.name}" task: "${z}".`), q(), Z();
          return;
        }
        throw z;
      }
    });
  }
  async extractDataStructures(A, t) {
    const i = this.xref;
    let s;
    const a = this.readToUnicode(t.toUnicode);
    if (t.composite) {
      const l = A.get("CIDSystemInfo");
      l instanceof R && (t.cidSystemInfo = {
        registry: jA(l.get("Registry")),
        ordering: jA(l.get("Ordering")),
        supplement: l.get("Supplement")
      });
      try {
        const h = A.get("CIDToGIDMap");
        h instanceof JA && (s = h.getBytes());
      } catch (h) {
        if (!this.options.ignoreErrors)
          throw h;
        k(`extractDataStructures - ignoring CIDToGIDMap data: "${h}".`);
      }
    }
    const n = [];
    let r = null, g;
    if (A.has("Encoding")) {
      if (g = A.get("Encoding"), g instanceof R) {
        if (r = g.get("BaseEncoding"), r = r instanceof L ? r.name : null, g.has("Differences")) {
          const l = g.get("Differences");
          let h = 0;
          for (const C of l) {
            const B = i.fetchIfRef(C);
            if (typeof B == "number")
              h = B;
            else if (B instanceof L)
              n[h++] = B.name;
            else
              throw new v(`Invalid entry in 'Differences' array: ${B}`);
          }
        }
      } else if (g instanceof L)
        r = g.name;
      else {
        const l = "Encoding is not a Name nor a Dict";
        if (!this.options.ignoreErrors)
          throw new v(l);
        k(l);
      }
      r !== "MacRomanEncoding" && r !== "MacExpertEncoding" && r !== "WinAnsiEncoding" && (r = null);
    }
    const o = !t.file || t.isInternalFont, I = Cg()[t.name];
    if (r && o && I && (r = null), r)
      t.defaultEncoding = Xs(r);
    else {
      const l = !!(t.flags & vt.Symbolic), h = !!(t.flags & vt.Nonsymbolic);
      g = Ei, t.type === "TrueType" && !h && (g = js), (l || I) && (g = Vg, o && (/Symbol/i.test(t.name) ? g = Zg : /Dingbats/i.test(t.name) ? g = jg : /Wingdings/i.test(t.name) && (g = js))), t.defaultEncoding = g;
    }
    t.differences = n, t.baseEncodingName = r, t.hasEncoding = !!r || n.length > 0, t.dict = A, t.toUnicode = await a;
    const c = await this.buildToUnicode(t);
    return t.toUnicode = c, s && (t.cidToGidMap = this.readCidToGidMap(s, c)), t;
  }
  _simpleFontToUnicode(A, t = !1) {
    _e(!A.composite, "Must be a simple font.");
    const i = [], s = A.defaultEncoding.slice(), a = A.baseEncodingName, n = A.differences;
    for (const g in n) {
      const o = n[g];
      o !== ".notdef" && (s[g] = o);
    }
    const r = ti();
    for (const g in s) {
      let o = s[g];
      if (o === "")
        continue;
      let I = r[o];
      if (I !== void 0) {
        i[g] = String.fromCharCode(I);
        continue;
      }
      let c = 0;
      switch (o[0]) {
        case "G":
          o.length === 3 && (c = parseInt(o.substring(1), 16));
          break;
        case "g":
          o.length === 5 && (c = parseInt(o.substring(1), 16));
          break;
        case "C":
        case "c":
          if (o.length >= 3 && o.length <= 4) {
            const l = o.substring(1);
            if (t) {
              c = parseInt(l, 16);
              break;
            }
            if (c = +l, Number.isNaN(c) && Number.isInteger(parseInt(l, 16)))
              return this._simpleFontToUnicode(A, !0);
          }
          break;
        case "u":
          I = is(o, r), I !== -1 && (c = I);
          break;
        default:
          switch (o) {
            case "f_h":
            case "f_t":
            case "T_h":
              i[g] = o.replaceAll("_", "");
              continue;
          }
          break;
      }
      if (c > 0 && c <= 1114111 && Number.isInteger(c)) {
        if (a && c === +g) {
          const l = Xs(a);
          if (l && (o = l[g])) {
            i[g] = String.fromCharCode(r[o]);
            continue;
          }
        }
        i[g] = String.fromCodePoint(c);
      }
    }
    return i;
  }
  async buildToUnicode(A) {
    var t, i;
    if (A.hasIncludedToUnicodeMap = ((t = A.toUnicode) == null ? void 0 : t.length) > 0, A.hasIncludedToUnicodeMap)
      return !A.composite && A.hasEncoding && (A.fallbackToUnicode = this._simpleFontToUnicode(A)), A.toUnicode;
    if (!A.composite)
      return new Gs(this._simpleFontToUnicode(A));
    if (A.composite && (A.cMap.builtInCMap && !(A.cMap instanceof O0) || ((i = A.cidSystemInfo) == null ? void 0 : i.registry) === "Adobe" && (A.cidSystemInfo.ordering === "GB1" || A.cidSystemInfo.ordering === "CNS1" || A.cidSystemInfo.ordering === "Japan1" || A.cidSystemInfo.ordering === "Korea1"))) {
      const {
        registry: s,
        ordering: a
      } = A.cidSystemInfo, n = L.get(`${s}-${a}-UCS2`), r = await qa.create({
        encoding: n,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      }), g = [], o = [];
      return A.cMap.forEach(function(I, c) {
        if (c > 65535)
          throw new v("Max size of CID is 65,535");
        const l = r.lookup(c);
        if (l) {
          o.length = 0;
          for (let h = 0, C = l.length; h < C; h += 2)
            o.push((l.charCodeAt(h) << 8) + l.charCodeAt(h + 1));
          g[I] = String.fromCharCode(...o);
        }
      }), new Gs(g);
    }
    return new Rt(A.firstChar, A.lastChar);
  }
  async readToUnicode(A) {
    if (!A)
      return null;
    if (A instanceof L) {
      const t = await qa.create({
        encoding: A,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      return t instanceof O0 ? new Rt(0, 65535) : new Gs(t.getMap());
    }
    if (A instanceof JA)
      try {
        const t = await qa.create({
          encoding: A,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        });
        if (t instanceof O0)
          return new Rt(0, 65535);
        const i = new Array(t.length);
        return t.forEach(function(s, a) {
          if (typeof a == "number") {
            i[s] = String.fromCodePoint(a);
            return;
          }
          a.length % 2 !== 0 && (a = "\0" + a);
          const n = [];
          for (let r = 0; r < a.length; r += 2) {
            const g = a.charCodeAt(r) << 8 | a.charCodeAt(r + 1);
            if ((g & 63488) !== 55296) {
              n.push(g);
              continue;
            }
            r += 2;
            const o = a.charCodeAt(r) << 8 | a.charCodeAt(r + 1);
            n.push(((g & 1023) << 10) + (o & 1023) + 65536);
          }
          i[s] = String.fromCodePoint(...n);
        }), new Gs(i);
      } catch (t) {
        if (t instanceof Te)
          return null;
        if (this.options.ignoreErrors)
          return k(`readToUnicode - ignoring ToUnicode data: "${t}".`), null;
        throw t;
      }
    return null;
  }
  readCidToGidMap(A, t) {
    const i = [];
    for (let s = 0, a = A.length; s < a; s++) {
      const n = A[s++] << 8 | A[s], r = s >> 1;
      n === 0 && !t.has(r) || (i[r] = n);
    }
    return i;
  }
  extractWidths(A, t, i) {
    const s = this.xref;
    let a = [], n = 0;
    const r = [];
    let g;
    if (i.composite) {
      const c = A.get("DW");
      n = typeof c == "number" ? Math.ceil(c) : 1e3;
      const l = A.get("W");
      if (Array.isArray(l))
        for (let h = 0, C = l.length; h < C; h++) {
          let B = s.fetchIfRef(l[h++]);
          if (!Number.isInteger(B))
            break;
          const Q = s.fetchIfRef(l[h]);
          if (Array.isArray(Q))
            for (const E of Q) {
              const f = s.fetchIfRef(E);
              typeof f == "number" && (a[B] = f), B++;
            }
          else if (Number.isInteger(Q)) {
            const E = s.fetchIfRef(l[++h]);
            if (typeof E != "number")
              continue;
            for (let f = B; f <= Q; f++)
              a[f] = E;
          } else
            break;
        }
      if (i.vertical) {
        const h = A.getArray("DW2");
        let C = at(h, 2) ? h : [880, -1e3];
        if (g = [C[1], n * 0.5, C[0]], C = A.get("W2"), Array.isArray(C))
          for (let B = 0, Q = C.length; B < Q; B++) {
            let E = s.fetchIfRef(C[B++]);
            if (!Number.isInteger(E))
              break;
            const f = s.fetchIfRef(C[B]);
            if (Array.isArray(f))
              for (let d = 0, u = f.length; d < u; d++) {
                const x = [s.fetchIfRef(f[d++]), s.fetchIfRef(f[d++]), s.fetchIfRef(f[d])];
                at(x, null) && (r[E] = x), E++;
              }
            else if (Number.isInteger(f)) {
              const d = [s.fetchIfRef(C[++B]), s.fetchIfRef(C[++B]), s.fetchIfRef(C[++B])];
              if (!at(d, null))
                continue;
              for (let u = E; u <= f; u++)
                r[u] = d;
            } else
              break;
          }
      }
    } else {
      const c = A.get("Widths");
      if (Array.isArray(c)) {
        let l = i.firstChar;
        for (const C of c) {
          const B = s.fetchIfRef(C);
          typeof B == "number" && (a[l] = B), l++;
        }
        const h = t.get("MissingWidth");
        n = typeof h == "number" ? h : 0;
      } else {
        const l = A.get("BaseFont");
        if (l instanceof L) {
          const h = this.getBaseFontMetrics(l.name);
          a = this.buildCharCodeToWidth(h.widths, i), n = h.defaultWidth;
        }
      }
    }
    let o = !0, I = n;
    for (const c in a) {
      const l = a[c];
      if (l) {
        if (!I) {
          I = l;
          continue;
        }
        if (I !== l) {
          o = !1;
          break;
        }
      }
    }
    o ? i.flags |= vt.FixedPitch : i.flags &= -2, i.defaultWidth = n, i.widths = a, i.defaultVMetrics = g, i.vmetrics = r;
  }
  isSerifFont(A) {
    const t = A.split("-", 1)[0];
    return t in zg() || /serif/gi.test(t);
  }
  getBaseFontMetrics(A) {
    let t = 0, i = /* @__PURE__ */ Object.create(null), s = !1, n = ir()[A] || A;
    const r = ZB();
    n in r || (n = this.isSerifFont(A) ? "Times-Roman" : "Helvetica");
    const g = r[n];
    return typeof g == "number" ? (t = g, s = !0) : i = g(), {
      defaultWidth: t,
      monospace: s,
      widths: i
    };
  }
  buildCharCodeToWidth(A, t) {
    const i = /* @__PURE__ */ Object.create(null), s = t.differences, a = t.defaultEncoding;
    for (let n = 0; n < 256; n++) {
      if (n in s && A[s[n]]) {
        i[n] = A[s[n]];
        continue;
      }
      if (n in a && A[a[n]]) {
        i[n] = A[a[n]];
        continue;
      }
    }
    return i;
  }
  preEvaluateFont(A) {
    const t = A;
    let i = A.get("Subtype");
    if (!(i instanceof L))
      throw new v("invalid font Subtype");
    let s = !1, a;
    if (i.name === "Type0") {
      const I = A.get("DescendantFonts");
      if (!I)
        throw new v("Descendant fonts are not specified");
      if (A = Array.isArray(I) ? this.xref.fetchIfRef(I[0]) : I, !(A instanceof R))
        throw new v("Descendant font is not a dictionary.");
      if (i = A.get("Subtype"), !(i instanceof L))
        throw new v("invalid font Subtype");
      s = !0;
    }
    let n = A.get("FirstChar");
    Number.isInteger(n) || (n = 0);
    let r = A.get("LastChar");
    Number.isInteger(r) || (r = s ? 65535 : 255);
    const g = A.get("FontDescriptor"), o = A.get("ToUnicode") || t.get("ToUnicode");
    if (g) {
      a = new M1();
      const I = t.getRaw("Encoding");
      if (I instanceof L)
        a.update(I.name);
      else if (I instanceof nA)
        a.update(I.toString());
      else if (I instanceof R) {
        for (const l of I.getRawValues())
          if (l instanceof L)
            a.update(l.name);
          else if (l instanceof nA)
            a.update(l.toString());
          else if (Array.isArray(l)) {
            const h = l.length, C = new Array(h);
            for (let B = 0; B < h; B++) {
              const Q = l[B];
              Q instanceof L ? C[B] = Q.name : (typeof Q == "number" || Q instanceof nA) && (C[B] = Q.toString());
            }
            a.update(C.join());
          }
      }
      if (a.update(`${n}-${r}`), o instanceof JA) {
        const l = o.str || o, h = l.buffer ? new Uint8Array(l.buffer.buffer, 0, l.bufferLength) : new Uint8Array(l.bytes.buffer, l.start, l.end - l.start);
        a.update(h);
      } else o instanceof L && a.update(o.name);
      const c = A.get("Widths") || t.get("Widths");
      if (Array.isArray(c)) {
        const l = [];
        for (const h of c)
          (typeof h == "number" || h instanceof nA) && l.push(h.toString());
        a.update(l.join());
      }
      if (s) {
        a.update("compositeFont");
        const l = A.get("W") || t.get("W");
        if (Array.isArray(l)) {
          const C = [];
          for (const B of l)
            if (typeof B == "number" || B instanceof nA)
              C.push(B.toString());
            else if (Array.isArray(B)) {
              const Q = [];
              for (const E of B)
                (typeof E == "number" || E instanceof nA) && Q.push(E.toString());
              C.push(`[${Q.join()}]`);
            }
          a.update(C.join());
        }
        const h = A.getRaw("CIDToGIDMap") || t.getRaw("CIDToGIDMap");
        h instanceof L ? a.update(h.name) : h instanceof nA ? a.update(h.toString()) : h instanceof JA && a.update(h.peekBytes());
      }
    }
    return {
      descriptor: g,
      dict: A,
      baseDict: t,
      composite: s,
      type: i.name,
      firstChar: n,
      lastChar: r,
      toUnicode: o,
      hash: a ? a.hexdigest() : ""
    };
  }
  async translateFont({
    descriptor: A,
    dict: t,
    baseDict: i,
    composite: s,
    type: a,
    firstChar: n,
    lastChar: r,
    toUnicode: g,
    cssFontInfo: o
  }) {
    const I = a === "Type3";
    if (!A)
      if (I) {
        const S = ii(t.getArray("FontBBox"), [0, 0, 0, 0]);
        A = new R(null), A.set("FontName", L.get(a)), A.set("FontBBox", S);
      } else {
        let S = t.get("BaseFont");
        if (!(S instanceof L))
          throw new v("Base font is not specified");
        S = S.name.replaceAll(/[,_]/g, "-");
        const tA = this.getBaseFontMetrics(S), $ = S.split("-", 1)[0], hA = (this.isSerifFont($) ? vt.Serif : 0) | (tA.monospace ? vt.FixedPitch : 0) | (Cg()[$] ? vt.Symbolic : vt.Nonsymbolic), yA = {
          type: a,
          name: S,
          loadedName: i.loadedName,
          systemFontInfo: null,
          widths: tA.widths,
          defaultWidth: tA.defaultWidth,
          isSimulatedFlags: !0,
          flags: hA,
          firstChar: n,
          lastChar: r,
          toUnicode: g,
          xHeight: 0,
          capHeight: 0,
          italicAngle: 0,
          isType3Font: I
        }, pA = t.get("Widths"), DA = iI(S);
        let X = null;
        DA && (X = await this.fetchStandardFontData(DA), yA.isInternalFont = !!X), !yA.isInternalFont && this.options.useSystemFonts && (yA.systemFontInfo = NI(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, S, DA, a));
        const qA = await this.extractDataStructures(t, yA);
        if (Array.isArray(pA)) {
          const IA = [];
          let U = n;
          for (const J of pA) {
            const q = this.xref.fetchIfRef(J);
            typeof q == "number" && (IA[U] = q), U++;
          }
          qA.widths = IA;
        } else
          qA.widths = this.buildCharCodeToWidth(tA.widths, qA);
        return new xI(S, X, qA);
      }
    let c = A.get("FontName"), l = t.get("BaseFont");
    typeof c == "string" && (c = L.get(c)), typeof l == "string" && (l = L.get(l));
    const h = c == null ? void 0 : c.name, C = l == null ? void 0 : l.name;
    if (!I && h !== C && (vA(`The FontDescriptor's FontName is "${h}" but should be the same as the Font's BaseFont "${C}".`), h && C && (C.startsWith(h) || !sI(h) && sI(C)) && (c = null)), c || (c = l), !(c instanceof L))
      throw new v("invalid font name");
    let B, Q, E, f, d;
    try {
      if (B = A.get("FontFile", "FontFile2", "FontFile3"), B)
        if (B instanceof JA) {
          if (B.isEmpty)
            throw new v("FontFile is empty");
        } else throw new v("FontFile should be a stream");
    } catch (S) {
      if (!this.options.ignoreErrors)
        throw S;
      k(`translateFont - fetching "${c.name}" font file: "${S}".`), B = null;
    }
    let u = !1, x = null, m = null;
    if (B) {
      if (B.dict) {
        const S = B.dict.get("Subtype");
        S instanceof L && (Q = S.name), E = B.dict.get("Length1"), f = B.dict.get("Length2"), d = B.dict.get("Length3");
      }
    } else if (o) {
      const S = to(c.name);
      S && (o.fontFamily = `${o.fontFamily}-PdfJS-XFA`, o.metrics = S.metrics || null, x = S.factors || null, B = await this.fetchStandardFontData(S.name), u = !!B, i = t = $c(c.name), s = !0);
    } else if (!I) {
      const S = iI(c.name);
      S && (B = await this.fetchStandardFontData(S), u = !!B), !u && this.options.useSystemFonts && (m = NI(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, c.name, S, a));
    }
    const p = Ji(t.getArray("FontMatrix"), o0), D = ii(A.getArray("FontBBox") || t.getArray("FontBBox"), void 0);
    let F = A.get("Ascent");
    typeof F != "number" && (F = void 0);
    let y = A.get("Descent");
    typeof y != "number" && (y = void 0);
    let H = A.get("XHeight");
    typeof H != "number" && (H = 0);
    let N = A.get("CapHeight");
    typeof N != "number" && (N = 0);
    let T = A.get("Flags");
    Number.isInteger(T) || (T = 0);
    let _ = A.get("ItalicAngle");
    typeof _ != "number" && (_ = 0);
    const oA = {
      type: a,
      name: c.name,
      subtype: Q,
      file: B,
      length1: E,
      length2: f,
      length3: d,
      isInternalFont: u,
      loadedName: i.loadedName,
      composite: s,
      fixedPitch: !1,
      fontMatrix: p,
      firstChar: n,
      lastChar: r,
      toUnicode: g,
      bbox: D,
      ascent: F,
      descent: y,
      xHeight: H,
      capHeight: N,
      flags: T,
      italicAngle: _,
      isType3Font: I,
      cssFontInfo: o,
      scaleFactors: x,
      systemFontInfo: m
    };
    if (s) {
      const S = i.get("Encoding");
      S instanceof L && (oA.cidEncoding = S.name);
      const tA = await qa.create({
        encoding: S,
        fetchBuiltInCMap: this._fetchBuiltInCMapBound,
        useCMap: null
      });
      oA.cMap = tA, oA.vertical = oA.cMap.vertical;
    }
    const G = await this.extractDataStructures(t, oA);
    return this.extractWidths(t, A, G), new xI(c.name, B, G);
  }
  static buildFontPaths(A, t, i, s) {
    function a(n) {
      const r = `${A.loadedName}_path_${n}`;
      try {
        if (A.renderer.hasBuiltPath(n))
          return;
        i.send("commonobj", [r, "FontPath", A.renderer.getPathJs(n)]);
      } catch (g) {
        if (s.ignoreErrors) {
          k(`buildFontPaths - ignoring ${r} glyph: "${g}".`);
          return;
        }
        throw g;
      }
    }
    for (const n of t) {
      a(n.fontChar);
      const r = n.accent;
      r != null && r.fontChar && a(r.fontChar);
    }
  }
  static get fallbackFontDict() {
    const A = new R();
    return A.set("BaseFont", L.get("Helvetica")), A.set("Type", L.get("FallbackType")), A.set("Subtype", L.get("FallbackType")), A.set("Encoding", L.get("WinAnsiEncoding")), iA(this, "fallbackFontDict", A);
  }
};
ua = new WeakSet(), pg = async function(A) {
  const t = await fetch(A);
  if (!t.ok)
    throw new Error(`Failed to fetch file "${A}" with "${t.statusText}".`);
  return new Uint8Array(await t.arrayBuffer());
};
let Ci = jn;
class Xa {
  constructor({
    loadedName: A,
    font: t,
    dict: i,
    evaluatorOptions: s
  }) {
    this.loadedName = A, this.font = t, this.dict = i, this._evaluatorOptions = s || nl, this.type3Loaded = null, this.type3Dependencies = t.isType3Font ? /* @__PURE__ */ new Set() : null, this.sent = !1;
  }
  send(A) {
    this.sent || (this.sent = !0, A.send("commonobj", [this.loadedName, "Font", this.font.exportData(this._evaluatorOptions.fontExtraProperties)]));
  }
  fallback(A) {
    this.font.data && (this.font.disableFontFace = !0, Ci.buildFontPaths(this.font, this.font.glyphCacheValues, A, this._evaluatorOptions));
  }
  loadType3Data(A, t, i) {
    if (this.type3Loaded)
      return this.type3Loaded;
    if (!this.font.isType3Font)
      throw new Error("Must be a Type3 font.");
    const s = A.clone({
      ignoreErrors: !1
    }), a = new Ne(A.type3FontRefs);
    this.dict.objId && !a.has(this.dict.objId) && a.put(this.dict.objId), s.type3FontRefs = a;
    const n = this.font, r = this.type3Dependencies;
    let g = Promise.resolve();
    const o = this.dict.get("CharProcs"), I = this.dict.get("Resources") || t, c = /* @__PURE__ */ Object.create(null), l = de.normalizeRect(n.bbox || [0, 0, 0, 0]), h = l[2] - l[0], C = l[3] - l[1], B = Math.hypot(h, C);
    for (const Q of o.getKeys())
      g = g.then(() => {
        const E = o.get(Q), f = new lt();
        return s.getOperatorList({
          stream: E,
          task: i,
          resources: I,
          operatorList: f
        }).then(() => {
          f.fnArray[0] === w.setCharWidthAndBounds && this._removeType3ColorOperators(f, B), c[Q] = f.getIR();
          for (const d of f.dependencies)
            r.add(d);
        }).catch(function(d) {
          k(`Type3 font resource "${Q}" is not available.`);
          const u = new lt();
          c[Q] = u.getIR();
        });
      });
    return this.type3Loaded = g.then(() => {
      n.charProcOperatorList = c, this._bbox && (n.isCharBBox = !0, n.bbox = this._bbox);
    }), this.type3Loaded;
  }
  _removeType3ColorOperators(A, t = NaN) {
    const i = de.normalizeRect(A.argsArray[0].slice(2)), s = i[2] - i[0], a = i[3] - i[1], n = Math.hypot(s, a);
    s === 0 || a === 0 ? (A.fnArray.splice(0, 1), A.argsArray.splice(0, 1)) : (t === 0 || Math.round(n / t) >= 10) && (this._bbox || (this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0]), this._bbox[0] = Math.min(this._bbox[0], i[0]), this._bbox[1] = Math.min(this._bbox[1], i[1]), this._bbox[2] = Math.max(this._bbox[2], i[2]), this._bbox[3] = Math.max(this._bbox[3], i[3]));
    let r = 0, g = A.length;
    for (; r < g; ) {
      switch (A.fnArray[r]) {
        case w.setCharWidthAndBounds:
          break;
        case w.setStrokeColorSpace:
        case w.setFillColorSpace:
        case w.setStrokeColor:
        case w.setStrokeColorN:
        case w.setFillColor:
        case w.setFillColorN:
        case w.setStrokeGray:
        case w.setFillGray:
        case w.setStrokeRGBColor:
        case w.setFillRGBColor:
        case w.setStrokeCMYKColor:
        case w.setFillCMYKColor:
        case w.shadingFill:
        case w.setRenderingIntent:
          A.fnArray.splice(r, 1), A.argsArray.splice(r, 1), g--;
          continue;
        case w.setGState:
          const [o] = A.argsArray[r];
          let I = 0, c = o.length;
          for (; I < c; ) {
            const [l] = o[I];
            switch (l) {
              case "TR":
              case "TR2":
              case "HT":
              case "BG":
              case "BG2":
              case "UCR":
              case "UCR2":
                o.splice(I, 1), c--;
                continue;
            }
            I++;
          }
          break;
      }
      r++;
    }
  }
}
class Qn {
  constructor(A = new gl()) {
    this.state = A, this.stateStack = [];
  }
  save() {
    const A = this.state;
    this.stateStack.push(this.state), this.state = A.clone();
  }
  restore() {
    const A = this.stateStack.pop();
    A && (this.state = A);
  }
  transform(A) {
    this.state.ctm = de.transform(this.state.ctm, A);
  }
}
class J1 {
  constructor() {
    this.ctm = new Float32Array(Wt), this.fontName = null, this.fontSize = 0, this.loadedName = null, this.font = null, this.fontMatrix = o0, this.textMatrix = Wt.slice(), this.textLineMatrix = Wt.slice(), this.charSpacing = 0, this.wordSpacing = 0, this.leading = 0, this.textHScale = 1, this.textRise = 0;
  }
  setTextMatrix(A, t, i, s, a, n) {
    const r = this.textMatrix;
    r[0] = A, r[1] = t, r[2] = i, r[3] = s, r[4] = a, r[5] = n;
  }
  setTextLineMatrix(A, t, i, s, a, n) {
    const r = this.textLineMatrix;
    r[0] = A, r[1] = t, r[2] = i, r[3] = s, r[4] = a, r[5] = n;
  }
  translateTextMatrix(A, t) {
    const i = this.textMatrix;
    i[4] = i[0] * A + i[2] * t + i[4], i[5] = i[1] * A + i[3] * t + i[5];
  }
  translateTextLineMatrix(A, t) {
    const i = this.textLineMatrix;
    i[4] = i[0] * A + i[2] * t + i[4], i[5] = i[1] * A + i[3] * t + i[5];
  }
  carriageReturn() {
    this.translateTextLineMatrix(0, -this.leading), this.textMatrix = this.textLineMatrix.slice();
  }
  clone() {
    const A = Object.create(this);
    return A.textMatrix = this.textMatrix.slice(), A.textLineMatrix = this.textLineMatrix.slice(), A.fontMatrix = this.fontMatrix.slice(), A;
  }
}
class gl {
  constructor() {
    this.ctm = new Float32Array(Wt), this.font = null, this.textRenderingMode = Cc.FILL, this._fillColorSpace = LA.singletons.gray, this._strokeColorSpace = LA.singletons.gray, this.patternFillColorSpace = null, this.patternStrokeColorSpace = null;
  }
  get fillColorSpace() {
    return this._fillColorSpace;
  }
  set fillColorSpace(A) {
    this._fillColorSpace = this.patternFillColorSpace = A;
  }
  get strokeColorSpace() {
    return this._strokeColorSpace;
  }
  set strokeColorSpace(A) {
    this._strokeColorSpace = this.patternStrokeColorSpace = A;
  }
  clone() {
    return Object.create(this);
  }
}
const T0 = class T0 {
  static get opMap() {
    return iA(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), {
      w: {
        id: w.setLineWidth,
        numArgs: 1,
        variableArgs: !1
      },
      J: {
        id: w.setLineCap,
        numArgs: 1,
        variableArgs: !1
      },
      j: {
        id: w.setLineJoin,
        numArgs: 1,
        variableArgs: !1
      },
      M: {
        id: w.setMiterLimit,
        numArgs: 1,
        variableArgs: !1
      },
      d: {
        id: w.setDash,
        numArgs: 2,
        variableArgs: !1
      },
      ri: {
        id: w.setRenderingIntent,
        numArgs: 1,
        variableArgs: !1
      },
      i: {
        id: w.setFlatness,
        numArgs: 1,
        variableArgs: !1
      },
      gs: {
        id: w.setGState,
        numArgs: 1,
        variableArgs: !1
      },
      q: {
        id: w.save,
        numArgs: 0,
        variableArgs: !1
      },
      Q: {
        id: w.restore,
        numArgs: 0,
        variableArgs: !1
      },
      cm: {
        id: w.transform,
        numArgs: 6,
        variableArgs: !1
      },
      m: {
        id: w.moveTo,
        numArgs: 2,
        variableArgs: !1
      },
      l: {
        id: w.lineTo,
        numArgs: 2,
        variableArgs: !1
      },
      c: {
        id: w.curveTo,
        numArgs: 6,
        variableArgs: !1
      },
      v: {
        id: w.curveTo2,
        numArgs: 4,
        variableArgs: !1
      },
      y: {
        id: w.curveTo3,
        numArgs: 4,
        variableArgs: !1
      },
      h: {
        id: w.closePath,
        numArgs: 0,
        variableArgs: !1
      },
      re: {
        id: w.rectangle,
        numArgs: 4,
        variableArgs: !1
      },
      S: {
        id: w.stroke,
        numArgs: 0,
        variableArgs: !1
      },
      s: {
        id: w.closeStroke,
        numArgs: 0,
        variableArgs: !1
      },
      f: {
        id: w.fill,
        numArgs: 0,
        variableArgs: !1
      },
      F: {
        id: w.fill,
        numArgs: 0,
        variableArgs: !1
      },
      "f*": {
        id: w.eoFill,
        numArgs: 0,
        variableArgs: !1
      },
      B: {
        id: w.fillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      "B*": {
        id: w.eoFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      b: {
        id: w.closeFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      "b*": {
        id: w.closeEOFillStroke,
        numArgs: 0,
        variableArgs: !1
      },
      n: {
        id: w.endPath,
        numArgs: 0,
        variableArgs: !1
      },
      W: {
        id: w.clip,
        numArgs: 0,
        variableArgs: !1
      },
      "W*": {
        id: w.eoClip,
        numArgs: 0,
        variableArgs: !1
      },
      BT: {
        id: w.beginText,
        numArgs: 0,
        variableArgs: !1
      },
      ET: {
        id: w.endText,
        numArgs: 0,
        variableArgs: !1
      },
      Tc: {
        id: w.setCharSpacing,
        numArgs: 1,
        variableArgs: !1
      },
      Tw: {
        id: w.setWordSpacing,
        numArgs: 1,
        variableArgs: !1
      },
      Tz: {
        id: w.setHScale,
        numArgs: 1,
        variableArgs: !1
      },
      TL: {
        id: w.setLeading,
        numArgs: 1,
        variableArgs: !1
      },
      Tf: {
        id: w.setFont,
        numArgs: 2,
        variableArgs: !1
      },
      Tr: {
        id: w.setTextRenderingMode,
        numArgs: 1,
        variableArgs: !1
      },
      Ts: {
        id: w.setTextRise,
        numArgs: 1,
        variableArgs: !1
      },
      Td: {
        id: w.moveText,
        numArgs: 2,
        variableArgs: !1
      },
      TD: {
        id: w.setLeadingMoveText,
        numArgs: 2,
        variableArgs: !1
      },
      Tm: {
        id: w.setTextMatrix,
        numArgs: 6,
        variableArgs: !1
      },
      "T*": {
        id: w.nextLine,
        numArgs: 0,
        variableArgs: !1
      },
      Tj: {
        id: w.showText,
        numArgs: 1,
        variableArgs: !1
      },
      TJ: {
        id: w.showSpacedText,
        numArgs: 1,
        variableArgs: !1
      },
      "'": {
        id: w.nextLineShowText,
        numArgs: 1,
        variableArgs: !1
      },
      '"': {
        id: w.nextLineSetSpacingShowText,
        numArgs: 3,
        variableArgs: !1
      },
      d0: {
        id: w.setCharWidth,
        numArgs: 2,
        variableArgs: !1
      },
      d1: {
        id: w.setCharWidthAndBounds,
        numArgs: 6,
        variableArgs: !1
      },
      CS: {
        id: w.setStrokeColorSpace,
        numArgs: 1,
        variableArgs: !1
      },
      cs: {
        id: w.setFillColorSpace,
        numArgs: 1,
        variableArgs: !1
      },
      SC: {
        id: w.setStrokeColor,
        numArgs: 4,
        variableArgs: !0
      },
      SCN: {
        id: w.setStrokeColorN,
        numArgs: 33,
        variableArgs: !0
      },
      sc: {
        id: w.setFillColor,
        numArgs: 4,
        variableArgs: !0
      },
      scn: {
        id: w.setFillColorN,
        numArgs: 33,
        variableArgs: !0
      },
      G: {
        id: w.setStrokeGray,
        numArgs: 1,
        variableArgs: !1
      },
      g: {
        id: w.setFillGray,
        numArgs: 1,
        variableArgs: !1
      },
      RG: {
        id: w.setStrokeRGBColor,
        numArgs: 3,
        variableArgs: !1
      },
      rg: {
        id: w.setFillRGBColor,
        numArgs: 3,
        variableArgs: !1
      },
      K: {
        id: w.setStrokeCMYKColor,
        numArgs: 4,
        variableArgs: !1
      },
      k: {
        id: w.setFillCMYKColor,
        numArgs: 4,
        variableArgs: !1
      },
      sh: {
        id: w.shadingFill,
        numArgs: 1,
        variableArgs: !1
      },
      BI: {
        id: w.beginInlineImage,
        numArgs: 0,
        variableArgs: !1
      },
      ID: {
        id: w.beginImageData,
        numArgs: 0,
        variableArgs: !1
      },
      EI: {
        id: w.endInlineImage,
        numArgs: 1,
        variableArgs: !1
      },
      Do: {
        id: w.paintXObject,
        numArgs: 1,
        variableArgs: !1
      },
      MP: {
        id: w.markPoint,
        numArgs: 1,
        variableArgs: !1
      },
      DP: {
        id: w.markPointProps,
        numArgs: 2,
        variableArgs: !1
      },
      BMC: {
        id: w.beginMarkedContent,
        numArgs: 1,
        variableArgs: !1
      },
      BDC: {
        id: w.beginMarkedContentProps,
        numArgs: 2,
        variableArgs: !1
      },
      EMC: {
        id: w.endMarkedContent,
        numArgs: 0,
        variableArgs: !1
      },
      BX: {
        id: w.beginCompat,
        numArgs: 0,
        variableArgs: !1
      },
      EX: {
        id: w.endCompat,
        numArgs: 0,
        variableArgs: !1
      },
      BM: null,
      BD: null,
      true: null,
      fa: null,
      fal: null,
      fals: null,
      false: null,
      nu: null,
      nul: null,
      null: null
    }));
  }
  constructor(A, t, i = new Qn()) {
    this.parser = new Si({
      lexer: new qt(A, T0.opMap),
      xref: t
    }), this.stateManager = i, this.nonProcessedArgs = [], this._isPathOp = !1, this._numInvalidPathOPS = 0;
  }
  get savedStatesDepth() {
    return this.stateManager.stateStack.length;
  }
  read(A) {
    let t = A.args;
    for (; ; ) {
      const i = this.parser.getObj();
      if (i instanceof be) {
        const s = i.cmd, a = T0.opMap[s];
        if (!a) {
          k(`Unknown command "${s}".`);
          continue;
        }
        const n = a.id, r = a.numArgs;
        let g = t !== null ? t.length : 0;
        if (this._isPathOp || (this._numInvalidPathOPS = 0), this._isPathOp = n >= w.moveTo && n <= w.endPath, a.variableArgs)
          g > r && vA(`Command ${s}: expected [0, ${r}] args, but received ${g} args.`);
        else {
          if (g !== r) {
            const o = this.nonProcessedArgs;
            for (; g > r; )
              o.push(t.shift()), g--;
            for (; g < r && o.length !== 0; )
              t === null && (t = []), t.unshift(o.pop()), g++;
          }
          if (g < r) {
            const o = `command ${s}: expected ${r} args, but received ${g} args.`;
            if (this._isPathOp && ++this._numInvalidPathOPS > T0.MAX_INVALID_PATH_OPS)
              throw new v(`Invalid ${o}`);
            k(`Skipping ${o}`), t !== null && (t.length = 0);
            continue;
          }
        }
        return this.preprocessCommand(n, t), A.fn = n, A.args = t, !0;
      }
      if (i === Le)
        return !1;
      if (i !== null && (t === null && (t = []), t.push(i), t.length > 33))
        throw new v("Too many arguments");
    }
  }
  preprocessCommand(A, t) {
    switch (A | 0) {
      case w.save:
        this.stateManager.save();
        break;
      case w.restore:
        this.stateManager.restore();
        break;
      case w.transform:
        this.stateManager.transform(t);
        break;
    }
  }
};
Me(T0, "MAX_INVALID_PATH_OPS", 10);
let as = T0;
class Y1 extends as {
  constructor(A) {
    super(new Ct(A));
  }
  parse() {
    const A = {
      fn: 0,
      args: []
    }, t = {
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3)
    };
    try {
      for (; A.args.length = 0, !!this.read(A); ) {
        if (this.savedStatesDepth !== 0)
          continue;
        const {
          fn: i,
          args: s
        } = A;
        switch (i | 0) {
          case w.setFont:
            const [a, n] = s;
            a instanceof L && (t.fontName = a.name), typeof n == "number" && n > 0 && (t.fontSize = n);
            break;
          case w.setFillRGBColor:
            LA.singletons.rgb.getRgbItem(s, 0, t.fontColor, 0);
            break;
          case w.setFillGray:
            LA.singletons.gray.getRgbItem(s, 0, t.fontColor, 0);
            break;
          case w.setFillCMYKColor:
            LA.singletons.cmyk.getRgbItem(s, 0, t.fontColor, 0);
            break;
        }
      }
    } catch (i) {
      k(`parseDefaultAppearance - ignoring errors: "${i}".`);
    }
    return t;
  }
}
function so(e) {
  return new Y1(e).parse();
}
class K1 extends as {
  constructor(A, t, i) {
    var s;
    super(A), this.stream = A, this.evaluatorOptions = t, this.xref = i, this.resources = (s = A.dict) == null ? void 0 : s.get("Resources");
  }
  parse() {
    const A = {
      fn: 0,
      args: []
    };
    let t = {
      scaleFactor: 1,
      fontSize: 0,
      fontName: "",
      fontColor: new Uint8ClampedArray(3),
      fillColorSpace: LA.singletons.gray
    }, i = !1;
    const s = [];
    try {
      for (; A.args.length = 0, !(i || !this.read(A)); ) {
        const {
          fn: a,
          args: n
        } = A;
        switch (a | 0) {
          case w.save:
            s.push({
              scaleFactor: t.scaleFactor,
              fontSize: t.fontSize,
              fontName: t.fontName,
              fontColor: t.fontColor.slice(),
              fillColorSpace: t.fillColorSpace
            });
            break;
          case w.restore:
            t = s.pop() || t;
            break;
          case w.setTextMatrix:
            t.scaleFactor *= Math.hypot(n[0], n[1]);
            break;
          case w.setFont:
            const [r, g] = n;
            r instanceof L && (t.fontName = r.name), typeof g == "number" && g > 0 && (t.fontSize = g * t.scaleFactor);
            break;
          case w.setFillColorSpace:
            t.fillColorSpace = LA.parse({
              cs: n[0],
              xref: this.xref,
              resources: this.resources,
              pdfFunctionFactory: this._pdfFunctionFactory,
              localColorSpaceCache: this._localColorSpaceCache
            });
            break;
          case w.setFillColor:
            t.fillColorSpace.getRgbItem(n, 0, t.fontColor, 0);
            break;
          case w.setFillRGBColor:
            LA.singletons.rgb.getRgbItem(n, 0, t.fontColor, 0);
            break;
          case w.setFillGray:
            LA.singletons.gray.getRgbItem(n, 0, t.fontColor, 0);
            break;
          case w.setFillCMYKColor:
            LA.singletons.cmyk.getRgbItem(n, 0, t.fontColor, 0);
            break;
          case w.showText:
          case w.showSpacedText:
          case w.nextLineShowText:
          case w.nextLineSetSpacingShowText:
            i = !0;
            break;
        }
      }
    } catch (a) {
      k(`parseAppearanceStream - ignoring errors: "${a}".`);
    }
    return this.stream.reset(), delete t.scaleFactor, delete t.fillColorSpace, t;
  }
  get _localColorSpaceCache() {
    return iA(this, "_localColorSpaceCache", new Al());
  }
  get _pdfFunctionFactory() {
    const A = new tl({
      xref: this.xref,
      isEvalSupported: this.evaluatorOptions.isEvalSupported
    });
    return iA(this, "_pdfFunctionFactory", A);
  }
}
function v1(e, A, t) {
  return new K1(e, A, t).parse();
}
function mi(e, A) {
  if (e[0] === e[1] && e[1] === e[2]) {
    const t = e[0] / 255;
    return `${$A(t)} ${A ? "g" : "G"}`;
  }
  return Array.from(e, (t) => $A(t / 255)).join(" ") + ` ${A ? "rg" : "RG"}`;
}
function T1({
  fontSize: e,
  fontName: A,
  fontColor: t
}) {
  return `/${Pg(A)} ${e} Tf ${mi(t, !0)}`;
}
class Ai {
  constructor(A, t) {
    this.xref = A, this.widths = null, this.firstChar = 1 / 0, this.lastChar = -1 / 0, this.fontFamily = t;
    const i = new OffscreenCanvas(1, 1);
    this.ctxMeasure = i.getContext("2d", {
      willReadFrequently: !0
    }), Ai._fontNameId || (Ai._fontNameId = 1), this.fontName = L.get(`InvalidPDFjsFont_${t}_${Ai._fontNameId++}`);
  }
  get fontDescriptorRef() {
    if (!Ai._fontDescriptorRef) {
      const A = new R(this.xref);
      A.set("Type", L.get("FontDescriptor")), A.set("FontName", this.fontName), A.set("FontFamily", "MyriadPro Regular"), A.set("FontBBox", [0, 0, 0, 0]), A.set("FontStretch", L.get("Normal")), A.set("FontWeight", 400), A.set("ItalicAngle", 0), Ai._fontDescriptorRef = this.xref.getNewPersistentRef(A);
    }
    return Ai._fontDescriptorRef;
  }
  get descendantFontRef() {
    const A = new R(this.xref);
    A.set("BaseFont", this.fontName), A.set("Type", L.get("Font")), A.set("Subtype", L.get("CIDFontType0")), A.set("CIDToGIDMap", L.get("Identity")), A.set("FirstChar", this.firstChar), A.set("LastChar", this.lastChar), A.set("FontDescriptor", this.fontDescriptorRef), A.set("DW", 1e3);
    const t = [], i = [...this.widths.entries()].sort();
    let s = null, a = null;
    for (const [r, g] of i) {
      if (!s) {
        s = r, a = [g];
        continue;
      }
      r === s + a.length ? a.push(g) : (t.push(s, a), s = r, a = [g]);
    }
    s && t.push(s, a), A.set("W", t);
    const n = new R(this.xref);
    return n.set("Ordering", "Identity"), n.set("Registry", "Adobe"), n.set("Supplement", 0), A.set("CIDSystemInfo", n), this.xref.getNewPersistentRef(A);
  }
  get baseFontRef() {
    const A = new R(this.xref);
    return A.set("BaseFont", this.fontName), A.set("Type", L.get("Font")), A.set("Subtype", L.get("Type0")), A.set("Encoding", L.get("Identity-H")), A.set("DescendantFonts", [this.descendantFontRef]), A.set("ToUnicode", L.get("Identity-H")), this.xref.getNewPersistentRef(A);
  }
  get resources() {
    const A = new R(this.xref), t = new R(this.xref);
    return t.set(this.fontName.name, this.baseFontRef), A.set("Font", t), A;
  }
  _createContext() {
    return this.widths = /* @__PURE__ */ new Map(), this.ctxMeasure.font = `1000px ${this.fontFamily}`, this.ctxMeasure;
  }
  createFontResources(A) {
    const t = this._createContext();
    for (const i of A.split(/\r\n?|\n/))
      for (const s of i.split("")) {
        const a = s.charCodeAt(0);
        if (this.widths.has(a))
          continue;
        const n = t.measureText(s), r = Math.ceil(n.width);
        this.widths.set(a, r), this.firstChar = Math.min(a, this.firstChar), this.lastChar = Math.max(a, this.lastChar);
      }
    return this.resources;
  }
  static getFirstPositionInfo(A, t, i) {
    const [s, a, n, r] = A;
    let g = n - s, o = r - a;
    t % 180 !== 0 && ([g, o] = [o, g]);
    const I = Qi * i, c = xn * i;
    return {
      coords: [0, o + c - I],
      bbox: [0, 0, g, o],
      matrix: t !== 0 ? wn(t, o, I) : void 0
    };
  }
  createAppearance(A, t, i, s, a, n) {
    const r = this._createContext(), g = [];
    let o = -1 / 0;
    for (const T of A.split(/\r\n?|\n/)) {
      g.push(T);
      const _ = r.measureText(T).width;
      o = Math.max(o, _);
      for (const oA of AC(T)) {
        const G = String.fromCodePoint(oA);
        let S = this.widths.get(oA);
        if (S === void 0) {
          const tA = r.measureText(G);
          S = Math.ceil(tA.width), this.widths.set(oA, S), this.firstChar = Math.min(oA, this.firstChar), this.lastChar = Math.max(oA, this.lastChar);
        }
      }
    }
    o *= s / 1e3;
    const [I, c, l, h] = t;
    let C = l - I, B = h - c;
    i % 180 !== 0 && ([C, B] = [B, C]);
    let Q = 1;
    o > C && (Q = C / o);
    let E = 1;
    const f = Qi * s, d = xn * s, u = f * g.length;
    u > B && (E = B / u);
    const x = Math.min(Q, E), m = s * x, p = ["q", `0 0 ${$A(C)} ${$A(B)} re W n`, "BT", `1 0 0 1 0 ${$A(B + d)} Tm 0 Tc ${mi(a, !0)}`, `/${this.fontName.name} ${$A(m)} Tf`], {
      resources: D
    } = this;
    if (n = typeof n == "number" && n >= 0 && n <= 1 ? n : 1, n !== 1) {
      p.push("/R0 gs");
      const T = new R(this.xref), _ = new R(this.xref);
      _.set("ca", n), _.set("CA", n), _.set("Type", L.get("ExtGState")), T.set("R0", _), D.set("ExtGState", T);
    }
    const F = $A(f);
    for (const T of g)
      p.push(`0 -${F} Td <${iC(T)}> Tj`);
    p.push("ET", "Q");
    const y = p.join(`
`), H = new R(this.xref);
    if (H.set("Subtype", L.get("Form")), H.set("Type", L.get("XObject")), H.set("BBox", [0, 0, C, B]), H.set("Length", y.length), H.set("Resources", D), i) {
      const T = wn(i, C, B);
      H.set("Matrix", T);
    }
    const N = new Ct(y);
    return N.dict = H, N;
  }
}
class ol {
  constructor(A, t, i) {
    this.root = A, this.xref = t, this._type = i;
  }
  getAll() {
    const A = /* @__PURE__ */ new Map();
    if (!this.root)
      return A;
    const t = this.xref, i = new Ne();
    i.put(this.root);
    const s = [this.root];
    for (; s.length > 0; ) {
      const a = t.fetchIfRef(s.shift());
      if (!(a instanceof R))
        continue;
      if (a.has("Kids")) {
        const r = a.get("Kids");
        if (!Array.isArray(r))
          continue;
        for (const g of r) {
          if (i.has(g))
            throw new v(`Duplicate entry in "${this._type}" tree.`);
          s.push(g), i.put(g);
        }
        continue;
      }
      const n = a.get(this._type);
      if (Array.isArray(n))
        for (let r = 0, g = n.length; r < g; r += 2)
          A.set(t.fetchIfRef(n[r]), t.fetchIfRef(n[r + 1]));
    }
    return A;
  }
  getRaw(A) {
    if (!this.root)
      return null;
    const t = this.xref;
    let i = t.fetchIfRef(this.root), s = 0;
    const a = 10;
    for (; i.has("Kids"); ) {
      if (++s > a)
        return k(`Search depth limit reached for "${this._type}" tree.`), null;
      const r = i.get("Kids");
      if (!Array.isArray(r))
        return null;
      let g = 0, o = r.length - 1;
      for (; g <= o; ) {
        const I = g + o >> 1, c = t.fetchIfRef(r[I]), l = c.get("Limits");
        if (A < t.fetchIfRef(l[0]))
          o = I - 1;
        else if (A > t.fetchIfRef(l[1]))
          g = I + 1;
        else {
          i = c;
          break;
        }
      }
      if (g > o)
        return null;
    }
    const n = i.get(this._type);
    if (Array.isArray(n)) {
      let r = 0, g = n.length - 2;
      for (; r <= g; ) {
        const o = r + g >> 1, I = o + (o & 1), c = t.fetchIfRef(n[I]);
        if (A < c)
          g = I - 2;
        else if (A > c)
          r = I + 2;
        else
          return n[I + 1];
      }
    }
    return null;
  }
  get(A) {
    return this.xref.fetchIfRef(this.getRaw(A));
  }
}
class b0 extends ol {
  constructor(A, t) {
    super(A, t, "Names");
  }
}
class Fn extends ol {
  constructor(A, t) {
    super(A, t, "Nums");
  }
}
function ao() {
  RQ(), Zh(), LB(), tr.cleanup();
}
function KI(e) {
  return e instanceof R ? e.has("UF") ? e.get("UF") : e.has("F") ? e.get("F") : e.has("Unix") ? e.get("Unix") : e.has("Mac") ? e.get("Mac") : e.has("DOS") ? e.get("DOS") : null : null;
}
function q1(e) {
  return e.substring(e.lastIndexOf("/") + 1);
}
var da;
class yg {
  constructor(A, t, i = !1) {
    ZA(this, da, !1);
    A instanceof R && (this.xref = t, this.root = A, A.has("FS") && (this.fs = A.get("FS")), A.has("RF") && k("Related file specifications are not supported"), i || (A.has("EF") ? wt(this, da, !0) : k("Non-embedded file specifications are not supported")));
  }
  get filename() {
    let A = "";
    const t = KI(this.root);
    return t && typeof t == "string" && (A = jA(t).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/")), iA(this, "filename", A || "unnamed");
  }
  get content() {
    var t;
    if (!PA(this, da))
      return null;
    this._contentRef || (this._contentRef = KI((t = this.root) == null ? void 0 : t.get("EF")));
    let A = null;
    if (this._contentRef) {
      const i = this.xref.fetchIfRef(this._contentRef);
      i instanceof JA ? A = i.getBytes() : k("Embedded file specification points to non-existing/invalid content");
    } else
      k("Embedded file specification does not have any content");
    return A;
  }
  get description() {
    var i;
    let A = "";
    const t = (i = this.root) == null ? void 0 : i.get("Desc");
    return t && typeof t == "string" && (A = jA(t)), iA(this, "description", A);
  }
  get serializable() {
    return {
      rawFilename: this.filename,
      filename: q1(this.filename),
      content: this.content,
      description: this.description
    };
  }
}
da = new WeakMap();
const gt = {
  NoError: 0,
  UnterminatedCdat: -2,
  UnterminatedXmlDeclaration: -3,
  UnterminatedDoctypeDeclaration: -4,
  UnterminatedComment: -5,
  MalformedElement: -6,
  UnterminatedElement: -9
};
function M0(e, A) {
  const t = e[A];
  return t === " " || t === `
` || t === "\r" || t === "	";
}
function P1(e) {
  for (let A = 0, t = e.length; A < t; A++)
    if (!M0(e, A))
      return !1;
  return !0;
}
class Il {
  _resolveEntities(A) {
    return A.replaceAll(/&([^;]+);/g, (t, i) => {
      if (i.substring(0, 2) === "#x")
        return String.fromCodePoint(parseInt(i.substring(2), 16));
      if (i.substring(0, 1) === "#")
        return String.fromCodePoint(parseInt(i.substring(1), 10));
      switch (i) {
        case "lt":
          return "<";
        case "gt":
          return ">";
        case "amp":
          return "&";
        case "quot":
          return '"';
        case "apos":
          return "'";
      }
      return this.onResolveEntity(i);
    });
  }
  _parseContent(A, t) {
    const i = [];
    let s = t;
    function a() {
      for (; s < A.length && M0(A, s); )
        ++s;
    }
    for (; s < A.length && !M0(A, s) && A[s] !== ">" && A[s] !== "/"; )
      ++s;
    const n = A.substring(t, s);
    for (a(); s < A.length && A[s] !== ">" && A[s] !== "/" && A[s] !== "?"; ) {
      a();
      let r = "", g = "";
      for (; s < A.length && !M0(A, s) && A[s] !== "="; )
        r += A[s], ++s;
      if (a(), A[s] !== "=")
        return null;
      ++s, a();
      const o = A[s];
      if (o !== '"' && o !== "'")
        return null;
      const I = A.indexOf(o, ++s);
      if (I < 0)
        return null;
      g = A.substring(s, I), i.push({
        name: r,
        value: this._resolveEntities(g)
      }), s = I + 1, a();
    }
    return {
      name: n,
      attributes: i,
      parsed: s - t
    };
  }
  _parseProcessingInstruction(A, t) {
    let i = t;
    function s() {
      for (; i < A.length && M0(A, i); )
        ++i;
    }
    for (; i < A.length && !M0(A, i) && A[i] !== ">" && A[i] !== "?" && A[i] !== "/"; )
      ++i;
    const a = A.substring(t, i);
    s();
    const n = i;
    for (; i < A.length && (A[i] !== "?" || A[i + 1] !== ">"); )
      ++i;
    const r = A.substring(n, i);
    return {
      name: a,
      value: r,
      parsed: i - t
    };
  }
  parseXml(A) {
    let t = 0;
    for (; t < A.length; ) {
      const i = A[t];
      let s = t;
      if (i === "<") {
        ++s;
        const a = A[s];
        let n;
        switch (a) {
          case "/":
            if (++s, n = A.indexOf(">", s), n < 0) {
              this.onError(gt.UnterminatedElement);
              return;
            }
            this.onEndElement(A.substring(s, n)), s = n + 1;
            break;
          case "?":
            ++s;
            const r = this._parseProcessingInstruction(A, s);
            if (A.substring(s + r.parsed, s + r.parsed + 2) !== "?>") {
              this.onError(gt.UnterminatedXmlDeclaration);
              return;
            }
            this.onPi(r.name, r.value), s += r.parsed + 2;
            break;
          case "!":
            if (A.substring(s + 1, s + 3) === "--") {
              if (n = A.indexOf("-->", s + 3), n < 0) {
                this.onError(gt.UnterminatedComment);
                return;
              }
              this.onComment(A.substring(s + 3, n)), s = n + 3;
            } else if (A.substring(s + 1, s + 8) === "[CDATA[") {
              if (n = A.indexOf("]]>", s + 8), n < 0) {
                this.onError(gt.UnterminatedCdat);
                return;
              }
              this.onCdata(A.substring(s + 8, n)), s = n + 3;
            } else if (A.substring(s + 1, s + 8) === "DOCTYPE") {
              const I = A.indexOf("[", s + 8);
              let c = !1;
              if (n = A.indexOf(">", s + 8), n < 0) {
                this.onError(gt.UnterminatedDoctypeDeclaration);
                return;
              }
              if (I > 0 && n > I) {
                if (n = A.indexOf("]>", s + 8), n < 0) {
                  this.onError(gt.UnterminatedDoctypeDeclaration);
                  return;
                }
                c = !0;
              }
              const l = A.substring(s + 8, n + (c ? 1 : 0));
              this.onDoctype(l), s = n + (c ? 2 : 1);
            } else {
              this.onError(gt.MalformedElement);
              return;
            }
            break;
          default:
            const g = this._parseContent(A, s);
            if (g === null) {
              this.onError(gt.MalformedElement);
              return;
            }
            let o = !1;
            if (A.substring(s + g.parsed, s + g.parsed + 2) === "/>")
              o = !0;
            else if (A.substring(s + g.parsed, s + g.parsed + 1) !== ">") {
              this.onError(gt.UnterminatedElement);
              return;
            }
            this.onBeginElement(g.name, g.attributes, o), s += g.parsed + (o ? 2 : 1);
            break;
        }
      } else {
        for (; s < A.length && A[s] !== "<"; )
          s++;
        const a = A.substring(t, s);
        this.onText(this._resolveEntities(a));
      }
      t = s;
    }
  }
  onResolveEntity(A) {
    return `&${A};`;
  }
  onPi(A, t) {
  }
  onComment(A) {
  }
  onCdata(A) {
  }
  onDoctype(A) {
  }
  onText(A) {
  }
  onBeginElement(A, t, i) {
  }
  onEndElement(A) {
  }
  onError(A) {
  }
}
class Js {
  constructor(A, t) {
    this.nodeName = A, this.nodeValue = t, Object.defineProperty(this, "parentNode", {
      value: null,
      writable: !0
    });
  }
  get firstChild() {
    var A;
    return (A = this.childNodes) == null ? void 0 : A[0];
  }
  get nextSibling() {
    const A = this.parentNode.childNodes;
    if (!A)
      return;
    const t = A.indexOf(this);
    if (t !== -1)
      return A[t + 1];
  }
  get textContent() {
    return this.childNodes ? this.childNodes.map(function(A) {
      return A.textContent;
    }).join("") : this.nodeValue || "";
  }
  get children() {
    return this.childNodes || [];
  }
  hasChildNodes() {
    var A;
    return ((A = this.childNodes) == null ? void 0 : A.length) > 0;
  }
  searchNode(A, t) {
    var n;
    if (t >= A.length)
      return this;
    const i = A[t];
    if (i.name.startsWith("#") && t < A.length - 1)
      return this.searchNode(A, t + 1);
    const s = [];
    let a = this;
    for (; ; ) {
      if (i.name === a.nodeName)
        if (i.pos === 0) {
          const r = a.searchNode(A, t + 1);
          if (r !== null)
            return r;
        } else {
          if (s.length === 0)
            return null;
          {
            const [r] = s.pop();
            let g = 0;
            for (const o of r.childNodes)
              if (i.name === o.nodeName) {
                if (g === i.pos)
                  return o.searchNode(A, t + 1);
                g++;
              }
            return a.searchNode(A, t + 1);
          }
        }
      if (((n = a.childNodes) == null ? void 0 : n.length) > 0)
        s.push([a, 0]), a = a.childNodes[0];
      else {
        if (s.length === 0)
          return null;
        for (; s.length !== 0; ) {
          const [r, g] = s.pop(), o = g + 1;
          if (o < r.childNodes.length) {
            s.push([r, o]), a = r.childNodes[o];
            break;
          }
        }
        if (s.length === 0)
          return null;
      }
    }
  }
  dump(A) {
    if (this.nodeName === "#text") {
      A.push(W0(this.nodeValue));
      return;
    }
    if (A.push(`<${this.nodeName}`), this.attributes)
      for (const t of this.attributes)
        A.push(` ${t.name}="${W0(t.value)}"`);
    if (this.hasChildNodes()) {
      A.push(">");
      for (const t of this.childNodes)
        t.dump(A);
      A.push(`</${this.nodeName}>`);
    } else this.nodeValue ? A.push(`>${W0(this.nodeValue)}</${this.nodeName}>`) : A.push("/>");
  }
}
class ar extends Il {
  constructor({
    hasAttributes: A = !1,
    lowerCaseName: t = !1
  }) {
    super(), this._currentFragment = null, this._stack = null, this._errorCode = gt.NoError, this._hasAttributes = A, this._lowerCaseName = t;
  }
  parseFromString(A) {
    if (this._currentFragment = [], this._stack = [], this._errorCode = gt.NoError, this.parseXml(A), this._errorCode !== gt.NoError)
      return;
    const [t] = this._currentFragment;
    if (t)
      return {
        documentElement: t
      };
  }
  onText(A) {
    if (P1(A))
      return;
    const t = new Js("#text", A);
    this._currentFragment.push(t);
  }
  onCdata(A) {
    const t = new Js("#text", A);
    this._currentFragment.push(t);
  }
  onBeginElement(A, t, i) {
    this._lowerCaseName && (A = A.toLowerCase());
    const s = new Js(A);
    s.childNodes = [], this._hasAttributes && (s.attributes = t), this._currentFragment.push(s), !i && (this._stack.push(this._currentFragment), this._currentFragment = s.childNodes);
  }
  onEndElement(A) {
    this._currentFragment = this._stack.pop() || [];
    const t = this._currentFragment.at(-1);
    if (!t)
      return null;
    for (const i of t.childNodes)
      i.parentNode = t;
    return t;
  }
  onError(A) {
    this._errorCode = A;
  }
}
class W1 {
  constructor(A) {
    A = this._repair(A);
    const i = new ar({
      lowerCaseName: !0
    }).parseFromString(A);
    this._metadataMap = /* @__PURE__ */ new Map(), this._data = A, i && this._parse(i);
  }
  _repair(A) {
    return A.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(t, i) {
      const s = i.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(n, r, g, o) {
        return String.fromCharCode(r * 64 + g * 8 + o * 1);
      }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(n, r) {
        switch (r) {
          case "amp":
            return "&";
          case "apos":
            return "'";
          case "gt":
            return ">";
          case "lt":
            return "<";
          case "quot":
            return '"';
        }
        throw new Error(`_repair: ${r} isn't defined.`);
      }), a = [">"];
      for (let n = 0, r = s.length; n < r; n += 2) {
        const g = s.charCodeAt(n) * 256 + s.charCodeAt(n + 1);
        g >= 32 && g < 127 && g !== 60 && g !== 62 && g !== 38 ? a.push(String.fromCharCode(g)) : a.push("&#x" + (65536 + g).toString(16).substring(1) + ";");
      }
      return a.join("");
    });
  }
  _getSequence(A) {
    const t = A.nodeName;
    return t !== "rdf:bag" && t !== "rdf:seq" && t !== "rdf:alt" ? null : A.childNodes.filter((i) => i.nodeName === "rdf:li");
  }
  _parseArray(A) {
    if (!A.hasChildNodes())
      return;
    const [t] = A.childNodes, i = this._getSequence(t) || [];
    this._metadataMap.set(A.nodeName, i.map((s) => s.textContent.trim()));
  }
  _parse(A) {
    let t = A.documentElement;
    if (t.nodeName !== "rdf:rdf")
      for (t = t.firstChild; t && t.nodeName !== "rdf:rdf"; )
        t = t.nextSibling;
    if (!(!t || t.nodeName !== "rdf:rdf" || !t.hasChildNodes())) {
      for (const i of t.childNodes)
        if (i.nodeName === "rdf:description")
          for (const s of i.childNodes) {
            const a = s.nodeName;
            switch (a) {
              case "#text":
                continue;
              case "dc:creator":
              case "dc:subject":
                this._parseArray(s);
                continue;
            }
            this._metadataMap.set(a, s.textContent.trim());
          }
    }
  }
  get serializable() {
    return {
      parsedData: this._metadataMap,
      rawData: this._data
    };
  }
}
const vI = 40, Ft = {
  PAGE_CONTENT: 1,
  STREAM_CONTENT: 2,
  OBJECT: 3,
  ANNOTATION: 4,
  ELEMENT: 5
};
var Xn, cl, Ht, wg, bg, ll, hl;
const a0 = class a0 {
  constructor(A, t) {
    ZA(this, Xn);
    this.dict = A, this.ref = t instanceof nA ? t : null, this.roleMap = /* @__PURE__ */ new Map(), this.structParentIds = null;
  }
  init() {
    this.readRoleMap();
  }
  addAnnotationIdToPage(A, t) {
    BA(this, Xn, cl).call(this, A, t, Ft.ANNOTATION);
  }
  readRoleMap() {
    const A = this.dict.get("RoleMap");
    if (A instanceof R)
      for (const [t, i] of A)
        i instanceof L && this.roleMap.set(t, i.name);
  }
  static async canCreateStructureTree({
    catalogRef: A,
    pdfManager: t,
    newAnnotationsByPage: i
  }) {
    var n;
    if (!(A instanceof nA))
      return k("Cannot save the struct tree: no catalog reference."), !1;
    let s = 0, a = !0;
    for (const [r, g] of i) {
      const {
        ref: o
      } = await t.getPage(r);
      if (!(o instanceof nA)) {
        k(`Cannot save the struct tree: page ${r} has no ref.`), a = !0;
        break;
      }
      for (const I of g)
        (n = I.accessibilityData) != null && n.type && (I.parentTreeId = s++, a = !1);
    }
    if (a) {
      for (const r of i.values())
        for (const g of r)
          delete g.parentTreeId;
      return !1;
    }
    return !0;
  }
  static async createStructureTree({
    newAnnotationsByPage: A,
    xref: t,
    catalogRef: i,
    pdfManager: s,
    changes: a
  }) {
    const n = s.catalog.cloneDict(), r = new ot();
    r.put(i, n);
    const g = t.getNewTemporaryRef();
    n.set("StructTreeRoot", g);
    const o = new R(t);
    o.set("Type", L.get("StructTreeRoot"));
    const I = t.getNewTemporaryRef();
    o.set("ParentTree", I);
    const c = [];
    o.set("K", c), r.put(g, o);
    const l = new R(t), h = [];
    l.set("Nums", h);
    const C = await BA(this, Ht, wg).call(this, {
      newAnnotationsByPage: A,
      structTreeRootRef: g,
      structTreeRoot: null,
      kids: c,
      nums: h,
      xref: t,
      pdfManager: s,
      changes: a,
      cache: r
    });
    o.set("ParentTreeNextKey", C), r.put(I, l);
    for (const [B, Q] of r.items())
      a.put(B, {
        data: Q
      });
  }
  async canUpdateStructTree({
    pdfManager: A,
    xref: t,
    newAnnotationsByPage: i
  }) {
    var o, I;
    if (!this.ref)
      return k("Cannot update the struct tree: no root reference."), !1;
    let s = this.dict.get("ParentTreeNextKey");
    if (!Number.isInteger(s) || s < 0)
      return k("Cannot update the struct tree: invalid next key."), !1;
    const a = this.dict.get("ParentTree");
    if (!(a instanceof R))
      return k("Cannot update the struct tree: ParentTree isn't a dict."), !1;
    const n = a.get("Nums");
    if (!Array.isArray(n))
      return k("Cannot update the struct tree: nums isn't an array."), !1;
    const r = new Fn(a, t);
    for (const c of i.keys()) {
      const {
        pageDict: l
      } = await A.getPage(c);
      if (!l.has("StructParents"))
        continue;
      const h = l.get("StructParents");
      if (!Number.isInteger(h) || !Array.isArray(r.get(h)))
        return k(`Cannot save the struct tree: page ${c} has a wrong id.`), !1;
    }
    let g = !0;
    for (const [c, l] of i) {
      const {
        pageDict: h
      } = await A.getPage(c);
      BA(o = a0, Ht, ll).call(o, {
        elements: l,
        xref: this.dict.xref,
        pageDict: h,
        numberTree: r
      });
      for (const C of l)
        (I = C.accessibilityData) != null && I.type && (C.accessibilityData.structParent >= 0 || (C.parentTreeId = s++), g = !1);
    }
    if (g) {
      for (const c of i.values())
        for (const l of c)
          delete l.parentTreeId, delete l.structTreeParent;
      return !1;
    }
    return !0;
  }
  async updateStructureTree({
    newAnnotationsByPage: A,
    pdfManager: t,
    changes: i
  }) {
    var h;
    const s = this.dict.xref, a = this.dict.clone(), n = this.ref, r = new ot();
    r.put(n, a);
    let g = a.getRaw("ParentTree"), o;
    g instanceof nA ? o = s.fetch(g) : (o = g, g = s.getNewTemporaryRef(), a.set("ParentTree", g)), o = o.clone(), r.put(g, o);
    let I = o.getRaw("Nums"), c = null;
    I instanceof nA && (c = I, I = s.fetch(c)), I = I.slice(), c || o.set("Nums", I);
    const l = await BA(h = a0, Ht, wg).call(h, {
      newAnnotationsByPage: A,
      structTreeRootRef: n,
      structTreeRoot: this,
      kids: null,
      nums: I,
      xref: s,
      pdfManager: t,
      changes: i,
      cache: r
    });
    if (l !== -1) {
      a.set("ParentTreeNextKey", l), c && r.put(c, I);
      for (const [C, B] of r.items())
        i.put(C, {
          data: B
        });
    }
  }
};
Xn = new WeakSet(), cl = function(A, t, i) {
  if (!(A instanceof nA) || t < 0)
    return;
  this.structParentIds || (this.structParentIds = new ot());
  let s = this.structParentIds.get(A);
  s || (s = [], this.structParentIds.put(A, s)), s.push([t, i]);
}, Ht = new WeakSet(), wg = async function({
  newAnnotationsByPage: A,
  structTreeRootRef: t,
  structTreeRoot: i,
  kids: s,
  nums: a,
  xref: n,
  pdfManager: r,
  changes: g,
  cache: o
}) {
  var h, C;
  const I = L.get("OBJR");
  let c = -1, l;
  for (const [B, Q] of A) {
    const E = await r.getPage(B), {
      ref: f
    } = E, d = f instanceof nA;
    for (const {
      accessibilityData: u,
      ref: x,
      parentTreeId: m,
      structTreeParent: p
    } of Q) {
      if (!(u != null && u.type))
        continue;
      const {
        structParent: D
      } = u;
      if (i && Number.isInteger(D) && D >= 0) {
        let N = (l || (l = /* @__PURE__ */ new Map())).get(B);
        N === void 0 && (N = new Cl(i, E.pageDict).collectObjects(f), l.set(B, N));
        const T = N == null ? void 0 : N.get(D);
        if (T) {
          const _ = n.fetch(T).clone();
          BA(h = a0, Ht, bg).call(h, _, u), g.put(T, {
            data: _
          });
          continue;
        }
      }
      c = Math.max(c, m);
      const F = n.getNewTemporaryRef(), y = new R(n);
      BA(C = a0, Ht, bg).call(C, y, u), await BA(this, Ht, hl).call(this, {
        structTreeParent: p,
        tagDict: y,
        newTagRef: F,
        structTreeRootRef: t,
        fallbackKids: s,
        xref: n,
        cache: o
      });
      const H = new R(n);
      y.set("K", H), H.set("Type", I), d && H.set("Pg", f), H.set("Obj", x), o.put(F, y), a.push(m, F);
    }
  }
  return c + 1;
}, bg = function(A, {
  type: t,
  title: i,
  lang: s,
  alt: a,
  expanded: n,
  actualText: r
}) {
  A.set("S", L.get(t)), i && A.set("T", Nt(i)), s && A.set("Lang", Nt(s)), a && A.set("Alt", Nt(a)), n && A.set("E", Nt(n)), r && A.set("ActualText", Nt(r));
}, ll = function({
  elements: A,
  xref: t,
  pageDict: i,
  numberTree: s
}) {
  const a = /* @__PURE__ */ new Map();
  for (const o of A)
    if (o.structTreeParentId) {
      const I = parseInt(o.structTreeParentId.split("_mc")[1], 10);
      let c = a.get(I);
      c || (c = [], a.set(I, c)), c.push(o);
    }
  const n = i.get("StructParents");
  if (!Number.isInteger(n))
    return;
  const r = s.get(n), g = (o, I, c) => {
    const l = a.get(o);
    if (l) {
      const h = I.getRaw("P"), C = t.fetchIfRef(h);
      if (h instanceof nA && C instanceof R) {
        const B = {
          ref: c,
          dict: I
        };
        for (const Q of l)
          Q.structTreeParent = B;
      }
      return !0;
    }
    return !1;
  };
  for (const o of r) {
    if (!(o instanceof nA))
      continue;
    const I = t.fetch(o), c = I.get("K");
    if (Number.isInteger(c)) {
      g(c, I, o);
      continue;
    }
    if (Array.isArray(c))
      for (let l of c) {
        if (l = t.fetchIfRef(l), Number.isInteger(l) && g(l, I, o))
          break;
        if (!(l instanceof R))
          continue;
        if (!xe(l.get("Type"), "MCR"))
          break;
        const h = l.get("MCID");
        if (Number.isInteger(h) && g(h, I, o))
          break;
      }
  }
}, hl = async function({
  structTreeParent: A,
  tagDict: t,
  newTagRef: i,
  structTreeRootRef: s,
  fallbackKids: a,
  xref: n,
  cache: r
}) {
  let g = null, o;
  A ? ({
    ref: g
  } = A, o = A.dict.getRaw("P") || s) : o = s, t.set("P", o);
  const I = n.fetchIfRef(o);
  if (!I) {
    a.push(i);
    return;
  }
  let c = r.get(o);
  c || (c = I.clone(), r.put(o, c));
  const l = c.getRaw("K");
  let h = l instanceof nA ? r.get(l) : null;
  if (!h) {
    h = n.fetchIfRef(l), h = Array.isArray(h) ? h.slice() : [l];
    const B = n.getNewTemporaryRef();
    c.set("K", B), r.put(B, h);
  }
  const C = h.indexOf(g);
  h.splice(C >= 0 ? C + 1 : h.length, 0, i);
}, ZA(a0, Ht);
let ea = a0;
class O1 {
  constructor(A, t) {
    this.tree = A, this.dict = t, this.kids = [], this.parseKids();
  }
  get role() {
    const A = this.dict.get("S"), t = A instanceof L ? A.name : "", {
      root: i
    } = this.tree;
    return i.roleMap.has(t) ? i.roleMap.get(t) : t;
  }
  parseKids() {
    let A = null;
    const t = this.dict.getRaw("Pg");
    t instanceof nA && (A = t.toString());
    const i = this.dict.get("K");
    if (Array.isArray(i))
      for (const s of i) {
        const a = this.parseKid(A, s);
        a && this.kids.push(a);
      }
    else {
      const s = this.parseKid(A, i);
      s && this.kids.push(s);
    }
  }
  parseKid(A, t) {
    if (Number.isInteger(t))
      return this.tree.pageDict.objId !== A ? null : new _a({
        type: Ft.PAGE_CONTENT,
        mcid: t,
        pageObjId: A
      });
    let i = null;
    if (t instanceof nA ? i = this.dict.xref.fetch(t) : t instanceof R && (i = t), !i)
      return null;
    const s = i.getRaw("Pg");
    s instanceof nA && (A = s.toString());
    const a = i.get("Type") instanceof L ? i.get("Type").name : null;
    if (a === "MCR") {
      if (this.tree.pageDict.objId !== A)
        return null;
      const n = i.getRaw("Stm");
      return new _a({
        type: Ft.STREAM_CONTENT,
        refObjId: n instanceof nA ? n.toString() : null,
        pageObjId: A,
        mcid: i.get("MCID")
      });
    }
    if (a === "OBJR") {
      if (this.tree.pageDict.objId !== A)
        return null;
      const n = i.getRaw("Obj");
      return new _a({
        type: Ft.OBJECT,
        refObjId: n instanceof nA ? n.toString() : null,
        pageObjId: A
      });
    }
    return new _a({
      type: Ft.ELEMENT,
      dict: i
    });
  }
}
class _a {
  constructor({
    type: A,
    dict: t = null,
    mcid: i = null,
    pageObjId: s = null,
    refObjId: a = null
  }) {
    this.type = A, this.dict = t, this.mcid = i, this.pageObjId = s, this.refObjId = a, this.parentNode = null;
  }
}
class Cl {
  constructor(A, t) {
    this.root = A, this.rootDict = A ? A.dict : null, this.pageDict = t, this.nodes = [];
  }
  collectObjects(A) {
    var n;
    if (!this.root || !this.rootDict || !(A instanceof nA))
      return null;
    const t = this.rootDict.get("ParentTree");
    if (!t)
      return null;
    const i = (n = this.root.structParentIds) == null ? void 0 : n.get(A);
    if (!i)
      return null;
    const s = /* @__PURE__ */ new Map(), a = new Fn(t, this.rootDict.xref);
    for (const [r] of i) {
      const g = a.getRaw(r);
      g instanceof nA && s.set(r, g);
    }
    return s;
  }
  parse(A) {
    var r, g;
    if (!this.root || !this.rootDict || !(A instanceof nA))
      return;
    const t = this.rootDict.get("ParentTree");
    if (!t)
      return;
    const i = this.pageDict.get("StructParents"), s = (r = this.root.structParentIds) == null ? void 0 : r.get(A);
    if (!Number.isInteger(i) && !s)
      return;
    const a = /* @__PURE__ */ new Map(), n = new Fn(t, this.rootDict.xref);
    if (Number.isInteger(i)) {
      const o = n.get(i);
      if (Array.isArray(o))
        for (const I of o)
          I instanceof nA && this.addNode(this.rootDict.xref.fetch(I), a);
    }
    if (s)
      for (const [o, I] of s) {
        const c = n.get(o);
        if (c) {
          const l = this.addNode(this.rootDict.xref.fetchIfRef(c), a);
          ((g = l == null ? void 0 : l.kids) == null ? void 0 : g.length) === 1 && l.kids[0].type === Ft.OBJECT && (l.kids[0].type = I);
        }
      }
  }
  addNode(A, t, i = 0) {
    if (i > vI)
      return k("StructTree MAX_DEPTH reached."), null;
    if (!(A instanceof R))
      return null;
    if (t.has(A))
      return t.get(A);
    const s = new O1(this, A);
    t.set(A, s);
    const a = A.get("P");
    if (!a || xe(a.get("Type"), "StructTreeRoot"))
      return this.addTopLevelNode(A, s) || t.delete(A), s;
    const n = this.addNode(a, t, i + 1);
    if (!n)
      return s;
    let r = !1;
    for (const g of n.kids)
      g.type === Ft.ELEMENT && g.dict === A && (g.parentNode = s, r = !0);
    return r || t.delete(A), s;
  }
  addTopLevelNode(A, t) {
    const i = this.rootDict.get("K");
    if (!i)
      return !1;
    if (i instanceof R)
      return i.objId !== A.objId ? !1 : (this.nodes[0] = t, !0);
    if (!Array.isArray(i))
      return !0;
    let s = !1;
    for (let a = 0; a < i.length; a++) {
      const n = i[a];
      (n == null ? void 0 : n.toString()) === A.objId && (this.nodes[a] = t, s = !0);
    }
    return s;
  }
  get serializable() {
    function A(i, s, a = 0) {
      if (a > vI) {
        k("StructTree too deep to be fully serialized.");
        return;
      }
      const n = /* @__PURE__ */ Object.create(null);
      n.role = i.role, n.children = [], s.children.push(n);
      let r = i.dict.get("Alt");
      typeof r != "string" && (r = i.dict.get("ActualText")), typeof r == "string" && (n.alt = jA(r));
      const g = i.dict.get("A");
      if (g instanceof R) {
        const I = ii(g.getArray("BBox"), null);
        if (I)
          n.bbox = I;
        else {
          const c = g.get("Width"), l = g.get("Height");
          typeof c == "number" && c > 0 && typeof l == "number" && l > 0 && (n.bbox = [0, 0, c, l]);
        }
      }
      const o = i.dict.get("Lang");
      typeof o == "string" && (n.lang = jA(o));
      for (const I of i.kids) {
        const c = I.type === Ft.ELEMENT ? I.parentNode : null;
        if (c) {
          A(c, n, a + 1);
          continue;
        } else I.type === Ft.PAGE_CONTENT || I.type === Ft.STREAM_CONTENT ? n.children.push({
          type: "content",
          id: `p${I.pageObjId}_mc${I.mcid}`
        }) : I.type === Ft.OBJECT ? n.children.push({
          type: "object",
          id: I.refObjId
        }) : I.type === Ft.ANNOTATION && n.children.push({
          type: "annotation",
          id: `${Wh}${I.refObjId}`
        });
      }
    }
    const t = /* @__PURE__ */ Object.create(null);
    t.children = [], t.role = "Root";
    for (const i of this.nodes)
      i && A(i, t);
    return t;
  }
}
function no(e) {
  if (!Array.isArray(e) || e.length < 2)
    return !1;
  const [A, t, ...i] = e;
  if (!(A instanceof nA) && !Number.isInteger(A) || !(t instanceof L))
    return !1;
  const s = i.length;
  let a = !0;
  switch (t.name) {
    case "XYZ":
      if (s < 2 || s > 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return s === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (s > 1)
        return !1;
      break;
    case "FitR":
      if (s !== 4)
        return !1;
      a = !1;
      break;
    default:
      return !1;
  }
  for (const n of i)
    if (!(typeof n == "number" || a && n === null))
      return !1;
  return !0;
}
function za(e) {
  return e instanceof R && (e = e.get("D")), no(e) ? e : null;
}
function TI(e) {
  let A = e.get("D");
  if (A) {
    if (A instanceof L && (A = A.name), typeof A == "string")
      return jA(A);
    if (no(A))
      return JSON.stringify(A);
  }
  return null;
}
var Is, Bl, Ql;
const _n = class _n {
  constructor(A, t) {
    ZA(this, Is);
    if (this.pdfManager = A, this.xref = t, this._catDict = t.getCatalogObj(), !(this._catDict instanceof R))
      throw new v("Catalog object is not a dictionary.");
    this.toplevelPagesDict, this._actualNumPages = null, this.fontCache = new ot(), this.builtInCMapCache = /* @__PURE__ */ new Map(), this.standardFontDataCache = /* @__PURE__ */ new Map(), this.globalImageCache = new fg(), this.pageKidsCountCache = new ot(), this.pageIndexCache = new ot(), this.pageDictCache = new ot(), this.nonBlendModesSet = new Ne(), this.systemFontCache = /* @__PURE__ */ new Map();
  }
  cloneDict() {
    return this._catDict.clone();
  }
  get version() {
    const A = this._catDict.get("Version");
    if (A instanceof L) {
      if (uc.test(A.name))
        return iA(this, "version", A.name);
      k(`Invalid PDF catalog version: ${A.name}`);
    }
    return iA(this, "version", null);
  }
  get lang() {
    const A = this._catDict.get("Lang");
    return iA(this, "lang", A && typeof A == "string" ? jA(A) : null);
  }
  get needsRendering() {
    const A = this._catDict.get("NeedsRendering");
    return iA(this, "needsRendering", typeof A == "boolean" ? A : !1);
  }
  get collection() {
    let A = null;
    try {
      const t = this._catDict.get("Collection");
      t instanceof R && t.size > 0 && (A = t);
    } catch (t) {
      if (t instanceof oe)
        throw t;
      vA("Cannot fetch Collection entry; assuming no collection is present.");
    }
    return iA(this, "collection", A);
  }
  get acroForm() {
    let A = null;
    try {
      const t = this._catDict.get("AcroForm");
      t instanceof R && t.size > 0 && (A = t);
    } catch (t) {
      if (t instanceof oe)
        throw t;
      vA("Cannot fetch AcroForm entry; assuming no forms are present.");
    }
    return iA(this, "acroForm", A);
  }
  get acroFormRef() {
    const A = this._catDict.getRaw("AcroForm");
    return iA(this, "acroFormRef", A instanceof nA ? A : null);
  }
  get metadata() {
    var i;
    const A = this._catDict.getRaw("Metadata");
    if (!(A instanceof nA))
      return iA(this, "metadata", null);
    let t = null;
    try {
      const s = this.xref.fetch(A, !((i = this.xref.encrypt) != null && i.encryptMetadata));
      if (s instanceof JA && s.dict instanceof R) {
        const a = s.dict.get("Type"), n = s.dict.get("Subtype");
        if (xe(a, "Metadata") && xe(n, "XML")) {
          const r = Vs(s.getString());
          r && (t = new W1(r).serializable);
        }
      }
    } catch (s) {
      if (s instanceof oe)
        throw s;
      vA(`Skipping invalid Metadata: "${s}".`);
    }
    return iA(this, "metadata", t);
  }
  get markInfo() {
    let A = null;
    try {
      A = this._readMarkInfo();
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k("Unable to read mark info.");
    }
    return iA(this, "markInfo", A);
  }
  _readMarkInfo() {
    const A = this._catDict.get("MarkInfo");
    if (!(A instanceof R))
      return null;
    const t = {
      Marked: !1,
      UserProperties: !1,
      Suspects: !1
    };
    for (const i in t) {
      const s = A.get(i);
      typeof s == "boolean" && (t[i] = s);
    }
    return t;
  }
  get structTreeRoot() {
    let A = null;
    try {
      A = this._readStructTreeRoot();
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k("Unable read to structTreeRoot info.");
    }
    return iA(this, "structTreeRoot", A);
  }
  _readStructTreeRoot() {
    const A = this._catDict.getRaw("StructTreeRoot"), t = this.xref.fetchIfRef(A);
    if (!(t instanceof R))
      return null;
    const i = new ea(t, A);
    return i.init(), i;
  }
  get toplevelPagesDict() {
    const A = this._catDict.get("Pages");
    if (!(A instanceof R))
      throw new v("Invalid top-level pages dictionary.");
    return iA(this, "toplevelPagesDict", A);
  }
  get documentOutline() {
    let A = null;
    try {
      A = this._readDocumentOutline();
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k("Unable to read document outline.");
    }
    return iA(this, "documentOutline", A);
  }
  _readDocumentOutline() {
    let A = this._catDict.get("Outlines");
    if (!(A instanceof R) || (A = A.getRaw("First"), !(A instanceof nA)))
      return null;
    const t = {
      items: []
    }, i = [{
      obj: A,
      parent: t
    }], s = new Ne();
    s.put(A);
    const a = this.xref, n = new Uint8ClampedArray(3);
    for (; i.length > 0; ) {
      const r = i.shift(), g = a.fetchIfRef(r.obj);
      if (g === null)
        continue;
      g.has("Title") || k("Invalid outline item encountered.");
      const o = {
        url: null,
        dest: null,
        action: null
      };
      _n.parseDestDictionary({
        destDict: g,
        resultObj: o,
        docBaseUrl: this.baseUrl,
        docAttachments: this.attachments
      });
      const I = g.get("Title"), c = g.get("F") || 0, l = g.getArray("C"), h = g.get("Count");
      let C = n;
      at(l, 3) && (l[0] !== 0 || l[1] !== 0 || l[2] !== 0) && (C = LA.singletons.rgb.getRgb(l, 0));
      const B = {
        action: o.action,
        attachment: o.attachment,
        dest: o.dest,
        url: o.url,
        unsafeUrl: o.unsafeUrl,
        newWindow: o.newWindow,
        setOCGState: o.setOCGState,
        title: typeof I == "string" ? jA(I) : "",
        color: C,
        count: Number.isInteger(h) ? h : void 0,
        bold: !!(c & 2),
        italic: !!(c & 1),
        items: []
      };
      r.parent.items.push(B), A = g.getRaw("First"), A instanceof nA && !s.has(A) && (i.push({
        obj: A,
        parent: B
      }), s.put(A)), A = g.getRaw("Next"), A instanceof nA && !s.has(A) && (i.push({
        obj: A,
        parent: r.parent
      }), s.put(A));
    }
    return t.items.length > 0 ? t.items : null;
  }
  get permissions() {
    let A = null;
    try {
      A = this._readPermissions();
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k("Unable to read permissions.");
    }
    return iA(this, "permissions", A);
  }
  _readPermissions() {
    const A = this.xref.trailer.get("Encrypt");
    if (!(A instanceof R))
      return null;
    let t = A.get("P");
    if (typeof t != "number")
      return null;
    t += 2 ** 32;
    const i = [];
    for (const s in Ro) {
      const a = Ro[s];
      t & a && i.push(a);
    }
    return i;
  }
  get optionalContentConfig() {
    let A = null;
    try {
      const t = this._catDict.get("OCProperties");
      if (!t)
        return iA(this, "optionalContentConfig", null);
      const i = t.get("D");
      if (!i)
        return iA(this, "optionalContentConfig", null);
      const s = t.get("OCGs");
      if (!Array.isArray(s))
        return iA(this, "optionalContentConfig", null);
      const a = new ot();
      for (const n of s)
        !(n instanceof nA) || a.has(n) || a.put(n, BA(this, Is, Bl).call(this, n));
      A = BA(this, Is, Ql).call(this, i, a);
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k(`Unable to read optional content config: ${t}`);
    }
    return iA(this, "optionalContentConfig", A);
  }
  setActualNumPages(A = null) {
    this._actualNumPages = A;
  }
  get hasActualNumPages() {
    return this._actualNumPages !== null;
  }
  get _pagesCount() {
    const A = this.toplevelPagesDict.get("Count");
    if (!Number.isInteger(A))
      throw new v("Page count in top-level pages dictionary is not an integer.");
    return iA(this, "_pagesCount", A);
  }
  get numPages() {
    return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
  }
  get destinations() {
    const A = this._readDests(), t = /* @__PURE__ */ Object.create(null);
    if (A instanceof b0)
      for (const [i, s] of A.getAll()) {
        const a = za(s);
        a && (t[jA(i)] = a);
      }
    else if (A instanceof R)
      for (const [i, s] of A) {
        const a = za(s);
        a && (t[i] = a);
      }
    return iA(this, "destinations", t);
  }
  getDestination(A) {
    const t = this._readDests();
    if (t instanceof b0) {
      const i = za(t.get(A));
      if (i)
        return i;
      const s = this.destinations[A];
      if (s)
        return k(`Found "${A}" at an incorrect position in the NameTree.`), s;
    } else if (t instanceof R) {
      const i = za(t.get(A));
      if (i)
        return i;
    }
    return null;
  }
  _readDests() {
    const A = this._catDict.get("Names");
    if (A != null && A.has("Dests"))
      return new b0(A.getRaw("Dests"), this.xref);
    if (this._catDict.has("Dests"))
      return this._catDict.get("Dests");
  }
  get pageLabels() {
    let A = null;
    try {
      A = this._readPageLabels();
    } catch (t) {
      if (t instanceof oe)
        throw t;
      k("Unable to read page labels.");
    }
    return iA(this, "pageLabels", A);
  }
  _readPageLabels() {
    const A = this._catDict.getRaw("PageLabels");
    if (!A)
      return null;
    const t = new Array(this.numPages);
    let i = null, s = "";
    const n = new Fn(A, this.xref).getAll();
    let r = "", g = 1;
    for (let o = 0, I = this.numPages; o < I; o++) {
      const c = n.get(o);
      if (c !== void 0) {
        if (!(c instanceof R))
          throw new v("PageLabel is not a dictionary.");
        if (c.has("Type") && !xe(c.get("Type"), "PageLabel"))
          throw new v("Invalid type in PageLabel dictionary.");
        if (c.has("S")) {
          const l = c.get("S");
          if (!(l instanceof L))
            throw new v("Invalid style in PageLabel dictionary.");
          i = l.name;
        } else
          i = null;
        if (c.has("P")) {
          const l = c.get("P");
          if (typeof l != "string")
            throw new v("Invalid prefix in PageLabel dictionary.");
          s = jA(l);
        } else
          s = "";
        if (c.has("St")) {
          const l = c.get("St");
          if (!(Number.isInteger(l) && l >= 1))
            throw new v("Invalid start in PageLabel dictionary.");
          g = l;
        } else
          g = 1;
      }
      switch (i) {
        case "D":
          r = g;
          break;
        case "R":
        case "r":
          r = _h(g, i === "r");
          break;
        case "A":
        case "a":
          const l = 26, B = i === "a" ? 97 : 65, Q = g - 1;
          r = String.fromCharCode(B + Q % l).repeat(Math.floor(Q / l) + 1);
          break;
        default:
          if (i)
            throw new v(`Invalid style "${i}" in PageLabel dictionary.`);
          r = "";
      }
      t[o] = s + r, g++;
    }
    return t;
  }
  get pageLayout() {
    const A = this._catDict.get("PageLayout");
    let t = "";
    if (A instanceof L)
      switch (A.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          t = A.name;
      }
    return iA(this, "pageLayout", t);
  }
  get pageMode() {
    const A = this._catDict.get("PageMode");
    let t = "UseNone";
    if (A instanceof L)
      switch (A.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          t = A.name;
      }
    return iA(this, "pageMode", t);
  }
  get viewerPreferences() {
    const A = this._catDict.get("ViewerPreferences");
    if (!(A instanceof R))
      return iA(this, "viewerPreferences", null);
    let t = null;
    for (const i of A.getKeys()) {
      const s = A.get(i);
      let a;
      switch (i) {
        case "HideToolbar":
        case "HideMenubar":
        case "HideWindowUI":
        case "FitWindow":
        case "CenterWindow":
        case "DisplayDocTitle":
        case "PickTrayByPDFSize":
          typeof s == "boolean" && (a = s);
          break;
        case "NonFullScreenPageMode":
          if (s instanceof L)
            switch (s.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                a = s.name;
                break;
              default:
                a = "UseNone";
            }
          break;
        case "Direction":
          if (s instanceof L)
            switch (s.name) {
              case "L2R":
              case "R2L":
                a = s.name;
                break;
              default:
                a = "L2R";
            }
          break;
        case "ViewArea":
        case "ViewClip":
        case "PrintArea":
        case "PrintClip":
          if (s instanceof L)
            switch (s.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                a = s.name;
                break;
              default:
                a = "CropBox";
            }
          break;
        case "PrintScaling":
          if (s instanceof L)
            switch (s.name) {
              case "None":
              case "AppDefault":
                a = s.name;
                break;
              default:
                a = "AppDefault";
            }
          break;
        case "Duplex":
          if (s instanceof L)
            switch (s.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                a = s.name;
                break;
              default:
                a = "None";
            }
          break;
        case "PrintPageRange":
          Array.isArray(s) && s.length % 2 === 0 && s.every((r, g, o) => Number.isInteger(r) && r > 0 && (g === 0 || r >= o[g - 1]) && r <= this.numPages) && (a = s);
          break;
        case "NumCopies":
          Number.isInteger(s) && s > 0 && (a = s);
          break;
        default:
          k(`Ignoring non-standard key in ViewerPreferences: ${i}.`);
          continue;
      }
      if (a === void 0) {
        k(`Bad value, for key "${i}", in ViewerPreferences: ${s}.`);
        continue;
      }
      t || (t = /* @__PURE__ */ Object.create(null)), t[i] = a;
    }
    return iA(this, "viewerPreferences", t);
  }
  get openAction() {
    const A = this._catDict.get("OpenAction"), t = /* @__PURE__ */ Object.create(null);
    if (A instanceof R) {
      const i = new R(this.xref);
      i.set("A", A);
      const s = {
        url: null,
        dest: null,
        action: null
      };
      _n.parseDestDictionary({
        destDict: i,
        resultObj: s
      }), Array.isArray(s.dest) ? t.dest = s.dest : s.action && (t.action = s.action);
    } else Array.isArray(A) && (t.dest = A);
    return iA(this, "openAction", Qc(t) > 0 ? t : null);
  }
  get attachments() {
    const A = this._catDict.get("Names");
    let t = null;
    if (A instanceof R && A.has("EmbeddedFiles")) {
      const i = new b0(A.getRaw("EmbeddedFiles"), this.xref);
      for (const [s, a] of i.getAll()) {
        const n = new yg(a, this.xref);
        t || (t = /* @__PURE__ */ Object.create(null)), t[jA(s)] = n.serializable;
      }
    }
    return iA(this, "attachments", t);
  }
  get xfaImages() {
    const A = this._catDict.get("Names");
    let t = null;
    if (A instanceof R && A.has("XFAImages")) {
      const i = new b0(A.getRaw("XFAImages"), this.xref);
      for (const [s, a] of i.getAll())
        t || (t = new R(this.xref)), t.set(jA(s), a);
    }
    return iA(this, "xfaImages", t);
  }
  _collectJavaScript() {
    const A = this._catDict.get("Names");
    let t = null;
    function i(a, n) {
      if (!(n instanceof R) || !xe(n.get("S"), "JavaScript"))
        return;
      let r = n.get("JS");
      if (r instanceof JA)
        r = r.getString();
      else if (typeof r != "string")
        return;
      r = jA(r).replaceAll("\0", ""), r && (t || (t = /* @__PURE__ */ new Map())).set(a, r);
    }
    if (A instanceof R && A.has("JavaScript")) {
      const a = new b0(A.getRaw("JavaScript"), this.xref);
      for (const [n, r] of a.getAll())
        i(jA(n), r);
    }
    const s = this._catDict.get("OpenAction");
    return s && i("OpenAction", s), t;
  }
  get jsActions() {
    const A = this._collectJavaScript();
    let t = $n(this.xref, this._catDict, Lh);
    if (A) {
      t || (t = /* @__PURE__ */ Object.create(null));
      for (const [i, s] of A)
        i in t ? t[i].push(s) : t[i] = [s];
    }
    return iA(this, "jsActions", t);
  }
  async fontFallback(A, t) {
    const i = await Promise.all(this.fontCache);
    for (const s of i)
      if (s.loadedName === A) {
        s.fallback(t);
        return;
      }
  }
  async cleanup(A = !1) {
    ao(), this.globalImageCache.clear(A), this.pageKidsCountCache.clear(), this.pageIndexCache.clear(), this.pageDictCache.clear(), this.nonBlendModesSet.clear();
    const t = await Promise.all(this.fontCache);
    for (const {
      dict: i
    } of t)
      delete i.cacheKey;
    this.fontCache.clear(), this.builtInCMapCache.clear(), this.standardFontDataCache.clear(), this.systemFontCache.clear();
  }
  async getPageDict(A) {
    const t = [this.toplevelPagesDict], i = new Ne(), s = this._catDict.getRaw("Pages");
    s instanceof nA && i.put(s);
    const a = this.xref, n = this.pageKidsCountCache, r = this.pageIndexCache, g = this.pageDictCache;
    let o = 0;
    for (; t.length; ) {
      const I = t.pop();
      if (I instanceof nA) {
        const C = n.get(I);
        if (C >= 0 && o + C <= A) {
          o += C;
          continue;
        }
        if (i.has(I))
          throw new v("Pages tree contains circular reference.");
        i.put(I);
        const B = await (g.get(I) || a.fetchAsync(I));
        if (B instanceof R) {
          let Q = B.getRaw("Type");
          if (Q instanceof nA && (Q = await a.fetchAsync(Q)), xe(Q, "Page") || !B.has("Kids")) {
            if (n.has(I) || n.put(I, 1), r.has(I) || r.put(I, o), o === A)
              return [B, I];
            o++;
            continue;
          }
        }
        t.push(B);
        continue;
      }
      if (!(I instanceof R))
        throw new v("Page dictionary kid reference points to wrong type of object.");
      const {
        objId: c
      } = I;
      let l = I.getRaw("Count");
      if (l instanceof nA && (l = await a.fetchAsync(l)), Number.isInteger(l) && l >= 0 && (c && !n.has(c) && n.put(c, l), o + l <= A)) {
        o += l;
        continue;
      }
      let h = I.getRaw("Kids");
      if (h instanceof nA && (h = await a.fetchAsync(h)), !Array.isArray(h)) {
        let C = I.getRaw("Type");
        if (C instanceof nA && (C = await a.fetchAsync(C)), xe(C, "Page") || !I.has("Kids")) {
          if (o === A)
            return [I, null];
          o++;
          continue;
        }
        throw new v("Page dictionary kids object is not an array.");
      }
      for (let C = h.length - 1; C >= 0; C--) {
        const B = h[C];
        t.push(B), I === this.toplevelPagesDict && B instanceof nA && !g.has(B) && g.put(B, a.fetchAsync(B));
      }
    }
    throw new Error(`Page index ${A} not found.`);
  }
  async getAllPageDicts(A = !1) {
    const {
      ignoreErrors: t
    } = this.pdfManager.evaluatorOptions, i = [{
      currentNode: this.toplevelPagesDict,
      posInKids: 0
    }], s = new Ne(), a = this._catDict.getRaw("Pages");
    a instanceof nA && s.put(a);
    const n = /* @__PURE__ */ new Map(), r = this.xref, g = this.pageIndexCache;
    let o = 0;
    function I(l, h) {
      h && !g.has(h) && g.put(h, o), n.set(o++, [l, h]);
    }
    function c(l) {
      if (l instanceof Hi && !A)
        throw l;
      A && t && o === 0 && (k(`getAllPageDicts - Skipping invalid first page: "${l}".`), l = R.empty), n.set(o++, [l, null]);
    }
    for (; i.length > 0; ) {
      const l = i.at(-1), {
        currentNode: h,
        posInKids: C
      } = l;
      let B = h.getRaw("Kids");
      if (B instanceof nA)
        try {
          B = await r.fetchAsync(B);
        } catch (d) {
          c(d);
          break;
        }
      if (!Array.isArray(B)) {
        c(new v("Page dictionary kids object is not an array."));
        break;
      }
      if (C >= B.length) {
        i.pop();
        continue;
      }
      const Q = B[C];
      let E;
      if (Q instanceof nA) {
        if (s.has(Q)) {
          c(new v("Pages tree contains circular reference."));
          break;
        }
        s.put(Q);
        try {
          E = await r.fetchAsync(Q);
        } catch (d) {
          c(d);
          break;
        }
      } else
        E = Q;
      if (!(E instanceof R)) {
        c(new v("Page dictionary kid reference points to wrong type of object."));
        break;
      }
      let f = E.getRaw("Type");
      if (f instanceof nA)
        try {
          f = await r.fetchAsync(f);
        } catch (d) {
          c(d);
          break;
        }
      xe(f, "Page") || !E.has("Kids") ? I(E, Q instanceof nA ? Q : null) : i.push({
        currentNode: E,
        posInKids: 0
      }), l.posInKids++;
    }
    return n;
  }
  getPageIndex(A) {
    const t = this.pageIndexCache.get(A);
    if (t !== void 0)
      return Promise.resolve(t);
    const i = this.xref;
    function s(r) {
      let g = 0, o;
      return i.fetchAsync(r).then(function(I) {
        if (pn(r, A) && !fc(I, "Page") && !(I instanceof R && !I.has("Type") && I.has("Contents")))
          throw new v("The reference does not point to a /Page dictionary.");
        if (!I)
          return null;
        if (!(I instanceof R))
          throw new v("Node must be a dictionary.");
        return o = I.getRaw("Parent"), I.getAsync("Parent");
      }).then(function(I) {
        if (!I)
          return null;
        if (!(I instanceof R))
          throw new v("Parent must be a dictionary.");
        return I.getAsync("Kids");
      }).then(function(I) {
        if (!I)
          return null;
        const c = [];
        let l = !1;
        for (const h of I) {
          if (!(h instanceof nA))
            throw new v("Kid must be a reference.");
          if (pn(h, r)) {
            l = !0;
            break;
          }
          c.push(i.fetchAsync(h).then(function(C) {
            if (!(C instanceof R))
              throw new v("Kid node must be a dictionary.");
            C.has("Count") ? g += C.get("Count") : g++;
          }));
        }
        if (!l)
          throw new v("Kid reference not found in parent's kids.");
        return Promise.all(c).then(function() {
          return [g, o];
        });
      });
    }
    let a = 0;
    const n = (r) => s(r).then((g) => {
      if (!g)
        return this.pageIndexCache.put(A, a), a;
      const [o, I] = g;
      return a += o, n(I);
    });
    return n(A);
  }
  get baseUrl() {
    const A = this._catDict.get("URI");
    if (A instanceof R) {
      const t = A.get("Base");
      if (typeof t == "string") {
        const i = mn(t, null, {
          tryConvertEncoding: !0
        });
        if (i)
          return iA(this, "baseUrl", i.href);
      }
    }
    return iA(this, "baseUrl", this.pdfManager.docBaseUrl);
  }
  static parseDestDictionary({
    destDict: A,
    resultObj: t,
    docBaseUrl: i = null,
    docAttachments: s = null
  }) {
    if (!(A instanceof R)) {
      k("parseDestDictionary: `destDict` must be a dictionary.");
      return;
    }
    let a = A.get("A"), n, r;
    if (a instanceof R || (A.has("Dest") ? a = A.get("Dest") : (a = A.get("AA"), a instanceof R && (a.has("D") ? a = a.get("D") : a.has("U") && (a = a.get("U"))))), a instanceof R) {
      const g = a.get("S");
      if (!(g instanceof L)) {
        k("parseDestDictionary: Invalid type in Action dictionary.");
        return;
      }
      const o = g.name;
      switch (o) {
        case "ResetForm":
          const I = a.get("Flags"), c = ((typeof I == "number" ? I : 0) & 1) === 0, l = [], h = [];
          for (const y of a.get("Fields") || [])
            y instanceof nA ? h.push(y.toString()) : typeof y == "string" && l.push(jA(y));
          t.resetForm = {
            fields: l,
            refs: h,
            include: c
          };
          break;
        case "URI":
          n = a.get("URI"), n instanceof L && (n = "/" + n.name);
          break;
        case "GoTo":
          r = a.get("D");
          break;
        case "Launch":
        case "GoToR":
          const C = a.get("F");
          if (C instanceof R) {
            const y = new yg(C, null, !0), {
              rawFilename: H
            } = y.serializable;
            n = H;
          } else typeof C == "string" && (n = C);
          const B = TI(a);
          B && typeof n == "string" && (n = n.split("#", 1)[0] + "#" + B);
          const Q = a.get("NewWindow");
          typeof Q == "boolean" && (t.newWindow = Q);
          break;
        case "GoToE":
          const E = a.get("T");
          let f;
          if (s && E instanceof R) {
            const y = E.get("R"), H = E.get("N");
            xe(y, "C") && typeof H == "string" && (f = s[jA(H)]);
          }
          if (f) {
            t.attachment = f;
            const y = TI(a);
            y && (t.attachmentDest = y);
          } else
            k('parseDestDictionary - unimplemented "GoToE" action.');
          break;
        case "Named":
          const d = a.get("N");
          d instanceof L && (t.action = d.name);
          break;
        case "SetOCGState":
          const u = a.get("State"), x = a.get("PreserveRB");
          if (!Array.isArray(u) || u.length === 0)
            break;
          const m = [];
          for (const y of u)
            if (y instanceof L)
              switch (y.name) {
                case "ON":
                case "OFF":
                case "Toggle":
                  m.push(y.name);
                  break;
              }
            else y instanceof nA && m.push(y.toString());
          if (m.length !== u.length)
            break;
          t.setOCGState = {
            state: m,
            preserveRB: typeof x == "boolean" ? x : !0
          };
          break;
        case "JavaScript":
          const p = a.get("JS");
          let D;
          p instanceof JA ? D = p.getString() : typeof p == "string" && (D = p);
          const F = D && mc(jA(D));
          if (F) {
            n = F.url, t.newWindow = F.newWindow;
            break;
          }
        default:
          if (o === "JavaScript" || o === "SubmitForm")
            break;
          k(`parseDestDictionary - unsupported action: "${o}".`);
          break;
      }
    } else A.has("Dest") && (r = A.get("Dest"));
    if (typeof n == "string") {
      const g = mn(n, i, {
        addDefaultProtocol: !0,
        tryConvertEncoding: !0
      });
      g && (t.url = g.href), t.unsafeUrl = n;
    }
    r && (r instanceof L && (r = r.name), typeof r == "string" ? t.dest = jA(r) : no(r) && (t.dest = r));
  }
};
Is = new WeakSet(), Bl = function(A) {
  const t = this.xref.fetch(A), i = {
    id: A.toString(),
    name: null,
    intent: null,
    usage: {
      print: null,
      view: null
    },
    rbGroups: []
  }, s = t.get("Name");
  typeof s == "string" && (i.name = jA(s));
  let a = t.getArray("Intent");
  Array.isArray(a) || (a = [a]), a.every((I) => I instanceof L) && (i.intent = a.map((I) => I.name));
  const n = t.get("Usage");
  if (!(n instanceof R))
    return i;
  const r = i.usage, g = n.get("Print");
  if (g instanceof R) {
    const I = g.get("PrintState");
    if (I instanceof L)
      switch (I.name) {
        case "ON":
        case "OFF":
          r.print = {
            printState: I.name
          };
      }
  }
  const o = n.get("View");
  if (o instanceof R) {
    const I = o.get("ViewState");
    if (I instanceof L)
      switch (I.name) {
        case "ON":
        case "OFF":
          r.view = {
            viewState: I.name
          };
      }
  }
  return i;
}, Ql = function(A, t) {
  function i(I) {
    const c = [];
    if (Array.isArray(I))
      for (const l of I)
        l instanceof nA && t.has(l) && c.push(l.toString());
    return c;
  }
  function s(I, c = 0) {
    if (!Array.isArray(I))
      return null;
    const l = [];
    for (const C of I) {
      if (C instanceof nA && t.has(C)) {
        g.put(C), l.push(C.toString());
        continue;
      }
      const B = a(C, c);
      B && l.push(B);
    }
    if (c > 0)
      return l;
    const h = [];
    for (const [C] of t.items())
      g.has(C) || h.push(C.toString());
    return h.length && l.push({
      name: null,
      order: h
    }), l;
  }
  function a(I, c) {
    if (++c > o)
      return k("parseNestedOrder - reached MAX_NESTED_LEVELS."), null;
    const l = r.fetchIfRef(I);
    if (!Array.isArray(l))
      return null;
    const h = r.fetchIfRef(l[0]);
    if (typeof h != "string")
      return null;
    const C = s(l.slice(1), c);
    return C != null && C.length ? {
      name: jA(h),
      order: C
    } : null;
  }
  function n(I) {
    if (Array.isArray(I))
      for (const c of I) {
        const l = r.fetchIfRef(c);
        if (!Array.isArray(l) || !l.length)
          continue;
        const h = /* @__PURE__ */ new Set();
        for (const C of l)
          C instanceof nA && t.has(C) && !h.has(C.toString()) && (h.add(C.toString()), t.get(C).rbGroups.push(h));
      }
  }
  const r = this.xref, g = new Ne(), o = 10;
  return n(A.get("RBGroups")), {
    name: typeof A.get("Name") == "string" ? jA(A.get("Name")) : null,
    creator: typeof A.get("Creator") == "string" ? jA(A.get("Creator")) : null,
    baseState: A.get("BaseState") instanceof L ? A.get("BaseState").name : null,
    on: i(A.get("ON")),
    off: i(A.get("OFF")),
    order: s(A.get("Order")),
    groups: [...t]
  };
};
let ta = _n;
function V1(e) {
  return e instanceof nA || e instanceof R || e instanceof JA || Array.isArray(e);
}
function Z1(e, A) {
  if (e instanceof R)
    e = e.getRawValues();
  else if (e instanceof JA)
    e = e.dict.getRawValues();
  else if (!Array.isArray(e))
    return;
  for (const t of e)
    V1(t) && A.push(t);
}
class Rn {
  constructor(A, t, i) {
    this.dict = A, this.keys = t, this.xref = i, this.refSet = null;
  }
  async load() {
    if (this.xref.stream.isDataLoaded)
      return;
    const {
      keys: A,
      dict: t
    } = this;
    this.refSet = new Ne();
    const i = [];
    for (const s of A) {
      const a = t.getRaw(s);
      a !== void 0 && i.push(a);
    }
    return this._walk(i);
  }
  async _walk(A) {
    const t = [], i = [];
    for (; A.length; ) {
      let s = A.pop();
      if (s instanceof nA) {
        if (this.refSet.has(s))
          continue;
        try {
          this.refSet.put(s), s = this.xref.fetch(s);
        } catch (a) {
          if (!(a instanceof oe)) {
            k(`ObjectLoader._walk - requesting all data: "${a}".`), this.refSet = null;
            const {
              manager: n
            } = this.xref.stream;
            return n.requestAllChunks();
          }
          t.push(s), i.push({
            begin: a.begin,
            end: a.end
          });
        }
      }
      if (s instanceof JA) {
        const a = s.getBaseStreams();
        if (a) {
          let n = !1;
          for (const r of a)
            r.isDataLoaded || (n = !0, i.push({
              begin: r.start,
              end: r.end
            }));
          n && t.push(s);
        }
      }
      Z1(s, A);
    }
    if (i.length) {
      await this.xref.stream.manager.requestRanges(i);
      for (const s of t)
        s instanceof nA && this.refSet.remove(s);
      return this._walk(t);
    }
    this.refSet = null;
  }
}
const nr = Symbol(), c0 = Symbol(), Be = Symbol(), Wi = Symbol(), Lt = Symbol(), H0 = Symbol(), En = Symbol(), Pt = Symbol(), ei = Symbol(), P = Symbol("content"), Mt = Symbol("data"), ns = Symbol(), Y = Symbol("extra"), ae = Symbol(), ba = Symbol(), Dg = Symbol(), El = Symbol(), l0 = Symbol(), rr = Symbol(), ia = Symbol(), Ys = Symbol(), ro = Symbol(), Oe = Symbol(), Ks = Symbol(), He = Symbol(), rs = Symbol(), hi = Symbol(), ye = Symbol(), MA = Symbol(), me = Symbol(), se = Symbol(), sa = Symbol(), U0 = Symbol(), kg = Symbol(), fn = Symbol(), go = Symbol(), u0 = Symbol(), J0 = Symbol(), Mi = Symbol(), vs = Symbol(), fi = Symbol(), pi = Symbol(), aa = Symbol(), na = Symbol(), j1 = Symbol(), pe = Symbol("namespaceId"), XA = Symbol("nodeName"), Ti = Symbol(), si = Symbol(), Sg = Symbol(), ui = Symbol(), ni = Symbol(), It = Symbol(), hs = Symbol(), qi = Symbol(), fl = Symbol("root"), Ns = Symbol(), Bi = Symbol(), Fg = Symbol(), ul = Symbol(), Bt = Symbol(), Tt = Symbol(), Se = Symbol(), dl = Symbol(), SA = Symbol(), Ts = Symbol(), VA = Symbol(), ee = Symbol("uid"), Vt = Symbol(), we = {
  config: {
    id: 0,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xci/")
  },
  connectionSet: {
    id: 1,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
  },
  datasets: {
    id: 2,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-data/")
  },
  form: {
    id: 3,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-form/")
  },
  localeSet: {
    id: 4,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
  },
  pdf: {
    id: 5,
    check: (e) => e === "http://ns.adobe.com/xdp/pdf/"
  },
  signature: {
    id: 6,
    check: (e) => e === "http://www.w3.org/2000/09/xmldsig#"
  },
  sourceSet: {
    id: 7,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-source-set/")
  },
  stylesheet: {
    id: 8,
    check: (e) => e === "http://www.w3.org/1999/XSL/Transform"
  },
  template: {
    id: 9,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xfa-template/")
  },
  xdc: {
    id: 10,
    check: (e) => e.startsWith("http://www.xfa.org/schema/xdc/")
  },
  xdp: {
    id: 11,
    check: (e) => e === "http://ns.adobe.com/xdp/"
  },
  xfdf: {
    id: 12,
    check: (e) => e === "http://ns.adobe.com/xfdf/"
  },
  xhtml: {
    id: 13,
    check: (e) => e === "http://www.w3.org/1999/xhtml"
  },
  xmpmeta: {
    id: 14,
    check: (e) => e === "http://ns.adobe.com/xmpmeta/"
  }
}, X1 = {
  pt: (e) => e,
  cm: (e) => e / 2.54 * 72,
  mm: (e) => e / (10 * 2.54) * 72,
  in: (e) => e * 72,
  px: (e) => e
}, _1 = /([+-]?\d+\.?\d*)(.*)/;
function gr(e) {
  return e.startsWith("'") || e.startsWith('"') ? e.slice(1, -1) : e;
}
function RA({
  data: e,
  defaultValue: A,
  validate: t
}) {
  if (!e)
    return A;
  e = e.trim();
  const i = parseInt(e, 10);
  return !isNaN(i) && t(i) ? i : A;
}
function Gn({
  data: e,
  defaultValue: A,
  validate: t
}) {
  if (!e)
    return A;
  e = e.trim();
  const i = parseFloat(e);
  return !isNaN(i) && t(i) ? i : A;
}
function or({
  data: e,
  defaultValue: A,
  validate: t
}) {
  return e ? (e = e.trim(), t(e) ? e : A) : A;
}
function O(e, A) {
  return or({
    data: e,
    defaultValue: A[0],
    validate: (t) => A.includes(t)
  });
}
function lA(e, A = "0") {
  if (A || (A = "0"), !e)
    return lA(A);
  const t = e.trim().match(_1);
  if (!t)
    return lA(A);
  const [, i, s] = t, a = parseFloat(i);
  if (isNaN(a))
    return lA(A);
  if (a === 0)
    return 0;
  const n = X1[s];
  return n ? n(a) : a;
}
function qI(e) {
  if (!e)
    return {
      num: 1,
      den: 1
    };
  const A = e.trim().split(/\s*:\s*/).map((s) => parseFloat(s)).filter((s) => !isNaN(s));
  if (A.length === 1 && A.push(1), A.length === 0)
    return {
      num: 1,
      den: 1
    };
  const [t, i] = A;
  return {
    num: t,
    den: i
  };
}
function Zt(e) {
  return e ? e.trim().split(/\s+/).map((A) => ({
    excluded: A[0] === "-",
    viewname: A.substring(1)
  })) : [];
}
function z1(e, A = [0, 0, 0]) {
  let [t, i, s] = A;
  if (!e)
    return {
      r: t,
      g: i,
      b: s
    };
  const a = e.trim().split(/\s*,\s*/).map((n) => Math.min(Math.max(0, parseInt(n.trim(), 10)), 255)).map((n) => isNaN(n) ? 0 : n);
  return a.length < 3 ? {
    r: t,
    g: i,
    b: s
  } : ([t, i, s] = a, {
    r: t,
    g: i,
    b: s
  });
}
function $1(e) {
  if (!e)
    return {
      x: -1,
      y: -1,
      width: -1,
      height: -1
    };
  const t = e.trim().split(/\s*,\s*/).map((r) => lA(r, "-1"));
  if (t.length < 4 || t[2] < 0 || t[3] < 0)
    return {
      x: -1,
      y: -1,
      width: -1,
      height: -1
    };
  const [i, s, a, n] = t;
  return {
    x: i,
    y: s,
    width: a,
    height: n
  };
}
class dA {
  static get FAILURE() {
    return iA(this, "FAILURE", new dA(!1, null, null, null));
  }
  static get EMPTY() {
    return iA(this, "EMPTY", new dA(!0, null, null, null));
  }
  constructor(A, t, i, s) {
    this.success = A, this.html = t, this.bbox = i, this.breakNode = s;
  }
  isBreak() {
    return !!this.breakNode;
  }
  static breakNode(A) {
    return new dA(!1, null, null, A);
  }
  static success(A, t = null) {
    return new dA(!0, A, t, null);
  }
}
class AE {
  constructor(A) {
    this.fonts = /* @__PURE__ */ new Map(), this.cache = /* @__PURE__ */ new Map(), this.warned = /* @__PURE__ */ new Set(), this.defaultFont = null, this.add(A);
  }
  add(A, t = null) {
    for (const s of A)
      this.addPdfFont(s);
    for (const s of this.fonts.values())
      s.regular || (s.regular = s.italic || s.bold || s.bolditalic);
    if (!t || t.size === 0)
      return;
    const i = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
    for (const s of t)
      this.fonts.set(s, i);
  }
  addPdfFont(A) {
    var r, g, o;
    const t = A.cssFontInfo, i = t.fontFamily;
    let s = this.fonts.get(i);
    s || (s = /* @__PURE__ */ Object.create(null), this.fonts.set(i, s), this.defaultFont || (this.defaultFont = s));
    let a = "";
    const n = parseFloat(t.fontWeight);
    parseFloat(t.italicAngle) !== 0 ? a = n >= 700 ? "bolditalic" : "italic" : n >= 700 && (a = "bold"), a || ((A.name.includes("Bold") || (r = A.psName) != null && r.includes("Bold")) && (a = "bold"), (A.name.includes("Italic") || A.name.endsWith("It") || (g = A.psName) != null && g.includes("Italic") || (o = A.psName) != null && o.endsWith("It")) && (a += "italic")), a || (a = "regular"), s[a] = A;
  }
  getDefault() {
    return this.defaultFont;
  }
  find(A, t = !0) {
    var r, g;
    let i = this.fonts.get(A) || this.cache.get(A);
    if (i)
      return i;
    const s = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
    let a = A.replaceAll(s, "");
    if (i = this.fonts.get(a), i)
      return this.cache.set(A, i), i;
    a = a.toLowerCase();
    const n = [];
    for (const [o, I] of this.fonts.entries())
      o.replaceAll(s, "").toLowerCase().startsWith(a) && n.push(I);
    if (n.length === 0)
      for (const [, o] of this.fonts.entries())
        (r = o.regular.name) != null && r.replaceAll(s, "").toLowerCase().startsWith(a) && n.push(o);
    if (n.length === 0) {
      a = a.replaceAll(/psmt|mt/gi, "");
      for (const [o, I] of this.fonts.entries())
        o.replaceAll(s, "").toLowerCase().startsWith(a) && n.push(I);
    }
    if (n.length === 0)
      for (const o of this.fonts.values())
        (g = o.regular.name) != null && g.replaceAll(s, "").toLowerCase().startsWith(a) && n.push(o);
    return n.length >= 1 ? (n.length !== 1 && t && k(`XFA - Too many choices to guess the correct font: ${A}`), this.cache.set(A, n[0]), n[0]) : (t && !this.warned.has(A) && (this.warned.add(A), k(`XFA - Cannot find the font: ${A}`)), null);
  }
}
function oo(e, A) {
  return e.posture === "italic" ? e.weight === "bold" ? A.bolditalic : A.italic : e.weight === "bold" ? A.bold : A.regular;
}
function eE(e, A = !1) {
  let t = null;
  if (e) {
    const n = gr(e.typeface), r = e[se].fontFinder.find(n);
    t = oo(e, r);
  }
  if (!t)
    return {
      lineHeight: 12,
      lineGap: 2,
      lineNoGap: 10
    };
  const i = e.size || 10, s = t.lineHeight ? Math.max(A ? 0 : 1.2, t.lineHeight) : 1.2, a = t.lineGap === void 0 ? 0.2 : t.lineGap;
  return {
    lineHeight: s * i,
    lineGap: a * i,
    lineNoGap: Math.max(1, s - a) * i
  };
}
const tE = 1.02;
class PI {
  constructor(A, t, i, s) {
    if (this.lineHeight = i, this.paraMargin = t || {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, !A) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(s);
      return;
    }
    this.xfaFont = {
      typeface: A.typeface,
      posture: A.posture,
      weight: A.weight,
      size: A.size,
      letterSpacing: A.letterSpacing
    };
    const a = s.find(A.typeface);
    if (!a) {
      [this.pdfFont, this.xfaFont] = this.defaultFont(s);
      return;
    }
    this.pdfFont = oo(A, a), this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(s));
  }
  defaultFont(A) {
    const t = A.find("Helvetica", !1) || A.find("Myriad Pro", !1) || A.find("Arial", !1) || A.getDefault();
    if (t != null && t.regular) {
      const s = t.regular, n = {
        typeface: s.cssFontInfo.fontFamily,
        posture: "normal",
        weight: "normal",
        size: 10,
        letterSpacing: 0
      };
      return [s, n];
    }
    return [null, {
      typeface: "Courier",
      posture: "normal",
      weight: "normal",
      size: 10,
      letterSpacing: 0
    }];
  }
}
class iE {
  constructor(A, t, i, s) {
    this.fontFinder = s, this.stack = [new PI(A, t, i, s)];
  }
  pushData(A, t, i) {
    const s = this.stack.at(-1);
    for (const n of ["typeface", "posture", "weight", "size", "letterSpacing"])
      A[n] || (A[n] = s.xfaFont[n]);
    for (const n of ["top", "bottom", "left", "right"])
      isNaN(t[n]) && (t[n] = s.paraMargin[n]);
    const a = new PI(A, t, i || s.lineHeight, this.fontFinder);
    a.pdfFont || (a.pdfFont = s.pdfFont), this.stack.push(a);
  }
  popFont() {
    this.stack.pop();
  }
  topFont() {
    return this.stack.at(-1);
  }
}
class sE {
  constructor(A, t, i, s) {
    this.glyphs = [], this.fontSelector = new iE(A, t, i, s), this.extraHeight = 0;
  }
  pushData(A, t, i) {
    this.fontSelector.pushData(A, t, i);
  }
  popFont(A) {
    return this.fontSelector.popFont();
  }
  addPara() {
    const A = this.fontSelector.topFont();
    this.extraHeight += A.paraMargin.top + A.paraMargin.bottom;
  }
  addString(A) {
    if (!A)
      return;
    const t = this.fontSelector.topFont(), i = t.xfaFont.size;
    if (t.pdfFont) {
      const s = t.xfaFont.letterSpacing, a = t.pdfFont, n = a.lineHeight || 1.2, r = t.lineHeight || Math.max(1.2, n) * i, g = a.lineGap === void 0 ? 0.2 : a.lineGap, o = n - g, I = Math.max(1, o) * i, c = i / 1e3, l = a.defaultWidth || a.charsToGlyphs(" ")[0].width;
      for (const h of A.split(/[\u2029\n]/)) {
        const C = a.encodeString(h).join(""), B = a.charsToGlyphs(C);
        for (const Q of B) {
          const E = Q.width || l;
          this.glyphs.push([E * c + s, r, I, Q.unicode, !1]);
        }
        this.glyphs.push([0, 0, 0, `
`, !0]);
      }
      this.glyphs.pop();
      return;
    }
    for (const s of A.split(/[\u2029\n]/)) {
      for (const a of s.split(""))
        this.glyphs.push([i, 1.2 * i, i, a, !1]);
      this.glyphs.push([0, 0, 0, `
`, !0]);
    }
    this.glyphs.pop();
  }
  compute(A) {
    let t = -1, i = 0, s = 0, a = 0, n = 0, r = 0, g = !1, o = !0;
    for (let I = 0, c = this.glyphs.length; I < c; I++) {
      const [l, h, C, B, Q] = this.glyphs[I], E = B === " ", f = o ? C : h;
      if (Q) {
        s = Math.max(s, n), n = 0, a += r, r = f, t = -1, i = 0, o = !1;
        continue;
      }
      if (E) {
        n + l > A ? (s = Math.max(s, n), n = 0, a += r, r = f, t = -1, i = 0, g = !0, o = !1) : (r = Math.max(f, r), i = n, n += l, t = I);
        continue;
      }
      if (n + l > A) {
        a += r, r = f, t !== -1 ? (I = t, s = Math.max(s, i), n = 0, t = -1, i = 0) : (s = Math.max(s, n), n = l), g = !0, o = !1;
        continue;
      }
      n += l, r = Math.max(f, r);
    }
    return s = Math.max(s, n), a += r + this.extraHeight, {
      width: tE * s,
      height: a,
      isBroken: g
    };
  }
}
const WI = /^[^.[]+/, aE = /^[^\]]+/, xt = {
  dot: 0,
  dotDot: 1,
  dotHash: 2,
  dotBracket: 3,
  dotParen: 4
}, xl = /* @__PURE__ */ new Map([["$data", (e, A) => e.datasets ? e.datasets.data : e], ["$record", (e, A) => (e.datasets ? e.datasets.data : e)[He]()[0]], ["$template", (e, A) => e.template], ["$connectionSet", (e, A) => e.connectionSet], ["$form", (e, A) => e.form], ["$layout", (e, A) => e.layout], ["$host", (e, A) => e.host], ["$dataWindow", (e, A) => e.dataWindow], ["$event", (e, A) => e.event], ["!", (e, A) => e.datasets], ["$xfa", (e, A) => e], ["xfa", (e, A) => e], ["$", (e, A) => A]]), OI = /* @__PURE__ */ new WeakMap();
function nE(e) {
  return e = e.trim(), e === "*" ? 1 / 0 : parseInt(e, 10) || 0;
}
function ml(e, A, t = !0) {
  let i = e.match(WI);
  if (!i)
    return null;
  let [s] = i;
  const a = [{
    name: s,
    cacheName: "." + s,
    index: 0,
    js: null,
    formCalc: null,
    operator: xt.dot
  }];
  let n = s.length;
  for (; n < e.length; ) {
    const r = n;
    if (e.charAt(n++) === "[") {
      if (i = e.slice(n).match(aE), !i)
        return k("XFA - Invalid index in SOM expression"), null;
      a.at(-1).index = nE(i[0]), n += i[0].length + 1;
      continue;
    }
    let o;
    switch (e.charAt(n)) {
      case ".":
        if (!A)
          return null;
        n++, o = xt.dotDot;
        break;
      case "#":
        n++, o = xt.dotHash;
        break;
      case "[":
        if (t)
          return k("XFA - SOM expression contains a FormCalc subexpression which is not supported for now."), null;
        o = xt.dotBracket;
        break;
      case "(":
        if (t)
          return k("XFA - SOM expression contains a JavaScript subexpression which is not supported for now."), null;
        o = xt.dotParen;
        break;
      default:
        o = xt.dot;
        break;
    }
    if (i = e.slice(n).match(WI), !i)
      break;
    [s] = i, n += s.length, a.push({
      name: s,
      cacheName: e.slice(r, n),
      operator: o,
      index: 0,
      js: null,
      formCalc: null
    });
  }
  return a;
}
function Fi(e, A, t, i = !0, s = !0) {
  const a = ml(t, i);
  if (!a)
    return null;
  const n = xl.get(a[0].name);
  let r = 0, g;
  n ? (g = !0, e = [n(e, A)], r = 1) : (g = A === null, e = [A || e]);
  for (let o = a.length; r < o; r++) {
    const {
      name: I,
      cacheName: c,
      operator: l,
      index: h
    } = a[r], C = [];
    for (const B of e) {
      if (!B.isXFAObject)
        continue;
      let Q, E;
      if (s && (E = OI.get(B), E || (E = /* @__PURE__ */ new Map(), OI.set(B, E)), Q = E.get(c)), !Q) {
        switch (l) {
          case xt.dot:
            Q = B[ia](I, !1);
            break;
          case xt.dotDot:
            Q = B[ia](I, !0);
            break;
          case xt.dotHash:
            Q = B[rr](I), Q = Q.isXFAObjectArray ? Q.children : [Q];
            break;
        }
        s && E.set(c, Q);
      }
      Q.length > 0 && C.push(Q);
    }
    if (C.length === 0 && !g && r === 0) {
      if (A = A[MA](), !A)
        return null;
      r = -1, e = [A];
      continue;
    }
    e = isFinite(h) ? C.filter((B) => h < B.length).map((B) => B[h]) : C.flat();
  }
  return e.length === 0 ? null : e;
}
function rE(e, A, t) {
  const i = ml(t);
  if (!i || i.some((n) => n.operator === xt.dotDot))
    return null;
  const s = xl.get(i[0].name);
  let a = 0;
  s ? (e = s(e, A), a = 1) : e = A || e;
  for (let n = i.length; a < n; a++) {
    const {
      name: r,
      operator: g,
      index: o
    } = i[a];
    if (!isFinite(o))
      return i[a].index = 0, e.createNodes(i.slice(a));
    let I;
    switch (g) {
      case xt.dot:
        I = e[ia](r, !1);
        break;
      case xt.dotDot:
        I = e[ia](r, !0);
        break;
      case xt.dotHash:
        I = e[rr](r), I = I.isXFAObjectArray ? I.children : [I];
        break;
    }
    if (I.length === 0)
      return e.createNodes(i.slice(a));
    if (o < I.length) {
      const c = I[o];
      if (!c.isXFAObject)
        return k("XFA - Cannot create a node."), null;
      e = c;
    } else
      return i[a].index = o - I.length, e.createNodes(i.slice(a));
  }
  return null;
}
const $a = Symbol(), _i = Symbol(), D0 = Symbol(), YA = Symbol("_children"), Hr = Symbol(), ki = Symbol(), Jr = Symbol(), VI = Symbol(), Yr = Symbol(), ZI = Symbol(), Kr = Symbol(), Ms = Symbol(), An = Symbol(), St = Symbol("parent"), ks = Symbol(), Ss = Symbol(), vr = Symbol();
let Rg = 0;
const pl = we.datasets.id;
class K {
  constructor(A, t, i = !1) {
    this[pe] = A, this[XA] = t, this[Kr] = i, this[St] = null, this[YA] = [], this[ee] = `${t}${Rg++}`, this[se] = null;
  }
  get isXFAObject() {
    return !0;
  }
  get isXFAObjectArray() {
    return !1;
  }
  createNodes(A) {
    let t = this, i = null;
    for (const {
      name: s,
      index: a
    } of A) {
      for (let n = 0, r = isFinite(a) ? a : 0; n <= r; n++) {
        const g = t[pe] === pl ? -1 : t[pe];
        i = new ai(g, s), t[Be](i);
      }
      t = i;
    }
    return i;
  }
  [si](A) {
    if (!this[Kr] || !this[Sg](A))
      return !1;
    const t = A[XA], i = this[t];
    if (i instanceof b) {
      if (i.push(A))
        return this[Be](A), !0;
    } else
      return i !== null && this[qi](i), this[t] = A, this[Be](A), !0;
    let s = "";
    return this.id ? s = ` (id: ${this.id})` : this.name && (s = ` (name: ${this.name} ${this.h.value})`), k(`XFA - node "${this[XA]}"${s} has already enough "${t}"!`), !1;
  }
  [Sg](A) {
    return this.hasOwnProperty(A[XA]) && A[pe] === this[pe];
  }
  [vs]() {
    return !1;
  }
  [nr]() {
    return !1;
  }
  [go]() {
    return !1;
  }
  [u0]() {
    return !1;
  }
  [It]() {
    this.para && this[me]()[Y].paraStack.pop();
  }
  [hs]() {
    this[me]()[Y].paraStack.push(this.para);
  }
  [Fg](A) {
    this.id && this[pe] === we.template.id && A.set(this.id, this);
  }
  [me]() {
    return this[se].template;
  }
  [fi]() {
    return !1;
  }
  [pi]() {
    return !1;
  }
  [Be](A) {
    A[St] = this, this[YA].push(A), !A[se] && this[se] && (A[se] = this[se]);
  }
  [qi](A) {
    const t = this[YA].indexOf(A);
    this[YA].splice(t, 1);
  }
  [sa]() {
    return this.hasOwnProperty("value");
  }
  [Bt](A) {
  }
  [ui](A) {
  }
  [ae]() {
  }
  [Lt](A) {
    delete this[Kr], this[En] && (A.clean(this[En]), delete this[En]);
  }
  [kg](A) {
    return this[YA].indexOf(A);
  }
  [fn](A, t) {
    t[St] = this, this[YA].splice(A, 0, t), !t[se] && this[se] && (t[se] = this[se]);
  }
  [aa]() {
    return !this.name;
  }
  [j1]() {
    return "";
  }
  [Se]() {
    return this[YA].length === 0 ? this[P] : this[YA].map((A) => A[Se]()).join("");
  }
  get [D0]() {
    const A = Object.getPrototypeOf(this);
    if (!A._attributes) {
      const t = A._attributes = /* @__PURE__ */ new Set();
      for (const i of Object.getOwnPropertyNames(this)) {
        if (this[i] === null || this[i] instanceof K || this[i] instanceof b)
          break;
        t.add(i);
      }
    }
    return iA(this, D0, A._attributes);
  }
  [Mi](A) {
    let t = this;
    for (; t; ) {
      if (t === A)
        return !0;
      t = t[MA]();
    }
    return !1;
  }
  [MA]() {
    return this[St];
  }
  [ye]() {
    return this[MA]();
  }
  [He](A = null) {
    return A ? this[A] : this[YA];
  }
  [ns]() {
    const A = /* @__PURE__ */ Object.create(null);
    this[P] && (A.$content = this[P]);
    for (const t of Object.getOwnPropertyNames(this)) {
      const i = this[t];
      i !== null && (i instanceof K ? A[t] = i[ns]() : i instanceof b ? i.isEmpty() || (A[t] = i.dump()) : A[t] = i);
    }
    return A;
  }
  [VA]() {
    return null;
  }
  [SA]() {
    return dA.EMPTY;
  }
  *[rs]() {
    for (const A of this[He]())
      yield A;
  }
  *[VI](A, t) {
    for (const i of this[rs]())
      if (!A || t === A.has(i[XA])) {
        const s = this[l0](), a = i[SA](s);
        a.success || (this[Y].failingNode = i), yield a;
      }
  }
  [ba]() {
    return null;
  }
  [c0](A, t) {
    this[Y].children.push(A);
  }
  [l0]() {
  }
  [Wi]({
    filter: A = null,
    include: t = !0
  }) {
    if (!this[Y].generator)
      this[Y].generator = this[VI](A, t);
    else {
      const i = this[l0](), s = this[Y].failingNode[SA](i);
      if (!s.success)
        return s;
      s.html && this[c0](s.html, s.bbox), delete this[Y].failingNode;
    }
    for (; ; ) {
      const i = this[Y].generator.next();
      if (i.done)
        break;
      const s = i.value;
      if (!s.success)
        return s;
      s.html && this[c0](s.html, s.bbox);
    }
    return this[Y].generator = null, dA.EMPTY;
  }
  [ul](A) {
    this[Ss] = new Set(Object.keys(A));
  }
  [ZI](A) {
    const t = this[D0], i = this[Ss];
    return [...A].filter((s) => t.has(s) && !i.has(s));
  }
  [Ns](A, t = /* @__PURE__ */ new Set()) {
    for (const i of this[YA])
      i[ks](A, t);
  }
  [ks](A, t) {
    const i = this[Yr](A, t);
    i ? this[$a](i, A, t) : this[Ns](A, t);
  }
  [Yr](A, t) {
    const {
      use: i,
      usehref: s
    } = this;
    if (!i && !s)
      return null;
    let a = null, n = null, r = null, g = i;
    if (s ? (g = s, s.startsWith("#som(") && s.endsWith(")") ? n = s.slice(5, -1) : s.startsWith(".#som(") && s.endsWith(")") ? n = s.slice(6, -1) : s.startsWith("#") ? r = s.slice(1) : s.startsWith(".#") && (r = s.slice(2))) : i.startsWith("#") ? r = i.slice(1) : n = i, this.use = this.usehref = "", r ? a = A.get(r) : (a = Fi(A.get(fl), this, n, !0, !1), a && (a = a[0])), !a)
      return k(`XFA - Invalid prototype reference: ${g}.`), null;
    if (a[XA] !== this[XA])
      return k(`XFA - Incompatible prototype: ${a[XA]} !== ${this[XA]}.`), null;
    if (t.has(a))
      return k("XFA - Cycle detected in prototypes use."), null;
    t.add(a);
    const o = a[Yr](A, t);
    return o && a[$a](o, A, t), a[Ns](A, t), t.delete(a), a;
  }
  [$a](A, t, i) {
    if (i.has(A)) {
      k("XFA - Cycle detected in prototypes use.");
      return;
    }
    !this[P] && A[P] && (this[P] = A[P]), new Set(i).add(A);
    for (const a of this[ZI](A[Ss]))
      this[a] = A[a], this[Ss] && this[Ss].add(a);
    for (const a of Object.getOwnPropertyNames(this)) {
      if (this[D0].has(a))
        continue;
      const n = this[a], r = A[a];
      if (n instanceof b) {
        for (const g of n[YA])
          g[ks](t, i);
        for (let g = n[YA].length, o = r[YA].length; g < o; g++) {
          const I = A[YA][g][Pt]();
          if (n.push(I))
            I[St] = this, this[YA].push(I), I[ks](t, i);
          else
            break;
        }
        continue;
      }
      if (n !== null) {
        n[Ns](t, i), r && n[$a](r, t, i);
        continue;
      }
      if (r !== null) {
        const g = r[Pt]();
        g[St] = this, this[a] = g, this[YA].push(g), g[ks](t, i);
      }
    }
  }
  static [Hr](A) {
    return Array.isArray(A) ? A.map((t) => K[Hr](t)) : typeof A == "object" && A !== null ? Object.assign({}, A) : A;
  }
  [Pt]() {
    const A = Object.create(Object.getPrototypeOf(this));
    for (const t of Object.getOwnPropertySymbols(this))
      try {
        A[t] = this[t];
      } catch {
        iA(A, t, this[t]);
      }
    A[ee] = `${A[XA]}${Rg++}`, A[YA] = [];
    for (const t of Object.getOwnPropertyNames(this)) {
      if (this[D0].has(t)) {
        A[t] = K[Hr](this[t]);
        continue;
      }
      const i = this[t];
      A[t] = i instanceof b ? new b(i[Ms]) : null;
    }
    for (const t of this[YA]) {
      const i = t[XA], s = t[Pt]();
      A[YA].push(s), s[St] = A, A[i] === null ? A[i] = s : A[i][YA].push(s);
    }
    return A;
  }
  [He](A = null) {
    return A ? this[YA].filter((t) => t[XA] === A) : this[YA];
  }
  [rr](A) {
    return this[A];
  }
  [ia](A, t, i = !0) {
    return Array.from(this[Ys](A, t, i));
  }
  *[Ys](A, t, i = !0) {
    if (A === "parent") {
      yield this[St];
      return;
    }
    for (const s of this[YA])
      s[XA] === A && (yield s), s.name === A && (yield s), (t || s[aa]()) && (yield* s[Ys](A, t, !1));
    i && this[D0].has(A) && (yield new Io(this, A, this[A]));
  }
}
class b {
  constructor(A = 1 / 0) {
    this[Ms] = A, this[YA] = [];
  }
  get isXFAObject() {
    return !1;
  }
  get isXFAObjectArray() {
    return !0;
  }
  push(A) {
    return this[YA].length <= this[Ms] ? (this[YA].push(A), !0) : (k(`XFA - node "${A[XA]}" accepts no more than ${this[Ms]} children`), !1);
  }
  isEmpty() {
    return this[YA].length === 0;
  }
  dump() {
    return this[YA].length === 1 ? this[YA][0][ns]() : this[YA].map((A) => A[ns]());
  }
  [Pt]() {
    const A = new b(this[Ms]);
    return A[YA] = this[YA].map((t) => t[Pt]()), A;
  }
  get children() {
    return this[YA];
  }
  clear() {
    this[YA].length = 0;
  }
}
class Io {
  constructor(A, t, i) {
    this[St] = A, this[XA] = t, this[P] = i, this[ei] = !1, this[ee] = `attribute${Rg++}`;
  }
  [MA]() {
    return this[St];
  }
  [J0]() {
    return !0;
  }
  [ro]() {
    return this[P].trim();
  }
  [Bt](A) {
    A = A.value || "", this[P] = A.toString();
  }
  [Se]() {
    return this[P];
  }
  [Mi](A) {
    return this[St] === A || this[St][Mi](A);
  }
}
class ai extends K {
  constructor(A, t, i = {}) {
    if (super(A, t), this[P] = "", this[ki] = null, t !== "#text") {
      const s = /* @__PURE__ */ new Map();
      this[_i] = s;
      for (const [a, n] of Object.entries(i))
        s.set(a, new Io(this, a, n));
      if (i.hasOwnProperty(Ti)) {
        const a = i[Ti].xfa.dataNode;
        a !== void 0 && (a === "dataGroup" ? this[ki] = !1 : a === "dataValue" && (this[ki] = !0));
      }
    }
    this[ei] = !1;
  }
  [Ts](A) {
    const t = this[XA];
    if (t === "#text") {
      A.push(W0(this[P]));
      return;
    }
    const i = Zr(t), s = this[pe] === pl ? "xfa:" : "";
    A.push(`<${s}${i}`);
    for (const [a, n] of this[_i].entries()) {
      const r = Zr(a);
      A.push(` ${r}="${W0(n[P])}"`);
    }
    if (this[ki] !== null && (this[ki] ? A.push(' xfa:dataNode="dataValue"') : A.push(' xfa:dataNode="dataGroup"')), !this[P] && this[YA].length === 0) {
      A.push("/>");
      return;
    }
    if (A.push(">"), this[P])
      typeof this[P] == "string" ? A.push(W0(this[P])) : this[P][Ts](A);
    else
      for (const a of this[YA])
        a[Ts](A);
    A.push(`</${s}${i}>`);
  }
  [si](A) {
    if (this[P]) {
      const t = new ai(this[pe], "#text");
      this[Be](t), t[P] = this[P], this[P] = "";
    }
    return this[Be](A), !0;
  }
  [ui](A) {
    this[P] += A;
  }
  [ae]() {
    if (this[P] && this[YA].length > 0) {
      const A = new ai(this[pe], "#text");
      this[Be](A), A[P] = this[P], delete this[P];
    }
  }
  [SA]() {
    return this[XA] === "#text" ? dA.success({
      name: "#text",
      value: this[P]
    }) : dA.EMPTY;
  }
  [He](A = null) {
    return A ? this[YA].filter((t) => t[XA] === A) : this[YA];
  }
  [El]() {
    return this[_i];
  }
  [rr](A) {
    const t = this[_i].get(A);
    return t !== void 0 ? t : this[He](A);
  }
  *[Ys](A, t) {
    const i = this[_i].get(A);
    i && (yield i);
    for (const s of this[YA])
      s[XA] === A && (yield s), t && (yield* s[Ys](A, t));
  }
  *[Dg](A, t) {
    const i = this[_i].get(A);
    i && (!t || !i[ei]) && (yield i);
    for (const s of this[YA])
      yield* s[Dg](A, t);
  }
  *[Ks](A, t, i) {
    for (const s of this[YA])
      s[XA] === A && (!i || !s[ei]) && (yield s), t && (yield* s[Ks](A, t, i));
  }
  [J0]() {
    return this[ki] === null ? this[YA].length === 0 || this[YA][0][pe] === we.xhtml.id : this[ki];
  }
  [ro]() {
    return this[ki] === null ? this[YA].length === 0 ? this[P].trim() : this[YA][0][pe] === we.xhtml.id ? this[YA][0][Se]().trim() : null : this[P].trim();
  }
  [Bt](A) {
    A = A.value || "", this[P] = A.toString();
  }
  [ns](A = !1) {
    const t = /* @__PURE__ */ Object.create(null);
    A && (t.$ns = this[pe]), this[P] && (t.$content = this[P]), t.$name = this[XA], t.children = [];
    for (const i of this[YA])
      t.children.push(i[ns](A));
    t.attributes = /* @__PURE__ */ Object.create(null);
    for (const [i, s] of this[_i])
      t.attributes[i] = s[P];
    return t;
  }
}
class Ee extends K {
  constructor(A, t) {
    super(A, t), this[P] = "";
  }
  [ui](A) {
    this[P] += A;
  }
  [ae]() {
  }
}
class te extends Ee {
  constructor(A, t, i) {
    super(A, t), this[An] = i;
  }
  [ae]() {
    this[P] = or({
      data: this[P],
      defaultValue: this[An][0],
      validate: (A) => this[An].includes(A)
    });
  }
  [Lt](A) {
    super[Lt](A), delete this[An];
  }
}
class TA extends Ee {
  [ae]() {
    this[P] = this[P].trim();
  }
}
class jt extends Ee {
  constructor(A, t, i, s) {
    super(A, t), this[Jr] = i, this[vr] = s;
  }
  [ae]() {
    this[P] = RA({
      data: this[P],
      defaultValue: this[Jr],
      validate: this[vr]
    });
  }
  [Lt](A) {
    super[Lt](A), delete this[Jr], delete this[vr];
  }
}
class Fe extends jt {
  constructor(A, t) {
    super(A, t, 0, (i) => i === 1);
  }
}
class yl extends jt {
  constructor(A, t) {
    super(A, t, 1, (i) => i === 0);
  }
}
function FA(e) {
  return typeof e == "string" ? "0px" : Number.isInteger(e) ? `${e}px` : `${e.toFixed(2)}px`;
}
const jI = {
  anchorType(e, A) {
    const t = e[ye]();
    if (!(!t || t.layout && t.layout !== "position"))
      switch ("transform" in A || (A.transform = ""), e.anchorType) {
        case "bottomCenter":
          A.transform += "translate(-50%, -100%)";
          break;
        case "bottomLeft":
          A.transform += "translate(0,-100%)";
          break;
        case "bottomRight":
          A.transform += "translate(-100%,-100%)";
          break;
        case "middleCenter":
          A.transform += "translate(-50%,-50%)";
          break;
        case "middleLeft":
          A.transform += "translate(0,-50%)";
          break;
        case "middleRight":
          A.transform += "translate(-100%,-50%)";
          break;
        case "topCenter":
          A.transform += "translate(-50%,0)";
          break;
        case "topRight":
          A.transform += "translate(-100%,0)";
          break;
      }
  },
  dimensions(e, A) {
    var a;
    const t = e[ye]();
    let i = e.w;
    const s = e.h;
    if ((a = t.layout) != null && a.includes("row")) {
      const n = t[Y], r = e.colSpan;
      let g;
      r === -1 ? (g = n.columnWidths.slice(n.currentColumn).reduce((o, I) => o + I, 0), n.currentColumn = 0) : (g = n.columnWidths.slice(n.currentColumn, n.currentColumn + r).reduce((o, I) => o + I, 0), n.currentColumn = (n.currentColumn + e.colSpan) % n.columnWidths.length), isNaN(g) || (i = e.w = g);
    }
    A.width = i !== "" ? FA(i) : "auto", A.height = s !== "" ? FA(s) : "auto";
  },
  position(e, A) {
    const t = e[ye]();
    t != null && t.layout && t.layout !== "position" || (A.position = "absolute", A.left = FA(e.x), A.top = FA(e.y));
  },
  rotate(e, A) {
    e.rotate && ("transform" in A || (A.transform = ""), A.transform += `rotate(-${e.rotate}deg)`, A.transformOrigin = "top left");
  },
  presence(e, A) {
    switch (e.presence) {
      case "invisible":
        A.visibility = "hidden";
        break;
      case "hidden":
      case "inactive":
        A.display = "none";
        break;
    }
  },
  hAlign(e, A) {
    if (e[XA] === "para")
      switch (e.hAlign) {
        case "justifyAll":
          A.textAlign = "justify-all";
          break;
        case "radix":
          A.textAlign = "left";
          break;
        default:
          A.textAlign = e.hAlign;
      }
    else
      switch (e.hAlign) {
        case "left":
          A.alignSelf = "start";
          break;
        case "center":
          A.alignSelf = "center";
          break;
        case "right":
          A.alignSelf = "end";
          break;
      }
  },
  margin(e, A) {
    e.margin && (A.margin = e.margin[VA]().margin);
  }
};
function wl(e, A) {
  e[ye]().layout === "position" && (e.minW > 0 && (A.minWidth = FA(e.minW)), e.maxW > 0 && (A.maxWidth = FA(e.maxW)), e.minH > 0 && (A.minHeight = FA(e.minH)), e.maxH > 0 && (A.maxHeight = FA(e.maxH)));
}
function XI(e, A, t, i, s, a) {
  const n = new sE(A, t, i, s);
  return typeof e == "string" ? n.addString(e) : e[ni](n), n.compute(a);
}
function co(e, A) {
  let t = null, i = null, s = !1;
  if ((!e.w || !e.h) && e.value) {
    let a = 0, n = 0;
    e.margin && (a = e.margin.leftInset + e.margin.rightInset, n = e.margin.topInset + e.margin.bottomInset);
    let r = null, g = null;
    e.para && (g = /* @__PURE__ */ Object.create(null), r = e.para.lineHeight === "" ? null : e.para.lineHeight, g.top = e.para.spaceAbove === "" ? 0 : e.para.spaceAbove, g.bottom = e.para.spaceBelow === "" ? 0 : e.para.spaceBelow, g.left = e.para.marginLeft === "" ? 0 : e.para.marginLeft, g.right = e.para.marginRight === "" ? 0 : e.para.marginRight);
    let o = e.font;
    if (!o) {
      const l = e[me]();
      let h = e[MA]();
      for (; h && h !== l; ) {
        if (h.font) {
          o = h.font;
          break;
        }
        h = h[MA]();
      }
    }
    const I = (e.w || A.width) - a, c = e[se].fontFinder;
    if (e.value.exData && e.value.exData[P] && e.value.exData.contentType === "text/html") {
      const l = XI(e.value.exData[P], o, g, r, c, I);
      i = l.width, t = l.height, s = l.isBroken;
    } else {
      const l = e.value[Se]();
      if (l) {
        const h = XI(l, o, g, r, c, I);
        i = h.width, t = h.height, s = h.isBroken;
      }
    }
    i !== null && !e.w && (i += a), t !== null && !e.h && (t += n);
  }
  return {
    w: i,
    h: t,
    isBroken: s
  };
}
function bl(e, A, t) {
  let i;
  if (e.w !== "" && e.h !== "")
    i = [e.x, e.y, e.w, e.h];
  else {
    if (!t)
      return null;
    let s = e.w;
    if (s === "") {
      if (e.maxW === 0) {
        const n = e[ye]();
        s = n.layout === "position" && n.w !== "" ? 0 : e.minW;
      } else
        s = Math.min(e.maxW, t.width);
      A.attributes.style.width = FA(s);
    }
    let a = e.h;
    if (a === "") {
      if (e.maxH === 0) {
        const n = e[ye]();
        a = n.layout === "position" && n.h !== "" ? 0 : e.minH;
      } else
        a = Math.min(e.maxH, t.height);
      A.attributes.style.height = FA(a);
    }
    i = [e.x, e.y, s, a];
  }
  return i;
}
function Ir(e) {
  var t;
  const A = e[ye]();
  if ((t = A.layout) != null && t.includes("row")) {
    const i = A[Y], s = e.colSpan;
    let a;
    s === -1 ? a = i.columnWidths.slice(i.currentColumn).reduce((n, r) => n + r, 0) : a = i.columnWidths.slice(i.currentColumn, i.currentColumn + s).reduce((n, r) => n + r, 0), isNaN(a) || (e.w = a);
  }
  A.layout && A.layout !== "position" && (e.x = e.y = 0), e.layout === "table" && e.w === "" && Array.isArray(e.columnWidths) && (e.w = e.columnWidths.reduce((i, s) => i + s, 0));
}
function Dl(e) {
  switch (e.layout) {
    case "position":
      return "xfaPosition";
    case "lr-tb":
      return "xfaLrTb";
    case "rl-row":
      return "xfaRlRow";
    case "rl-tb":
      return "xfaRlTb";
    case "row":
      return "xfaRow";
    case "table":
      return "xfaTable";
    case "tb":
      return "xfaTb";
    default:
      return "xfaPosition";
  }
}
function nt(e, ...A) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i of A) {
    const s = e[i];
    if (s !== null) {
      if (jI.hasOwnProperty(i)) {
        jI[i](e, t);
        continue;
      }
      if (s instanceof K) {
        const a = s[VA]();
        a ? Object.assign(t, a) : k(`(DEBUG) - XFA - style for ${i} not implemented yet`);
      }
    }
  }
  return t;
}
function h0(e, A) {
  const {
    attributes: t
  } = A, {
    style: i
  } = t, s = {
    name: "div",
    attributes: {
      class: ["xfaWrapper"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: []
  };
  if (t.class.push("xfaWrapped"), e.border) {
    const {
      widths: a,
      insets: n
    } = e.border[Y];
    let r, g, o = n[0], I = n[3];
    const c = n[0] + n[2], l = n[1] + n[3];
    switch (e.border.hand) {
      case "even":
        o -= a[0] / 2, I -= a[3] / 2, r = `calc(100% + ${(a[1] + a[3]) / 2 - l}px)`, g = `calc(100% + ${(a[0] + a[2]) / 2 - c}px)`;
        break;
      case "left":
        o -= a[0], I -= a[3], r = `calc(100% + ${a[1] + a[3] - l}px)`, g = `calc(100% + ${a[0] + a[2] - c}px)`;
        break;
      case "right":
        r = l ? `calc(100% - ${l}px)` : "100%", g = c ? `calc(100% - ${c}px)` : "100%";
        break;
    }
    const h = ["xfaBorder"];
    Cs(e.border) && h.push("xfaPrintOnly");
    const C = {
      name: "div",
      attributes: {
        class: h,
        style: {
          top: `${o}px`,
          left: `${I}px`,
          width: r,
          height: g
        }
      },
      children: []
    };
    for (const B of ["border", "borderWidth", "borderColor", "borderRadius", "borderStyle"])
      i[B] !== void 0 && (C.attributes.style[B] = i[B], delete i[B]);
    s.children.push(C, A);
  } else
    s.children.push(A);
  for (const a of ["background", "backgroundClip", "top", "left", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "transform", "transformOrigin", "visibility"])
    i[a] !== void 0 && (s.attributes.style[a] = i[a], delete i[a]);
  return s.attributes.style.position = i.position === "absolute" ? "absolute" : "relative", delete i.position, i.alignSelf && (s.attributes.style.alignSelf = i.alignSelf, delete i.alignSelf), s;
}
function kl(e) {
  const A = lA(e.textIndent, "0px");
  if (A >= 0)
    return;
  const i = "padding" + ((e.textAlign === "right" ? "right" : "left") === "left" ? "Left" : "Right"), s = lA(e[i], "0px");
  e[i] = `${s - A}px`;
}
function lo(e, A) {
  switch (e.access) {
    case "nonInteractive":
      A.push("xfaNonInteractive");
      break;
    case "readOnly":
      A.push("xfaReadOnly");
      break;
    case "protected":
      A.push("xfaDisabled");
      break;
  }
}
function Cs(e) {
  return e.relevant.length > 0 && !e.relevant[0].excluded && e.relevant[0].viewname === "print";
}
function Sl(e) {
  const A = e[me]()[Y].paraStack;
  return A.length ? A.at(-1) : null;
}
function Fl(e, A, t) {
  var i;
  if ((i = t.attributes.class) != null && i.includes("xfaRich")) {
    A && (e.h === "" && (A.height = "auto"), e.w === "" && (A.width = "auto"));
    const s = Sl(e);
    if (s) {
      const a = t.attributes.style;
      switch (a.display = "flex", a.flexDirection = "column", s.vAlign) {
        case "top":
          a.justifyContent = "start";
          break;
        case "bottom":
          a.justifyContent = "end";
          break;
        case "middle":
          a.justifyContent = "center";
          break;
      }
      const n = s[VA]();
      for (const [r, g] of Object.entries(n))
        r in a || (a[r] = g);
    }
  }
}
function Rl(e, A, t, i) {
  if (!t) {
    delete i.fontFamily;
    return;
  }
  const s = gr(e.typeface);
  i.fontFamily = `"${s}"`;
  const a = t.find(s);
  if (a) {
    const {
      fontFamily: n
    } = a.regular.cssFontInfo;
    n !== s && (i.fontFamily = `"${n}"`);
    const r = Sl(A);
    if (r && r.lineHeight !== "" || i.lineHeight)
      return;
    const g = oo(e, a);
    g && (i.lineHeight = Math.max(1.2, g.lineHeight));
  }
}
function Gl(e) {
  const A = mn(e, null, {
    addDefaultProtocol: !0,
    tryConvertEncoding: !0
  });
  return A ? A.href : null;
}
function Nl(e, A) {
  return {
    name: "div",
    attributes: {
      class: [e.layout === "lr-tb" ? "xfaLr" : "xfaRl"]
    },
    children: A
  };
}
function Ml(e) {
  if (!e[Y])
    return null;
  const t = {
    name: "div",
    attributes: e[Y].attributes,
    children: e[Y].children
  };
  if (e[Y].failingNode) {
    const i = e[Y].failingNode[ba]();
    i && (e.layout.endsWith("-tb") ? t.children.push(Nl(e, [i])) : t.children.push(i));
  }
  return t.children.length === 0 ? null : t;
}
function Ul(e, A, t) {
  const i = e[Y], s = i.availableSpace, [a, n, r, g] = t;
  switch (e.layout) {
    case "position": {
      i.width = Math.max(i.width, a + r), i.height = Math.max(i.height, n + g), i.children.push(A);
      break;
    }
    case "lr-tb":
    case "rl-tb":
      (!i.line || i.attempt === 1) && (i.line = Nl(e, []), i.children.push(i.line), i.numberInLine = 0), i.numberInLine += 1, i.line.children.push(A), i.attempt === 0 ? (i.currentWidth += r, i.height = Math.max(i.height, i.prevHeight + g)) : (i.currentWidth = r, i.prevHeight = i.height, i.height += g, i.attempt = 0), i.width = Math.max(i.width, i.currentWidth);
      break;
    case "rl-row":
    case "row": {
      i.children.push(A), i.width += r, i.height = Math.max(i.height, g);
      const o = FA(i.height);
      for (const I of i.children)
        I.attributes.style.height = o;
      break;
    }
    case "table": {
      i.width = Math.min(s.width, Math.max(i.width, r)), i.height += g, i.children.push(A);
      break;
    }
    case "tb": {
      i.width = Math.min(s.width, Math.max(i.width, r)), i.height += g, i.children.push(A);
      break;
    }
  }
}
function Ll(e) {
  const A = e[Y].availableSpace, t = e.margin ? e.margin.topInset + e.margin.bottomInset : 0, i = e.margin ? e.margin.leftInset + e.margin.rightInset : 0;
  switch (e.layout) {
    case "lr-tb":
    case "rl-tb":
      return e[Y].attempt === 0 ? {
        width: A.width - i - e[Y].currentWidth,
        height: A.height - t - e[Y].prevHeight
      } : {
        width: A.width - i,
        height: A.height - t - e[Y].height
      };
    case "rl-row":
    case "row":
      return {
        width: e[Y].columnWidths.slice(e[Y].currentColumn).reduce((a, n) => a + n),
        height: A.height - i
      };
    case "table":
    case "tb":
      return {
        width: A.width - i,
        height: A.height - t - e[Y].height
      };
    case "position":
    default:
      return A;
  }
}
function gE(e) {
  let A = e.w === "" ? NaN : e.w, t = e.h === "" ? NaN : e.h, [i, s] = [0, 0];
  switch (e.anchorType || "") {
    case "bottomCenter":
      [i, s] = [A / 2, t];
      break;
    case "bottomLeft":
      [i, s] = [0, t];
      break;
    case "bottomRight":
      [i, s] = [A, t];
      break;
    case "middleCenter":
      [i, s] = [A / 2, t / 2];
      break;
    case "middleLeft":
      [i, s] = [0, t / 2];
      break;
    case "middleRight":
      [i, s] = [A, t / 2];
      break;
    case "topCenter":
      [i, s] = [A / 2, 0];
      break;
    case "topRight":
      [i, s] = [A, 0];
      break;
  }
  let a, n;
  switch (e.rotate || 0) {
    case 0:
      [a, n] = [-i, -s];
      break;
    case 90:
      [a, n] = [-s, i], [A, t] = [t, -A];
      break;
    case 180:
      [a, n] = [i, s], [A, t] = [-A, -t];
      break;
    case 270:
      [a, n] = [s, -i], [A, t] = [-t, A];
      break;
  }
  return [e.x + a + Math.min(0, A), e.y + n + Math.min(0, t), Math.abs(A), Math.abs(t)];
}
function cr(e, A) {
  var g;
  if (e[me]()[Y].firstUnsplittable === null || e.w === 0 || e.h === 0)
    return !0;
  const t = 2, i = e[ye](), s = ((g = i[Y]) == null ? void 0 : g.attempt) || 0, [, a, n, r] = gE(e);
  switch (i.layout) {
    case "lr-tb":
    case "rl-tb":
      return s === 0 ? e[me]()[Y].noLayoutFailure ? e.w !== "" ? Math.round(n - A.width) <= t : A.width > t : e.h !== "" && Math.round(r - A.height) > t ? !1 : e.w !== "" ? Math.round(n - A.width) <= t ? !0 : i[Y].numberInLine === 0 ? A.height > t : !1 : A.width > t : e[me]()[Y].noLayoutFailure ? !0 : e.h !== "" && Math.round(r - A.height) > t ? !1 : e.w === "" || Math.round(n - A.width) <= t ? A.height > t : i[pi]() ? !1 : A.height > t;
    case "table":
    case "tb":
      return e[me]()[Y].noLayoutFailure ? !0 : e.h !== "" && !e[fi]() ? Math.round(r - A.height) <= t : e.w === "" || Math.round(n - A.width) <= t ? A.height > t : i[pi]() ? !1 : A.height > t;
    case "position":
      if (e[me]()[Y].noLayoutFailure || e.h === "" || Math.round(r + a - A.height) <= t)
        return !0;
      const o = e[me]()[Y].currentContentArea;
      return r + a > o.h;
    case "rl-row":
    case "row":
      return e[me]()[Y].noLayoutFailure ? !0 : e.h !== "" ? Math.round(r - A.height) <= t : !0;
    default:
      return !0;
  }
}
const eA = we.template.id, C0 = "http://www.w3.org/2000/svg", Nn = 2, oE = 3, IE = 5e3, cE = /^H(\d+)$/, lE = /* @__PURE__ */ new Set(["image/gif", "image/jpeg", "image/jpg", "image/pjpeg", "image/png", "image/apng", "image/x-png", "image/bmp", "image/x-ms-bmp", "image/tiff", "image/tif", "application/octet-stream"]), hE = [[[66, 77], "image/bmp"], [[255, 216, 255], "image/jpeg"], [[73, 73, 42, 0], "image/tiff"], [[77, 77, 0, 42], "image/tiff"], [[71, 73, 70, 56, 57, 97], "image/gif"], [[137, 80, 78, 71, 13, 10, 26, 10], "image/png"]];
function _I(e) {
  if (!e || !e.border)
    return {
      w: 0,
      h: 0
    };
  const A = e.border[Oe]();
  return A ? {
    w: A.widths[0] + A.widths[2] + A.insets[0] + A.insets[2],
    h: A.widths[1] + A.widths[3] + A.insets[1] + A.insets[3]
  } : {
    w: 0,
    h: 0
  };
}
function ho(e) {
  return e.margin && (e.margin.topInset || e.margin.rightInset || e.margin.bottomInset || e.margin.leftInset);
}
function Co(e, A) {
  if (!e.value) {
    const t = new mo({});
    e[Be](t), e.value = t;
  }
  e.value[Bt](A);
}
function* Bo(e) {
  for (const A of e[He]()) {
    if (A instanceof fo) {
      yield* A[rs]();
      continue;
    }
    yield A;
  }
}
function Da(e) {
  var A;
  return ((A = e.validate) == null ? void 0 : A.nullTest) === "error";
}
function lr(e) {
  for (; e; ) {
    if (!e.traversal) {
      e[Tt] = e[MA]()[Tt];
      return;
    }
    if (e[Tt])
      return;
    let A = null;
    for (const s of e.traversal[He]())
      if (s.operation === "next") {
        A = s;
        break;
      }
    if (!A || !A.ref) {
      e[Tt] = e[MA]()[Tt];
      return;
    }
    const t = e[me]();
    e[Tt] = ++t[Tt];
    const i = t[Bi](A.ref, e);
    if (!i)
      return;
    e = i[0];
  }
}
function hr(e, A) {
  var i;
  const t = e.assist;
  if (t) {
    const s = t[SA]();
    s && (A.title = s);
    const n = t.role.match(cE);
    if (n) {
      const r = "heading", g = n[1];
      A.role = r, A["aria-level"] = g;
    }
  }
  if (e.layout === "table")
    A.role = "table";
  else if (e.layout === "row")
    A.role = "row";
  else {
    const s = e[MA]();
    s.layout === "row" && (A.role = ((i = s.assist) == null ? void 0 : i.role) === "TH" ? "columnheader" : "cell");
  }
}
function E0(e) {
  if (!e.assist)
    return null;
  const A = e.assist;
  return A.speak && A.speak[P] !== "" ? A.speak[P] : A.toolTip ? A.toolTip[P] : null;
}
function Oi(e) {
  return dA.success({
    name: "div",
    attributes: {
      class: ["xfaRich"],
      style: /* @__PURE__ */ Object.create(null)
    },
    children: [{
      name: "span",
      attributes: {
        style: /* @__PURE__ */ Object.create(null)
      },
      value: e
    }]
  });
}
function Cr(e) {
  const A = e[me]();
  A[Y].firstUnsplittable === null && (A[Y].firstUnsplittable = e, A[Y].noLayoutFailure = !0);
}
function Br(e) {
  const A = e[me]();
  A[Y].firstUnsplittable === e && (A[Y].noLayoutFailure = !1);
}
function zI(e) {
  if (e[Y] || (e[Y] = /* @__PURE__ */ Object.create(null), e.targetType === "auto"))
    return !1;
  const A = e[me]();
  let t = null;
  if (e.target) {
    if (t = A[Bi](e.target, e[MA]()), !t)
      return !1;
    t = t[0];
  }
  const {
    currentPageArea: i,
    currentContentArea: s
  } = A[Y];
  if (e.targetType === "pageArea")
    return t instanceof gs || (t = null), e.startNew ? (e[Y].target = t || i, !0) : t && t !== i ? (e[Y].target = t, !0) : !1;
  t instanceof Qo || (t = null);
  const a = t && t[MA]();
  let n, r = a;
  if (e.startNew)
    if (t) {
      const g = a.contentArea.children, o = g.indexOf(s), I = g.indexOf(t);
      o !== -1 && o < I && (r = null), n = I - 1;
    } else
      n = i.contentArea.children.indexOf(s);
  else if (t && t !== s)
    n = a.contentArea.children.indexOf(t) - 1, r = a === i ? null : a;
  else
    return !1;
  return e[Y].target = r, e[Y].index = n, !0;
}
function $I(e, A, t) {
  const i = e[me](), s = i[Y].noLayoutFailure, a = A[ye];
  A[ye] = () => e, i[Y].noLayoutFailure = !0;
  const n = A[SA](t);
  e[c0](n.html, n.bbox), i[Y].noLayoutFailure = s, A[ye] = a;
}
class CE extends TA {
  constructor(A) {
    super(eA, "appearanceFilter"), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Hl extends K {
  constructor(A) {
    super(eA, "arc", !0), this.circular = RA({
      data: A.circular,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.hand = O(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.startAngle = Gn({
      data: A.startAngle,
      defaultValue: 0,
      validate: (t) => !0
    }), this.sweepAngle = Gn({
      data: A.sweepAngle,
      defaultValue: 360,
      validate: (t) => !0
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.edge = null, this.fill = null;
  }
  [SA]() {
    var g;
    const A = this.edge || new ka({}), t = A[VA](), i = /* @__PURE__ */ Object.create(null);
    ((g = this.fill) == null ? void 0 : g.presence) === "visible" ? Object.assign(i, this.fill[VA]()) : i.fill = "transparent", i.strokeWidth = FA(A.presence === "visible" ? A.thickness : 0), i.stroke = t.color;
    let s;
    const a = {
      xmlns: C0,
      style: {
        width: "100%",
        height: "100%",
        overflow: "visible"
      }
    };
    if (this.sweepAngle === 360)
      s = {
        name: "ellipse",
        attributes: {
          xmlns: C0,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style: i
        }
      };
    else {
      const o = this.startAngle * Math.PI / 180, I = this.sweepAngle * Math.PI / 180, c = this.sweepAngle > 180 ? 1 : 0, [l, h, C, B] = [50 * (1 + Math.cos(o)), 50 * (1 - Math.sin(o)), 50 * (1 + Math.cos(o + I)), 50 * (1 - Math.sin(o + I))];
      s = {
        name: "path",
        attributes: {
          xmlns: C0,
          d: `M ${l} ${h} A 50 50 0 ${c} 0 ${C} ${B}`,
          vectorEffect: "non-scaling-stroke",
          style: i
        }
      }, Object.assign(a, {
        viewBox: "0 0 100 100",
        preserveAspectRatio: "none"
      });
    }
    const n = {
      name: "svg",
      children: [s],
      attributes: a
    }, r = this[MA]()[MA]();
    return ho(r) ? dA.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [n]
    }) : (n.attributes.style.position = "absolute", dA.success(n));
  }
}
class BE extends K {
  constructor(A) {
    super(eA, "area", !0), this.colSpan = RA({
      data: A.colSpan,
      defaultValue: 1,
      validate: (t) => t >= 1 || t === -1
    }), this.id = A.id || "", this.name = A.name || "", this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.desc = null, this.extras = null, this.area = new b(), this.draw = new b(), this.exObject = new b(), this.exclGroup = new b(), this.field = new b(), this.subform = new b(), this.subformSet = new b();
  }
  *[rs]() {
    yield* Bo(this);
  }
  [aa]() {
    return !0;
  }
  [u0]() {
    return !0;
  }
  [c0](A, t) {
    const [i, s, a, n] = t;
    this[Y].width = Math.max(this[Y].width, i + a), this[Y].height = Math.max(this[Y].height, s + n), this[Y].children.push(A);
  }
  [l0]() {
    return this[Y].availableSpace;
  }
  [SA](A) {
    const t = nt(this, "position"), i = {
      style: t,
      id: this[ee],
      class: ["xfaArea"]
    };
    Cs(this) && i.class.push("xfaPrintOnly"), this.name && (i.xfaName = this.name);
    const s = [];
    this[Y] = {
      children: s,
      width: 0,
      height: 0,
      availableSpace: A
    };
    const a = this[Wi]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "exclGroup", "subform", "subformSet"]),
      include: !0
    });
    if (!a.success)
      return a.isBreak() ? a : (delete this[Y], dA.FAILURE);
    t.width = FA(this[Y].width), t.height = FA(this[Y].height);
    const n = {
      name: "div",
      attributes: i,
      children: s
    }, r = [this.x, this.y, this[Y].width, this[Y].height];
    return delete this[Y], dA.success(n, r);
  }
}
class QE extends K {
  constructor(A) {
    super(eA, "assist", !0), this.id = A.id || "", this.role = A.role || "", this.use = A.use || "", this.usehref = A.usehref || "", this.speak = null, this.toolTip = null;
  }
  [SA]() {
    var A;
    return ((A = this.toolTip) == null ? void 0 : A[P]) || null;
  }
}
class EE extends K {
  constructor(A) {
    super(eA, "barcode", !0), this.charEncoding = or({
      data: A.charEncoding ? A.charEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (t) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(t) || t.match(/iso-8859-\d{2}/)
    }), this.checksum = O(A.checksum, ["none", "1mod10", "1mod10_1mod11", "2mod10", "auto"]), this.dataColumnCount = RA({
      data: A.dataColumnCount,
      defaultValue: -1,
      validate: (t) => t >= 0
    }), this.dataLength = RA({
      data: A.dataLength,
      defaultValue: -1,
      validate: (t) => t >= 0
    }), this.dataPrep = O(A.dataPrep, ["none", "flateCompress"]), this.dataRowCount = RA({
      data: A.dataRowCount,
      defaultValue: -1,
      validate: (t) => t >= 0
    }), this.endChar = A.endChar || "", this.errorCorrectionLevel = RA({
      data: A.errorCorrectionLevel,
      defaultValue: -1,
      validate: (t) => t >= 0 && t <= 8
    }), this.id = A.id || "", this.moduleHeight = lA(A.moduleHeight, "5mm"), this.moduleWidth = lA(A.moduleWidth, "0.25mm"), this.printCheckDigit = RA({
      data: A.printCheckDigit,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.rowColumnRatio = qI(A.rowColumnRatio), this.startChar = A.startChar || "", this.textLocation = O(A.textLocation, ["below", "above", "aboveEmbedded", "belowEmbedded", "none"]), this.truncate = RA({
      data: A.truncate,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.type = O(A.type ? A.type.toLowerCase() : "", ["aztec", "codabar", "code2of5industrial", "code2of5interleaved", "code2of5matrix", "code2of5standard", "code3of9", "code3of9extended", "code11", "code49", "code93", "code128", "code128a", "code128b", "code128c", "code128sscc", "datamatrix", "ean8", "ean8add2", "ean8add5", "ean13", "ean13add2", "ean13add5", "ean13pwcd", "fim", "logmars", "maxicode", "msi", "pdf417", "pdf417macro", "plessey", "postauscust2", "postauscust3", "postausreplypaid", "postausstandard", "postukrm4scc", "postusdpbc", "postusimb", "postusstandard", "postus5zip", "qrcode", "rfid", "rss14", "rss14expanded", "rss14limited", "rss14stacked", "rss14stackedomni", "rss14truncated", "telepen", "ucc128", "ucc128random", "ucc128sscc", "upca", "upcaadd2", "upcaadd5", "upcapwcd", "upce", "upceadd2", "upceadd5", "upcean2", "upcean5", "upsmaxicode"]), this.upsMode = O(A.upsMode, ["usCarrier", "internationalCarrier", "secureSymbol", "standardSymbol"]), this.use = A.use || "", this.usehref = A.usehref || "", this.wideNarrowRatio = qI(A.wideNarrowRatio), this.encrypt = null, this.extras = null;
  }
}
class fE extends K {
  constructor(A) {
    super(eA, "bind", !0), this.match = O(A.match, ["once", "dataRef", "global", "none"]), this.ref = A.ref || "", this.picture = null;
  }
}
class Gg extends K {
  constructor(A) {
    super(eA, "bindItems"), this.connection = A.connection || "", this.labelRef = A.labelRef || "", this.ref = A.ref || "", this.valueRef = A.valueRef || "";
  }
}
class uE extends K {
  constructor(A) {
    super(eA, "bookend"), this.id = A.id || "", this.leader = A.leader || "", this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class dE extends Fe {
  constructor(A) {
    super(eA, "boolean"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [SA](A) {
    return Oi(this[P] === 1 ? "1" : "0");
  }
}
class Jl extends K {
  constructor(A) {
    super(eA, "border", !0), this.break = O(A.break, ["close", "open"]), this.hand = O(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.corner = new b(4), this.edge = new b(4), this.extras = null, this.fill = null, this.margin = null;
  }
  [Oe]() {
    if (!this[Y]) {
      const A = this.edge.children.slice();
      if (A.length < 4) {
        const s = A.at(-1) || new ka({});
        for (let a = A.length; a < 4; a++)
          A.push(s);
      }
      const t = A.map((s) => s.thickness), i = [0, 0, 0, 0];
      this.margin && (i[0] = this.margin.topInset, i[1] = this.margin.rightInset, i[2] = this.margin.bottomInset, i[3] = this.margin.leftInset), this[Y] = {
        widths: t,
        insets: i,
        edges: A
      };
    }
    return this[Y];
  }
  [VA]() {
    var s;
    const {
      edges: A
    } = this[Oe](), t = A.map((a) => {
      const n = a[VA]();
      return n.color || (n.color = "#000000"), n;
    }), i = /* @__PURE__ */ Object.create(null);
    if (this.margin && Object.assign(i, this.margin[VA]()), ((s = this.fill) == null ? void 0 : s.presence) === "visible" && Object.assign(i, this.fill[VA]()), this.corner.children.some((a) => a.radius !== 0)) {
      const a = this.corner.children.map((n) => n[VA]());
      if (a.length === 2 || a.length === 3) {
        const n = a.at(-1);
        for (let r = a.length; r < 4; r++)
          a.push(n);
      }
      i.borderRadius = a.map((n) => n.radius).join(" ");
    }
    switch (this.presence) {
      case "invisible":
      case "hidden":
        i.borderStyle = "";
        break;
      case "inactive":
        i.borderStyle = "none";
        break;
      default:
        i.borderStyle = t.map((a) => a.style).join(" ");
        break;
    }
    return i.borderWidth = t.map((a) => a.width).join(" "), i.borderColor = t.map((a) => a.color).join(" "), i;
  }
}
class xE extends K {
  constructor(A) {
    super(eA, "break", !0), this.after = O(A.after, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.afterTarget = A.afterTarget || "", this.before = O(A.before, ["auto", "contentArea", "pageArea", "pageEven", "pageOdd"]), this.beforeTarget = A.beforeTarget || "", this.bookendLeader = A.bookendLeader || "", this.bookendTrailer = A.bookendTrailer || "", this.id = A.id || "", this.overflowLeader = A.overflowLeader || "", this.overflowTarget = A.overflowTarget || "", this.overflowTrailer = A.overflowTrailer || "", this.startNew = RA({
      data: A.startNew,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class Yl extends K {
  constructor(A) {
    super(eA, "breakAfter", !0), this.id = A.id || "", this.leader = A.leader || "", this.startNew = RA({
      data: A.startNew,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.target = A.target || "", this.targetType = O(A.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "", this.script = null;
  }
}
class Kl extends K {
  constructor(A) {
    super(eA, "breakBefore", !0), this.id = A.id || "", this.leader = A.leader || "", this.startNew = RA({
      data: A.startNew,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.target = A.target || "", this.targetType = O(A.targetType, ["auto", "contentArea", "pageArea"]), this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "", this.script = null;
  }
  [SA](A) {
    return this[Y] = {}, dA.FAILURE;
  }
}
class mE extends K {
  constructor(A) {
    super(eA, "button", !0), this.highlight = O(A.highlight, ["inverted", "none", "outline", "push"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [SA](A) {
    const i = this[MA]()[MA](), s = {
      name: "button",
      attributes: {
        id: this[ee],
        class: ["xfaButton"],
        style: {}
      },
      children: []
    };
    for (const a of i.event.children) {
      if (a.activity !== "click" || !a.script)
        continue;
      const n = mc(a.script[P]);
      if (!n)
        continue;
      const r = Gl(n.url);
      r && s.children.push({
        name: "a",
        attributes: {
          id: "link" + this[ee],
          href: r,
          newWindow: n.newWindow,
          class: ["xfaLink"],
          style: {}
        },
        children: []
      });
    }
    return dA.success(s);
  }
}
class pE extends K {
  constructor(A) {
    super(eA, "calculate", !0), this.id = A.id || "", this.override = O(A.override, ["disabled", "error", "ignore", "warning"]), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.message = null, this.script = null;
  }
}
class yE extends K {
  constructor(A) {
    super(eA, "caption", !0), this.id = A.id || "", this.placement = O(A.placement, ["left", "bottom", "inline", "right", "top"]), this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.reserve = Math.ceil(lA(A.reserve)), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.font = null, this.margin = null, this.para = null, this.value = null;
  }
  [Bt](A) {
    Co(this, A);
  }
  [Oe](A) {
    if (!this[Y]) {
      let {
        width: t,
        height: i
      } = A;
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          t = this.reserve <= 0 ? t : this.reserve;
          break;
        case "top":
        case "bottom":
          i = this.reserve <= 0 ? i : this.reserve;
          break;
      }
      this[Y] = co(this, {
        width: t
      });
    }
    return this[Y];
  }
  [SA](A) {
    if (!this.value)
      return dA.EMPTY;
    this[hs]();
    const t = this.value[SA](A).html;
    if (!t)
      return this[It](), dA.EMPTY;
    const i = this.reserve;
    if (this.reserve <= 0) {
      const {
        w: n,
        h: r
      } = this[Oe](A);
      switch (this.placement) {
        case "left":
        case "right":
        case "inline":
          this.reserve = n;
          break;
        case "top":
        case "bottom":
          this.reserve = r;
          break;
      }
    }
    const s = [];
    typeof t == "string" ? s.push({
      name: "#text",
      value: t
    }) : s.push(t);
    const a = nt(this, "font", "margin", "visibility");
    switch (this.placement) {
      case "left":
      case "right":
        this.reserve > 0 && (a.width = FA(this.reserve));
        break;
      case "top":
      case "bottom":
        this.reserve > 0 && (a.height = FA(this.reserve));
        break;
    }
    return Fl(this, null, t), this[It](), this.reserve = i, dA.success({
      name: "div",
      attributes: {
        style: a,
        class: ["xfaCaption"]
      },
      children: s
    });
  }
}
class wE extends TA {
  constructor(A) {
    super(eA, "certificate"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class bE extends K {
  constructor(A) {
    super(eA, "certificates", !0), this.credentialServerPolicy = O(A.credentialServerPolicy, ["optional", "required"]), this.id = A.id || "", this.url = A.url || "", this.urlPolicy = A.urlPolicy || "", this.use = A.use || "", this.usehref = A.usehref || "", this.encryption = null, this.issuers = null, this.keyUsage = null, this.oids = null, this.signing = null, this.subjectDNs = null;
  }
}
class vl extends K {
  constructor(A) {
    super(eA, "checkButton", !0), this.id = A.id || "", this.mark = O(A.mark, ["default", "check", "circle", "cross", "diamond", "square", "star"]), this.shape = O(A.shape, ["square", "round"]), this.size = lA(A.size, "10pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    var Q, E, f;
    const t = nt("margin"), i = FA(this.size);
    t.width = t.height = i;
    let s, a, n;
    const r = this[MA]()[MA](), g = r.items.children.length && r.items.children[0][SA]().html || [], o = {
      on: (g[0] !== void 0 ? g[0] : "on").toString(),
      off: (g[1] !== void 0 ? g[1] : "off").toString()
    }, c = (((Q = r.value) == null ? void 0 : Q[Se]()) || "off") === o.on || void 0, l = r[ye](), h = r[ee];
    let C;
    l instanceof Wl ? (n = l[ee], s = "radio", a = "xfaRadio", C = ((E = l[Mt]) == null ? void 0 : E[ee]) || l[ee]) : (s = "checkbox", a = "xfaCheckbox", C = ((f = r[Mt]) == null ? void 0 : f[ee]) || r[ee]);
    const B = {
      name: "input",
      attributes: {
        class: [a],
        style: t,
        fieldId: h,
        dataId: C,
        type: s,
        checked: c,
        xfaOn: o.on,
        xfaOff: o.off,
        "aria-label": E0(r),
        "aria-required": !1
      }
    };
    return n && (B.attributes.name = n), Da(r) && (B.attributes["aria-required"] = !0, B.attributes.required = !0), dA.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [B]
    });
  }
}
class Tl extends K {
  constructor(A) {
    super(eA, "choiceList", !0), this.commitOn = O(A.commitOn, ["select", "exit"]), this.id = A.id || "", this.open = O(A.open, ["userControl", "always", "multiSelect", "onEntry"]), this.textEntry = RA({
      data: A.textEntry,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    var o, I, c;
    const t = nt(this, "border", "margin"), s = this[MA]()[MA](), n = {
      fontSize: `calc(${((o = s.font) == null ? void 0 : o.size) || 10}px * var(--scale-factor))`
    }, r = [];
    if (s.items.children.length > 0) {
      const l = s.items;
      let h = 0, C = 0;
      l.children.length === 2 && (h = l.children[0].save, C = 1 - h);
      const B = l.children[h][SA]().html, Q = l.children[C][SA]().html;
      let E = !1;
      const f = ((I = s.value) == null ? void 0 : I[Se]()) || "";
      for (let d = 0, u = B.length; d < u; d++) {
        const x = {
          name: "option",
          attributes: {
            value: Q[d] || B[d],
            style: n
          },
          value: B[d]
        };
        Q[d] === f && (x.attributes.selected = E = !0), r.push(x);
      }
      E || r.splice(0, 0, {
        name: "option",
        attributes: {
          hidden: !0,
          selected: !0
        },
        value: " "
      });
    }
    const g = {
      class: ["xfaSelect"],
      fieldId: s[ee],
      dataId: ((c = s[Mt]) == null ? void 0 : c[ee]) || s[ee],
      style: t,
      "aria-label": E0(s),
      "aria-required": !1
    };
    return Da(s) && (g["aria-required"] = !0, g.required = !0), this.open === "multiSelect" && (g.multiple = !0), dA.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [{
        name: "select",
        children: r,
        attributes: g
      }]
    });
  }
}
class DE extends K {
  constructor(A) {
    super(eA, "color", !0), this.cSpace = O(A.cSpace, ["SRGB"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.value = A.value ? z1(A.value) : "", this.extras = null;
  }
  [sa]() {
    return !1;
  }
  [VA]() {
    return this.value ? de.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
  }
}
class kE extends K {
  constructor(A) {
    super(eA, "comb"), this.id = A.id || "", this.numberOfCells = RA({
      data: A.numberOfCells,
      defaultValue: 0,
      validate: (t) => t >= 0
    }), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class SE extends K {
  constructor(A) {
    super(eA, "connect", !0), this.connection = A.connection || "", this.id = A.id || "", this.ref = A.ref || "", this.usage = O(A.usage, ["exportAndImport", "exportOnly", "importOnly"]), this.use = A.use || "", this.usehref = A.usehref || "", this.picture = null;
  }
}
class Qo extends K {
  constructor(A) {
    super(eA, "contentArea", !0), this.h = lA(A.h), this.id = A.id || "", this.name = A.name || "", this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.w = lA(A.w), this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.desc = null, this.extras = null;
  }
  [SA](A) {
    const t = FA(this.x), i = FA(this.y), s = {
      left: t,
      top: i,
      width: FA(this.w),
      height: FA(this.h)
    }, a = ["xfaContentarea"];
    return Cs(this) && a.push("xfaPrintOnly"), dA.success({
      name: "div",
      children: [],
      attributes: {
        style: s,
        class: a,
        id: this[ee]
      }
    });
  }
}
class ql extends K {
  constructor(A) {
    super(eA, "corner", !0), this.id = A.id || "", this.inverted = RA({
      data: A.inverted,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.join = O(A.join, ["square", "round"]), this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.radius = lA(A.radius), this.stroke = O(A.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = lA(A.thickness, "0.5pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA]() {
    const A = nt(this, "visibility");
    return A.radius = FA(this.join === "square" ? 0 : this.radius), A;
  }
}
class FE extends Ee {
  constructor(A) {
    super(eA, "date"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = this[P].trim();
    this[P] = A ? new Date(A) : null;
  }
  [SA](A) {
    return Oi(this[P] ? this[P].toString() : "");
  }
}
class RE extends Ee {
  constructor(A) {
    super(eA, "dateTime"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = this[P].trim();
    this[P] = A ? new Date(A) : null;
  }
  [SA](A) {
    return Oi(this[P] ? this[P].toString() : "");
  }
}
class GE extends K {
  constructor(A) {
    super(eA, "dateTimeEdit", !0), this.hScrollPolicy = O(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.picker = O(A.picker, ["host", "none"]), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    var a;
    const t = nt(this, "border", "font", "margin"), i = this[MA]()[MA](), s = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: i[ee],
        dataId: ((a = i[Mt]) == null ? void 0 : a[ee]) || i[ee],
        class: ["xfaTextfield"],
        style: t,
        "aria-label": E0(i),
        "aria-required": !1
      }
    };
    return Da(i) && (s.attributes["aria-required"] = !0, s.attributes.required = !0), dA.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [s]
    });
  }
}
class NE extends Ee {
  constructor(A) {
    super(eA, "decimal"), this.fracDigits = RA({
      data: A.fracDigits,
      defaultValue: 2,
      validate: (t) => !0
    }), this.id = A.id || "", this.leadDigits = RA({
      data: A.leadDigits,
      defaultValue: -1,
      validate: (t) => !0
    }), this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = parseFloat(this[P].trim());
    this[P] = isNaN(A) ? null : A;
  }
  [SA](A) {
    return Oi(this[P] !== null ? this[P].toString() : "");
  }
}
class ME extends K {
  constructor(A) {
    super(eA, "defaultUi", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class UE extends K {
  constructor(A) {
    super(eA, "desc", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new b(), this.date = new b(), this.dateTime = new b(), this.decimal = new b(), this.exData = new b(), this.float = new b(), this.image = new b(), this.integer = new b(), this.text = new b(), this.time = new b();
  }
}
class LE extends te {
  constructor(A) {
    super(eA, "digestMethod", ["", "SHA1", "SHA256", "SHA512", "RIPEMD160"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class HE extends K {
  constructor(A) {
    super(eA, "digestMethods", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.digestMethod = new b();
  }
}
class Pl extends K {
  constructor(A) {
    super(eA, "draw", !0), this.anchorType = O(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = RA({
      data: A.colSpan,
      defaultValue: 1,
      validate: (t) => t >= 1 || t === -1
    }), this.h = A.h ? lA(A.h) : "", this.hAlign = O(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.locale = A.locale || "", this.maxH = lA(A.maxH, "0pt"), this.maxW = lA(A.maxW, "0pt"), this.minH = lA(A.minH, "0pt"), this.minW = lA(A.minW, "0pt"), this.name = A.name || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Zt(A.relevant), this.rotate = RA({
      data: A.rotate,
      defaultValue: 0,
      validate: (t) => t % 90 === 0
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? lA(A.w) : "", this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.assist = null, this.border = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.value = null, this.setProperty = new b();
  }
  [Bt](A) {
    Co(this, A);
  }
  [SA](A) {
    if (lr(this), this.presence === "hidden" || this.presence === "inactive")
      return dA.EMPTY;
    Ir(this), this[hs]();
    const t = this.w, i = this.h, {
      w: s,
      h: a,
      isBroken: n
    } = co(this, A);
    if (s && this.w === "") {
      if (n && this[ye]()[pi]())
        return this[It](), dA.FAILURE;
      this.w = s;
    }
    if (a && this.h === "" && (this.h = a), Cr(this), !cr(this, A))
      return this.w = t, this.h = i, this[It](), dA.FAILURE;
    Br(this);
    const r = nt(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
    wl(this, r), r.margin && (r.padding = r.margin, delete r.margin);
    const g = ["xfaDraw"];
    this.font && g.push("xfaFont"), Cs(this) && g.push("xfaPrintOnly");
    const o = {
      style: r,
      id: this[ee],
      class: g
    };
    this.name && (o.xfaName = this.name);
    const I = {
      name: "div",
      attributes: o,
      children: []
    };
    hr(this, o);
    const c = bl(this, I, A), l = this.value ? this.value[SA](A).html : null;
    return l === null ? (this.w = t, this.h = i, this[It](), dA.success(h0(this, I), c)) : (I.children.push(l), Fl(this, r, l), this.w = t, this.h = i, this[It](), dA.success(h0(this, I), c));
  }
}
class ka extends K {
  constructor(A) {
    super(eA, "edge", !0), this.cap = O(A.cap, ["square", "butt", "round"]), this.id = A.id || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.stroke = O(A.stroke, ["solid", "dashDot", "dashDotDot", "dashed", "dotted", "embossed", "etched", "lowered", "raised"]), this.thickness = lA(A.thickness, "0.5pt"), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA]() {
    const A = nt(this, "visibility");
    if (Object.assign(A, {
      linecap: this.cap,
      width: FA(this.thickness),
      color: this.color ? this.color[VA]() : "#000000",
      style: ""
    }), this.presence !== "visible")
      A.style = "none";
    else
      switch (this.stroke) {
        case "solid":
          A.style = "solid";
          break;
        case "dashDot":
          A.style = "dashed";
          break;
        case "dashDotDot":
          A.style = "dashed";
          break;
        case "dashed":
          A.style = "dashed";
          break;
        case "dotted":
          A.style = "dotted";
          break;
        case "embossed":
          A.style = "ridge";
          break;
        case "etched":
          A.style = "groove";
          break;
        case "lowered":
          A.style = "inset";
          break;
        case "raised":
          A.style = "outset";
          break;
      }
    return A;
  }
}
class JE extends te {
  constructor(A) {
    super(eA, "encoding", ["adbe.x509.rsa_sha1", "adbe.pkcs7.detached", "adbe.pkcs7.sha1"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class YE extends K {
  constructor(A) {
    super(eA, "encodings", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.encoding = new b();
  }
}
class KE extends K {
  constructor(A) {
    super(eA, "encrypt", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = null;
  }
}
class vE extends K {
  constructor(A) {
    super(eA, "encryptData", !0), this.id = A.id || "", this.operation = O(A.operation, ["encrypt", "decrypt"]), this.target = A.target || "", this.use = A.use || "", this.usehref = A.usehref || "", this.filter = null, this.manifest = null;
  }
}
class TE extends K {
  constructor(A) {
    super(eA, "encryption", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new b();
  }
}
class qE extends te {
  constructor(A) {
    super(eA, "encryptionMethod", ["", "AES256-CBC", "TRIPLEDES-CBC", "AES128-CBC", "AES192-CBC"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class PE extends K {
  constructor(A) {
    super(eA, "encryptionMethods", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.encryptionMethod = new b();
  }
}
class WE extends K {
  constructor(A) {
    super(eA, "event", !0), this.activity = O(A.activity, ["click", "change", "docClose", "docReady", "enter", "exit", "full", "indexChange", "initialize", "mouseDown", "mouseEnter", "mouseExit", "mouseUp", "postExecute", "postOpen", "postPrint", "postSave", "postSign", "postSubmit", "preExecute", "preOpen", "prePrint", "preSave", "preSign", "preSubmit", "ready", "validationState"]), this.id = A.id || "", this.listen = O(A.listen, ["refOnly", "refAndDescendents"]), this.name = A.name || "", this.ref = A.ref || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.encryptData = null, this.execute = null, this.script = null, this.signData = null, this.submit = null;
  }
}
class OE extends Ee {
  constructor(A) {
    super(eA, "exData"), this.contentType = A.contentType || "", this.href = A.href || "", this.id = A.id || "", this.maxLength = RA({
      data: A.maxLength,
      defaultValue: -1,
      validate: (t) => t >= -1
    }), this.name = A.name || "", this.rid = A.rid || "", this.transferEncoding = O(A.transferEncoding, ["none", "base64", "package"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [go]() {
    return this.contentType === "text/html";
  }
  [si](A) {
    return this.contentType === "text/html" && A[pe] === we.xhtml.id ? (this[P] = A, !0) : this.contentType === "text/xml" ? (this[P] = A, !0) : !1;
  }
  [SA](A) {
    return this.contentType !== "text/html" || !this[P] ? dA.EMPTY : this[P][SA](A);
  }
}
class VE extends K {
  constructor(A) {
    super(eA, "exObject", !0), this.archive = A.archive || "", this.classId = A.classId || "", this.codeBase = A.codeBase || "", this.codeType = A.codeType || "", this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.boolean = new b(), this.date = new b(), this.dateTime = new b(), this.decimal = new b(), this.exData = new b(), this.exObject = new b(), this.float = new b(), this.image = new b(), this.integer = new b(), this.text = new b(), this.time = new b();
  }
}
class Wl extends K {
  constructor(A) {
    super(eA, "exclGroup", !0), this.access = O(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = A.accessKey || "", this.anchorType = O(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = RA({
      data: A.colSpan,
      defaultValue: 1,
      validate: (t) => t >= 1 || t === -1
    }), this.h = A.h ? lA(A.h) : "", this.hAlign = O(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.layout = O(A.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.maxH = lA(A.maxH, "0pt"), this.maxW = lA(A.maxW, "0pt"), this.minH = lA(A.minH, "0pt"), this.minW = lA(A.minW, "0pt"), this.name = A.name || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? lA(A.w) : "", this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.margin = null, this.para = null, this.traversal = null, this.validate = null, this.connect = new b(), this.event = new b(), this.field = new b(), this.setProperty = new b();
  }
  [u0]() {
    return !0;
  }
  [sa]() {
    return !0;
  }
  [Bt](A) {
    for (const t of this.field.children) {
      if (!t.value) {
        const i = new mo({});
        t[Be](i), t.value = i;
      }
      t.value[Bt](A);
    }
  }
  [pi]() {
    return this.layout.endsWith("-tb") && this[Y].attempt === 0 && this[Y].numberInLine > 0 || this[MA]()[pi]();
  }
  [fi]() {
    var t;
    const A = this[ye]();
    return A[fi]() ? this[Y]._isSplittable !== void 0 ? this[Y]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[Y]._isSplittable = !1, !1) : (t = A.layout) != null && t.endsWith("-tb") && A[Y].numberInLine !== 0 ? !1 : (this[Y]._isSplittable = !0, !0) : !1;
  }
  [ba]() {
    return Ml(this);
  }
  [c0](A, t) {
    Ul(this, A, t);
  }
  [l0]() {
    return Ll(this);
  }
  [SA](A) {
    if (lr(this), this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
      return dA.EMPTY;
    Ir(this);
    const t = [], i = {
      id: this[ee],
      class: []
    };
    lo(this, i.class), this[Y] || (this[Y] = /* @__PURE__ */ Object.create(null)), Object.assign(this[Y], {
      children: t,
      attributes: i,
      attempt: 0,
      line: null,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || 1 / 0, A.width),
        height: Math.min(this.h || 1 / 0, A.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const s = this[fi]();
    if (s || Cr(this), !cr(this, A))
      return dA.FAILURE;
    const a = /* @__PURE__ */ new Set(["field"]);
    if (this.layout.includes("row")) {
      const E = this[ye]().columnWidths;
      Array.isArray(E) && E.length > 0 && (this[Y].columnWidths = E, this[Y].currentColumn = 0);
    }
    const n = nt(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), r = ["xfaExclgroup"], g = Dl(this);
    g && r.push(g), Cs(this) && r.push("xfaPrintOnly"), i.style = n, i.class = r, this.name && (i.xfaName = this.name), this[hs]();
    const o = this.layout === "lr-tb" || this.layout === "rl-tb", I = o ? Nn : 1;
    for (; this[Y].attempt < I; this[Y].attempt++) {
      o && this[Y].attempt === Nn - 1 && (this[Y].numberInLine = 0);
      const E = this[Wi]({
        filter: a,
        include: !0
      });
      if (E.success)
        break;
      if (E.isBreak())
        return this[It](), E;
      if (o && this[Y].attempt === 0 && this[Y].numberInLine === 0 && !this[me]()[Y].noLayoutFailure) {
        this[Y].attempt = I;
        break;
      }
    }
    if (this[It](), s || Br(this), this[Y].attempt === I)
      return s || delete this[Y], dA.FAILURE;
    let c = 0, l = 0;
    this.margin && (c = this.margin.leftInset + this.margin.rightInset, l = this.margin.topInset + this.margin.bottomInset);
    const h = Math.max(this[Y].width + c, this.w || 0), C = Math.max(this[Y].height + l, this.h || 0), B = [this.x, this.y, h, C];
    this.w === "" && (n.width = FA(h)), this.h === "" && (n.height = FA(C));
    const Q = {
      name: "div",
      attributes: i,
      children: t
    };
    return hr(this, i), delete this[Y], dA.success(h0(this, Q), B);
  }
}
class ZE extends K {
  constructor(A) {
    super(eA, "execute"), this.connection = A.connection || "", this.executeType = O(A.executeType, ["import", "remerge"]), this.id = A.id || "", this.runAt = O(A.runAt, ["client", "both", "server"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class jE extends K {
  constructor(A) {
    super(eA, "extras", !0), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new b(), this.date = new b(), this.dateTime = new b(), this.decimal = new b(), this.exData = new b(), this.extras = new b(), this.float = new b(), this.image = new b(), this.integer = new b(), this.text = new b(), this.time = new b();
  }
}
class Eo extends K {
  constructor(A) {
    super(eA, "field", !0), this.access = O(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.accessKey = A.accessKey || "", this.anchorType = O(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = RA({
      data: A.colSpan,
      defaultValue: 1,
      validate: (t) => t >= 1 || t === -1
    }), this.h = A.h ? lA(A.h) : "", this.hAlign = O(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.locale = A.locale || "", this.maxH = lA(A.maxH, "0pt"), this.maxW = lA(A.maxW, "0pt"), this.minH = lA(A.minH, "0pt"), this.minW = lA(A.minW, "0pt"), this.name = A.name || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Zt(A.relevant), this.rotate = RA({
      data: A.rotate,
      defaultValue: 0,
      validate: (t) => t % 90 === 0
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? lA(A.w) : "", this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.assist = null, this.bind = null, this.border = null, this.calculate = null, this.caption = null, this.desc = null, this.extras = null, this.font = null, this.format = null, this.items = new b(2), this.keep = null, this.margin = null, this.para = null, this.traversal = null, this.ui = null, this.validate = null, this.value = null, this.bindItems = new b(), this.connect = new b(), this.event = new b(), this.setProperty = new b();
  }
  [u0]() {
    return !0;
  }
  [Bt](A) {
    Co(this, A);
  }
  [SA](A) {
    var E, f, d;
    if (lr(this), !this.ui) {
      this.ui = new xo({}), this.ui[se] = this[se], this[Be](this.ui);
      let u;
      switch (this.items.children.length) {
        case 0:
          u = new _l({}), this.ui.textEdit = u;
          break;
        case 1:
          u = new vl({}), this.ui.checkButton = u;
          break;
        case 2:
          u = new Tl({}), this.ui.choiceList = u;
          break;
      }
      this.ui[Be](u);
    }
    if (!this.ui || this.presence === "hidden" || this.presence === "inactive" || this.h === 0 || this.w === 0)
      return dA.EMPTY;
    this.caption && delete this.caption[Y], this[hs]();
    const t = this.caption ? this.caption[SA](A).html : null, i = this.w, s = this.h;
    let a = 0, n = 0;
    this.margin && (a = this.margin.leftInset + this.margin.rightInset, n = this.margin.topInset + this.margin.bottomInset);
    let r = null;
    if (this.w === "" || this.h === "") {
      let u = null, x = null, m = 0, p = 0;
      if (this.ui.checkButton)
        m = p = this.ui.checkButton.size;
      else {
        const {
          w: D,
          h: F
        } = co(this, A);
        D !== null ? (m = D, p = F) : p = eE(this.font, !0).lineNoGap;
      }
      if (r = _I(this.ui[Oe]()), m += r.w, p += r.h, this.caption) {
        const {
          w: D,
          h: F,
          isBroken: y
        } = this.caption[Oe](A);
        if (y && this[ye]()[pi]())
          return this[It](), dA.FAILURE;
        switch (u = D, x = F, this.caption.placement) {
          case "left":
          case "right":
          case "inline":
            u += m;
            break;
          case "top":
          case "bottom":
            x += p;
            break;
        }
      } else
        u = m, x = p;
      u && this.w === "" && (u += a, this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < u ? u : this.minW)), x && this.h === "" && (x += n, this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < x ? x : this.minH));
    }
    if (this[It](), Ir(this), Cr(this), !cr(this, A))
      return this.w = i, this.h = s, this[It](), dA.FAILURE;
    Br(this);
    const g = nt(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
    wl(this, g);
    const o = ["xfaField"];
    this.font && o.push("xfaFont"), Cs(this) && o.push("xfaPrintOnly");
    const I = {
      style: g,
      id: this[ee],
      class: o
    };
    g.margin && (g.padding = g.margin, delete g.margin), lo(this, o), this.name && (I.xfaName = this.name);
    const c = [], l = {
      name: "div",
      attributes: I,
      children: c
    };
    hr(this, I);
    const h = this.border ? this.border[VA]() : null, C = bl(this, l, A), B = this.ui[SA]().html;
    if (!B)
      return Object.assign(g, h), dA.success(h0(this, l), C);
    this[Tt] && ((E = B.children) != null && E[0] ? B.children[0].attributes.tabindex = this[Tt] : B.attributes.tabindex = this[Tt]), B.attributes.style || (B.attributes.style = /* @__PURE__ */ Object.create(null));
    let Q = null;
    if (this.ui.button ? (B.children.length === 1 && ([Q] = B.children.splice(0, 1)), Object.assign(B.attributes.style, h)) : Object.assign(g, h), c.push(B), this.value) {
      if (this.ui.imageEdit)
        B.children.push(this.value[SA]().html);
      else if (!this.ui.button) {
        let u = "";
        if (this.value.exData)
          u = this.value.exData[Se]();
        else if (this.value.text)
          u = this.value.text[Oe]();
        else {
          const x = this.value[SA]().html;
          x !== null && (u = x.children[0].value);
        }
        this.ui.textEdit && ((f = this.value.text) != null && f.maxChars) && (B.children[0].attributes.maxLength = this.value.text.maxChars), u && (this.ui.numericEdit && (u = parseFloat(u), u = isNaN(u) ? "" : u.toString()), B.children[0].name === "textarea" ? B.children[0].attributes.textContent = u : B.children[0].attributes.value = u);
      }
    }
    if (!this.ui.imageEdit && ((d = B.children) != null && d[0]) && this.h) {
      r = r || _I(this.ui[Oe]());
      let u = 0;
      if (this.caption && ["top", "bottom"].includes(this.caption.placement)) {
        u = this.caption.reserve, u <= 0 && (u = this.caption[Oe](A).h);
        const x = this.h - u - n - r.h;
        B.children[0].attributes.style.height = FA(x);
      } else
        B.children[0].attributes.style.height = "100%";
    }
    if (Q && B.children.push(Q), !t)
      return B.attributes.class && B.attributes.class.push("xfaLeft"), this.w = i, this.h = s, dA.success(h0(this, l), C);
    if (this.ui.button)
      return g.padding && delete g.padding, t.name === "div" && (t.name = "span"), B.children.push(t), dA.success(l, C);
    switch (this.ui.checkButton && (t.attributes.class[0] = "xfaCaptionForCheckButton"), B.attributes.class || (B.attributes.class = []), B.children.splice(0, 0, t), this.caption.placement) {
      case "left":
        B.attributes.class.push("xfaLeft");
        break;
      case "right":
        B.attributes.class.push("xfaRight");
        break;
      case "top":
        B.attributes.class.push("xfaTop");
        break;
      case "bottom":
        B.attributes.class.push("xfaBottom");
        break;
      case "inline":
        B.attributes.class.push("xfaLeft");
        break;
    }
    return this.w = i, this.h = s, dA.success(h0(this, l), C);
  }
}
class XE extends K {
  constructor(A) {
    super(eA, "fill", !0), this.id = A.id || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null, this.linear = null, this.pattern = null, this.radial = null, this.solid = null, this.stipple = null;
  }
  [VA]() {
    var r;
    const A = this[MA](), i = A[MA]()[MA](), s = /* @__PURE__ */ Object.create(null);
    let a = "color", n = a;
    A instanceof Jl && (a = "background-color", n = "background", i instanceof xo && (s.backgroundColor = "white")), (A instanceof Zl || A instanceof Hl) && (a = n = "fill", s.fill = "white");
    for (const g of Object.getOwnPropertyNames(this)) {
      if (g === "extras" || g === "color")
        continue;
      const o = this[g];
      if (!(o instanceof K))
        continue;
      const I = o[VA](this.color);
      return I && (s[I.startsWith("#") ? a : n] = I), s;
    }
    if ((r = this.color) != null && r.value) {
      const g = this.color[VA]();
      s[g.startsWith("#") ? a : n] = g;
    }
    return s;
  }
}
class _E extends K {
  constructor(A) {
    super(eA, "filter", !0), this.addRevocationInfo = O(A.addRevocationInfo, ["", "required", "optional", "none"]), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.version = RA({
      data: this.version,
      defaultValue: 5,
      validate: (t) => t >= 1 && t <= 5
    }), this.appearanceFilter = null, this.certificates = null, this.digestMethods = null, this.encodings = null, this.encryptionMethods = null, this.handler = null, this.lockDocument = null, this.mdp = null, this.reasons = null, this.timeStamp = null;
  }
}
class zE extends Ee {
  constructor(A) {
    super(eA, "float"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = parseFloat(this[P].trim());
    this[P] = isNaN(A) ? null : A;
  }
  [SA](A) {
    return Oi(this[P] !== null ? this[P].toString() : "");
  }
}
class $E extends K {
  constructor(A) {
    super(eA, "font", !0), this.baselineShift = lA(A.baselineShift), this.fontHorizontalScale = Gn({
      data: A.fontHorizontalScale,
      defaultValue: 100,
      validate: (t) => t >= 0
    }), this.fontVerticalScale = Gn({
      data: A.fontVerticalScale,
      defaultValue: 100,
      validate: (t) => t >= 0
    }), this.id = A.id || "", this.kerningMode = O(A.kerningMode, ["none", "pair"]), this.letterSpacing = lA(A.letterSpacing, "0"), this.lineThrough = RA({
      data: A.lineThrough,
      defaultValue: 0,
      validate: (t) => t === 1 || t === 2
    }), this.lineThroughPeriod = O(A.lineThroughPeriod, ["all", "word"]), this.overline = RA({
      data: A.overline,
      defaultValue: 0,
      validate: (t) => t === 1 || t === 2
    }), this.overlinePeriod = O(A.overlinePeriod, ["all", "word"]), this.posture = O(A.posture, ["normal", "italic"]), this.size = lA(A.size, "10pt"), this.typeface = A.typeface || "Courier", this.underline = RA({
      data: A.underline,
      defaultValue: 0,
      validate: (t) => t === 1 || t === 2
    }), this.underlinePeriod = O(A.underlinePeriod, ["all", "word"]), this.use = A.use || "", this.usehref = A.usehref || "", this.weight = O(A.weight, ["normal", "bold"]), this.extras = null, this.fill = null;
  }
  [Lt](A) {
    super[Lt](A), this[se].usedTypefaces.add(this.typeface);
  }
  [VA]() {
    const A = nt(this, "fill"), t = A.color;
    return t && (t === "#000000" ? delete A.color : t.startsWith("#") || (A.background = t, A.backgroundClip = "text", A.color = "transparent")), this.baselineShift && (A.verticalAlign = FA(this.baselineShift)), A.fontKerning = this.kerningMode === "none" ? "none" : "normal", A.letterSpacing = FA(this.letterSpacing), this.lineThrough !== 0 && (A.textDecoration = "line-through", this.lineThrough === 2 && (A.textDecorationStyle = "double")), this.overline !== 0 && (A.textDecoration = "overline", this.overline === 2 && (A.textDecorationStyle = "double")), A.fontStyle = this.posture, A.fontSize = FA(0.99 * this.size), Rl(this, this, this[se].fontFinder, A), this.underline !== 0 && (A.textDecoration = "underline", this.underline === 2 && (A.textDecorationStyle = "double")), A.fontWeight = this.weight, A;
  }
}
class Af extends K {
  constructor(A) {
    super(eA, "format", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.picture = null;
  }
}
class ef extends TA {
  constructor(A) {
    super(eA, "handler"), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class tf extends K {
  constructor(A) {
    super(eA, "hyphenation"), this.excludeAllCaps = RA({
      data: A.excludeAllCaps,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.excludeInitialCap = RA({
      data: A.excludeInitialCap,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.hyphenate = RA({
      data: A.hyphenate,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.id = A.id || "", this.pushCharacterCount = RA({
      data: A.pushCharacterCount,
      defaultValue: 3,
      validate: (t) => t >= 0
    }), this.remainCharacterCount = RA({
      data: A.remainCharacterCount,
      defaultValue: 3,
      validate: (t) => t >= 0
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.wordCharacterCount = RA({
      data: A.wordCharacterCount,
      defaultValue: 7,
      validate: (t) => t >= 0
    });
  }
}
class Ol extends TA {
  constructor(A) {
    super(eA, "image"), this.aspect = O(A.aspect, ["fit", "actual", "height", "none", "width"]), this.contentType = A.contentType || "", this.href = A.href || "", this.id = A.id || "", this.name = A.name || "", this.transferEncoding = O(A.transferEncoding, ["base64", "none", "package"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [SA]() {
    if (this.contentType && !lE.has(this.contentType.toLowerCase()))
      return dA.EMPTY;
    let A = this[se].images && this[se].images.get(this.href);
    if (!A && (this.href || !this[P]) || (!A && this.transferEncoding === "base64" && (A = Oh(this[P])), !A))
      return dA.EMPTY;
    if (!this.contentType) {
      for (const [a, n] of hE)
        if (A.length > a.length && a.every((r, g) => r === A[g])) {
          this.contentType = n;
          break;
        }
      if (!this.contentType)
        return dA.EMPTY;
    }
    const t = new Blob([A], {
      type: this.contentType
    });
    let i;
    switch (this.aspect) {
      case "fit":
      case "actual":
        break;
      case "height":
        i = {
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "none":
        i = {
          width: "100%",
          height: "100%",
          objectFit: "fill"
        };
        break;
      case "width":
        i = {
          width: "100%",
          objectFit: "fill"
        };
        break;
    }
    const s = this[MA]();
    return dA.success({
      name: "img",
      attributes: {
        class: ["xfaImage"],
        style: i,
        src: URL.createObjectURL(t),
        alt: s ? E0(s[MA]()) : null
      }
    });
  }
}
class sf extends K {
  constructor(A) {
    super(eA, "imageEdit", !0), this.data = O(A.data, ["link", "embed"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    return this.data === "embed" ? dA.success({
      name: "div",
      children: [],
      attributes: {}
    }) : dA.EMPTY;
  }
}
class af extends Ee {
  constructor(A) {
    super(eA, "integer"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = parseInt(this[P].trim(), 10);
    this[P] = isNaN(A) ? null : A;
  }
  [SA](A) {
    return Oi(this[P] !== null ? this[P].toString() : "");
  }
}
class nf extends K {
  constructor(A) {
    super(eA, "issuers", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new b();
  }
}
class Ng extends K {
  constructor(A) {
    super(eA, "items", !0), this.id = A.id || "", this.name = A.name || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.ref = A.ref || "", this.save = RA({
      data: A.save,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new b(), this.date = new b(), this.dateTime = new b(), this.decimal = new b(), this.exData = new b(), this.float = new b(), this.image = new b(), this.integer = new b(), this.text = new b(), this.time = new b();
  }
  [SA]() {
    const A = [];
    for (const t of this[He]())
      A.push(t[Se]());
    return dA.success(A);
  }
}
class rf extends K {
  constructor(A) {
    super(eA, "keep", !0), this.id = A.id || "";
    const t = ["none", "contentArea", "pageArea"];
    this.intact = O(A.intact, t), this.next = O(A.next, t), this.previous = O(A.previous, t), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
}
class gf extends K {
  constructor(A) {
    super(eA, "keyUsage");
    const t = ["", "yes", "no"];
    this.crlSign = O(A.crlSign, t), this.dataEncipherment = O(A.dataEncipherment, t), this.decipherOnly = O(A.decipherOnly, t), this.digitalSignature = O(A.digitalSignature, t), this.encipherOnly = O(A.encipherOnly, t), this.id = A.id || "", this.keyAgreement = O(A.keyAgreement, t), this.keyCertSign = O(A.keyCertSign, t), this.keyEncipherment = O(A.keyEncipherment, t), this.nonRepudiation = O(A.nonRepudiation, t), this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class of extends K {
  constructor(A) {
    super(eA, "line", !0), this.hand = O(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.slope = O(A.slope, ["\\", "/"]), this.use = A.use || "", this.usehref = A.usehref || "", this.edge = null;
  }
  [SA]() {
    const A = this[MA]()[MA](), t = this.edge || new ka({}), i = t[VA](), s = /* @__PURE__ */ Object.create(null), a = t.presence === "visible" ? t.thickness : 0;
    s.strokeWidth = FA(a), s.stroke = i.color;
    let n, r, g, o, I = "100%", c = "100%";
    A.w <= a ? ([n, r, g, o] = ["50%", 0, "50%", "100%"], I = s.strokeWidth) : A.h <= a ? ([n, r, g, o] = [0, "50%", "100%", "50%"], c = s.strokeWidth) : this.slope === "\\" ? [n, r, g, o] = [0, 0, "100%", "100%"] : [n, r, g, o] = [0, "100%", "100%", 0];
    const h = {
      name: "svg",
      children: [{
        name: "line",
        attributes: {
          xmlns: C0,
          x1: n,
          y1: r,
          x2: g,
          y2: o,
          style: s
        }
      }],
      attributes: {
        xmlns: C0,
        width: I,
        height: c,
        style: {
          overflow: "visible"
        }
      }
    };
    return ho(A) ? dA.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [h]
    }) : (h.attributes.style.position = "absolute", dA.success(h));
  }
}
class If extends K {
  constructor(A) {
    super(eA, "linear", !0), this.id = A.id || "", this.type = O(A.type, ["toRight", "toBottom", "toLeft", "toTop"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA](A) {
    A = A ? A[VA]() : "#FFFFFF";
    const t = this.type.replace(/([RBLT])/, " $1").toLowerCase(), i = this.color ? this.color[VA]() : "#000000";
    return `linear-gradient(${t}, ${A}, ${i})`;
  }
}
class cf extends Ee {
  constructor(A) {
    super(eA, "lockDocument"), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    this[P] = O(this[P], ["auto", "0", "1"]);
  }
}
class lf extends K {
  constructor(A) {
    super(eA, "manifest", !0), this.action = O(A.action, ["include", "all", "exclude"]), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.ref = new b();
  }
}
class hf extends K {
  constructor(A) {
    super(eA, "margin", !0), this.bottomInset = lA(A.bottomInset, "0"), this.id = A.id || "", this.leftInset = lA(A.leftInset, "0"), this.rightInset = lA(A.rightInset, "0"), this.topInset = lA(A.topInset, "0"), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [VA]() {
    return {
      margin: FA(this.topInset) + " " + FA(this.rightInset) + " " + FA(this.bottomInset) + " " + FA(this.leftInset)
    };
  }
}
class Cf extends K {
  constructor(A) {
    super(eA, "mdp"), this.id = A.id || "", this.permissions = RA({
      data: A.permissions,
      defaultValue: 2,
      validate: (t) => t === 1 || t === 3
    }), this.signatureType = O(A.signatureType, ["filler", "author"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Bf extends K {
  constructor(A) {
    super(eA, "medium"), this.id = A.id || "", this.imagingBBox = $1(A.imagingBBox), this.long = lA(A.long), this.orientation = O(A.orientation, ["portrait", "landscape"]), this.short = lA(A.short), this.stock = A.stock || "", this.trayIn = O(A.trayIn, ["auto", "delegate", "pageFront"]), this.trayOut = O(A.trayOut, ["auto", "delegate"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Qf extends K {
  constructor(A) {
    super(eA, "message", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.text = new b();
  }
}
class Ef extends K {
  constructor(A) {
    super(eA, "numericEdit", !0), this.hScrollPolicy = O(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    var a;
    const t = nt(this, "border", "font", "margin"), i = this[MA]()[MA](), s = {
      name: "input",
      attributes: {
        type: "text",
        fieldId: i[ee],
        dataId: ((a = i[Mt]) == null ? void 0 : a[ee]) || i[ee],
        class: ["xfaTextfield"],
        style: t,
        "aria-label": E0(i),
        "aria-required": !1
      }
    };
    return Da(i) && (s.attributes["aria-required"] = !0, s.attributes.required = !0), dA.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [s]
    });
  }
}
class ff extends K {
  constructor(A) {
    super(eA, "occur", !0), this.id = A.id || "", this.initial = A.initial !== "" ? RA({
      data: A.initial,
      defaultValue: "",
      validate: (t) => !0
    }) : "", this.max = A.max !== "" ? RA({
      data: A.max,
      defaultValue: 1,
      validate: (t) => !0
    }) : "", this.min = A.min !== "" ? RA({
      data: A.min,
      defaultValue: 1,
      validate: (t) => !0
    }) : "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [Lt]() {
    const A = this[MA](), t = this.min;
    this.min === "" && (this.min = A instanceof gs || A instanceof ra ? 0 : 1), this.max === "" && (t === "" ? this.max = A instanceof gs || A instanceof ra ? -1 : 1 : this.max = this.min), this.max !== -1 && this.max < this.min && (this.max = this.min), this.initial === "" && (this.initial = A instanceof uo ? 1 : this.min);
  }
}
class uf extends TA {
  constructor(A) {
    super(eA, "oid"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class df extends K {
  constructor(A) {
    super(eA, "oids", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.oid = new b();
  }
}
class Vl extends K {
  constructor(A) {
    super(eA, "overflow"), this.id = A.id || "", this.leader = A.leader || "", this.target = A.target || "", this.trailer = A.trailer || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [Oe]() {
    if (!this[Y]) {
      const A = this[MA](), t = this[me](), i = t[Bi](this.target, A), s = t[Bi](this.leader, A), a = t[Bi](this.trailer, A);
      this[Y] = {
        target: (i == null ? void 0 : i[0]) || null,
        leader: (s == null ? void 0 : s[0]) || null,
        trailer: (a == null ? void 0 : a[0]) || null,
        addLeader: !1,
        addTrailer: !1
      };
    }
    return this[Y];
  }
}
class gs extends K {
  constructor(A) {
    super(eA, "pageArea", !0), this.blankOrNotBlank = O(A.blankOrNotBlank, ["any", "blank", "notBlank"]), this.id = A.id || "", this.initialNumber = RA({
      data: A.initialNumber,
      defaultValue: 1,
      validate: (t) => !0
    }), this.name = A.name || "", this.numbered = RA({
      data: A.numbered,
      defaultValue: 1,
      validate: (t) => !0
    }), this.oddOrEven = O(A.oddOrEven, ["any", "even", "odd"]), this.pagePosition = O(A.pagePosition, ["any", "first", "last", "only", "rest"]), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.desc = null, this.extras = null, this.medium = null, this.occur = null, this.area = new b(), this.contentArea = new b(), this.draw = new b(), this.exclGroup = new b(), this.field = new b(), this.subform = new b();
  }
  [na]() {
    return this[Y] ? !this.occur || this.occur.max === -1 || this[Y].numberOfUse < this.occur.max : (this[Y] = {
      numberOfUse: 0
    }, !0);
  }
  [H0]() {
    delete this[Y];
  }
  [hi]() {
    this[Y] || (this[Y] = {
      numberOfUse: 0
    });
    const A = this[MA]();
    return A.relation === "orderedOccurrence" && this[na]() ? (this[Y].numberOfUse += 1, this) : A[hi]();
  }
  [l0]() {
    return this[Y].space || {
      width: 0,
      height: 0
    };
  }
  [SA]() {
    this[Y] || (this[Y] = {
      numberOfUse: 1
    });
    const A = [];
    this[Y].children = A;
    const t = /* @__PURE__ */ Object.create(null);
    if (this.medium && this.medium.short && this.medium.long) {
      if (t.width = FA(this.medium.short), t.height = FA(this.medium.long), this[Y].space = {
        width: this.medium.short,
        height: this.medium.long
      }, this.medium.orientation === "landscape") {
        const i = t.width;
        t.width = t.height, t.height = i, this[Y].space = {
          width: this.medium.long,
          height: this.medium.short
        };
      }
    } else
      k("XFA - No medium specified in pageArea: please file a bug.");
    return this[Wi]({
      filter: /* @__PURE__ */ new Set(["area", "draw", "field", "subform"]),
      include: !0
    }), this[Wi]({
      filter: /* @__PURE__ */ new Set(["contentArea"]),
      include: !0
    }), dA.success({
      name: "div",
      children: A,
      attributes: {
        class: ["xfaPage"],
        id: this[ee],
        style: t,
        xfaName: this.name
      }
    });
  }
}
class ra extends K {
  constructor(A) {
    super(eA, "pageSet", !0), this.duplexImposition = O(A.duplexImposition, ["longEdge", "shortEdge"]), this.id = A.id || "", this.name = A.name || "", this.relation = O(A.relation, ["orderedOccurrence", "duplexPaginated", "simplexPaginated"]), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.occur = null, this.pageArea = new b(), this.pageSet = new b();
  }
  [H0]() {
    for (const A of this.pageArea.children)
      A[H0]();
    for (const A of this.pageSet.children)
      A[H0]();
  }
  [na]() {
    return !this.occur || this.occur.max === -1 || this[Y].numberOfUse < this.occur.max;
  }
  [hi]() {
    if (this[Y] || (this[Y] = {
      numberOfUse: 1,
      pageIndex: -1,
      pageSetIndex: -1
    }), this.relation === "orderedOccurrence") {
      if (this[Y].pageIndex + 1 < this.pageArea.children.length)
        return this[Y].pageIndex += 1, this.pageArea.children[this[Y].pageIndex][hi]();
      if (this[Y].pageSetIndex + 1 < this.pageSet.children.length)
        return this[Y].pageSetIndex += 1, this.pageSet.children[this[Y].pageSetIndex][hi]();
      if (this[na]())
        return this[Y].numberOfUse += 1, this[Y].pageIndex = -1, this[Y].pageSetIndex = -1, this[hi]();
      const a = this[MA]();
      return a instanceof ra ? a[hi]() : (this[H0](), this[hi]());
    }
    const A = this[me]()[Y].pageNumber, t = A % 2 === 0 ? "even" : "odd", i = A === 0 ? "first" : "rest";
    let s = this.pageArea.children.find((a) => a.oddOrEven === t && a.pagePosition === i);
    return s || (s = this.pageArea.children.find((a) => a.oddOrEven === "any" && a.pagePosition === i), s) || (s = this.pageArea.children.find((a) => a.oddOrEven === "any" && a.pagePosition === "any"), s) ? s : this.pageArea.children[0];
  }
}
class xf extends K {
  constructor(A) {
    super(eA, "para", !0), this.hAlign = O(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.lineHeight = A.lineHeight ? lA(A.lineHeight, "0pt") : "", this.marginLeft = A.marginLeft ? lA(A.marginLeft, "0pt") : "", this.marginRight = A.marginRight ? lA(A.marginRight, "0pt") : "", this.orphans = RA({
      data: A.orphans,
      defaultValue: 0,
      validate: (t) => t >= 0
    }), this.preserve = A.preserve || "", this.radixOffset = A.radixOffset ? lA(A.radixOffset, "0pt") : "", this.spaceAbove = A.spaceAbove ? lA(A.spaceAbove, "0pt") : "", this.spaceBelow = A.spaceBelow ? lA(A.spaceBelow, "0pt") : "", this.tabDefault = A.tabDefault ? lA(this.tabDefault) : "", this.tabStops = (A.tabStops || "").trim().split(/\s+/).map((t, i) => i % 2 === 1 ? lA(t) : t), this.textIndent = A.textIndent ? lA(A.textIndent, "0pt") : "", this.use = A.use || "", this.usehref = A.usehref || "", this.vAlign = O(A.vAlign, ["top", "bottom", "middle"]), this.widows = RA({
      data: A.widows,
      defaultValue: 0,
      validate: (t) => t >= 0
    }), this.hyphenation = null;
  }
  [VA]() {
    const A = nt(this, "hAlign");
    return this.marginLeft !== "" && (A.paddingLeft = FA(this.marginLeft)), this.marginRight !== "" && (A.paddingRight = FA(this.marginRight)), this.spaceAbove !== "" && (A.paddingTop = FA(this.spaceAbove)), this.spaceBelow !== "" && (A.paddingBottom = FA(this.spaceBelow)), this.textIndent !== "" && (A.textIndent = FA(this.textIndent), kl(A)), this.lineHeight > 0 && (A.lineHeight = FA(this.lineHeight)), this.tabDefault !== "" && (A.tabSize = FA(this.tabDefault)), this.tabStops.length > 0, this.hyphenatation && Object.assign(A, this.hyphenatation[VA]()), A;
  }
}
class mf extends K {
  constructor(A) {
    super(eA, "passwordEdit", !0), this.hScrollPolicy = O(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.passwordChar = A.passwordChar || "*", this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.margin = null;
  }
}
class pf extends K {
  constructor(A) {
    super(eA, "pattern", !0), this.id = A.id || "", this.type = O(A.type, ["crossHatch", "crossDiagonal", "diagonalLeft", "diagonalRight", "horizontal", "vertical"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA](A) {
    A = A ? A[VA]() : "#FFFFFF";
    const t = this.color ? this.color[VA]() : "#000000", i = 5, s = "repeating-linear-gradient", a = `${A},${A} ${i}px,${t} ${i}px,${t} ${2 * i}px`;
    switch (this.type) {
      case "crossHatch":
        return `${s}(to top,${a}) ${s}(to right,${a})`;
      case "crossDiagonal":
        return `${s}(45deg,${a}) ${s}(-45deg,${a})`;
      case "diagonalLeft":
        return `${s}(45deg,${a})`;
      case "diagonalRight":
        return `${s}(-45deg,${a})`;
      case "horizontal":
        return `${s}(to top,${a})`;
      case "vertical":
        return `${s}(to right,${a})`;
    }
    return "";
  }
}
class yf extends TA {
  constructor(A) {
    super(eA, "picture"), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class wf extends K {
  constructor(A) {
    super(eA, "proto", !0), this.appearanceFilter = new b(), this.arc = new b(), this.area = new b(), this.assist = new b(), this.barcode = new b(), this.bindItems = new b(), this.bookend = new b(), this.boolean = new b(), this.border = new b(), this.break = new b(), this.breakAfter = new b(), this.breakBefore = new b(), this.button = new b(), this.calculate = new b(), this.caption = new b(), this.certificate = new b(), this.certificates = new b(), this.checkButton = new b(), this.choiceList = new b(), this.color = new b(), this.comb = new b(), this.connect = new b(), this.contentArea = new b(), this.corner = new b(), this.date = new b(), this.dateTime = new b(), this.dateTimeEdit = new b(), this.decimal = new b(), this.defaultUi = new b(), this.desc = new b(), this.digestMethod = new b(), this.digestMethods = new b(), this.draw = new b(), this.edge = new b(), this.encoding = new b(), this.encodings = new b(), this.encrypt = new b(), this.encryptData = new b(), this.encryption = new b(), this.encryptionMethod = new b(), this.encryptionMethods = new b(), this.event = new b(), this.exData = new b(), this.exObject = new b(), this.exclGroup = new b(), this.execute = new b(), this.extras = new b(), this.field = new b(), this.fill = new b(), this.filter = new b(), this.float = new b(), this.font = new b(), this.format = new b(), this.handler = new b(), this.hyphenation = new b(), this.image = new b(), this.imageEdit = new b(), this.integer = new b(), this.issuers = new b(), this.items = new b(), this.keep = new b(), this.keyUsage = new b(), this.line = new b(), this.linear = new b(), this.lockDocument = new b(), this.manifest = new b(), this.margin = new b(), this.mdp = new b(), this.medium = new b(), this.message = new b(), this.numericEdit = new b(), this.occur = new b(), this.oid = new b(), this.oids = new b(), this.overflow = new b(), this.pageArea = new b(), this.pageSet = new b(), this.para = new b(), this.passwordEdit = new b(), this.pattern = new b(), this.picture = new b(), this.radial = new b(), this.reason = new b(), this.reasons = new b(), this.rectangle = new b(), this.ref = new b(), this.script = new b(), this.setProperty = new b(), this.signData = new b(), this.signature = new b(), this.signing = new b(), this.solid = new b(), this.speak = new b(), this.stipple = new b(), this.subform = new b(), this.subformSet = new b(), this.subjectDN = new b(), this.subjectDNs = new b(), this.submit = new b(), this.text = new b(), this.textEdit = new b(), this.time = new b(), this.timeStamp = new b(), this.toolTip = new b(), this.traversal = new b(), this.traverse = new b(), this.ui = new b(), this.validate = new b(), this.value = new b(), this.variables = new b();
  }
}
class bf extends K {
  constructor(A) {
    super(eA, "radial", !0), this.id = A.id || "", this.type = O(A.type, ["toEdge", "toCenter"]), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA](A) {
    A = A ? A[VA]() : "#FFFFFF";
    const t = this.color ? this.color[VA]() : "#000000";
    return `radial-gradient(circle at center, ${this.type === "toEdge" ? `${A},${t}` : `${t},${A}`})`;
  }
}
class Df extends TA {
  constructor(A) {
    super(eA, "reason"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class kf extends K {
  constructor(A) {
    super(eA, "reasons", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.reason = new b();
  }
}
class Zl extends K {
  constructor(A) {
    super(eA, "rectangle", !0), this.hand = O(A.hand, ["even", "left", "right"]), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.corner = new b(4), this.edge = new b(4), this.fill = null;
  }
  [SA]() {
    var o;
    const A = this.edge.children.length ? this.edge.children[0] : new ka({}), t = A[VA](), i = /* @__PURE__ */ Object.create(null);
    ((o = this.fill) == null ? void 0 : o.presence) === "visible" ? Object.assign(i, this.fill[VA]()) : i.fill = "transparent", i.strokeWidth = FA(A.presence === "visible" ? A.thickness : 0), i.stroke = t.color;
    const a = (this.corner.children.length ? this.corner.children[0] : new ql({}))[VA](), r = {
      name: "svg",
      children: [{
        name: "rect",
        attributes: {
          xmlns: C0,
          width: "100%",
          height: "100%",
          x: 0,
          y: 0,
          rx: a.radius,
          ry: a.radius,
          style: i
        }
      }],
      attributes: {
        xmlns: C0,
        style: {
          overflow: "visible"
        },
        width: "100%",
        height: "100%"
      }
    }, g = this[MA]()[MA]();
    return ho(g) ? dA.success({
      name: "div",
      attributes: {
        style: {
          display: "inline",
          width: "100%",
          height: "100%"
        }
      },
      children: [r]
    }) : (r.attributes.style.position = "absolute", dA.success(r));
  }
}
class Sf extends TA {
  constructor(A) {
    super(eA, "ref"), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Ff extends TA {
  constructor(A) {
    super(eA, "script"), this.binding = A.binding || "", this.contentType = A.contentType || "", this.id = A.id || "", this.name = A.name || "", this.runAt = O(A.runAt, ["client", "both", "server"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Mg extends K {
  constructor(A) {
    super(eA, "setProperty"), this.connection = A.connection || "", this.ref = A.ref || "", this.target = A.target || "";
  }
}
class Rf extends K {
  constructor(A) {
    super(eA, "signData", !0), this.id = A.id || "", this.operation = O(A.operation, ["sign", "clear", "verify"]), this.ref = A.ref || "", this.target = A.target || "", this.use = A.use || "", this.usehref = A.usehref || "", this.filter = null, this.manifest = null;
  }
}
class Gf extends K {
  constructor(A) {
    super(eA, "signature", !0), this.id = A.id || "", this.type = O(A.type, ["PDF1.3", "PDF1.6"]), this.use = A.use || "", this.usehref = A.usehref || "", this.border = null, this.extras = null, this.filter = null, this.manifest = null, this.margin = null;
  }
}
class Nf extends K {
  constructor(A) {
    super(eA, "signing", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.certificate = new b();
  }
}
class Mf extends K {
  constructor(A) {
    super(eA, "solid", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null;
  }
  [VA](A) {
    return A ? A[VA]() : "#FFFFFF";
  }
}
class Uf extends TA {
  constructor(A) {
    super(eA, "speak"), this.disable = RA({
      data: A.disable,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.id = A.id || "", this.priority = O(A.priority, ["custom", "caption", "name", "toolTip"]), this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Lf extends K {
  constructor(A) {
    super(eA, "stipple", !0), this.id = A.id || "", this.rate = RA({
      data: A.rate,
      defaultValue: 50,
      validate: (t) => t >= 0 && t <= 100
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.color = null, this.extras = null;
  }
  [VA](A) {
    const t = this.rate / 100;
    return de.makeHexColor(Math.round(A.value.r * (1 - t) + this.value.r * t), Math.round(A.value.g * (1 - t) + this.value.g * t), Math.round(A.value.b * (1 - t) + this.value.b * t));
  }
}
class jl extends K {
  constructor(A) {
    super(eA, "subform", !0), this.access = O(A.access, ["open", "nonInteractive", "protected", "readOnly"]), this.allowMacro = RA({
      data: A.allowMacro,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.anchorType = O(A.anchorType, ["topLeft", "bottomCenter", "bottomLeft", "bottomRight", "middleCenter", "middleLeft", "middleRight", "topCenter", "topRight"]), this.colSpan = RA({
      data: A.colSpan,
      defaultValue: 1,
      validate: (t) => t >= 1 || t === -1
    }), this.columnWidths = (A.columnWidths || "").trim().split(/\s+/).map((t) => t === "-1" ? -1 : lA(t)), this.h = A.h ? lA(A.h) : "", this.hAlign = O(A.hAlign, ["left", "center", "justify", "justifyAll", "radix", "right"]), this.id = A.id || "", this.layout = O(A.layout, ["position", "lr-tb", "rl-row", "rl-tb", "row", "table", "tb"]), this.locale = A.locale || "", this.maxH = lA(A.maxH, "0pt"), this.maxW = lA(A.maxW, "0pt"), this.mergeMode = O(A.mergeMode, ["consumeData", "matchTemplate"]), this.minH = lA(A.minH, "0pt"), this.minW = lA(A.minW, "0pt"), this.name = A.name || "", this.presence = O(A.presence, ["visible", "hidden", "inactive", "invisible"]), this.relevant = Zt(A.relevant), this.restoreState = O(A.restoreState, ["manual", "auto"]), this.scope = O(A.scope, ["name", "none"]), this.use = A.use || "", this.usehref = A.usehref || "", this.w = A.w ? lA(A.w) : "", this.x = lA(A.x, "0pt"), this.y = lA(A.y, "0pt"), this.assist = null, this.bind = null, this.bookend = null, this.border = null, this.break = null, this.calculate = null, this.desc = null, this.extras = null, this.keep = null, this.margin = null, this.occur = null, this.overflow = null, this.pageSet = null, this.para = null, this.traversal = null, this.validate = null, this.variables = null, this.area = new b(), this.breakAfter = new b(), this.breakBefore = new b(), this.connect = new b(), this.draw = new b(), this.event = new b(), this.exObject = new b(), this.exclGroup = new b(), this.field = new b(), this.proto = new b(), this.setProperty = new b(), this.subform = new b(), this.subformSet = new b();
  }
  [ye]() {
    const A = this[MA]();
    return A instanceof fo ? A[ye]() : A;
  }
  [u0]() {
    return !0;
  }
  [pi]() {
    return this.layout.endsWith("-tb") && this[Y].attempt === 0 && this[Y].numberInLine > 0 || this[MA]()[pi]();
  }
  *[rs]() {
    yield* Bo(this);
  }
  [ba]() {
    return Ml(this);
  }
  [c0](A, t) {
    Ul(this, A, t);
  }
  [l0]() {
    return Ll(this);
  }
  [fi]() {
    var t;
    const A = this[ye]();
    return A[fi]() ? this[Y]._isSplittable !== void 0 ? this[Y]._isSplittable : this.layout === "position" || this.layout.includes("row") ? (this[Y]._isSplittable = !1, !1) : this.keep && this.keep.intact !== "none" ? (this[Y]._isSplittable = !1, !1) : (t = A.layout) != null && t.endsWith("-tb") && A[Y].numberInLine !== 0 ? !1 : (this[Y]._isSplittable = !0, !0) : !1;
  }
  [SA](A) {
    var u;
    if (lr(this), this.break) {
      if (this.break.after !== "auto" || this.break.afterTarget !== "") {
        const x = new Yl({
          targetType: this.break.after,
          target: this.break.afterTarget,
          startNew: this.break.startNew.toString()
        });
        x[se] = this[se], this[Be](x), this.breakAfter.push(x);
      }
      if (this.break.before !== "auto" || this.break.beforeTarget !== "") {
        const x = new Kl({
          targetType: this.break.before,
          target: this.break.beforeTarget,
          startNew: this.break.startNew.toString()
        });
        x[se] = this[se], this[Be](x), this.breakBefore.push(x);
      }
      if (this.break.overflowTarget !== "") {
        const x = new Vl({
          target: this.break.overflowTarget,
          leader: this.break.overflowLeader,
          trailer: this.break.overflowTrailer
        });
        x[se] = this[se], this[Be](x), this.overflow.push(x);
      }
      this[qi](this.break), this.break = null;
    }
    if (this.presence === "hidden" || this.presence === "inactive")
      return dA.EMPTY;
    if ((this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && k("XFA - Several breakBefore or breakAfter in subforms: please file a bug."), this.breakBefore.children.length >= 1) {
      const x = this.breakBefore.children[0];
      if (zI(x))
        return dA.breakNode(x);
    }
    if ((u = this[Y]) != null && u.afterBreakAfter)
      return dA.EMPTY;
    Ir(this);
    const t = [], i = {
      id: this[ee],
      class: []
    };
    lo(this, i.class), this[Y] || (this[Y] = /* @__PURE__ */ Object.create(null)), Object.assign(this[Y], {
      children: t,
      line: null,
      attributes: i,
      attempt: 0,
      numberInLine: 0,
      availableSpace: {
        width: Math.min(this.w || 1 / 0, A.width),
        height: Math.min(this.h || 1 / 0, A.height)
      },
      width: 0,
      height: 0,
      prevHeight: 0,
      currentWidth: 0
    });
    const s = this[me](), a = s[Y].noLayoutFailure, n = this[fi]();
    if (n || Cr(this), !cr(this, A))
      return dA.FAILURE;
    const r = /* @__PURE__ */ new Set(["area", "draw", "exclGroup", "field", "subform", "subformSet"]);
    if (this.layout.includes("row")) {
      const x = this[ye]().columnWidths;
      Array.isArray(x) && x.length > 0 && (this[Y].columnWidths = x, this[Y].currentColumn = 0);
    }
    const g = nt(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), o = ["xfaSubform"], I = Dl(this);
    if (I && o.push(I), i.style = g, i.class = o, this.name && (i.xfaName = this.name), this.overflow) {
      const x = this.overflow[Oe]();
      x.addLeader && (x.addLeader = !1, $I(this, x.leader, A));
    }
    this[hs]();
    const c = this.layout === "lr-tb" || this.layout === "rl-tb", l = c ? Nn : 1;
    for (; this[Y].attempt < l; this[Y].attempt++) {
      c && this[Y].attempt === Nn - 1 && (this[Y].numberInLine = 0);
      const x = this[Wi]({
        filter: r,
        include: !0
      });
      if (x.success)
        break;
      if (x.isBreak())
        return this[It](), x;
      if (c && this[Y].attempt === 0 && this[Y].numberInLine === 0 && !s[Y].noLayoutFailure) {
        this[Y].attempt = l;
        break;
      }
    }
    if (this[It](), n || Br(this), s[Y].noLayoutFailure = a, this[Y].attempt === l)
      return this.overflow && (this[me]()[Y].overflowNode = this.overflow), n || delete this[Y], dA.FAILURE;
    if (this.overflow) {
      const x = this.overflow[Oe]();
      x.addTrailer && (x.addTrailer = !1, $I(this, x.trailer, A));
    }
    let h = 0, C = 0;
    this.margin && (h = this.margin.leftInset + this.margin.rightInset, C = this.margin.topInset + this.margin.bottomInset);
    const B = Math.max(this[Y].width + h, this.w || 0), Q = Math.max(this[Y].height + C, this.h || 0), E = [this.x, this.y, B, Q];
    if (this.w === "" && (g.width = FA(B)), this.h === "" && (g.height = FA(Q)), (g.width === "0px" || g.height === "0px") && t.length === 0)
      return dA.EMPTY;
    const f = {
      name: "div",
      attributes: i,
      children: t
    };
    hr(this, i);
    const d = dA.success(h0(this, f), E);
    if (this.breakAfter.children.length >= 1) {
      const x = this.breakAfter.children[0];
      if (zI(x))
        return this[Y].afterBreakAfter = d, dA.breakNode(x);
    }
    return delete this[Y], d;
  }
}
class fo extends K {
  constructor(A) {
    super(eA, "subformSet", !0), this.id = A.id || "", this.name = A.name || "", this.relation = O(A.relation, ["ordered", "choice", "unordered"]), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.bookend = null, this.break = null, this.desc = null, this.extras = null, this.occur = null, this.overflow = null, this.breakAfter = new b(), this.breakBefore = new b(), this.subform = new b(), this.subformSet = new b();
  }
  *[rs]() {
    yield* Bo(this);
  }
  [ye]() {
    let A = this[MA]();
    for (; !(A instanceof jl); )
      A = A[MA]();
    return A;
  }
  [u0]() {
    return !0;
  }
}
class Hf extends Ee {
  constructor(A) {
    super(eA, "subjectDN"), this.delimiter = A.delimiter || ",", this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    this[P] = new Map(this[P].split(this.delimiter).map((A) => (A = A.split("=", 2), A[0] = A[0].trim(), A)));
  }
}
class Jf extends K {
  constructor(A) {
    super(eA, "subjectDNs", !0), this.id = A.id || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "", this.subjectDN = new b();
  }
}
class Yf extends K {
  constructor(A) {
    super(eA, "submit", !0), this.embedPDF = RA({
      data: A.embedPDF,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.format = O(A.format, ["xdp", "formdata", "pdf", "urlencoded", "xfd", "xml"]), this.id = A.id || "", this.target = A.target || "", this.textEncoding = or({
      data: A.textEncoding ? A.textEncoding.toLowerCase() : "",
      defaultValue: "",
      validate: (t) => ["utf-8", "big-five", "fontspecific", "gbk", "gb-18030", "gb-2312", "ksc-5601", "none", "shift-jis", "ucs-2", "utf-16"].includes(t) || t.match(/iso-8859-\d{2}/)
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.xdpContent = A.xdpContent || "", this.encrypt = null, this.encryptData = new b(), this.signData = new b();
  }
}
class uo extends K {
  constructor(A) {
    super(eA, "template", !0), this.baseProfile = O(A.baseProfile, ["full", "interactiveForms"]), this.extras = null, this.subform = new b();
  }
  [ae]() {
    this.subform.children.length === 0 && k("XFA - No subforms in template node."), this.subform.children.length >= 2 && k("XFA - Several subforms in template node: please file a bug."), this[Tt] = IE;
  }
  [fi]() {
    return !0;
  }
  [Bi](A, t) {
    return A.startsWith("#") ? [this[U0].get(A.slice(1))] : Fi(this, t, A, !0, !0);
  }
  *[dl]() {
    var C, B, Q;
    if (!this.subform.children.length)
      return dA.success({
        name: "div",
        children: []
      });
    this[Y] = {
      overflowNode: null,
      firstUnsplittable: null,
      currentContentArea: null,
      currentPageArea: null,
      noLayoutFailure: !1,
      pageNumber: 1,
      pagePosition: "first",
      oddOrEven: "odd",
      blankOrNotBlank: "nonBlank",
      paraStack: []
    };
    const A = this.subform.children[0];
    A.pageSet[H0]();
    const t = A.pageSet.pageArea.children, i = {
      name: "div",
      children: []
    };
    let s = null, a = null, n = null;
    if (A.breakBefore.children.length >= 1 ? (a = A.breakBefore.children[0], n = a.target) : A.subform.children.length >= 1 && A.subform.children[0].breakBefore.children.length >= 1 ? (a = A.subform.children[0].breakBefore.children[0], n = a.target) : (C = A.break) != null && C.beforeTarget ? (a = A.break, n = a.beforeTarget) : A.subform.children.length >= 1 && ((B = A.subform.children[0].break) != null && B.beforeTarget) && (a = A.subform.children[0].break, n = a.beforeTarget), a) {
      const E = this[Bi](n, a[MA]());
      E instanceof gs && (s = E, a[Y] = {});
    }
    s || (s = t[0]), s[Y] = {
      numberOfUse: 1
    };
    const r = s[MA]();
    r[Y] = {
      numberOfUse: 1,
      pageIndex: r.pageArea.children.indexOf(s),
      pageSetIndex: 0
    };
    let g, o = null, I = null, c = !0, l = 0, h = 0;
    for (; ; ) {
      if (c)
        l = 0;
      else if (i.children.pop(), ++l === oE)
        return k("XFA - Something goes wrong: please file a bug."), i;
      g = null, this[Y].currentPageArea = s;
      const E = s[SA]().html;
      i.children.push(E), o && (this[Y].noLayoutFailure = !0, E.children.push(o[SA](s[Y].space).html), o = null), I && (this[Y].noLayoutFailure = !0, E.children.push(I[SA](s[Y].space).html), I = null);
      const f = s.contentArea.children, d = E.children.filter((x) => x.attributes.class.includes("xfaContentarea"));
      c = !1, this[Y].firstUnsplittable = null, this[Y].noLayoutFailure = !1;
      const u = (x) => {
        var p;
        const m = A[ba]();
        m && (c || (c = ((p = m.children) == null ? void 0 : p.length) > 0), d[x].children.push(m));
      };
      for (let x = h, m = f.length; x < m; x++) {
        const p = this[Y].currentContentArea = f[x], D = {
          width: p.w,
          height: p.h
        };
        h = 0, o && (d[x].children.push(o[SA](D).html), o = null), I && (d[x].children.push(I[SA](D).html), I = null);
        const F = A[SA](D);
        if (F.success)
          return F.html ? (c || (c = ((Q = F.html.children) == null ? void 0 : Q.length) > 0), d[x].children.push(F.html)) : !c && i.children.length > 1 && i.children.pop(), i;
        if (F.isBreak()) {
          const y = F.breakNode;
          if (u(x), y.targetType === "auto")
            continue;
          y.leader && (o = this[Bi](y.leader, y[MA]()), o = o ? o[0] : null), y.trailer && (I = this[Bi](y.trailer, y[MA]()), I = I ? I[0] : null), y.targetType === "pageArea" ? (g = y[Y].target, x = 1 / 0) : y[Y].target ? (g = y[Y].target, h = y[Y].index + 1, x = 1 / 0) : x = y[Y].index;
          continue;
        }
        if (this[Y].overflowNode) {
          const y = this[Y].overflowNode;
          this[Y].overflowNode = null;
          const H = y[Oe](), N = H.target;
          H.addLeader = H.leader !== null, H.addTrailer = H.trailer !== null, u(x);
          const T = x;
          if (x = 1 / 0, N instanceof gs)
            g = N;
          else if (N instanceof Qo) {
            const _ = f.indexOf(N);
            _ !== -1 ? _ > T ? x = _ - 1 : h = _ : (g = N[MA](), h = g.contentArea.children.indexOf(N));
          }
          continue;
        }
        u(x);
      }
      this[Y].pageNumber += 1, g && (g[na]() ? g[Y].numberOfUse += 1 : g = null), s = g || s[hi](), yield null;
    }
  }
}
class Xl extends Ee {
  constructor(A) {
    super(eA, "text"), this.id = A.id || "", this.maxChars = RA({
      data: A.maxChars,
      defaultValue: 0,
      validate: (t) => t >= 0
    }), this.name = A.name || "", this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [nr]() {
    return !0;
  }
  [si](A) {
    return A[pe] === we.xhtml.id ? (this[P] = A, !0) : (k(`XFA - Invalid content in Text: ${A[XA]}.`), !1);
  }
  [ui](A) {
    this[P] instanceof K || super[ui](A);
  }
  [ae]() {
    typeof this[P] == "string" && (this[P] = this[P].replaceAll(`\r
`, `
`));
  }
  [Oe]() {
    return typeof this[P] == "string" ? this[P].split(/[\u2029\u2028\n]/).reduce((A, t) => (t && A.push(t), A), []).join(`
`) : this[P][Se]();
  }
  [SA](A) {
    if (typeof this[P] == "string") {
      const t = Oi(this[P]).html;
      return this[P].includes("\u2029") ? (t.name = "div", t.children = [], this[P].split("\u2029").map((i) => i.split(/[\u2028\n]/).reduce((s, a) => (s.push({
        name: "span",
        value: a
      }, {
        name: "br"
      }), s), [])).forEach((i) => {
        t.children.push({
          name: "p",
          children: i
        });
      })) : /[\u2028\n]/.test(this[P]) && (t.name = "div", t.children = [], this[P].split(/[\u2028\n]/).forEach((i) => {
        t.children.push({
          name: "span",
          value: i
        }, {
          name: "br"
        });
      })), dA.success(t);
    }
    return this[P][SA](A);
  }
}
class _l extends K {
  constructor(A) {
    super(eA, "textEdit", !0), this.allowRichText = RA({
      data: A.allowRichText,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.hScrollPolicy = O(A.hScrollPolicy, ["auto", "off", "on"]), this.id = A.id || "", this.multiLine = RA({
      data: A.multiLine,
      defaultValue: "",
      validate: (t) => t === 0 || t === 1
    }), this.use = A.use || "", this.usehref = A.usehref || "", this.vScrollPolicy = O(A.vScrollPolicy, ["auto", "off", "on"]), this.border = null, this.comb = null, this.extras = null, this.margin = null;
  }
  [SA](A) {
    var a, n;
    const t = nt(this, "border", "font", "margin");
    let i;
    const s = this[MA]()[MA]();
    return this.multiLine === "" && (this.multiLine = s instanceof Pl ? 1 : 0), this.multiLine === 1 ? i = {
      name: "textarea",
      attributes: {
        dataId: ((a = s[Mt]) == null ? void 0 : a[ee]) || s[ee],
        fieldId: s[ee],
        class: ["xfaTextfield"],
        style: t,
        "aria-label": E0(s),
        "aria-required": !1
      }
    } : i = {
      name: "input",
      attributes: {
        type: "text",
        dataId: ((n = s[Mt]) == null ? void 0 : n[ee]) || s[ee],
        fieldId: s[ee],
        class: ["xfaTextfield"],
        style: t,
        "aria-label": E0(s),
        "aria-required": !1
      }
    }, Da(s) && (i.attributes["aria-required"] = !0, i.attributes.required = !0), dA.success({
      name: "label",
      attributes: {
        class: ["xfaLabel"]
      },
      children: [i]
    });
  }
}
class Kf extends TA {
  constructor(A) {
    super(eA, "time"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
  [ae]() {
    const A = this[P].trim();
    this[P] = A ? new Date(A) : null;
  }
  [SA](A) {
    return Oi(this[P] ? this[P].toString() : "");
  }
}
class vf extends K {
  constructor(A) {
    super(eA, "timeStamp"), this.id = A.id || "", this.server = A.server || "", this.type = O(A.type, ["optional", "required"]), this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class Tf extends TA {
  constructor(A) {
    super(eA, "toolTip"), this.id = A.id || "", this.rid = A.rid || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class qf extends K {
  constructor(A) {
    super(eA, "traversal", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.traverse = new b();
  }
}
class Pf extends K {
  constructor(A) {
    super(eA, "traverse", !0), this.id = A.id || "", this.operation = O(A.operation, ["next", "back", "down", "first", "left", "right", "up"]), this.ref = A.ref || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.script = null;
  }
  get name() {
    return this.operation;
  }
  [aa]() {
    return !1;
  }
}
class xo extends K {
  constructor(A) {
    super(eA, "ui", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.picture = null, this.barcode = null, this.button = null, this.checkButton = null, this.choiceList = null, this.dateTimeEdit = null, this.defaultUi = null, this.imageEdit = null, this.numericEdit = null, this.passwordEdit = null, this.signature = null, this.textEdit = null;
  }
  [Oe]() {
    if (this[Y] === void 0) {
      for (const A of Object.getOwnPropertyNames(this)) {
        if (A === "extras" || A === "picture")
          continue;
        const t = this[A];
        if (t instanceof K)
          return this[Y] = t, t;
      }
      this[Y] = null;
    }
    return this[Y];
  }
  [SA](A) {
    const t = this[Oe]();
    return t ? t[SA](A) : dA.EMPTY;
  }
}
class Wf extends K {
  constructor(A) {
    super(eA, "validate", !0), this.formatTest = O(A.formatTest, ["warning", "disabled", "error"]), this.id = A.id || "", this.nullTest = O(A.nullTest, ["disabled", "error", "warning"]), this.scriptTest = O(A.scriptTest, ["error", "disabled", "warning"]), this.use = A.use || "", this.usehref = A.usehref || "", this.extras = null, this.message = null, this.picture = null, this.script = null;
  }
}
class mo extends K {
  constructor(A) {
    super(eA, "value", !0), this.id = A.id || "", this.override = RA({
      data: A.override,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.relevant = Zt(A.relevant), this.use = A.use || "", this.usehref = A.usehref || "", this.arc = null, this.boolean = null, this.date = null, this.dateTime = null, this.decimal = null, this.exData = null, this.float = null, this.image = null, this.integer = null, this.line = null, this.rectangle = null, this.text = null, this.time = null;
  }
  [Bt](A) {
    var s;
    const t = this[MA]();
    if (t instanceof Eo && (s = t.ui) != null && s.imageEdit) {
      this.image || (this.image = new Ol({}), this[Be](this.image)), this.image[P] = A[P];
      return;
    }
    const i = A[XA];
    if (this[i] !== null) {
      this[i][P] = A[P];
      return;
    }
    for (const a of Object.getOwnPropertyNames(this)) {
      const n = this[a];
      n instanceof K && (this[a] = null, this[qi](n));
    }
    this[A[XA]] = A, this[Be](A);
  }
  [Se]() {
    if (this.exData)
      return typeof this.exData[P] == "string" ? this.exData[P].trim() : this.exData[P][Se]().trim();
    for (const A of Object.getOwnPropertyNames(this)) {
      if (A === "image")
        continue;
      const t = this[A];
      if (t instanceof K)
        return (t[P] || "").toString().trim();
    }
    return null;
  }
  [SA](A) {
    for (const t of Object.getOwnPropertyNames(this)) {
      const i = this[t];
      if (i instanceof K)
        return i[SA](A);
    }
    return dA.EMPTY;
  }
}
class Of extends K {
  constructor(A) {
    super(eA, "variables", !0), this.id = A.id || "", this.use = A.use || "", this.usehref = A.usehref || "", this.boolean = new b(), this.date = new b(), this.dateTime = new b(), this.decimal = new b(), this.exData = new b(), this.float = new b(), this.image = new b(), this.integer = new b(), this.manifest = new b(), this.script = new b(), this.text = new b(), this.time = new b();
  }
  [aa]() {
    return !0;
  }
}
class Mn {
  static [Vt](A, t) {
    if (Mn.hasOwnProperty(A)) {
      const i = Mn[A](t);
      return i[ul](t), i;
    }
  }
  static appearanceFilter(A) {
    return new CE(A);
  }
  static arc(A) {
    return new Hl(A);
  }
  static area(A) {
    return new BE(A);
  }
  static assist(A) {
    return new QE(A);
  }
  static barcode(A) {
    return new EE(A);
  }
  static bind(A) {
    return new fE(A);
  }
  static bindItems(A) {
    return new Gg(A);
  }
  static bookend(A) {
    return new uE(A);
  }
  static boolean(A) {
    return new dE(A);
  }
  static border(A) {
    return new Jl(A);
  }
  static break(A) {
    return new xE(A);
  }
  static breakAfter(A) {
    return new Yl(A);
  }
  static breakBefore(A) {
    return new Kl(A);
  }
  static button(A) {
    return new mE(A);
  }
  static calculate(A) {
    return new pE(A);
  }
  static caption(A) {
    return new yE(A);
  }
  static certificate(A) {
    return new wE(A);
  }
  static certificates(A) {
    return new bE(A);
  }
  static checkButton(A) {
    return new vl(A);
  }
  static choiceList(A) {
    return new Tl(A);
  }
  static color(A) {
    return new DE(A);
  }
  static comb(A) {
    return new kE(A);
  }
  static connect(A) {
    return new SE(A);
  }
  static contentArea(A) {
    return new Qo(A);
  }
  static corner(A) {
    return new ql(A);
  }
  static date(A) {
    return new FE(A);
  }
  static dateTime(A) {
    return new RE(A);
  }
  static dateTimeEdit(A) {
    return new GE(A);
  }
  static decimal(A) {
    return new NE(A);
  }
  static defaultUi(A) {
    return new ME(A);
  }
  static desc(A) {
    return new UE(A);
  }
  static digestMethod(A) {
    return new LE(A);
  }
  static digestMethods(A) {
    return new HE(A);
  }
  static draw(A) {
    return new Pl(A);
  }
  static edge(A) {
    return new ka(A);
  }
  static encoding(A) {
    return new JE(A);
  }
  static encodings(A) {
    return new YE(A);
  }
  static encrypt(A) {
    return new KE(A);
  }
  static encryptData(A) {
    return new vE(A);
  }
  static encryption(A) {
    return new TE(A);
  }
  static encryptionMethod(A) {
    return new qE(A);
  }
  static encryptionMethods(A) {
    return new PE(A);
  }
  static event(A) {
    return new WE(A);
  }
  static exData(A) {
    return new OE(A);
  }
  static exObject(A) {
    return new VE(A);
  }
  static exclGroup(A) {
    return new Wl(A);
  }
  static execute(A) {
    return new ZE(A);
  }
  static extras(A) {
    return new jE(A);
  }
  static field(A) {
    return new Eo(A);
  }
  static fill(A) {
    return new XE(A);
  }
  static filter(A) {
    return new _E(A);
  }
  static float(A) {
    return new zE(A);
  }
  static font(A) {
    return new $E(A);
  }
  static format(A) {
    return new Af(A);
  }
  static handler(A) {
    return new ef(A);
  }
  static hyphenation(A) {
    return new tf(A);
  }
  static image(A) {
    return new Ol(A);
  }
  static imageEdit(A) {
    return new sf(A);
  }
  static integer(A) {
    return new af(A);
  }
  static issuers(A) {
    return new nf(A);
  }
  static items(A) {
    return new Ng(A);
  }
  static keep(A) {
    return new rf(A);
  }
  static keyUsage(A) {
    return new gf(A);
  }
  static line(A) {
    return new of(A);
  }
  static linear(A) {
    return new If(A);
  }
  static lockDocument(A) {
    return new cf(A);
  }
  static manifest(A) {
    return new lf(A);
  }
  static margin(A) {
    return new hf(A);
  }
  static mdp(A) {
    return new Cf(A);
  }
  static medium(A) {
    return new Bf(A);
  }
  static message(A) {
    return new Qf(A);
  }
  static numericEdit(A) {
    return new Ef(A);
  }
  static occur(A) {
    return new ff(A);
  }
  static oid(A) {
    return new uf(A);
  }
  static oids(A) {
    return new df(A);
  }
  static overflow(A) {
    return new Vl(A);
  }
  static pageArea(A) {
    return new gs(A);
  }
  static pageSet(A) {
    return new ra(A);
  }
  static para(A) {
    return new xf(A);
  }
  static passwordEdit(A) {
    return new mf(A);
  }
  static pattern(A) {
    return new pf(A);
  }
  static picture(A) {
    return new yf(A);
  }
  static proto(A) {
    return new wf(A);
  }
  static radial(A) {
    return new bf(A);
  }
  static reason(A) {
    return new Df(A);
  }
  static reasons(A) {
    return new kf(A);
  }
  static rectangle(A) {
    return new Zl(A);
  }
  static ref(A) {
    return new Sf(A);
  }
  static script(A) {
    return new Ff(A);
  }
  static setProperty(A) {
    return new Mg(A);
  }
  static signData(A) {
    return new Rf(A);
  }
  static signature(A) {
    return new Gf(A);
  }
  static signing(A) {
    return new Nf(A);
  }
  static solid(A) {
    return new Mf(A);
  }
  static speak(A) {
    return new Uf(A);
  }
  static stipple(A) {
    return new Lf(A);
  }
  static subform(A) {
    return new jl(A);
  }
  static subformSet(A) {
    return new fo(A);
  }
  static subjectDN(A) {
    return new Hf(A);
  }
  static subjectDNs(A) {
    return new Jf(A);
  }
  static submit(A) {
    return new Yf(A);
  }
  static template(A) {
    return new uo(A);
  }
  static text(A) {
    return new Xl(A);
  }
  static textEdit(A) {
    return new _l(A);
  }
  static time(A) {
    return new Kf(A);
  }
  static timeStamp(A) {
    return new vf(A);
  }
  static toolTip(A) {
    return new Tf(A);
  }
  static traversal(A) {
    return new qf(A);
  }
  static traverse(A) {
    return new Pf(A);
  }
  static ui(A) {
    return new xo(A);
  }
  static validate(A) {
    return new Wf(A);
  }
  static value(A) {
    return new mo(A);
  }
  static variables(A) {
    return new Of(A);
  }
}
const Ac = we.datasets.id;
function en(e) {
  const A = new Xl({});
  return A[P] = e, A;
}
class Vf {
  constructor(A) {
    var t;
    this.root = A, this.datasets = A.datasets, this.data = ((t = A.datasets) == null ? void 0 : t.data) || new ai(we.datasets.id, "data"), this.emptyMerge = this.data[He]().length === 0, this.root.form = this.form = A.template[Pt]();
  }
  _isConsumeData() {
    return !this.emptyMerge && this._mergeMode;
  }
  _isMatchTemplate() {
    return !this._isConsumeData();
  }
  bind() {
    return this._bindElement(this.form, this.data), this.form;
  }
  getData() {
    return this.data;
  }
  _bindValue(A, t, i) {
    var s, a;
    if (A[Mt] = t, A[sa]())
      if (t[J0]()) {
        const n = t[ro]();
        A[Bt](en(n));
      } else if (A instanceof Eo && ((a = (s = A.ui) == null ? void 0 : s.choiceList) == null ? void 0 : a.open) === "multiSelect") {
        const n = t[He]().map((r) => r[P].trim()).join(`
`);
        A[Bt](en(n));
      } else this._isConsumeData() && k("XFA - Nodes haven't the same type.");
    else !t[J0]() || this._isMatchTemplate() ? this._bindElement(A, t) : k("XFA - Nodes haven't the same type.");
  }
  _findDataByNameToConsume(A, t, i, s) {
    if (!A)
      return null;
    let a, n;
    for (let r = 0; r < 3; r++) {
      for (a = i[Ks](A, !1, !0); n = a.next().value, !!n; )
        if (t === n[J0]())
          return n;
      if (i[pe] === we.datasets.id && i[XA] === "data")
        break;
      i = i[MA]();
    }
    return s ? (a = this.data[Ks](A, !0, !1), n = a.next().value, n || (a = this.data[Dg](A, !0), n = a.next().value, n != null && n[J0]()) ? n : null) : null;
  }
  _setProperties(A, t) {
    if (A.hasOwnProperty("setProperty"))
      for (const {
        ref: i,
        target: s,
        connection: a
      } of A.setProperty.children) {
        if (a || !i)
          continue;
        const n = Fi(this.root, t, i, !1, !1);
        if (!n) {
          k(`XFA - Invalid reference: ${i}.`);
          continue;
        }
        const [r] = n;
        if (!r[Mi](this.data)) {
          k("XFA - Invalid node: must be a data node.");
          continue;
        }
        const g = Fi(this.root, A, s, !1, !1);
        if (!g) {
          k(`XFA - Invalid target: ${s}.`);
          continue;
        }
        const [o] = g;
        if (!o[Mi](A)) {
          k("XFA - Invalid target: must be a property or subproperty.");
          continue;
        }
        const I = o[MA]();
        if (o instanceof Mg || I instanceof Mg) {
          k("XFA - Invalid target: cannot be a setProperty or one of its properties.");
          continue;
        }
        if (o instanceof Gg || I instanceof Gg) {
          k("XFA - Invalid target: cannot be a bindItems or one of its properties.");
          continue;
        }
        const c = r[Se](), l = o[XA];
        if (o instanceof Io) {
          const h = /* @__PURE__ */ Object.create(null);
          h[l] = c;
          const C = Reflect.construct(Object.getPrototypeOf(I).constructor, [h]);
          I[l] = C[l];
          continue;
        }
        if (!o.hasOwnProperty(P)) {
          k("XFA - Invalid node to use in setProperty");
          continue;
        }
        o[Mt] = r, o[P] = c, o[ae]();
      }
  }
  _bindItems(A, t) {
    if (!A.hasOwnProperty("items") || !A.hasOwnProperty("bindItems") || A.bindItems.isEmpty())
      return;
    for (const a of A.items.children)
      A[qi](a);
    A.items.clear();
    const i = new Ng({}), s = new Ng({});
    A[Be](i), A.items.push(i), A[Be](s), A.items.push(s);
    for (const {
      ref: a,
      labelRef: n,
      valueRef: r,
      connection: g
    } of A.bindItems.children) {
      if (g || !a)
        continue;
      const o = Fi(this.root, t, a, !1, !1);
      if (!o) {
        k(`XFA - Invalid reference: ${a}.`);
        continue;
      }
      for (const I of o) {
        if (!I[Mi](this.datasets)) {
          k(`XFA - Invalid ref (${a}): must be a datasets child.`);
          continue;
        }
        const c = Fi(this.root, I, n, !0, !1);
        if (!c) {
          k(`XFA - Invalid label: ${n}.`);
          continue;
        }
        const [l] = c;
        if (!l[Mi](this.datasets)) {
          k("XFA - Invalid label: must be a datasets child.");
          continue;
        }
        const h = Fi(this.root, I, r, !0, !1);
        if (!h) {
          k(`XFA - Invalid value: ${r}.`);
          continue;
        }
        const [C] = h;
        if (!C[Mi](this.datasets)) {
          k("XFA - Invalid value: must be a datasets child.");
          continue;
        }
        const B = en(l[Se]()), Q = en(C[Se]());
        i[Be](B), i.text.push(B), s[Be](Q), s.text.push(Q);
      }
    }
  }
  _bindOccurrences(A, t, i) {
    let s;
    if (t.length > 1 && (s = A[Pt](), s[qi](s.occur), s.occur = null), this._bindValue(A, t[0], i), this._setProperties(A, t[0]), this._bindItems(A, t[0]), t.length === 1)
      return;
    const a = A[MA](), n = A[XA], r = a[kg](A);
    for (let g = 1, o = t.length; g < o; g++) {
      const I = t[g], c = s[Pt]();
      a[n].push(c), a[fn](r + g, c), this._bindValue(c, I, i), this._setProperties(c, I), this._bindItems(c, I);
    }
  }
  _createOccurrences(A) {
    if (!this.emptyMerge)
      return;
    const {
      occur: t
    } = A;
    if (!t || t.initial <= 1)
      return;
    const i = A[MA](), s = A[XA];
    if (!(i[s] instanceof b))
      return;
    let a;
    A.name ? a = i[s].children.filter((g) => g.name === A.name).length : a = i[s].children.length;
    const n = i[kg](A) + 1, r = t.initial - a;
    if (r) {
      const g = A[Pt]();
      g[qi](g.occur), g.occur = null, i[s].push(g), i[fn](n, g);
      for (let o = 1; o < r; o++) {
        const I = g[Pt]();
        i[s].push(I), i[fn](n + o, I);
      }
    }
  }
  _getOccurInfo(A) {
    const {
      name: t,
      occur: i
    } = A;
    if (!i || !t)
      return [1, 1];
    const s = i.max === -1 ? 1 / 0 : i.max;
    return [i.min, s];
  }
  _setAndBind(A, t) {
    this._setProperties(A, t), this._bindItems(A, t), this._bindElement(A, t);
  }
  _bindElement(A, t) {
    const i = [];
    this._createOccurrences(A);
    for (const s of A[He]()) {
      if (s[Mt])
        continue;
      if (this._mergeMode === void 0 && s[XA] === "subform") {
        this._mergeMode = s.mergeMode === "consumeData";
        const c = t[He]();
        if (c.length > 0)
          this._bindOccurrences(s, [c[0]], null);
        else if (this.emptyMerge) {
          const l = t[pe] === Ac ? -1 : t[pe], h = s[Mt] = new ai(l, s.name || "root");
          t[Be](h), this._bindElement(s, h);
        }
        continue;
      }
      if (!s[u0]())
        continue;
      let a = !1, n = null, r = null, g = null;
      if (s.bind) {
        switch (s.bind.match) {
          case "none":
            this._setAndBind(s, t);
            continue;
          case "global":
            a = !0;
            break;
          case "dataRef":
            if (!s.bind.ref) {
              k(`XFA - ref is empty in node ${s[XA]}.`), this._setAndBind(s, t);
              continue;
            }
            r = s.bind.ref;
            break;
        }
        s.bind.picture && (n = s.bind.picture[P]);
      }
      const [o, I] = this._getOccurInfo(s);
      if (r)
        if (g = Fi(this.root, t, r, !0, !1), g === null) {
          if (g = rE(this.data, t, r), !g)
            continue;
          this._isConsumeData() && (g[ei] = !0), this._setAndBind(s, g);
          continue;
        } else
          this._isConsumeData() && (g = g.filter((c) => !c[ei])), g.length > I ? g = g.slice(0, I) : g.length === 0 && (g = null), g && this._isConsumeData() && g.forEach((c) => {
            c[ei] = !0;
          });
      else {
        if (!s.name) {
          this._setAndBind(s, t);
          continue;
        }
        if (this._isConsumeData()) {
          const c = [];
          for (; c.length < I; ) {
            const l = this._findDataByNameToConsume(s.name, s[sa](), t, a);
            if (!l)
              break;
            l[ei] = !0, c.push(l);
          }
          g = c.length > 0 ? c : null;
        } else {
          if (g = t[Ks](s.name, !1, this.emptyMerge).next().value, !g) {
            if (o === 0) {
              i.push(s);
              continue;
            }
            const c = t[pe] === Ac ? -1 : t[pe];
            g = s[Mt] = new ai(c, s.name), this.emptyMerge && (g[ei] = !0), t[Be](g), this._setAndBind(s, g);
            continue;
          }
          this.emptyMerge && (g[ei] = !0), g = [g];
        }
      }
      g ? this._bindOccurrences(s, g, n) : o > 0 ? this._setAndBind(s, t) : i.push(s);
    }
    i.forEach((s) => s[MA]()[qi](s));
  }
}
class Zf {
  constructor(A, t) {
    this.data = t, this.dataset = A.datasets || null;
  }
  serialize(A) {
    const t = [[-1, this.data[He]()]];
    for (; t.length > 0; ) {
      const s = t.at(-1), [a, n] = s;
      if (a + 1 === n.length) {
        t.pop();
        continue;
      }
      const r = n[++s[0]], g = A.get(r[ee]);
      if (g)
        r[Bt](g);
      else {
        const I = r[El]();
        for (const c of I.values()) {
          const l = A.get(c[ee]);
          if (l) {
            c[Bt](l);
            break;
          }
        }
      }
      const o = r[He]();
      o.length > 0 && t.push([-1, o]);
    }
    const i = ['<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'];
    if (this.dataset)
      for (const s of this.dataset[He]())
        s[XA] !== "data" && s[Ts](i);
    return this.data[Ts](i), i.push("</xfa:datasets>"), i.join("");
  }
}
const j = we.config.id;
class jf extends K {
  constructor(A) {
    super(j, "acrobat", !0), this.acrobat7 = null, this.autoSave = null, this.common = null, this.validate = null, this.validateApprovalSignatures = null, this.submitUrl = new b();
  }
}
class Xf extends K {
  constructor(A) {
    super(j, "acrobat7", !0), this.dynamicRender = null;
  }
}
class _f extends te {
  constructor(A) {
    super(j, "ADBE_JSConsole", ["delegate", "Enable", "Disable"]);
  }
}
class zf extends te {
  constructor(A) {
    super(j, "ADBE_JSDebugger", ["delegate", "Enable", "Disable"]);
  }
}
class $f extends Fe {
  constructor(A) {
    super(j, "addSilentPrint");
  }
}
class Au extends Fe {
  constructor(A) {
    super(j, "addViewerPreferences");
  }
}
class eu extends yl {
  constructor(A) {
    super(j, "adjustData");
  }
}
class tu extends jt {
  constructor(A) {
    super(j, "adobeExtensionLevel", 0, (t) => t >= 1 && t <= 8);
  }
}
class iu extends K {
  constructor(A) {
    super(j, "agent", !0), this.name = A.name ? A.name.trim() : "", this.common = new b();
  }
}
class su extends Ee {
  constructor(A) {
    super(j, "alwaysEmbed");
  }
}
class au extends TA {
  constructor(A) {
    super(j, "amd");
  }
}
class nu extends K {
  constructor(A) {
    super(j, "area"), this.level = RA({
      data: A.level,
      defaultValue: 0,
      validate: (t) => t >= 1 && t <= 3
    }), this.name = O(A.name, ["", "barcode", "coreinit", "deviceDriver", "font", "general", "layout", "merge", "script", "signature", "sourceSet", "templateCache"]);
  }
}
class ru extends te {
  constructor(A) {
    super(j, "attributes", ["preserve", "delegate", "ignore"]);
  }
}
class gu extends te {
  constructor(A) {
    super(j, "autoSave", ["disabled", "enabled"]);
  }
}
class ou extends TA {
  constructor(A) {
    super(j, "base");
  }
}
class Iu extends K {
  constructor(A) {
    super(j, "batchOutput"), this.format = O(A.format, ["none", "concat", "zip", "zipCompress"]);
  }
}
class cu extends Ee {
  constructor(A) {
    super(j, "behaviorOverride");
  }
  [ae]() {
    this[P] = new Map(this[P].trim().split(/\s+/).filter((A) => A.includes(":")).map((A) => A.split(":", 2)));
  }
}
class lu extends K {
  constructor(A) {
    super(j, "cache", !0), this.templateCache = null;
  }
}
class hu extends Fe {
  constructor(A) {
    super(j, "change");
  }
}
class Cu extends K {
  constructor(A) {
    super(j, "common", !0), this.data = null, this.locale = null, this.localeSet = null, this.messaging = null, this.suppressBanner = null, this.template = null, this.validationMessaging = null, this.versionControl = null, this.log = new b();
  }
}
class Bu extends K {
  constructor(A) {
    super(j, "compress"), this.scope = O(A.scope, ["imageOnly", "document"]);
  }
}
class Qu extends Fe {
  constructor(A) {
    super(j, "compressLogicalStructure");
  }
}
class Eu extends yl {
  constructor(A) {
    super(j, "compressObjectStream");
  }
}
class fu extends K {
  constructor(A) {
    super(j, "compression", !0), this.compressLogicalStructure = null, this.compressObjectStream = null, this.level = null, this.type = null;
  }
}
class uu extends K {
  constructor(A) {
    super(j, "config", !0), this.acrobat = null, this.present = null, this.trace = null, this.agent = new b();
  }
}
class du extends te {
  constructor(A) {
    super(j, "conformance", ["A", "B"]);
  }
}
class xu extends Fe {
  constructor(A) {
    super(j, "contentCopy");
  }
}
class mu extends jt {
  constructor(A) {
    super(j, "copies", 1, (t) => t >= 1);
  }
}
class pu extends TA {
  constructor(A) {
    super(j, "creator");
  }
}
class yu extends jt {
  constructor(A) {
    super(j, "currentPage", 0, (t) => t >= 0);
  }
}
class wu extends K {
  constructor(A) {
    super(j, "data", !0), this.adjustData = null, this.attributes = null, this.incrementalLoad = null, this.outputXSL = null, this.range = null, this.record = null, this.startNode = null, this.uri = null, this.window = null, this.xsl = null, this.excludeNS = new b(), this.transform = new b();
  }
}
class bu extends K {
  constructor(A) {
    super(j, "debug", !0), this.uri = null;
  }
}
class Du extends Ee {
  constructor(A) {
    super(j, "defaultTypeface"), this.writingScript = O(A.writingScript, ["*", "Arabic", "Cyrillic", "EastEuropeanRoman", "Greek", "Hebrew", "Japanese", "Korean", "Roman", "SimplifiedChinese", "Thai", "TraditionalChinese", "Vietnamese"]);
  }
}
class ku extends te {
  constructor(A) {
    super(j, "destination", ["pdf", "pcl", "ps", "webClient", "zpl"]);
  }
}
class Su extends Fe {
  constructor(A) {
    super(j, "documentAssembly");
  }
}
class Fu extends K {
  constructor(A) {
    super(j, "driver", !0), this.name = A.name ? A.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class Ru extends te {
  constructor(A) {
    super(j, "duplexOption", ["simplex", "duplexFlipLongEdge", "duplexFlipShortEdge"]);
  }
}
class Gu extends te {
  constructor(A) {
    super(j, "dynamicRender", ["forbidden", "required"]);
  }
}
class Nu extends Fe {
  constructor(A) {
    super(j, "embed");
  }
}
class Mu extends Fe {
  constructor(A) {
    super(j, "encrypt");
  }
}
class Uu extends K {
  constructor(A) {
    super(j, "encryption", !0), this.encrypt = null, this.encryptionLevel = null, this.permissions = null;
  }
}
class Lu extends te {
  constructor(A) {
    super(j, "encryptionLevel", ["40bit", "128bit"]);
  }
}
class Hu extends TA {
  constructor(A) {
    super(j, "enforce");
  }
}
class Ju extends K {
  constructor(A) {
    super(j, "equate"), this.force = RA({
      data: A.force,
      defaultValue: 1,
      validate: (t) => t === 0
    }), this.from = A.from || "", this.to = A.to || "";
  }
}
class Yu extends K {
  constructor(A) {
    super(j, "equateRange"), this.from = A.from || "", this.to = A.to || "", this._unicodeRange = A.unicodeRange || "";
  }
  get unicodeRange() {
    const A = [], t = /U\+([0-9a-fA-F]+)/, i = this._unicodeRange;
    for (let s of i.split(",").map((a) => a.trim()).filter((a) => !!a))
      s = s.split("-", 2).map((a) => {
        const n = a.match(t);
        return n ? parseInt(n[1], 16) : 0;
      }), s.length === 1 && s.push(s[0]), A.push(s);
    return iA(this, "unicodeRange", A);
  }
}
class Ku extends Ee {
  constructor(A) {
    super(j, "exclude");
  }
  [ae]() {
    this[P] = this[P].trim().split(/\s+/).filter((A) => A && ["calculate", "close", "enter", "exit", "initialize", "ready", "validate"].includes(A));
  }
}
class vu extends TA {
  constructor(A) {
    super(j, "excludeNS");
  }
}
class Tu extends te {
  constructor(A) {
    super(j, "flipLabel", ["usePrinterSetting", "on", "off"]);
  }
}
class qu extends K {
  constructor(A) {
    super(j, "fontInfo", !0), this.embed = null, this.map = null, this.subsetBelow = null, this.alwaysEmbed = new b(), this.defaultTypeface = new b(), this.neverEmbed = new b();
  }
}
class Pu extends Fe {
  constructor(A) {
    super(j, "formFieldFilling");
  }
}
class Wu extends TA {
  constructor(A) {
    super(j, "groupParent");
  }
}
class Ou extends te {
  constructor(A) {
    super(j, "ifEmpty", ["dataValue", "dataGroup", "ignore", "remove"]);
  }
}
class Vu extends TA {
  constructor(A) {
    super(j, "includeXDPContent");
  }
}
class Zu extends te {
  constructor(A) {
    super(j, "incrementalLoad", ["none", "forwardOnly"]);
  }
}
class ju extends Fe {
  constructor(A) {
    super(j, "incrementalMerge");
  }
}
class Xu extends Fe {
  constructor(A) {
    super(j, "interactive");
  }
}
class _u extends te {
  constructor(A) {
    super(j, "jog", ["usePrinterSetting", "none", "pageSet"]);
  }
}
class zu extends K {
  constructor(A) {
    super(j, "labelPrinter", !0), this.name = O(A.name, ["zpl", "dpl", "ipl", "tcpl"]), this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class $u extends te {
  constructor(A) {
    super(j, "layout", ["paginate", "panel"]);
  }
}
class Ad extends jt {
  constructor(A) {
    super(j, "level", 0, (t) => t > 0);
  }
}
class ed extends Fe {
  constructor(A) {
    super(j, "linearized");
  }
}
class td extends TA {
  constructor(A) {
    super(j, "locale");
  }
}
class id extends TA {
  constructor(A) {
    super(j, "localeSet");
  }
}
class sd extends K {
  constructor(A) {
    super(j, "log", !0), this.mode = null, this.threshold = null, this.to = null, this.uri = null;
  }
}
class ad extends K {
  constructor(A) {
    super(j, "map", !0), this.equate = new b(), this.equateRange = new b();
  }
}
class nd extends K {
  constructor(A) {
    super(j, "mediumInfo", !0), this.map = null;
  }
}
class rd extends K {
  constructor(A) {
    super(j, "message", !0), this.msgId = null, this.severity = null;
  }
}
class gd extends K {
  constructor(A) {
    super(j, "messaging", !0), this.message = new b();
  }
}
class od extends te {
  constructor(A) {
    super(j, "mode", ["append", "overwrite"]);
  }
}
class Id extends Fe {
  constructor(A) {
    super(j, "modifyAnnots");
  }
}
class cd extends jt {
  constructor(A) {
    super(j, "msgId", 1, (t) => t >= 1);
  }
}
class ld extends TA {
  constructor(A) {
    super(j, "nameAttr");
  }
}
class hd extends Ee {
  constructor(A) {
    super(j, "neverEmbed");
  }
}
class Cd extends jt {
  constructor(A) {
    super(j, "numberOfCopies", null, (t) => t >= 2 && t <= 5);
  }
}
class Bd extends K {
  constructor(A) {
    super(j, "openAction", !0), this.destination = null;
  }
}
class Qd extends K {
  constructor(A) {
    super(j, "output", !0), this.to = null, this.type = null, this.uri = null;
  }
}
class Ed extends TA {
  constructor(A) {
    super(j, "outputBin");
  }
}
class fd extends K {
  constructor(A) {
    super(j, "outputXSL", !0), this.uri = null;
  }
}
class ud extends te {
  constructor(A) {
    super(j, "overprint", ["none", "both", "draw", "field"]);
  }
}
class dd extends TA {
  constructor(A) {
    super(j, "packets");
  }
  [ae]() {
    this[P] !== "*" && (this[P] = this[P].trim().split(/\s+/).filter((A) => ["config", "datasets", "template", "xfdf", "xslt"].includes(A)));
  }
}
class xd extends K {
  constructor(A) {
    super(j, "pageOffset"), this.x = RA({
      data: A.x,
      defaultValue: "useXDCSetting",
      validate: (t) => !0
    }), this.y = RA({
      data: A.y,
      defaultValue: "useXDCSetting",
      validate: (t) => !0
    });
  }
}
class md extends TA {
  constructor(A) {
    super(j, "pageRange");
  }
  [ae]() {
    const A = this[P].trim().split(/\s+/).map((i) => parseInt(i, 10)), t = [];
    for (let i = 0, s = A.length; i < s; i += 2)
      t.push(A.slice(i, i + 2));
    this[P] = t;
  }
}
class pd extends te {
  constructor(A) {
    super(j, "pagination", ["simplex", "duplexShortEdge", "duplexLongEdge"]);
  }
}
class yd extends te {
  constructor(A) {
    super(j, "paginationOverride", ["none", "forceDuplex", "forceDuplexLongEdge", "forceDuplexShortEdge", "forceSimplex"]);
  }
}
class wd extends jt {
  constructor(A) {
    super(j, "part", 1, (t) => !1);
  }
}
class bd extends K {
  constructor(A) {
    super(j, "pcl", !0), this.name = A.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.pageOffset = null, this.staple = null, this.xdc = null;
  }
}
class Dd extends K {
  constructor(A) {
    super(j, "pdf", !0), this.name = A.name || "", this.adobeExtensionLevel = null, this.batchOutput = null, this.compression = null, this.creator = null, this.encryption = null, this.fontInfo = null, this.interactive = null, this.linearized = null, this.openAction = null, this.pdfa = null, this.producer = null, this.renderPolicy = null, this.scriptModel = null, this.silentPrint = null, this.submitFormat = null, this.tagged = null, this.version = null, this.viewerPreferences = null, this.xdc = null;
  }
}
class kd extends K {
  constructor(A) {
    super(j, "pdfa", !0), this.amd = null, this.conformance = null, this.includeXDPContent = null, this.part = null;
  }
}
class Sd extends K {
  constructor(A) {
    super(j, "permissions", !0), this.accessibleContent = null, this.change = null, this.contentCopy = null, this.documentAssembly = null, this.formFieldFilling = null, this.modifyAnnots = null, this.plaintextMetadata = null, this.print = null, this.printHighQuality = null;
  }
}
class Fd extends Fe {
  constructor(A) {
    super(j, "pickTrayByPDFSize");
  }
}
class Rd extends TA {
  constructor(A) {
    super(j, "picture");
  }
}
class Gd extends Fe {
  constructor(A) {
    super(j, "plaintextMetadata");
  }
}
class Nd extends te {
  constructor(A) {
    super(j, "presence", ["preserve", "dissolve", "dissolveStructure", "ignore", "remove"]);
  }
}
class Md extends K {
  constructor(A) {
    super(j, "present", !0), this.behaviorOverride = null, this.cache = null, this.common = null, this.copies = null, this.destination = null, this.incrementalMerge = null, this.layout = null, this.output = null, this.overprint = null, this.pagination = null, this.paginationOverride = null, this.script = null, this.validate = null, this.xdp = null, this.driver = new b(), this.labelPrinter = new b(), this.pcl = new b(), this.pdf = new b(), this.ps = new b(), this.submitUrl = new b(), this.webClient = new b(), this.zpl = new b();
  }
}
class Ud extends Fe {
  constructor(A) {
    super(j, "print");
  }
}
class Ld extends Fe {
  constructor(A) {
    super(j, "printHighQuality");
  }
}
class Hd extends te {
  constructor(A) {
    super(j, "printScaling", ["appdefault", "noScaling"]);
  }
}
class Jd extends TA {
  constructor(A) {
    super(j, "printerName");
  }
}
class Yd extends TA {
  constructor(A) {
    super(j, "producer");
  }
}
class Kd extends K {
  constructor(A) {
    super(j, "ps", !0), this.name = A.name || "", this.batchOutput = null, this.fontInfo = null, this.jog = null, this.mediumInfo = null, this.outputBin = null, this.staple = null, this.xdc = null;
  }
}
class vd extends Ee {
  constructor(A) {
    super(j, "range");
  }
  [ae]() {
    this[P] = this[P].trim().split(/\s*,\s*/, 2).map((A) => A.split("-").map((t) => parseInt(t.trim(), 10))).filter((A) => A.every((t) => !isNaN(t))).map((A) => (A.length === 1 && A.push(A[0]), A));
  }
}
class Td extends Ee {
  constructor(A) {
    super(j, "record");
  }
  [ae]() {
    this[P] = this[P].trim();
    const A = parseInt(this[P], 10);
    !isNaN(A) && A >= 0 && (this[P] = A);
  }
}
class qd extends Ee {
  constructor(A) {
    super(j, "relevant");
  }
  [ae]() {
    this[P] = this[P].trim().split(/\s+/);
  }
}
class Pd extends Ee {
  constructor(A) {
    super(j, "rename");
  }
  [ae]() {
    this[P] = this[P].trim(), (this[P].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[P])) && k("XFA - Rename: invalid XFA name");
  }
}
class Wd extends te {
  constructor(A) {
    super(j, "renderPolicy", ["server", "client"]);
  }
}
class Od extends te {
  constructor(A) {
    super(j, "runScripts", ["both", "client", "none", "server"]);
  }
}
class Vd extends K {
  constructor(A) {
    super(j, "script", !0), this.currentPage = null, this.exclude = null, this.runScripts = null;
  }
}
class Zd extends te {
  constructor(A) {
    super(j, "scriptModel", ["XFA", "none"]);
  }
}
class jd extends te {
  constructor(A) {
    super(j, "severity", ["ignore", "error", "information", "trace", "warning"]);
  }
}
class Xd extends K {
  constructor(A) {
    super(j, "silentPrint", !0), this.addSilentPrint = null, this.printerName = null;
  }
}
class _d extends K {
  constructor(A) {
    super(j, "staple"), this.mode = O(A.mode, ["usePrinterSetting", "on", "off"]);
  }
}
class zd extends TA {
  constructor(A) {
    super(j, "startNode");
  }
}
class $d extends jt {
  constructor(A) {
    super(j, "startPage", 0, (t) => !0);
  }
}
class A2 extends te {
  constructor(A) {
    super(j, "submitFormat", ["html", "delegate", "fdf", "xml", "pdf"]);
  }
}
class e2 extends TA {
  constructor(A) {
    super(j, "submitUrl");
  }
}
class t2 extends jt {
  constructor(A) {
    super(j, "subsetBelow", 100, (t) => t >= 0 && t <= 100);
  }
}
class i2 extends Fe {
  constructor(A) {
    super(j, "suppressBanner");
  }
}
class s2 extends Fe {
  constructor(A) {
    super(j, "tagged");
  }
}
class a2 extends K {
  constructor(A) {
    super(j, "template", !0), this.base = null, this.relevant = null, this.startPage = null, this.uri = null, this.xsl = null;
  }
}
class n2 extends te {
  constructor(A) {
    super(j, "threshold", ["trace", "error", "information", "warning"]);
  }
}
class r2 extends te {
  constructor(A) {
    super(j, "to", ["null", "memory", "stderr", "stdout", "system", "uri"]);
  }
}
class g2 extends K {
  constructor(A) {
    super(j, "templateCache"), this.maxEntries = RA({
      data: A.maxEntries,
      defaultValue: 5,
      validate: (t) => t >= 0
    });
  }
}
class o2 extends K {
  constructor(A) {
    super(j, "trace", !0), this.area = new b();
  }
}
class I2 extends K {
  constructor(A) {
    super(j, "transform", !0), this.groupParent = null, this.ifEmpty = null, this.nameAttr = null, this.picture = null, this.presence = null, this.rename = null, this.whitespace = null;
  }
}
class c2 extends te {
  constructor(A) {
    super(j, "type", ["none", "ascii85", "asciiHex", "ccittfax", "flate", "lzw", "runLength", "native", "xdp", "mergedXDP"]);
  }
}
class l2 extends TA {
  constructor(A) {
    super(j, "uri");
  }
}
class h2 extends te {
  constructor(A) {
    super(j, "validate", ["preSubmit", "prePrint", "preExecute", "preSave"]);
  }
}
class C2 extends Ee {
  constructor(A) {
    super(j, "validateApprovalSignatures");
  }
  [ae]() {
    this[P] = this[P].trim().split(/\s+/).filter((A) => ["docReady", "postSign"].includes(A));
  }
}
class B2 extends te {
  constructor(A) {
    super(j, "validationMessaging", ["allMessagesIndividually", "allMessagesTogether", "firstMessageOnly", "noMessages"]);
  }
}
class Q2 extends te {
  constructor(A) {
    super(j, "version", ["1.7", "1.6", "1.5", "1.4", "1.3", "1.2"]);
  }
}
class E2 extends K {
  constructor(A) {
    super(j, "VersionControl"), this.outputBelow = O(A.outputBelow, ["warn", "error", "update"]), this.sourceAbove = O(A.sourceAbove, ["warn", "error"]), this.sourceBelow = O(A.sourceBelow, ["update", "maintain"]);
  }
}
class f2 extends K {
  constructor(A) {
    super(j, "viewerPreferences", !0), this.ADBE_JSConsole = null, this.ADBE_JSDebugger = null, this.addViewerPreferences = null, this.duplexOption = null, this.enforce = null, this.numberOfCopies = null, this.pageRange = null, this.pickTrayByPDFSize = null, this.printScaling = null;
  }
}
class u2 extends K {
  constructor(A) {
    super(j, "webClient", !0), this.name = A.name ? A.name.trim() : "", this.fontInfo = null, this.xdc = null;
  }
}
class d2 extends te {
  constructor(A) {
    super(j, "whitespace", ["preserve", "ltrim", "normalize", "rtrim", "trim"]);
  }
}
class x2 extends Ee {
  constructor(A) {
    super(j, "window");
  }
  [ae]() {
    const A = this[P].trim().split(/\s*,\s*/, 2).map((t) => parseInt(t, 10));
    if (A.some((t) => isNaN(t))) {
      this[P] = [0, 0];
      return;
    }
    A.length === 1 && A.push(A[0]), this[P] = A;
  }
}
class m2 extends K {
  constructor(A) {
    super(j, "xdc", !0), this.uri = new b(), this.xsl = new b();
  }
}
class p2 extends K {
  constructor(A) {
    super(j, "xdp", !0), this.packets = null;
  }
}
class y2 extends K {
  constructor(A) {
    super(j, "xsl", !0), this.debug = null, this.uri = null;
  }
}
class w2 extends K {
  constructor(A) {
    super(j, "zpl", !0), this.name = A.name ? A.name.trim() : "", this.batchOutput = null, this.flipLabel = null, this.fontInfo = null, this.xdc = null;
  }
}
class Un {
  static [Vt](A, t) {
    if (Un.hasOwnProperty(A))
      return Un[A](t);
  }
  static acrobat(A) {
    return new jf(A);
  }
  static acrobat7(A) {
    return new Xf(A);
  }
  static ADBE_JSConsole(A) {
    return new _f(A);
  }
  static ADBE_JSDebugger(A) {
    return new zf(A);
  }
  static addSilentPrint(A) {
    return new $f(A);
  }
  static addViewerPreferences(A) {
    return new Au(A);
  }
  static adjustData(A) {
    return new eu(A);
  }
  static adobeExtensionLevel(A) {
    return new tu(A);
  }
  static agent(A) {
    return new iu(A);
  }
  static alwaysEmbed(A) {
    return new su(A);
  }
  static amd(A) {
    return new au(A);
  }
  static area(A) {
    return new nu(A);
  }
  static attributes(A) {
    return new ru(A);
  }
  static autoSave(A) {
    return new gu(A);
  }
  static base(A) {
    return new ou(A);
  }
  static batchOutput(A) {
    return new Iu(A);
  }
  static behaviorOverride(A) {
    return new cu(A);
  }
  static cache(A) {
    return new lu(A);
  }
  static change(A) {
    return new hu(A);
  }
  static common(A) {
    return new Cu(A);
  }
  static compress(A) {
    return new Bu(A);
  }
  static compressLogicalStructure(A) {
    return new Qu(A);
  }
  static compressObjectStream(A) {
    return new Eu(A);
  }
  static compression(A) {
    return new fu(A);
  }
  static config(A) {
    return new uu(A);
  }
  static conformance(A) {
    return new du(A);
  }
  static contentCopy(A) {
    return new xu(A);
  }
  static copies(A) {
    return new mu(A);
  }
  static creator(A) {
    return new pu(A);
  }
  static currentPage(A) {
    return new yu(A);
  }
  static data(A) {
    return new wu(A);
  }
  static debug(A) {
    return new bu(A);
  }
  static defaultTypeface(A) {
    return new Du(A);
  }
  static destination(A) {
    return new ku(A);
  }
  static documentAssembly(A) {
    return new Su(A);
  }
  static driver(A) {
    return new Fu(A);
  }
  static duplexOption(A) {
    return new Ru(A);
  }
  static dynamicRender(A) {
    return new Gu(A);
  }
  static embed(A) {
    return new Nu(A);
  }
  static encrypt(A) {
    return new Mu(A);
  }
  static encryption(A) {
    return new Uu(A);
  }
  static encryptionLevel(A) {
    return new Lu(A);
  }
  static enforce(A) {
    return new Hu(A);
  }
  static equate(A) {
    return new Ju(A);
  }
  static equateRange(A) {
    return new Yu(A);
  }
  static exclude(A) {
    return new Ku(A);
  }
  static excludeNS(A) {
    return new vu(A);
  }
  static flipLabel(A) {
    return new Tu(A);
  }
  static fontInfo(A) {
    return new qu(A);
  }
  static formFieldFilling(A) {
    return new Pu(A);
  }
  static groupParent(A) {
    return new Wu(A);
  }
  static ifEmpty(A) {
    return new Ou(A);
  }
  static includeXDPContent(A) {
    return new Vu(A);
  }
  static incrementalLoad(A) {
    return new Zu(A);
  }
  static incrementalMerge(A) {
    return new ju(A);
  }
  static interactive(A) {
    return new Xu(A);
  }
  static jog(A) {
    return new _u(A);
  }
  static labelPrinter(A) {
    return new zu(A);
  }
  static layout(A) {
    return new $u(A);
  }
  static level(A) {
    return new Ad(A);
  }
  static linearized(A) {
    return new ed(A);
  }
  static locale(A) {
    return new td(A);
  }
  static localeSet(A) {
    return new id(A);
  }
  static log(A) {
    return new sd(A);
  }
  static map(A) {
    return new ad(A);
  }
  static mediumInfo(A) {
    return new nd(A);
  }
  static message(A) {
    return new rd(A);
  }
  static messaging(A) {
    return new gd(A);
  }
  static mode(A) {
    return new od(A);
  }
  static modifyAnnots(A) {
    return new Id(A);
  }
  static msgId(A) {
    return new cd(A);
  }
  static nameAttr(A) {
    return new ld(A);
  }
  static neverEmbed(A) {
    return new hd(A);
  }
  static numberOfCopies(A) {
    return new Cd(A);
  }
  static openAction(A) {
    return new Bd(A);
  }
  static output(A) {
    return new Qd(A);
  }
  static outputBin(A) {
    return new Ed(A);
  }
  static outputXSL(A) {
    return new fd(A);
  }
  static overprint(A) {
    return new ud(A);
  }
  static packets(A) {
    return new dd(A);
  }
  static pageOffset(A) {
    return new xd(A);
  }
  static pageRange(A) {
    return new md(A);
  }
  static pagination(A) {
    return new pd(A);
  }
  static paginationOverride(A) {
    return new yd(A);
  }
  static part(A) {
    return new wd(A);
  }
  static pcl(A) {
    return new bd(A);
  }
  static pdf(A) {
    return new Dd(A);
  }
  static pdfa(A) {
    return new kd(A);
  }
  static permissions(A) {
    return new Sd(A);
  }
  static pickTrayByPDFSize(A) {
    return new Fd(A);
  }
  static picture(A) {
    return new Rd(A);
  }
  static plaintextMetadata(A) {
    return new Gd(A);
  }
  static presence(A) {
    return new Nd(A);
  }
  static present(A) {
    return new Md(A);
  }
  static print(A) {
    return new Ud(A);
  }
  static printHighQuality(A) {
    return new Ld(A);
  }
  static printScaling(A) {
    return new Hd(A);
  }
  static printerName(A) {
    return new Jd(A);
  }
  static producer(A) {
    return new Yd(A);
  }
  static ps(A) {
    return new Kd(A);
  }
  static range(A) {
    return new vd(A);
  }
  static record(A) {
    return new Td(A);
  }
  static relevant(A) {
    return new qd(A);
  }
  static rename(A) {
    return new Pd(A);
  }
  static renderPolicy(A) {
    return new Wd(A);
  }
  static runScripts(A) {
    return new Od(A);
  }
  static script(A) {
    return new Vd(A);
  }
  static scriptModel(A) {
    return new Zd(A);
  }
  static severity(A) {
    return new jd(A);
  }
  static silentPrint(A) {
    return new Xd(A);
  }
  static staple(A) {
    return new _d(A);
  }
  static startNode(A) {
    return new zd(A);
  }
  static startPage(A) {
    return new $d(A);
  }
  static submitFormat(A) {
    return new A2(A);
  }
  static submitUrl(A) {
    return new e2(A);
  }
  static subsetBelow(A) {
    return new t2(A);
  }
  static suppressBanner(A) {
    return new i2(A);
  }
  static tagged(A) {
    return new s2(A);
  }
  static template(A) {
    return new a2(A);
  }
  static templateCache(A) {
    return new g2(A);
  }
  static threshold(A) {
    return new n2(A);
  }
  static to(A) {
    return new r2(A);
  }
  static trace(A) {
    return new o2(A);
  }
  static transform(A) {
    return new I2(A);
  }
  static type(A) {
    return new c2(A);
  }
  static uri(A) {
    return new l2(A);
  }
  static validate(A) {
    return new h2(A);
  }
  static validateApprovalSignatures(A) {
    return new C2(A);
  }
  static validationMessaging(A) {
    return new B2(A);
  }
  static version(A) {
    return new Q2(A);
  }
  static versionControl(A) {
    return new E2(A);
  }
  static viewerPreferences(A) {
    return new f2(A);
  }
  static webClient(A) {
    return new u2(A);
  }
  static whitespace(A) {
    return new d2(A);
  }
  static window(A) {
    return new x2(A);
  }
  static xdc(A) {
    return new m2(A);
  }
  static xdp(A) {
    return new p2(A);
  }
  static xsl(A) {
    return new y2(A);
  }
  static zpl(A) {
    return new w2(A);
  }
}
const Jt = we.connectionSet.id;
class b2 extends K {
  constructor(A) {
    super(Jt, "connectionSet", !0), this.wsdlConnection = new b(), this.xmlConnection = new b(), this.xsdConnection = new b();
  }
}
class D2 extends K {
  constructor(A) {
    super(Jt, "effectiveInputPolicy"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class k2 extends K {
  constructor(A) {
    super(Jt, "effectiveOutputPolicy"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class S2 extends TA {
  constructor(A) {
    super(Jt, "operation"), this.id = A.id || "", this.input = A.input || "", this.name = A.name || "", this.output = A.output || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class F2 extends TA {
  constructor(A) {
    super(Jt, "rootElement"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class R2 extends TA {
  constructor(A) {
    super(Jt, "soapAction"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class G2 extends TA {
  constructor(A) {
    super(Jt, "soapAddress"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class N2 extends TA {
  constructor(A) {
    super(Jt, "uri"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class M2 extends TA {
  constructor(A) {
    super(Jt, "wsdlAddress"), this.id = A.id || "", this.name = A.name || "", this.use = A.use || "", this.usehref = A.usehref || "";
  }
}
class U2 extends K {
  constructor(A) {
    super(Jt, "wsdlConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.effectiveInputPolicy = null, this.effectiveOutputPolicy = null, this.operation = null, this.soapAction = null, this.soapAddress = null, this.wsdlAddress = null;
  }
}
class L2 extends K {
  constructor(A) {
    super(Jt, "xmlConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.uri = null;
  }
}
class H2 extends K {
  constructor(A) {
    super(Jt, "xsdConnection", !0), this.dataDescription = A.dataDescription || "", this.name = A.name || "", this.rootElement = null, this.uri = null;
  }
}
class Ln {
  static [Vt](A, t) {
    if (Ln.hasOwnProperty(A))
      return Ln[A](t);
  }
  static connectionSet(A) {
    return new b2(A);
  }
  static effectiveInputPolicy(A) {
    return new D2(A);
  }
  static effectiveOutputPolicy(A) {
    return new k2(A);
  }
  static operation(A) {
    return new S2(A);
  }
  static rootElement(A) {
    return new F2(A);
  }
  static soapAction(A) {
    return new R2(A);
  }
  static soapAddress(A) {
    return new G2(A);
  }
  static uri(A) {
    return new N2(A);
  }
  static wsdlAddress(A) {
    return new M2(A);
  }
  static wsdlConnection(A) {
    return new U2(A);
  }
  static xmlConnection(A) {
    return new L2(A);
  }
  static xsdConnection(A) {
    return new H2(A);
  }
}
const Ug = we.datasets.id;
class J2 extends ai {
  constructor(A) {
    super(Ug, "data", A);
  }
  [vs]() {
    return !0;
  }
}
class Y2 extends K {
  constructor(A) {
    super(Ug, "datasets", !0), this.data = null, this.Signature = null;
  }
  [si](A) {
    const t = A[XA];
    (t === "data" && A[pe] === Ug || t === "Signature" && A[pe] === we.signature.id) && (this[t] = A), this[Be](A);
  }
}
class Hn {
  static [Vt](A, t) {
    if (Hn.hasOwnProperty(A))
      return Hn[A](t);
  }
  static datasets(A) {
    return new Y2(A);
  }
  static data(A) {
    return new J2(A);
  }
}
const fe = we.localeSet.id;
class K2 extends K {
  constructor(A) {
    super(fe, "calendarSymbols", !0), this.name = "gregorian", this.dayNames = new b(2), this.eraNames = null, this.meridiemNames = null, this.monthNames = new b(2);
  }
}
class v2 extends TA {
  constructor(A) {
    super(fe, "currencySymbol"), this.name = O(A.name, ["symbol", "isoname", "decimal"]);
  }
}
class T2 extends K {
  constructor(A) {
    super(fe, "currencySymbols", !0), this.currencySymbol = new b(3);
  }
}
class q2 extends TA {
  constructor(A) {
    super(fe, "datePattern"), this.name = O(A.name, ["full", "long", "med", "short"]);
  }
}
class P2 extends K {
  constructor(A) {
    super(fe, "datePatterns", !0), this.datePattern = new b(4);
  }
}
class W2 extends Ee {
  constructor(A) {
    super(fe, "dateTimeSymbols");
  }
}
class O2 extends TA {
  constructor(A) {
    super(fe, "day");
  }
}
class V2 extends K {
  constructor(A) {
    super(fe, "dayNames", !0), this.abbr = RA({
      data: A.abbr,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.day = new b(7);
  }
}
class Z2 extends TA {
  constructor(A) {
    super(fe, "era");
  }
}
class j2 extends K {
  constructor(A) {
    super(fe, "eraNames", !0), this.era = new b(2);
  }
}
class X2 extends K {
  constructor(A) {
    super(fe, "locale", !0), this.desc = A.desc || "", this.name = "isoname", this.calendarSymbols = null, this.currencySymbols = null, this.datePatterns = null, this.dateTimeSymbols = null, this.numberPatterns = null, this.numberSymbols = null, this.timePatterns = null, this.typeFaces = null;
  }
}
class _2 extends K {
  constructor(A) {
    super(fe, "localeSet", !0), this.locale = new b();
  }
}
class z2 extends TA {
  constructor(A) {
    super(fe, "meridiem");
  }
}
class $2 extends K {
  constructor(A) {
    super(fe, "meridiemNames", !0), this.meridiem = new b(2);
  }
}
class A9 extends TA {
  constructor(A) {
    super(fe, "month");
  }
}
class e9 extends K {
  constructor(A) {
    super(fe, "monthNames", !0), this.abbr = RA({
      data: A.abbr,
      defaultValue: 0,
      validate: (t) => t === 1
    }), this.month = new b(12);
  }
}
class t9 extends TA {
  constructor(A) {
    super(fe, "numberPattern"), this.name = O(A.name, ["full", "long", "med", "short"]);
  }
}
class i9 extends K {
  constructor(A) {
    super(fe, "numberPatterns", !0), this.numberPattern = new b(4);
  }
}
class s9 extends TA {
  constructor(A) {
    super(fe, "numberSymbol"), this.name = O(A.name, ["decimal", "grouping", "percent", "minus", "zero"]);
  }
}
class a9 extends K {
  constructor(A) {
    super(fe, "numberSymbols", !0), this.numberSymbol = new b(5);
  }
}
class n9 extends TA {
  constructor(A) {
    super(fe, "timePattern"), this.name = O(A.name, ["full", "long", "med", "short"]);
  }
}
class r9 extends K {
  constructor(A) {
    super(fe, "timePatterns", !0), this.timePattern = new b(4);
  }
}
class g9 extends K {
  constructor(A) {
    super(fe, "typeFace", !0), this.name = A.name | "";
  }
}
class o9 extends K {
  constructor(A) {
    super(fe, "typeFaces", !0), this.typeFace = new b();
  }
}
class Jn {
  static [Vt](A, t) {
    if (Jn.hasOwnProperty(A))
      return Jn[A](t);
  }
  static calendarSymbols(A) {
    return new K2(A);
  }
  static currencySymbol(A) {
    return new v2(A);
  }
  static currencySymbols(A) {
    return new T2(A);
  }
  static datePattern(A) {
    return new q2(A);
  }
  static datePatterns(A) {
    return new P2(A);
  }
  static dateTimeSymbols(A) {
    return new W2(A);
  }
  static day(A) {
    return new O2(A);
  }
  static dayNames(A) {
    return new V2(A);
  }
  static era(A) {
    return new Z2(A);
  }
  static eraNames(A) {
    return new j2(A);
  }
  static locale(A) {
    return new X2(A);
  }
  static localeSet(A) {
    return new _2(A);
  }
  static meridiem(A) {
    return new z2(A);
  }
  static meridiemNames(A) {
    return new $2(A);
  }
  static month(A) {
    return new A9(A);
  }
  static monthNames(A) {
    return new e9(A);
  }
  static numberPattern(A) {
    return new t9(A);
  }
  static numberPatterns(A) {
    return new i9(A);
  }
  static numberSymbol(A) {
    return new s9(A);
  }
  static numberSymbols(A) {
    return new a9(A);
  }
  static timePattern(A) {
    return new n9(A);
  }
  static timePatterns(A) {
    return new r9(A);
  }
  static typeFace(A) {
    return new g9(A);
  }
  static typeFaces(A) {
    return new o9(A);
  }
}
const I9 = we.signature.id;
class c9 extends K {
  constructor(A) {
    super(I9, "signature", !0);
  }
}
class Yn {
  static [Vt](A, t) {
    if (Yn.hasOwnProperty(A))
      return Yn[A](t);
  }
  static signature(A) {
    return new c9(A);
  }
}
const l9 = we.stylesheet.id;
class h9 extends K {
  constructor(A) {
    super(l9, "stylesheet", !0);
  }
}
class Kn {
  static [Vt](A, t) {
    if (Kn.hasOwnProperty(A))
      return Kn[A](t);
  }
  static stylesheet(A) {
    return new h9(A);
  }
}
const C9 = we.xdp.id;
class B9 extends K {
  constructor(A) {
    super(C9, "xdp", !0), this.uuid = A.uuid || "", this.timeStamp = A.timeStamp || "", this.config = null, this.connectionSet = null, this.datasets = null, this.localeSet = null, this.stylesheet = new b(), this.template = null;
  }
  [Sg](A) {
    const t = we[A[XA]];
    return t && A[pe] === t.id;
  }
}
class vn {
  static [Vt](A, t) {
    if (vn.hasOwnProperty(A))
      return vn[A](t);
  }
  static xdp(A) {
    return new B9(A);
  }
}
const Q9 = we.xhtml.id, tn = Symbol(), E9 = /* @__PURE__ */ new Set(["color", "font", "font-family", "font-size", "font-stretch", "font-style", "font-weight", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "letter-spacing", "line-height", "orphans", "page-break-after", "page-break-before", "page-break-inside", "tab-interval", "tab-stop", "text-align", "text-decoration", "text-indent", "vertical-align", "widows", "kerning-mode", "xfa-font-horizontal-scale", "xfa-font-vertical-scale", "xfa-spacerun", "xfa-tab-stops"]), f9 = /* @__PURE__ */ new Map([["page-break-after", "breakAfter"], ["page-break-before", "breakBefore"], ["page-break-inside", "breakInside"], ["kerning-mode", (e) => e === "none" ? "none" : "normal"], ["xfa-font-horizontal-scale", (e) => `scaleX(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], ["xfa-font-vertical-scale", (e) => `scaleY(${Math.max(0, Math.min(parseInt(e) / 100)).toFixed(2)})`], ["xfa-spacerun", ""], ["xfa-tab-stops", ""], ["font-size", (e, A) => (e = A.fontSize = Math.abs(lA(e)), FA(0.99 * e))], ["letter-spacing", (e) => FA(lA(e))], ["line-height", (e) => FA(lA(e))], ["margin", (e) => FA(lA(e))], ["margin-bottom", (e) => FA(lA(e))], ["margin-left", (e) => FA(lA(e))], ["margin-right", (e) => FA(lA(e))], ["margin-top", (e) => FA(lA(e))], ["text-indent", (e) => FA(lA(e))], ["font-family", (e) => e], ["vertical-align", (e) => FA(lA(e))]]), u9 = /\s+/g, d9 = /[\r\n]+/g, x9 = /\r\n?/g;
function m9(e, A, t) {
  const i = /* @__PURE__ */ Object.create(null);
  if (!e)
    return i;
  const s = /* @__PURE__ */ Object.create(null);
  for (const [a, n] of e.split(";").map((r) => r.split(":", 2))) {
    const r = f9.get(a);
    if (r === "")
      continue;
    let g = n;
    r && (g = typeof r == "string" ? r : r(n, s)), a.endsWith("scale") ? i.transform = i.transform ? `${i[a]} ${g}` : g : i[a.replaceAll(/-([a-zA-Z])/g, (o, I) => I.toUpperCase())] = g;
  }
  if (i.fontFamily && Rl({
    typeface: i.fontFamily,
    weight: i.fontWeight || "normal",
    posture: i.fontStyle || "normal",
    size: s.fontSize || 0
  }, A, A[se].fontFinder, i), t && i.verticalAlign && i.verticalAlign !== "0px" && i.fontSize) {
    const r = lA(i.fontSize);
    i.fontSize = FA(r * 0.583), i.verticalAlign = FA(Math.sign(lA(i.verticalAlign)) * r * 0.333);
  }
  return t && i.fontSize && (i.fontSize = `calc(${i.fontSize} * var(--scale-factor))`), kl(i), i;
}
function p9(e) {
  return e.style ? e.style.trim().split(/\s*;\s*/).filter((A) => !!A).map((A) => A.split(/\s*:\s*/, 2)).filter(([A, t]) => (A === "font-family" && e[se].usedTypefaces.add(t), E9.has(A))).map((A) => A.join(":")).join(";") : "";
}
const y9 = /* @__PURE__ */ new Set(["body", "html"]);
class yt extends ai {
  constructor(A, t) {
    super(Q9, t), this[tn] = !1, this.style = A.style || "";
  }
  [Lt](A) {
    super[Lt](A), this.style = p9(this);
  }
  [nr]() {
    return !y9.has(this[XA]);
  }
  [ui](A, t = !1) {
    t ? this[tn] = !0 : (A = A.replaceAll(d9, ""), this.style.includes("xfa-spacerun:yes") || (A = A.replaceAll(u9, " "))), A && (this[P] += A);
  }
  [ni](A, t = !0) {
    const i = /* @__PURE__ */ Object.create(null), s = {
      top: NaN,
      bottom: NaN,
      left: NaN,
      right: NaN
    };
    let a = null;
    for (const [n, r] of this.style.split(";").map((g) => g.split(":", 2)))
      switch (n) {
        case "font-family":
          i.typeface = gr(r);
          break;
        case "font-size":
          i.size = lA(r);
          break;
        case "font-weight":
          i.weight = r;
          break;
        case "font-style":
          i.posture = r;
          break;
        case "letter-spacing":
          i.letterSpacing = lA(r);
          break;
        case "margin":
          const g = r.split(/ \t/).map((o) => lA(o));
          switch (g.length) {
            case 1:
              s.top = s.bottom = s.left = s.right = g[0];
              break;
            case 2:
              s.top = s.bottom = g[0], s.left = s.right = g[1];
              break;
            case 3:
              s.top = g[0], s.bottom = g[2], s.left = s.right = g[1];
              break;
            case 4:
              s.top = g[0], s.left = g[1], s.bottom = g[2], s.right = g[3];
              break;
          }
          break;
        case "margin-top":
          s.top = lA(r);
          break;
        case "margin-bottom":
          s.bottom = lA(r);
          break;
        case "margin-left":
          s.left = lA(r);
          break;
        case "margin-right":
          s.right = lA(r);
          break;
        case "line-height":
          a = lA(r);
          break;
      }
    if (A.pushData(i, s, a), this[P])
      A.addString(this[P]);
    else
      for (const n of this[He]()) {
        if (n[XA] === "#text") {
          A.addString(n[P]);
          continue;
        }
        n[ni](A);
      }
    t && A.popFont();
  }
  [SA](A) {
    const t = [];
    if (this[Y] = {
      children: t
    }, this[Wi]({}), t.length === 0 && !this[P])
      return dA.EMPTY;
    let i;
    return this[tn] ? i = this[P] ? this[P].replaceAll(x9, `
`) : void 0 : i = this[P] || void 0, dA.success({
      name: this[XA],
      attributes: {
        href: this.href,
        style: m9(this.style, this, this[tn])
      },
      children: t,
      value: i
    });
  }
}
class w9 extends yt {
  constructor(A) {
    super(A, "a"), this.href = Gl(A.href) || "";
  }
}
class b9 extends yt {
  constructor(A) {
    super(A, "b");
  }
  [ni](A) {
    A.pushFont({
      weight: "bold"
    }), super[ni](A), A.popFont();
  }
}
class D9 extends yt {
  constructor(A) {
    super(A, "body");
  }
  [SA](A) {
    const t = super[SA](A), {
      html: i
    } = t;
    return i ? (i.name = "div", i.attributes.class = ["xfaRich"], t) : dA.EMPTY;
  }
}
class k9 extends yt {
  constructor(A) {
    super(A, "br");
  }
  [Se]() {
    return `
`;
  }
  [ni](A) {
    A.addString(`
`);
  }
  [SA](A) {
    return dA.success({
      name: "br"
    });
  }
}
class S9 extends yt {
  constructor(A) {
    super(A, "html");
  }
  [SA](A) {
    var i;
    const t = [];
    if (this[Y] = {
      children: t
    }, this[Wi]({}), t.length === 0)
      return dA.success({
        name: "div",
        attributes: {
          class: ["xfaRich"],
          style: {}
        },
        value: this[P] || ""
      });
    if (t.length === 1) {
      const s = t[0];
      if ((i = s.attributes) != null && i.class.includes("xfaRich"))
        return dA.success(s);
    }
    return dA.success({
      name: "div",
      attributes: {
        class: ["xfaRich"],
        style: {}
      },
      children: t
    });
  }
}
class F9 extends yt {
  constructor(A) {
    super(A, "i");
  }
  [ni](A) {
    A.pushFont({
      posture: "italic"
    }), super[ni](A), A.popFont();
  }
}
class R9 extends yt {
  constructor(A) {
    super(A, "li");
  }
}
class G9 extends yt {
  constructor(A) {
    super(A, "ol");
  }
}
class N9 extends yt {
  constructor(A) {
    super(A, "p");
  }
  [ni](A) {
    super[ni](A, !1), A.addString(`
`), A.addPara(), A.popFont();
  }
  [Se]() {
    return this[MA]()[He]().at(-1) === this ? super[Se]() : super[Se]() + `
`;
  }
}
class M9 extends yt {
  constructor(A) {
    super(A, "span");
  }
}
class U9 extends yt {
  constructor(A) {
    super(A, "sub");
  }
}
class L9 extends yt {
  constructor(A) {
    super(A, "sup");
  }
}
class H9 extends yt {
  constructor(A) {
    super(A, "ul");
  }
}
class os {
  static [Vt](A, t) {
    if (os.hasOwnProperty(A))
      return os[A](t);
  }
  static a(A) {
    return new w9(A);
  }
  static b(A) {
    return new b9(A);
  }
  static body(A) {
    return new D9(A);
  }
  static br(A) {
    return new k9(A);
  }
  static html(A) {
    return new S9(A);
  }
  static i(A) {
    return new F9(A);
  }
  static li(A) {
    return new R9(A);
  }
  static ol(A) {
    return new G9(A);
  }
  static p(A) {
    return new N9(A);
  }
  static span(A) {
    return new M9(A);
  }
  static sub(A) {
    return new U9(A);
  }
  static sup(A) {
    return new L9(A);
  }
  static ul(A) {
    return new H9(A);
  }
}
const ec = {
  config: Un,
  connection: Ln,
  datasets: Hn,
  localeSet: Jn,
  signature: Yn,
  stylesheet: Kn,
  template: Mn,
  xdp: vn,
  xhtml: os
};
class tc {
  constructor(A) {
    this.namespaceId = A;
  }
  [Vt](A, t) {
    return new ai(this.namespaceId, A, t);
  }
}
class J9 extends K {
  constructor(A) {
    super(-1, "root", /* @__PURE__ */ Object.create(null)), this.element = null, this[U0] = A;
  }
  [si](A) {
    return this.element = A, !0;
  }
  [ae]() {
    super[ae](), this.element.template instanceof uo && (this[U0].set(fl, this.element), this.element.template[Ns](this[U0]), this.element.template[U0] = this[U0]);
  }
}
class Y9 extends K {
  constructor() {
    super(-1, "", /* @__PURE__ */ Object.create(null));
  }
  [si](A) {
    return !1;
  }
}
class K9 {
  constructor(A = null) {
    this._namespaceStack = [], this._nsAgnosticLevel = 0, this._namespacePrefixes = /* @__PURE__ */ new Map(), this._namespaces = /* @__PURE__ */ new Map(), this._nextNsId = Math.max(...Object.values(we).map(({
      id: t
    }) => t)), this._currentNamespace = A || new tc(++this._nextNsId);
  }
  buildRoot(A) {
    return new J9(A);
  }
  build({
    nsPrefix: A,
    name: t,
    attributes: i,
    namespace: s,
    prefixes: a
  }) {
    const n = s !== null;
    if (n && (this._namespaceStack.push(this._currentNamespace), this._currentNamespace = this._searchNamespace(s)), a && this._addNamespacePrefix(a), i.hasOwnProperty(Ti)) {
      const o = ec.datasets, I = i[Ti];
      let c = null;
      for (const [l, h] of Object.entries(I))
        if (this._getNamespaceToUse(l) === o) {
          c = {
            xfa: h
          };
          break;
        }
      c ? i[Ti] = c : delete i[Ti];
    }
    const r = this._getNamespaceToUse(A), g = (r == null ? void 0 : r[Vt](t, i)) || new Y9();
    return g[vs]() && this._nsAgnosticLevel++, (n || a || g[vs]()) && (g[En] = {
      hasNamespace: n,
      prefixes: a,
      nsAgnostic: g[vs]()
    }), g;
  }
  isNsAgnostic() {
    return this._nsAgnosticLevel > 0;
  }
  _searchNamespace(A) {
    let t = this._namespaces.get(A);
    if (t)
      return t;
    for (const [i, {
      check: s
    }] of Object.entries(we))
      if (s(A)) {
        if (t = ec[i], t)
          return this._namespaces.set(A, t), t;
        break;
      }
    return t = new tc(++this._nextNsId), this._namespaces.set(A, t), t;
  }
  _addNamespacePrefix(A) {
    for (const {
      prefix: t,
      value: i
    } of A) {
      const s = this._searchNamespace(i);
      let a = this._namespacePrefixes.get(t);
      a || (a = [], this._namespacePrefixes.set(t, a)), a.push(s);
    }
  }
  _getNamespaceToUse(A) {
    if (!A)
      return this._currentNamespace;
    const t = this._namespacePrefixes.get(A);
    return (t == null ? void 0 : t.length) > 0 ? t.at(-1) : (k(`Unknown namespace prefix: ${A}.`), null);
  }
  clean(A) {
    const {
      hasNamespace: t,
      prefixes: i,
      nsAgnostic: s
    } = A;
    t && (this._currentNamespace = this._namespaceStack.pop()), i && i.forEach(({
      prefix: a
    }) => {
      this._namespacePrefixes.get(a).pop();
    }), s && this._nsAgnosticLevel--;
  }
}
class Tn extends Il {
  constructor(A = null, t = !1) {
    super(), this._builder = new K9(A), this._stack = [], this._globalData = {
      usedTypefaces: /* @__PURE__ */ new Set()
    }, this._ids = /* @__PURE__ */ new Map(), this._current = this._builder.buildRoot(this._ids), this._errorCode = gt.NoError, this._whiteRegex = /^\s+$/, this._nbsps = /\xa0+/g, this._richText = t;
  }
  parse(A) {
    if (this.parseXml(A), this._errorCode === gt.NoError)
      return this._current[ae](), this._current.element;
  }
  onText(A) {
    if (A = A.replace(this._nbsps, (t) => t.slice(1) + " "), this._richText || this._current[nr]()) {
      this._current[ui](A, this._richText);
      return;
    }
    this._whiteRegex.test(A) || this._current[ui](A.trim());
  }
  onCdata(A) {
    this._current[ui](A);
  }
  _mkAttributes(A, t) {
    let i = null, s = null;
    const a = /* @__PURE__ */ Object.create({});
    for (const {
      name: n,
      value: r
    } of A)
      if (n === "xmlns")
        i ? k(`XFA - multiple namespace definition in <${t}>`) : i = r;
      else if (n.startsWith("xmlns:")) {
        const g = n.substring(6);
        s || (s = []), s.push({
          prefix: g,
          value: r
        });
      } else {
        const g = n.indexOf(":");
        if (g === -1)
          a[n] = r;
        else {
          let o = a[Ti];
          o || (o = a[Ti] = /* @__PURE__ */ Object.create(null));
          const [I, c] = [n.slice(0, g), n.slice(g + 1)], l = o[I] || (o[I] = /* @__PURE__ */ Object.create(null));
          l[c] = r;
        }
      }
    return [i, s, a];
  }
  _getNameAndPrefix(A, t) {
    const i = A.indexOf(":");
    return i === -1 ? [A, null] : [A.substring(i + 1), t ? "" : A.substring(0, i)];
  }
  onBeginElement(A, t, i) {
    const [s, a, n] = this._mkAttributes(t, A), [r, g] = this._getNameAndPrefix(A, this._builder.isNsAgnostic()), o = this._builder.build({
      nsPrefix: g,
      name: r,
      attributes: n,
      namespace: s,
      prefixes: a
    });
    if (o[se] = this._globalData, i) {
      o[ae](), this._current[si](o) && o[Fg](this._ids), o[Lt](this._builder);
      return;
    }
    this._stack.push(this._current), this._current = o;
  }
  onEndElement(A) {
    const t = this._current;
    if (t[go]() && typeof t[P] == "string") {
      const i = new Tn();
      i._globalData = this._globalData;
      const s = i.parse(t[P]);
      t[P] = null, t[si](s);
    }
    t[ae](), this._current = this._stack.pop(), this._current[si](t) && t[Fg](this._ids), t[Lt](this._builder);
  }
  onError(A) {
    this._errorCode = A;
  }
}
class Sa {
  constructor(A) {
    try {
      this.root = new Tn().parse(Sa._createDocument(A));
      const t = new Vf(this.root);
      this.form = t.bind(), this.dataHandler = new Zf(this.root, t.getData()), this.form[se].template = this.form;
    } catch (t) {
      k(`XFA - an error occurred during parsing and binding: ${t}`);
    }
  }
  isValid() {
    return this.root && this.form;
  }
  _createPagesHelper() {
    const A = this.form[dl]();
    return new Promise((t, i) => {
      const s = () => {
        try {
          const a = A.next();
          a.done ? t(a.value) : setTimeout(s, 0);
        } catch (a) {
          i(a);
        }
      };
      setTimeout(s, 0);
    });
  }
  async _createPages() {
    try {
      this.pages = await this._createPagesHelper(), this.dims = this.pages.children.map((A) => {
        const {
          width: t,
          height: i
        } = A.attributes.style;
        return [0, 0, parseInt(t), parseInt(i)];
      });
    } catch (A) {
      k(`XFA - an error occurred during layout: ${A}`);
    }
  }
  getBoundingBox(A) {
    return this.dims[A];
  }
  async getNumPages() {
    return this.pages || await this._createPages(), this.dims.length;
  }
  setImages(A) {
    this.form[se].images = A;
  }
  setFonts(A) {
    this.form[se].fontFinder = new AE(A);
    const t = [];
    for (let i of this.form[se].usedTypefaces)
      i = gr(i), this.form[se].fontFinder.find(i) || t.push(i);
    return t.length > 0 ? t : null;
  }
  appendFonts(A, t) {
    this.form[se].fontFinder.add(A, t);
  }
  async getPages() {
    this.pages || await this._createPages();
    const A = this.pages;
    return this.pages = null, A;
  }
  serializeData(A) {
    return this.dataHandler.serialize(A);
  }
  static _createDocument(A) {
    return A["/xdp:xdp"] ? Object.values(A).join("") : A["xdp:xdp"];
  }
  static getRichTextAsHtml(A) {
    if (!A || typeof A != "string")
      return null;
    try {
      let t = new Tn(os, !0).parse(A);
      if (!["body", "xhtml"].includes(t[XA])) {
        const n = os.body({});
        n[Be](t), t = n;
      }
      const i = t[SA]();
      if (!i.success)
        return null;
      const {
        html: s
      } = i, {
        attributes: a
      } = s;
      return a && (a.class && (a.class = a.class.filter((n) => !n.startsWith("xfa"))), a.dir = "auto"), {
        html: s,
        str: t[Se]()
      };
    } catch (t) {
      k(`XFA - an error occurred during parsing of rich text: ${t}`);
    }
    return null;
  }
}
class Ui {
  static createGlobals(A) {
    return Promise.all([A.ensureCatalog("acroForm"), A.ensureDoc("xfaDatasets"), A.ensureCatalog("structTreeRoot"), A.ensureCatalog("baseUrl"), A.ensureCatalog("attachments")]).then(([t, i, s, a, n]) => ({
      pdfManager: A,
      acroForm: t instanceof R ? t : R.empty,
      xfaDatasets: i,
      structTreeRoot: s,
      baseUrl: a,
      attachments: n
    }), (t) => (k(`createGlobals: "${t}".`), null));
  }
  static async create(A, t, i, s, a, n, r) {
    const g = a ? await this._getPageIndex(A, t, i.pdfManager) : null;
    return i.pdfManager.ensure(this, "_create", [A, t, i, s, a, n, g, r]);
  }
  static _create(A, t, i, s, a = !1, n = null, r = null, g = null) {
    const o = A.fetchIfRef(t);
    if (!(o instanceof R))
      return;
    const {
      acroForm: I,
      pdfManager: c
    } = i, l = t instanceof nA ? t.toString() : `annot_${s.createObjId()}`;
    let h = o.get("Subtype");
    h = h instanceof L ? h.name : null;
    const C = {
      xref: A,
      ref: t,
      dict: o,
      subtype: h,
      id: l,
      annotationGlobals: i,
      collectFields: a,
      orphanFields: n,
      needAppearances: !a && I.get("NeedAppearances") === !0,
      pageIndex: r,
      evaluatorOptions: c.evaluatorOptions,
      pageRef: g
    };
    switch (h) {
      case "Link":
        return new O9(C);
      case "Text":
        return new W9(C);
      case "Widget":
        let B = Gt({
          dict: o,
          key: "FT"
        });
        switch (B = B instanceof L ? B.name : null, B) {
          case "Tx":
            return new T9(C);
          case "Btn":
            return new q9(C);
          case "Ch":
            return new P9(C);
          case "Sig":
            return new zl(C);
        }
        return k(`Unimplemented widget field type "${B}", falling back to base field type.`), new Ot(C);
      case "Popup":
        return new $l(C);
      case "FreeText":
        return new Tr(C);
      case "Line":
        return new V9(C);
      case "Square":
        return new Z9(C);
      case "Circle":
        return new j9(C);
      case "PolyLine":
        return new Ah(C);
      case "Polygon":
        return new eh(C);
      case "Caret":
        return new X9(C);
      case "Ink":
        return new Fs(C);
      case "Highlight":
        return new qr(C);
      case "Underline":
        return new _9(C);
      case "Squiggly":
        return new z9(C);
      case "StrikeOut":
        return new $9(C);
      case "Stamp":
        return new sn(C);
      case "FileAttachment":
        return new Ax(C);
      default:
        return a || k(h ? `Unimplemented annotation type "${h}", falling back to base annotation.` : "Annotation is missing the required /Subtype."), new Ra(C);
    }
  }
  static async _getPageIndex(A, t, i) {
    try {
      const s = await A.fetchIfRefAsync(t);
      if (!(s instanceof R))
        return -1;
      const a = s.getRaw("P");
      if (a instanceof nA)
        try {
          return await i.ensureCatalog("getPageIndex", [a]);
        } catch (r) {
          vA(`_getPageIndex -- not a valid page reference: "${r}".`);
        }
      if (s.has("Kids"))
        return -1;
      const n = await i.ensureDoc("numPages");
      for (let r = 0; r < n; r++) {
        const g = await i.getPage(r), o = await i.ensure(g, "annotations");
        for (const I of o)
          if (I instanceof nA && pn(I, t))
            return r;
      }
    } catch (s) {
      k(`_getPageIndex: "${s}".`);
    }
    return -1;
  }
  static generateImages(A, t, i) {
    if (!i)
      return k("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images."), null;
    let s;
    for (const {
      bitmapId: a,
      bitmap: n
    } of A)
      n && (s || (s = /* @__PURE__ */ new Map()), s.set(a, sn.createImage(n, t)));
    return s;
  }
  static async saveNewAnnotations(A, t, i, s, a) {
    const n = A.xref;
    let r;
    const g = [], {
      isOffscreenCanvasSupported: o
    } = A.options;
    for (const I of i)
      if (!I.deleted)
        switch (I.annotationType) {
          case wi.FREETEXT:
            if (!r) {
              const l = new R(n);
              l.set("BaseFont", L.get("Helvetica")), l.set("Type", L.get("Font")), l.set("Subtype", L.get("Type1")), l.set("Encoding", L.get("WinAnsiEncoding")), r = n.getNewTemporaryRef(), a.put(r, {
                data: l
              });
            }
            g.push(Tr.createNewAnnotation(n, I, a, {
              evaluator: A,
              task: t,
              baseFontRef: r
            }));
            break;
          case wi.HIGHLIGHT:
            I.quadPoints ? g.push(qr.createNewAnnotation(n, I, a)) : g.push(Fs.createNewAnnotation(n, I, a));
            break;
          case wi.INK:
            g.push(Fs.createNewAnnotation(n, I, a));
            break;
          case wi.STAMP:
            const c = o ? await (s == null ? void 0 : s.get(I.bitmapId)) : null;
            if (c != null && c.imageStream) {
              const {
                imageStream: l,
                smaskStream: h
              } = c;
              if (h) {
                const B = n.getNewTemporaryRef();
                a.put(B, {
                  data: h
                }), l.dict.set("SMask", B);
              }
              const C = c.imageRef = n.getNewTemporaryRef();
              a.put(C, {
                data: l
              }), c.imageStream = c.smaskStream = null;
            }
            g.push(sn.createNewAnnotation(n, I, a, {
              image: c
            }));
            break;
        }
    return {
      annotations: await Promise.all(g)
    };
  }
  static async printNewAnnotations(A, t, i, s, a) {
    if (!s)
      return null;
    const {
      options: n,
      xref: r
    } = t, g = [];
    for (const o of s)
      if (!o.deleted)
        switch (o.annotationType) {
          case wi.FREETEXT:
            g.push(Tr.createNewPrintAnnotation(A, r, o, {
              evaluator: t,
              task: i,
              evaluatorOptions: n
            }));
            break;
          case wi.HIGHLIGHT:
            o.quadPoints ? g.push(qr.createNewPrintAnnotation(A, r, o, {
              evaluatorOptions: n
            })) : g.push(Fs.createNewPrintAnnotation(A, r, o, {
              evaluatorOptions: n
            }));
            break;
          case wi.INK:
            g.push(Fs.createNewPrintAnnotation(A, r, o, {
              evaluatorOptions: n
            }));
            break;
          case wi.STAMP:
            const I = n.isOffscreenCanvasSupported ? await (a == null ? void 0 : a.get(o.bitmapId)) : null;
            if (I != null && I.imageStream) {
              const {
                imageStream: c,
                smaskStream: l
              } = I;
              l && c.dict.set("SMask", l), I.imageRef = new ts(c, c.length), I.imageStream = I.smaskStream = null;
            }
            g.push(sn.createNewPrintAnnotation(A, r, o, {
              image: I,
              evaluatorOptions: n
            }));
            break;
        }
    return Promise.all(g);
  }
}
function j0(e, A = new Uint8ClampedArray(3)) {
  if (!Array.isArray(e))
    return A;
  const t = A || new Uint8ClampedArray(3);
  switch (e.length) {
    case 0:
      return null;
    case 1:
      return LA.singletons.gray.getRgbItem(e, 0, t, 0), t;
    case 3:
      return LA.singletons.rgb.getRgbItem(e, 0, t, 0), t;
    case 4:
      return LA.singletons.cmyk.getRgbItem(e, 0, t, 0), t;
    default:
      return A;
  }
}
function Qt(e) {
  return Array.from(e, (A) => A / 255);
}
function Fa(e, A) {
  const t = e.getArray("QuadPoints");
  if (!at(t, null) || t.length === 0 || t.length % 8 > 0)
    return null;
  const i = new Float32Array(t.length);
  for (let s = 0, a = t.length; s < a; s += 8) {
    const [n, r, g, o, I, c, l, h] = t.slice(s, s + 8), C = Math.min(n, g, I, l), B = Math.max(n, g, I, l), Q = Math.min(r, o, c, h), E = Math.max(r, o, c, h);
    if (A !== null && (C < A[0] || B > A[2] || Q < A[1] || E > A[3]))
      return null;
    i.set([C, E, B, E, C, Q, B, Q], s);
  }
  return i;
}
function Lg(e, A, t) {
  const [i, s, a, n] = de.getAxialAlignedBoundingBox(A, t);
  if (i === a || s === n)
    return [1, 0, 0, 1, e[0], e[1]];
  const r = (e[2] - e[0]) / (a - i), g = (e[3] - e[1]) / (n - s);
  return [r, 0, 0, g, e[0] - i * r, e[1] - s * g];
}
class Ra {
  constructor(A) {
    const {
      dict: t,
      xref: i,
      annotationGlobals: s,
      ref: a,
      orphanFields: n
    } = A, r = n == null ? void 0 : n.get(a);
    r && t.set("Parent", r), this.setTitle(t.get("T")), this.setContents(t.get("Contents")), this.setModificationDate(t.get("M")), this.setFlags(t.get("F")), this.setRectangle(t.getArray("Rect")), this.setColor(t.getArray("C")), this.setBorderStyle(t), this.setAppearance(t), this.setOptionalContent(t);
    const g = t.get("MK");
    this.setBorderAndBackgroundColors(g), this.setRotation(g, t), this.ref = A.ref instanceof nA ? A.ref : null, this._streams = [], this.appearance && this._streams.push(this.appearance);
    const o = !!(this.flags & ke.LOCKED), I = !!(this.flags & ke.LOCKEDCONTENTS);
    if (this.data = {
      annotationFlags: this.flags,
      borderStyle: this.borderStyle,
      color: this.color,
      backgroundColor: this.backgroundColor,
      borderColor: this.borderColor,
      rotation: this.rotation,
      contentsObj: this._contents,
      hasAppearance: !!this.appearance,
      id: A.id,
      modificationDate: this.modificationDate,
      rect: this.rectangle,
      subtype: A.subtype,
      hasOwnCanvas: !1,
      noRotate: !!(this.flags & ke.NOROTATE),
      noHTML: o && I,
      isEditable: !1,
      structParent: -1
    }, s.structTreeRoot) {
      let l = t.get("StructParent");
      this.data.structParent = l = Number.isInteger(l) && l >= 0 ? l : -1, s.structTreeRoot.addAnnotationIdToPage(A.pageRef, l);
    }
    if (A.collectFields) {
      const l = t.get("Kids");
      if (Array.isArray(l)) {
        const h = [];
        for (const C of l)
          C instanceof nA && h.push(C.toString());
        h.length !== 0 && (this.data.kidIds = h);
      }
      this.data.actions = $n(i, t, Bc), this.data.fieldName = this._constructFieldName(t), this.data.pageIndex = A.pageIndex;
    }
    const c = t.get("IT");
    c instanceof L && (this.data.it = c.name), this._isOffscreenCanvasSupported = A.evaluatorOptions.isOffscreenCanvasSupported, this._fallbackFontDict = null, this._needAppearances = !1;
  }
  _hasFlag(A, t) {
    return !!(A & t);
  }
  _buildFlags(A, t) {
    let {
      flags: i
    } = this;
    return A === void 0 ? t === void 0 ? void 0 : t ? i & -5 : i & -3 | ke.PRINT : A ? (i |= ke.PRINT, t ? i & -33 | ke.HIDDEN : i & -3 | ke.NOVIEW) : (i &= -35, t ? i & -5 : i | ke.PRINT);
  }
  _isViewable(A) {
    return !this._hasFlag(A, ke.INVISIBLE) && !this._hasFlag(A, ke.NOVIEW);
  }
  _isPrintable(A) {
    return this._hasFlag(A, ke.PRINT) && !this._hasFlag(A, ke.HIDDEN) && !this._hasFlag(A, ke.INVISIBLE);
  }
  mustBeViewed(A, t) {
    var s;
    const i = (s = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : s.noView;
    return i !== void 0 ? !i : this.viewable && !this._hasFlag(this.flags, ke.HIDDEN);
  }
  mustBePrinted(A) {
    var i;
    const t = (i = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : i.noPrint;
    return t !== void 0 ? !t : this.printable;
  }
  mustBeViewedWhenEditing(A, t = null) {
    return A ? !this.data.isEditable : !(t != null && t.has(this.data.id));
  }
  get viewable() {
    return this.data.quadPoints === null ? !1 : this.flags === 0 ? !0 : this._isViewable(this.flags);
  }
  get printable() {
    return this.data.quadPoints === null || this.flags === 0 ? !1 : this._isPrintable(this.flags);
  }
  _parseStringHelper(A) {
    const t = typeof A == "string" ? jA(A) : "", i = t && il(t).dir === "rtl" ? "rtl" : "ltr";
    return {
      str: t,
      dir: i
    };
  }
  setDefaultAppearance(A) {
    const {
      dict: t,
      annotationGlobals: i
    } = A, s = Gt({
      dict: t,
      key: "DA"
    }) || i.acroForm.get("DA");
    this._defaultAppearance = typeof s == "string" ? s : "", this.data.defaultAppearanceData = so(this._defaultAppearance);
  }
  setTitle(A) {
    this._title = this._parseStringHelper(A);
  }
  setContents(A) {
    this._contents = this._parseStringHelper(A);
  }
  setModificationDate(A) {
    this.modificationDate = typeof A == "string" ? A : null;
  }
  setFlags(A) {
    this.flags = Number.isInteger(A) && A > 0 ? A : 0, this.flags & ke.INVISIBLE && this.constructor.name !== "Annotation" && (this.flags ^= ke.INVISIBLE);
  }
  hasFlag(A) {
    return this._hasFlag(this.flags, A);
  }
  setRectangle(A) {
    this.rectangle = ii(A, [0, 0, 0, 0]);
  }
  setColor(A) {
    this.color = j0(A);
  }
  setLineEndings(A) {
    if (this.lineEndings = ["None", "None"], Array.isArray(A) && A.length === 2)
      for (let t = 0; t < 2; t++) {
        const i = A[t];
        if (i instanceof L)
          switch (i.name) {
            case "None":
              continue;
            case "Square":
            case "Circle":
            case "Diamond":
            case "OpenArrow":
            case "ClosedArrow":
            case "Butt":
            case "ROpenArrow":
            case "RClosedArrow":
            case "Slash":
              this.lineEndings[t] = i.name;
              continue;
          }
        k(`Ignoring invalid lineEnding: ${i}`);
      }
  }
  setRotation(A, t) {
    this.rotation = 0;
    let i = A instanceof R ? A.get("R") || 0 : t.get("Rotate") || 0;
    Number.isInteger(i) && i !== 0 && (i %= 360, i < 0 && (i += 360), i % 90 === 0 && (this.rotation = i));
  }
  setBorderAndBackgroundColors(A) {
    A instanceof R ? (this.borderColor = j0(A.getArray("BC"), null), this.backgroundColor = j0(A.getArray("BG"), null)) : this.borderColor = this.backgroundColor = null;
  }
  setBorderStyle(A) {
    if (this.borderStyle = new v9(), A instanceof R)
      if (A.has("BS")) {
        const t = A.get("BS");
        if (t instanceof R) {
          const i = t.get("Type");
          (!i || xe(i, "Border")) && (this.borderStyle.setWidth(t.get("W"), this.rectangle), this.borderStyle.setStyle(t.get("S")), this.borderStyle.setDashArray(t.getArray("D")));
        }
      } else if (A.has("Border")) {
        const t = A.getArray("Border");
        Array.isArray(t) && t.length >= 3 && (this.borderStyle.setHorizontalCornerRadius(t[0]), this.borderStyle.setVerticalCornerRadius(t[1]), this.borderStyle.setWidth(t[2], this.rectangle), t.length === 4 && this.borderStyle.setDashArray(t[3], !0));
      } else
        this.borderStyle.setWidth(0);
  }
  setAppearance(A) {
    this.appearance = null;
    const t = A.get("AP");
    if (!(t instanceof R))
      return;
    const i = t.get("N");
    if (i instanceof JA) {
      this.appearance = i;
      return;
    }
    if (!(i instanceof R))
      return;
    const s = A.get("AS");
    if (!(s instanceof L) || !i.has(s.name))
      return;
    const a = i.get(s.name);
    a instanceof JA && (this.appearance = a);
  }
  setOptionalContent(A) {
    this.oc = null;
    const t = A.get("OC");
    t instanceof L ? k("setOptionalContent: Support for /Name-entry is not implemented.") : t instanceof R && (this.oc = t);
  }
  loadResources(A, t) {
    return t.dict.getAsync("Resources").then((i) => i ? new Rn(i, A, i.xref).load().then(function() {
      return i;
    }) : void 0);
  }
  async getOperatorList(A, t, i, s) {
    const {
      hasOwnCanvas: a,
      id: n,
      rect: r
    } = this.data;
    let g = this.appearance;
    const o = !!(a && i & it.DISPLAY);
    if (o && (r[0] === r[2] || r[1] === r[3]))
      return this.data.hasOwnCanvas = !1, {
        opList: new lt(),
        separateForm: !1,
        separateCanvas: !1
      };
    if (!g) {
      if (!o)
        return {
          opList: new lt(),
          separateForm: !1,
          separateCanvas: !1
        };
      g = new Ct(""), g.dict = new R();
    }
    const I = g.dict, c = await this.loadResources(["ExtGState", "ColorSpace", "Pattern", "Shading", "XObject", "Font"], g), l = _r(I.getArray("BBox"), [0, 0, 1, 1]), h = Ji(I.getArray("Matrix"), Wt), C = Lg(r, l, h), B = new lt();
    let Q;
    return this.oc && (Q = await A.parseMarkedContentProps(this.oc, null)), Q !== void 0 && B.addOp(w.beginMarkedContentProps, ["OC", Q]), B.addOp(w.beginAnnotation, [n, r, C, h, o]), await A.getOperatorList({
      stream: g,
      task: t,
      resources: c,
      operatorList: B,
      fallbackFontDict: this._fallbackFontDict
    }), B.addOp(w.endAnnotation, []), Q !== void 0 && B.addOp(w.endMarkedContent, []), this.reset(), {
      opList: B,
      separateForm: !1,
      separateCanvas: o
    };
  }
  async save(A, t, i, s) {
    return null;
  }
  get hasTextContent() {
    return !1;
  }
  async extractTextContent(A, t, i) {
    if (!this.appearance)
      return;
    const s = await this.loadResources(["ExtGState", "Font", "Properties", "XObject"], this.appearance), a = [], n = [];
    let r = null;
    const g = {
      desiredSize: Math.Infinity,
      ready: !0,
      enqueue(o, I) {
        for (const c of o.items)
          c.str !== void 0 && (r || (r = c.transform.slice(-2)), n.push(c.str), c.hasEOL && (a.push(n.join("").trimEnd()), n.length = 0));
      }
    };
    if (await A.getTextContent({
      stream: this.appearance,
      task: t,
      resources: s,
      includeMarkedContent: !0,
      keepWhiteSpace: !0,
      sink: g,
      viewBox: i
    }), this.reset(), n.length && a.push(n.join("").trimEnd()), a.length > 1 || a[0]) {
      const o = this.appearance.dict, I = _r(o.getArray("BBox"), null), c = Ji(o.getArray("Matrix"), null);
      this.data.textPosition = this._transformPoint(r, I, c), this.data.textContent = a;
    }
  }
  _transformPoint(A, t, i) {
    const {
      rect: s
    } = this.data;
    t || (t = [0, 0, 1, 1]), i || (i = [1, 0, 0, 1, 0, 0]);
    const a = Lg(s, t, i);
    return a[4] -= s[0], a[5] -= s[1], A = de.applyTransform(A, a), de.applyTransform(A, i);
  }
  getFieldObject() {
    return this.data.kidIds ? {
      id: this.data.id,
      actions: this.data.actions,
      name: this.data.fieldName,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      type: "",
      kidIds: this.data.kidIds,
      page: this.data.pageIndex,
      rotation: this.rotation
    } : null;
  }
  reset() {
    for (const A of this._streams)
      A.reset();
  }
  _constructFieldName(A) {
    if (!A.has("T") && !A.has("Parent"))
      return k("Unknown field name, falling back to empty field name."), "";
    if (!A.has("Parent"))
      return jA(A.get("T"));
    const t = [];
    A.has("T") && t.unshift(jA(A.get("T")));
    let i = A;
    const s = new Ne();
    for (A.objId && s.put(A.objId); i.has("Parent") && (i = i.get("Parent"), !(!(i instanceof R) || i.objId && s.has(i.objId))); )
      i.objId && s.put(i.objId), i.has("T") && t.unshift(jA(i.get("T")));
    return t.join(".");
  }
}
class v9 {
  constructor() {
    this.width = 1, this.rawWidth = 1, this.style = x0.SOLID, this.dashArray = [3], this.horizontalCornerRadius = 0, this.verticalCornerRadius = 0;
  }
  setWidth(A, t = [0, 0, 0, 0]) {
    if (A instanceof L) {
      this.width = 0;
      return;
    }
    if (typeof A == "number") {
      if (A > 0) {
        this.rawWidth = A;
        const i = (t[2] - t[0]) / 2, s = (t[3] - t[1]) / 2;
        i > 0 && s > 0 && (A > i || A > s) && (k(`AnnotationBorderStyle.setWidth - ignoring width: ${A}`), A = 1);
      }
      this.width = A;
    }
  }
  setStyle(A) {
    if (A instanceof L)
      switch (A.name) {
        case "S":
          this.style = x0.SOLID;
          break;
        case "D":
          this.style = x0.DASHED;
          break;
        case "B":
          this.style = x0.BEVELED;
          break;
        case "I":
          this.style = x0.INSET;
          break;
        case "U":
          this.style = x0.UNDERLINE;
          break;
      }
  }
  setDashArray(A, t = !1) {
    if (Array.isArray(A)) {
      let i = !0, s = !0;
      for (const a of A)
        if (+a >= 0)
          a > 0 && (s = !1);
        else {
          i = !1;
          break;
        }
      A.length === 0 || i && !s ? (this.dashArray = A, t && this.setStyle(L.get("D"))) : this.width = 0;
    } else A && (this.width = 0);
  }
  setHorizontalCornerRadius(A) {
    Number.isInteger(A) && (this.horizontalCornerRadius = A);
  }
  setVerticalCornerRadius(A) {
    Number.isInteger(A) && (this.verticalCornerRadius = A);
  }
}
class Et extends Ra {
  constructor(A) {
    super(A);
    const {
      dict: t
    } = A;
    if (t.has("IRT")) {
      const s = t.getRaw("IRT");
      this.data.inReplyTo = s instanceof nA ? s.toString() : null;
      const a = t.get("RT");
      this.data.replyType = a instanceof L ? a.name : Or.REPLY;
    }
    let i = null;
    if (this.data.replyType === Or.GROUP) {
      const s = t.get("IRT");
      this.setTitle(s.get("T")), this.data.titleObj = this._title, this.setContents(s.get("Contents")), this.data.contentsObj = this._contents, s.has("CreationDate") ? (this.setCreationDate(s.get("CreationDate")), this.data.creationDate = this.creationDate) : this.data.creationDate = null, s.has("M") ? (this.setModificationDate(s.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i = s.getRaw("Popup"), s.has("C") ? (this.setColor(s.getArray("C")), this.data.color = this.color) : this.data.color = null;
    } else
      this.data.titleObj = this._title, this.setCreationDate(t.get("CreationDate")), this.data.creationDate = this.creationDate, i = t.getRaw("Popup"), t.has("C") || (this.data.color = null);
    this.data.popupRef = i instanceof nA ? i.toString() : null, t.has("RC") && (this.data.richText = Sa.getRichTextAsHtml(t.get("RC")));
  }
  setCreationDate(A) {
    this.creationDate = typeof A == "string" ? A : null;
  }
  _setDefaultAppearance({
    xref: A,
    extra: t,
    strokeColor: i,
    fillColor: s,
    blendMode: a,
    strokeAlpha: n,
    fillAlpha: r,
    pointsCallback: g
  }) {
    let o = Number.MAX_VALUE, I = Number.MAX_VALUE, c = Number.MIN_VALUE, l = Number.MIN_VALUE;
    const h = ["q"];
    t && h.push(t), i && h.push(`${i[0]} ${i[1]} ${i[2]} RG`), s && h.push(`${s[0]} ${s[1]} ${s[2]} rg`);
    const C = this.data.quadPoints || Float32Array.from([this.rectangle[0], this.rectangle[3], this.rectangle[2], this.rectangle[3], this.rectangle[0], this.rectangle[1], this.rectangle[2], this.rectangle[1]]);
    for (let p = 0, D = C.length; p < D; p += 8) {
      const [F, y, H, N] = g(h, C.subarray(p, p + 8));
      o = Math.min(o, F), c = Math.max(c, y), I = Math.min(I, H), l = Math.max(l, N);
    }
    h.push("Q");
    const B = new R(A), Q = new R(A);
    Q.set("Subtype", L.get("Form"));
    const E = new Ct(h.join(" "));
    E.dict = Q, B.set("Fm0", E);
    const f = new R(A);
    a && f.set("BM", L.get(a)), typeof n == "number" && f.set("CA", n), typeof r == "number" && f.set("ca", r);
    const d = new R(A);
    d.set("GS0", f);
    const u = new R(A);
    u.set("ExtGState", d), u.set("XObject", B);
    const x = new R(A);
    x.set("Resources", u);
    const m = this.data.rect = [o, I, c, l];
    x.set("BBox", m), this.appearance = new Ct("/GS0 gs /Fm0 Do"), this.appearance.dict = x, this._streams.push(this.appearance, E);
  }
  static async createNewAnnotation(A, t, i, s) {
    const a = t.ref || (t.ref = A.getNewTemporaryRef()), n = await this.createNewAppearanceStream(t, A, s);
    let r;
    if (n) {
      const g = A.getNewTemporaryRef();
      r = this.createNewDict(t, A, {
        apRef: g
      }), i.put(g, {
        data: n
      });
    } else
      r = this.createNewDict(t, A, {});
    return Number.isInteger(t.parentTreeId) && r.set("StructParent", t.parentTreeId), i.put(a, {
      data: r
    }), {
      ref: a
    };
  }
  static async createNewPrintAnnotation(A, t, i, s) {
    const a = await this.createNewAppearanceStream(i, t, s), n = this.createNewDict(i, t, a ? {
      ap: a
    } : {}), r = new this.prototype.constructor({
      dict: n,
      xref: t,
      annotationGlobals: A,
      evaluatorOptions: s.evaluatorOptions
    });
    return i.ref && (r.ref = r.refToReplace = i.ref), r;
  }
}
class Ot extends Ra {
  constructor(A) {
    var l;
    super(A);
    const {
      dict: t,
      xref: i,
      annotationGlobals: s
    } = A, a = this.data;
    this._needAppearances = A.needAppearances, a.annotationType = Je.WIDGET, a.fieldName === void 0 && (a.fieldName = this._constructFieldName(t)), a.actions === void 0 && (a.actions = $n(i, t, Bc));
    let n = Gt({
      dict: t,
      key: "V",
      getArray: !0
    });
    a.fieldValue = this._decodeFormValue(n);
    const r = Gt({
      dict: t,
      key: "DV",
      getArray: !0
    });
    if (a.defaultFieldValue = this._decodeFormValue(r), n === void 0 && s.xfaDatasets) {
      const h = this._title.str;
      h && (this._hasValueFromXFA = !0, a.fieldValue = n = s.xfaDatasets.getValue(h));
    }
    n === void 0 && a.defaultFieldValue !== null && (a.fieldValue = a.defaultFieldValue), a.alternativeText = jA(t.get("TU") || ""), this.setDefaultAppearance(A), a.hasAppearance || (a.hasAppearance = this._needAppearances && a.fieldValue !== void 0 && a.fieldValue !== null);
    const g = Gt({
      dict: t,
      key: "FT"
    });
    a.fieldType = g instanceof L ? g.name : null;
    const o = Gt({
      dict: t,
      key: "DR"
    }), I = s.acroForm.get("DR"), c = (l = this.appearance) == null ? void 0 : l.dict.get("Resources");
    this._fieldResources = {
      localResources: o,
      acroFormResources: I,
      appearanceResources: c,
      mergedResources: R.merge({
        xref: i,
        dictArray: [o, c, I],
        mergeSubDicts: !0
      })
    }, a.fieldFlags = Gt({
      dict: t,
      key: "Ff"
    }), (!Number.isInteger(a.fieldFlags) || a.fieldFlags < 0) && (a.fieldFlags = 0), a.readOnly = this.hasFieldFlag(Pe.READONLY), a.required = this.hasFieldFlag(Pe.REQUIRED), a.hidden = this._hasFlag(a.annotationFlags, ke.HIDDEN) || this._hasFlag(a.annotationFlags, ke.NOVIEW);
  }
  _decodeFormValue(A) {
    return Array.isArray(A) ? A.filter((t) => typeof t == "string").map((t) => jA(t)) : A instanceof L ? jA(A.name) : typeof A == "string" ? jA(A) : null;
  }
  hasFieldFlag(A) {
    return !!(this.data.fieldFlags & A);
  }
  _isViewable(A) {
    return !0;
  }
  mustBeViewed(A, t) {
    return t ? this.viewable : super.mustBeViewed(A, t) && !this._hasFlag(this.flags, ke.NOVIEW);
  }
  getRotationMatrix(A) {
    var a;
    let t = (a = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : a.rotation;
    if (t === void 0 && (t = this.rotation), t === 0)
      return Wt;
    const i = this.data.rect[2] - this.data.rect[0], s = this.data.rect[3] - this.data.rect[1];
    return wn(t, i, s);
  }
  getBorderAndBackgroundAppearances(A) {
    var r;
    let t = (r = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : r.rotation;
    if (t === void 0 && (t = this.rotation), !this.backgroundColor && !this.borderColor)
      return "";
    const i = this.data.rect[2] - this.data.rect[0], s = this.data.rect[3] - this.data.rect[1], a = t === 0 || t === 180 ? `0 0 ${i} ${s} re` : `0 0 ${s} ${i} re`;
    let n = "";
    if (this.backgroundColor && (n = `${mi(this.backgroundColor, !0)} ${a} f `), this.borderColor) {
      const g = this.borderStyle.width || 1;
      n += `${g} w ${mi(this.borderColor, !1)} ${a} S `;
    }
    return n;
  }
  async getOperatorList(A, t, i, s) {
    if (i & it.ANNOTATIONS_FORMS && !(this instanceof zl) && !this.data.noHTML && !this.data.hasOwnCanvas)
      return {
        opList: new lt(),
        separateForm: !0,
        separateCanvas: !1
      };
    if (!this._hasText)
      return super.getOperatorList(A, t, i, s);
    const a = await this._getAppearance(A, t, i, s);
    if (this.appearance && a === null)
      return super.getOperatorList(A, t, i, s);
    const n = new lt();
    if (!this._defaultAppearance || a === null)
      return {
        opList: n,
        separateForm: !1,
        separateCanvas: !1
      };
    const r = !!(this.data.hasOwnCanvas && i & it.DISPLAY), g = [1, 0, 0, 1, 0, 0], o = [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]], I = Lg(this.data.rect, o, g);
    let c;
    this.oc && (c = await A.parseMarkedContentProps(this.oc, null)), c !== void 0 && n.addOp(w.beginMarkedContentProps, ["OC", c]), n.addOp(w.beginAnnotation, [this.data.id, this.data.rect, I, this.getRotationMatrix(s), r]);
    const l = new Ct(a);
    return await A.getOperatorList({
      stream: l,
      task: t,
      resources: this._fieldResources.mergedResources,
      operatorList: n
    }), n.addOp(w.endAnnotation, []), c !== void 0 && n.addOp(w.endMarkedContent, []), {
      opList: n,
      separateForm: !1,
      separateCanvas: r
    };
  }
  _getMKDict(A) {
    const t = new R(null);
    return A && t.set("R", A), this.borderColor && t.set("BC", Qt(this.borderColor)), this.backgroundColor && t.set("BG", Qt(this.backgroundColor)), t.size > 0 ? t : null;
  }
  amendSavedDict(A, t) {
  }
  setValue(A, t, i, s) {
    const {
      dict: a,
      ref: n
    } = Xh(A, this.ref, i);
    if (!a)
      A.set("V", t);
    else if (!s.has(n)) {
      const r = a.clone();
      return r.set("V", t), s.put(n, {
        data: r
      }), r;
    }
    return null;
  }
  async save(A, t, i, s) {
    const a = i == null ? void 0 : i.get(this.data.id), n = this._buildFlags(a == null ? void 0 : a.noView, a == null ? void 0 : a.noPrint);
    let r = a == null ? void 0 : a.value, g = a == null ? void 0 : a.rotation;
    if (r === this.data.fieldValue || r === void 0) {
      if (!this._hasValueFromXFA && g === void 0 && n === void 0)
        return;
      r || (r = this.data.fieldValue);
    }
    if (g === void 0 && !this._hasValueFromXFA && Array.isArray(r) && Array.isArray(this.data.fieldValue) && B0(r, this.data.fieldValue) && n === void 0)
      return;
    g === void 0 && (g = this.rotation);
    let o = null;
    if (!this._needAppearances && (o = await this._getAppearance(A, t, it.SAVE, i), o === null && n === void 0))
      return;
    let I = !1;
    o != null && o.needAppearances && (I = !0, o = null);
    const {
      xref: c
    } = A, l = c.fetchIfRef(this.ref);
    if (!(l instanceof R))
      return;
    const h = new R(c);
    for (const E of l.getKeys())
      E !== "AP" && h.set(E, l.getRaw(E));
    if (n !== void 0 && (h.set("F", n), o === null && !I)) {
      const E = l.getRaw("AP");
      E && h.set("AP", E);
    }
    const C = {
      path: this.data.fieldName,
      value: r
    }, B = this.setValue(h, Array.isArray(r) ? r.map(Nt) : Nt(r), c, s);
    this.amendSavedDict(i, B || h);
    const Q = this._getMKDict(g);
    if (Q && h.set("MK", Q), s.put(this.ref, {
      data: h,
      xfa: C,
      needAppearances: I
    }), o !== null) {
      const E = c.getNewTemporaryRef(), f = new R(c);
      h.set("AP", f), f.set("N", E);
      const d = this._getSaveFieldResources(c), u = new Ct(o), x = u.dict = new R(c);
      x.set("Subtype", L.get("Form")), x.set("Resources", d), x.set("BBox", [0, 0, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]]);
      const m = this.getRotationMatrix(i);
      m !== Wt && x.set("Matrix", m), s.put(E, {
        data: u,
        xfa: null,
        needAppearances: !1
      });
    }
    h.set("M", `D:${xi()}`);
  }
  async _getAppearance(A, t, i, s) {
    if (this.hasFieldFlag(Pe.PASSWORD))
      return null;
    const n = s == null ? void 0 : s.get(this.data.id);
    let r, g;
    if (n && (r = n.formattedValue || n.value, g = n.rotation), g === void 0 && r === void 0 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance))
      return null;
    const o = this.getBorderAndBackgroundAppearances(s);
    if (r === void 0 && (r = this.data.fieldValue, !r))
      return `/Tx BMC q ${o}Q EMC`;
    if (Array.isArray(r) && r.length === 1 && (r = r[0]), _e(typeof r == "string", "Expected `value` to be a string."), r = r.trimEnd(), this.data.combo) {
      const N = this.data.options.find(({
        exportValue: T
      }) => r === T);
      r = (N == null ? void 0 : N.displayValue) || r;
    }
    if (r === "")
      return `/Tx BMC q ${o}Q EMC`;
    g === void 0 && (g = this.rotation);
    let I = -1, c;
    this.data.multiLine ? (c = r.split(/\r\n?|\n/).map((N) => N.normalize("NFC")), I = c.length) : c = [r.replace(/\r\n?|\n/, "").normalize("NFC")];
    const l = 1, h = 2;
    let C = this.data.rect[3] - this.data.rect[1], B = this.data.rect[2] - this.data.rect[0];
    (g === 90 || g === 270) && ([B, C] = [C, B]), this._defaultAppearance || (this.data.defaultAppearanceData = so(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    let Q = await Ot._getFontData(A, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources), E, f, d;
    const u = [];
    let x = !1;
    for (const N of c) {
      const T = Q.encodeString(N);
      T.length > 1 && (x = !0), u.push(T.join(""));
    }
    if (x && i & it.SAVE)
      return {
        needAppearances: !0
      };
    if (x && this._isOffscreenCanvasSupported) {
      const N = this.data.comb ? "monospace" : "sans-serif", T = new Ai(A.xref, N), _ = T.createFontResources(c.join("")), oA = _.getRaw("Font");
      if (this._fieldResources.mergedResources.has("Font")) {
        const tA = this._fieldResources.mergedResources.get("Font");
        for (const $ of oA.getKeys())
          tA.set($, oA.getRaw($));
      } else
        this._fieldResources.mergedResources.set("Font", oA);
      const G = T.fontName.name;
      Q = await Ot._getFontData(A, t, {
        fontName: G,
        fontSize: 0
      }, _);
      for (let tA = 0, $ = u.length; tA < $; tA++)
        u[tA] = yc(c[tA]);
      const S = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
      this.data.defaultAppearanceData.fontSize = 0, this.data.defaultAppearanceData.fontName = G, [E, f, d] = this._computeFontSize(C - 2 * l, B - 2 * h, r, Q, I), this.data.defaultAppearanceData = S;
    } else
      this._isOffscreenCanvasSupported || k("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly."), [E, f, d] = this._computeFontSize(C - 2 * l, B - 2 * h, r, Q, I);
    let m = Q.descent;
    isNaN(m) ? m = Fo * d : m = Math.max(Fo * d, Math.abs(m) * f);
    const p = Math.min(Math.floor((C - f) / 2), l), D = this.data.textAlignment;
    if (this.data.multiLine)
      return this._getMultilineAppearance(E, u, Q, f, B, C, D, h, p, m, d, s);
    if (this.data.comb)
      return this._getCombAppearance(E, Q, u[0], f, B, C, h, p, m, d, s);
    const F = p + m;
    if (D === 0 || D > 2)
      return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 ${$A(h)} ${$A(F)} Tm (${es(u[0])}) Tj ET Q EMC`;
    const y = {
      shift: 0
    }, H = this._renderText(u[0], Q, f, B, D, y, h, F);
    return `/Tx BMC q ${o}BT ` + E + ` 1 0 0 1 0 0 Tm ${H} ET Q EMC`;
  }
  static async _getFontData(A, t, i, s) {
    const a = new lt(), n = {
      font: null,
      clone() {
        return this;
      }
    }, {
      fontName: r,
      fontSize: g
    } = i;
    return await A.handleSetFont(s, [r && L.get(r), g], null, a, t, n, null), n.font;
  }
  _getTextWidth(A, t) {
    return t.charsToGlyphs(A).reduce((i, s) => i + s.width, 0) / 1e3;
  }
  _computeFontSize(A, t, i, s, a) {
    let {
      fontSize: n
    } = this.data.defaultAppearanceData, r = (n || 12) * Qi, g = Math.round(A / r);
    if (!n) {
      const o = (l) => Math.floor(l * 100) / 100;
      if (a === -1) {
        const l = this._getTextWidth(i, s);
        n = o(Math.min(A / Qi, t / l)), g = 1;
      } else {
        const l = i.split(/\r\n?|\n/), h = [];
        for (const B of l) {
          const Q = s.encodeString(B).join(""), E = s.charsToGlyphs(Q), f = s.getCharPositions(Q);
          h.push({
            line: Q,
            glyphs: E,
            positions: f
          });
        }
        const C = (B) => {
          let Q = 0;
          for (const E of h) {
            const f = this._splitLine(null, s, B, t, E);
            if (Q += f.length * B, Q > A)
              return !0;
          }
          return !1;
        };
        for (g = Math.max(g, a); ; ) {
          if (r = A / g, n = o(r / Qi), C(n)) {
            g++;
            continue;
          }
          break;
        }
      }
      const {
        fontName: I,
        fontColor: c
      } = this.data.defaultAppearanceData;
      this._defaultAppearance = T1({
        fontSize: n,
        fontName: I,
        fontColor: c
      });
    }
    return [this._defaultAppearance, n, A / g];
  }
  _renderText(A, t, i, s, a, n, r, g) {
    let o;
    if (a === 1) {
      const c = this._getTextWidth(A, t) * i;
      o = (s - c) / 2;
    } else if (a === 2) {
      const c = this._getTextWidth(A, t) * i;
      o = s - c - r;
    } else
      o = r;
    const I = $A(o - n.shift);
    return n.shift = o, g = $A(g), `${I} ${g} Td (${es(A)}) Tj`;
  }
  _getSaveFieldResources(A) {
    var n;
    const {
      localResources: t,
      appearanceResources: i,
      acroFormResources: s
    } = this._fieldResources, a = (n = this.data.defaultAppearanceData) == null ? void 0 : n.fontName;
    if (!a)
      return t || R.empty;
    for (const r of [t, i])
      if (r instanceof R) {
        const g = r.get("Font");
        if (g instanceof R && g.has(a))
          return r;
      }
    if (s instanceof R) {
      const r = s.get("Font");
      if (r instanceof R && r.has(a)) {
        const g = new R(A);
        g.set(a, r.getRaw(a));
        const o = new R(A);
        return o.set("Font", g), R.merge({
          xref: A,
          dictArray: [o, t],
          mergeSubDicts: !0
        });
      }
    }
    return t || R.empty;
  }
  getFieldObject() {
    return null;
  }
}
class T9 extends Ot {
  constructor(A) {
    super(A);
    const {
      dict: t
    } = A;
    t.has("PMD") && (this.flags |= ke.HIDDEN, this.data.hidden = !0, k("Barcodes are not supported")), this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML, this._hasText = !0, typeof this.data.fieldValue != "string" && (this.data.fieldValue = "");
    let i = Gt({
      dict: t,
      key: "Q"
    });
    (!Number.isInteger(i) || i < 0 || i > 2) && (i = null), this.data.textAlignment = i;
    let s = Gt({
      dict: t,
      key: "MaxLen"
    });
    (!Number.isInteger(s) || s < 0) && (s = 0), this.data.maxLen = s, this.data.multiLine = this.hasFieldFlag(Pe.MULTILINE), this.data.comb = this.hasFieldFlag(Pe.COMB) && !this.hasFieldFlag(Pe.MULTILINE) && !this.hasFieldFlag(Pe.PASSWORD) && !this.hasFieldFlag(Pe.FILESELECT) && this.data.maxLen !== 0, this.data.doNotScroll = this.hasFieldFlag(Pe.DONOTSCROLL);
  }
  get hasTextContent() {
    return !!this.appearance && !this._needAppearances;
  }
  _getCombAppearance(A, t, i, s, a, n, r, g, o, I, c) {
    const l = a / this.data.maxLen, h = this.getBorderAndBackgroundAppearances(c), C = [], B = t.getCharPositions(i);
    for (const [E, f] of B)
      C.push(`(${es(i.substring(E, f))}) Tj`);
    const Q = C.join(` ${$A(l)} 0 Td `);
    return `/Tx BMC q ${h}BT ` + A + ` 1 0 0 1 ${$A(r)} ${$A(g + o)} Tm ${Q} ET Q EMC`;
  }
  _getMultilineAppearance(A, t, i, s, a, n, r, g, o, I, c, l) {
    const h = [], C = a - 2 * g, B = {
      shift: 0
    };
    for (let f = 0, d = t.length; f < d; f++) {
      const u = t[f], x = this._splitLine(u, i, s, C);
      for (let m = 0, p = x.length; m < p; m++) {
        const D = x[m], F = f === 0 && m === 0 ? -o - (c - I) : -c;
        h.push(this._renderText(D, i, s, a, r, B, g, F));
      }
    }
    const Q = this.getBorderAndBackgroundAppearances(l), E = h.join(`
`);
    return `/Tx BMC q ${Q}BT ` + A + ` 1 0 0 1 0 ${$A(n)} Tm ${E} ET Q EMC`;
  }
  _splitLine(A, t, i, s, a = {}) {
    A = a.line || A;
    const n = a.glyphs || t.charsToGlyphs(A);
    if (n.length <= 1)
      return [A];
    const r = a.positions || t.getCharPositions(A), g = i / 1e3, o = [];
    let I = -1, c = -1, l = -1, h = 0, C = 0;
    for (let B = 0, Q = n.length; B < Q; B++) {
      const [E, f] = r[B], d = n[B], u = d.width * g;
      d.unicode === " " ? C + u > s ? (o.push(A.substring(h, E)), h = E, C = u, I = -1, l = -1) : (C += u, I = E, c = f, l = B) : C + u > s ? I !== -1 ? (o.push(A.substring(h, c)), h = c, B = l + 1, I = -1, C = 0) : (o.push(A.substring(h, E)), h = E, C = u) : C += u;
    }
    return h < A.length && o.push(A.substring(h, A.length)), o;
  }
  async extractTextContent(A, t, i) {
    await super.extractTextContent(A, t, i);
    const s = this.data.textContent;
    if (!s)
      return;
    const a = s.join(`
`);
    if (a === this.data.fieldValue)
      return;
    const n = a.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (r, g) => g ? `\\${g}` : "\\s+");
    new RegExp(`^\\s*${n}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split(`
`));
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: this.data.fieldValue,
      defaultValue: this.data.defaultFieldValue || "",
      multiline: this.data.multiLine,
      password: this.hasFieldFlag(Pe.PASSWORD),
      charLimit: this.data.maxLen,
      comb: this.data.comb,
      editable: !this.data.readOnly,
      hidden: this.data.hidden,
      name: this.data.fieldName,
      rect: this.data.rect,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: "text"
    };
  }
}
class q9 extends Ot {
  constructor(A) {
    super(A), this.checkedAppearance = null, this.uncheckedAppearance = null, this.data.checkBox = !this.hasFieldFlag(Pe.RADIO) && !this.hasFieldFlag(Pe.PUSHBUTTON), this.data.radioButton = this.hasFieldFlag(Pe.RADIO) && !this.hasFieldFlag(Pe.PUSHBUTTON), this.data.pushButton = this.hasFieldFlag(Pe.PUSHBUTTON), this.data.isTooltipOnly = !1, this.data.checkBox ? this._processCheckBox(A) : this.data.radioButton ? this._processRadioButton(A) : this.data.pushButton ? (this.data.hasOwnCanvas = !0, this.data.noHTML = !1, this._processPushButton(A)) : k("Invalid field flags for button widget annotation");
  }
  async getOperatorList(A, t, i, s) {
    if (this.data.pushButton)
      return super.getOperatorList(A, t, i, !1, s);
    let a = null, n = null;
    if (s) {
      const g = s.get(this.data.id);
      a = g ? g.value : null, n = g ? g.rotation : null;
    }
    if (a === null && this.appearance)
      return super.getOperatorList(A, t, i, s);
    a == null && (a = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
    const r = a ? this.checkedAppearance : this.uncheckedAppearance;
    if (r) {
      const g = this.appearance, o = Ji(r.dict.getArray("Matrix"), Wt);
      n && r.dict.set("Matrix", this.getRotationMatrix(s)), this.appearance = r;
      const I = super.getOperatorList(A, t, i, s);
      return this.appearance = g, r.dict.set("Matrix", o), I;
    }
    return {
      opList: new lt(),
      separateForm: !1,
      separateCanvas: !1
    };
  }
  async save(A, t, i, s) {
    if (this.data.checkBox) {
      this._saveCheckbox(A, t, i, s);
      return;
    }
    this.data.radioButton && this._saveRadioButton(A, t, i, s);
  }
  async _saveCheckbox(A, t, i, s) {
    if (!i)
      return;
    const a = i.get(this.data.id), n = this._buildFlags(a == null ? void 0 : a.noView, a == null ? void 0 : a.noPrint);
    let r = a == null ? void 0 : a.rotation, g = a == null ? void 0 : a.value;
    if (r === void 0 && n === void 0 && (g === void 0 || this.data.fieldValue === this.data.exportValue === g))
      return;
    let o = A.xref.fetchIfRef(this.ref);
    if (!(o instanceof R))
      return;
    o = o.clone(), r === void 0 && (r = this.rotation), g === void 0 && (g = this.data.fieldValue === this.data.exportValue);
    const I = {
      path: this.data.fieldName,
      value: g ? this.data.exportValue : ""
    }, c = L.get(g ? this.data.exportValue : "Off");
    this.setValue(o, c, A.xref, s), o.set("AS", c), o.set("M", `D:${xi()}`), n !== void 0 && o.set("F", n);
    const l = this._getMKDict(r);
    l && o.set("MK", l), s.put(this.ref, {
      data: o,
      xfa: I,
      needAppearances: !1
    });
  }
  async _saveRadioButton(A, t, i, s) {
    if (!i)
      return;
    const a = i.get(this.data.id), n = this._buildFlags(a == null ? void 0 : a.noView, a == null ? void 0 : a.noPrint);
    let r = a == null ? void 0 : a.rotation, g = a == null ? void 0 : a.value;
    if (r === void 0 && n === void 0 && (g === void 0 || this.data.fieldValue === this.data.buttonValue === g))
      return;
    let o = A.xref.fetchIfRef(this.ref);
    if (!(o instanceof R))
      return;
    o = o.clone(), g === void 0 && (g = this.data.fieldValue === this.data.buttonValue), r === void 0 && (r = this.rotation);
    const I = {
      path: this.data.fieldName,
      value: g ? this.data.buttonValue : ""
    }, c = L.get(g ? this.data.buttonValue : "Off");
    g && this.setValue(o, c, A.xref, s), o.set("AS", c), o.set("M", `D:${xi()}`), n !== void 0 && o.set("F", n);
    const l = this._getMKDict(r);
    l && o.set("MK", l), s.put(this.ref, {
      data: o,
      xfa: I,
      needAppearances: !1
    });
  }
  _getDefaultCheckedAppearance(A, t) {
    const i = this.data.rect[2] - this.data.rect[0], s = this.data.rect[3] - this.data.rect[1], a = [0, 0, i, s], r = Math.min(i, s) * 0.8;
    let g, o;
    t === "check" ? (g = {
      width: 0.755 * r,
      height: 0.705 * r
    }, o = "3") : t === "disc" ? (g = {
      width: 0.791 * r,
      height: 0.705 * r
    }, o = "l") : WA(`_getDefaultCheckedAppearance - unsupported type: ${t}`);
    const I = $A((i - g.width) / 2), c = $A((s - g.height) / 2), l = `q BT /PdfJsZaDb ${r} Tf 0 g ${I} ${c} Td (${o}) Tj ET Q`, h = new R(A.xref);
    h.set("FormType", 1), h.set("Subtype", L.get("Form")), h.set("Type", L.get("XObject")), h.set("BBox", a), h.set("Matrix", [1, 0, 0, 1, 0, 0]), h.set("Length", l.length);
    const C = new R(A.xref), B = new R(A.xref);
    B.set("PdfJsZaDb", this.fallbackFontDict), C.set("Font", B), h.set("Resources", C), this.checkedAppearance = new Ct(l), this.checkedAppearance.dict = h, this._streams.push(this.checkedAppearance);
  }
  _processCheckBox(A) {
    const t = A.dict.get("AP");
    if (!(t instanceof R))
      return;
    const i = t.get("N");
    if (!(i instanceof R))
      return;
    const s = this._decodeFormValue(A.dict.get("AS"));
    typeof s == "string" && (this.data.fieldValue = s);
    const a = this.data.fieldValue !== null && this.data.fieldValue !== "Off" ? this.data.fieldValue : "Yes", n = i.getKeys();
    if (n.length === 0)
      n.push("Off", a);
    else if (n.length === 1)
      n[0] === "Off" ? n.push(a) : n.unshift("Off");
    else if (n.includes(a))
      n.length = 0, n.push("Off", a);
    else {
      const o = n.find((I) => I !== "Off");
      n.length = 0, n.push("Off", o);
    }
    n.includes(this.data.fieldValue) || (this.data.fieldValue = "Off"), this.data.exportValue = n[1];
    const r = i.get(this.data.exportValue);
    this.checkedAppearance = r instanceof JA ? r : null;
    const g = i.get("Off");
    this.uncheckedAppearance = g instanceof JA ? g : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(A, "check"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processRadioButton(A) {
    this.data.buttonValue = null;
    const t = A.dict.get("Parent");
    if (t instanceof R) {
      this.parent = A.dict.getRaw("Parent");
      const r = t.get("V");
      r instanceof L && (this.data.fieldValue = this._decodeFormValue(r));
    }
    const i = A.dict.get("AP");
    if (!(i instanceof R))
      return;
    const s = i.get("N");
    if (!(s instanceof R))
      return;
    for (const r of s.getKeys())
      if (r !== "Off") {
        this.data.buttonValue = this._decodeFormValue(r);
        break;
      }
    const a = s.get(this.data.buttonValue);
    this.checkedAppearance = a instanceof JA ? a : null;
    const n = s.get("Off");
    this.uncheckedAppearance = n instanceof JA ? n : null, this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(A, "disc"), this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance), this._fallbackFontDict = this.fallbackFontDict, this.data.defaultFieldValue === null && (this.data.defaultFieldValue = "Off");
  }
  _processPushButton(A) {
    const {
      dict: t,
      annotationGlobals: i
    } = A;
    if (!t.has("A") && !t.has("AA") && !this.data.alternativeText) {
      k("Push buttons without action dictionaries are not supported");
      return;
    }
    this.data.isTooltipOnly = !t.has("A") && !t.has("AA"), ta.parseDestDictionary({
      destDict: t,
      resultObj: this.data,
      docBaseUrl: i.baseUrl,
      docAttachments: i.attachments
    });
  }
  getFieldObject() {
    let A = "button", t;
    return this.data.checkBox ? (A = "checkbox", t = this.data.exportValue) : this.data.radioButton && (A = "radiobutton", t = this.data.buttonValue), {
      id: this.data.id,
      value: this.data.fieldValue || "Off",
      defaultValue: this.data.defaultFieldValue,
      exportValues: t,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: A
    };
  }
  get fallbackFontDict() {
    const A = new R();
    return A.set("BaseFont", L.get("ZapfDingbats")), A.set("Type", L.get("FallbackType")), A.set("Subtype", L.get("FallbackType")), A.set("Encoding", L.get("ZapfDingbatsEncoding")), iA(this, "fallbackFontDict", A);
  }
}
class P9 extends Ot {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    this.indices = t.getArray("I"), this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0, this.data.options = [];
    const s = Gt({
      dict: t,
      key: "Opt"
    });
    if (Array.isArray(s))
      for (let a = 0, n = s.length; a < n; a++) {
        const r = i.fetchIfRef(s[a]), g = Array.isArray(r);
        this.data.options[a] = {
          exportValue: this._decodeFormValue(g ? i.fetchIfRef(r[0]) : r),
          displayValue: this._decodeFormValue(g ? i.fetchIfRef(r[1]) : r)
        };
      }
    if (!this.hasIndices)
      typeof this.data.fieldValue == "string" ? this.data.fieldValue = [this.data.fieldValue] : this.data.fieldValue || (this.data.fieldValue = []);
    else {
      this.data.fieldValue = [];
      const a = this.data.options.length;
      for (const n of this.indices)
        Number.isInteger(n) && n >= 0 && n < a && this.data.fieldValue.push(this.data.options[n].exportValue);
    }
    this.data.options.length === 0 && this.data.fieldValue.length > 0 && (this.data.options = this.data.fieldValue.map((a) => ({
      exportValue: a,
      displayValue: a
    }))), this.data.combo = this.hasFieldFlag(Pe.COMBO), this.data.multiSelect = this.hasFieldFlag(Pe.MULTISELECT), this._hasText = !0;
  }
  getFieldObject() {
    const A = this.data.combo ? "combobox" : "listbox", t = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
    return {
      id: this.data.id,
      value: t,
      defaultValue: this.data.defaultFieldValue,
      editable: !this.data.readOnly,
      name: this.data.fieldName,
      rect: this.data.rect,
      numItems: this.data.fieldValue.length,
      multipleSelection: this.data.multiSelect,
      hidden: this.data.hidden,
      actions: this.data.actions,
      items: this.data.options,
      page: this.data.pageIndex,
      strokeColor: this.data.borderColor,
      fillColor: this.data.backgroundColor,
      rotation: this.rotation,
      type: A
    };
  }
  amendSavedDict(A, t) {
    var n;
    if (!this.hasIndices)
      return;
    let i = (n = A == null ? void 0 : A.get(this.data.id)) == null ? void 0 : n.value;
    Array.isArray(i) || (i = [i]);
    const s = [], {
      options: a
    } = this.data;
    for (let r = 0, g = 0, o = a.length; r < o; r++)
      a[r].exportValue === i[g] && (s.push(r), g += 1);
    t.set("I", s);
  }
  async _getAppearance(A, t, i, s) {
    if (this.data.combo)
      return super._getAppearance(A, t, i, s);
    let a, n;
    const r = s == null ? void 0 : s.get(this.data.id);
    if (r && (n = r.rotation, a = r.value), n === void 0 && a === void 0 && !this._needAppearances)
      return null;
    a === void 0 ? a = this.data.fieldValue : Array.isArray(a) || (a = [a]);
    const g = 1, o = 2;
    let I = this.data.rect[3] - this.data.rect[1], c = this.data.rect[2] - this.data.rect[0];
    (n === 90 || n === 270) && ([c, I] = [I, c]);
    const l = this.data.options.length, h = [];
    for (let D = 0; D < l; D++) {
      const {
        exportValue: F
      } = this.data.options[D];
      a.includes(F) && h.push(D);
    }
    this._defaultAppearance || (this.data.defaultAppearanceData = so(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
    const C = await Ot._getFontData(A, t, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
    let B, {
      fontSize: Q
    } = this.data.defaultAppearanceData;
    if (Q)
      B = this._defaultAppearance;
    else {
      const D = (I - g) / l;
      let F = -1, y;
      for (const {
        displayValue: H
      } of this.data.options) {
        const N = this._getTextWidth(H, C);
        N > F && (F = N, y = H);
      }
      [B, Q] = this._computeFontSize(D, c - 2 * o, y, C, -1);
    }
    const E = Q * Qi, f = (E - Q) / 2, d = Math.floor(I / E);
    let u = 0;
    if (h.length > 0) {
      const D = Math.min(...h), F = Math.max(...h);
      u = Math.max(0, F - d + 1), u > D && (u = D);
    }
    const x = Math.min(u + d + 1, l), m = ["/Tx BMC q", `1 1 ${c} ${I} re W n`];
    if (h.length) {
      m.push("0.600006 0.756866 0.854904 rg");
      for (const D of h)
        u <= D && D < x && m.push(`1 ${I - (D - u + 1) * E} ${c} ${E} re f`);
    }
    m.push("BT", B, `1 0 0 1 0 ${I} Tm`);
    const p = {
      shift: 0
    };
    for (let D = u; D < x; D++) {
      const {
        displayValue: F
      } = this.data.options[D], y = D === u ? f : 0;
      m.push(this._renderText(F, C, Q, c, 0, p, o, -E + y));
    }
    return m.push("ET Q EMC"), m.join(`
`);
  }
}
class zl extends Ot {
  constructor(A) {
    super(A), this.data.fieldValue = null, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !this.data.hasOwnCanvas;
  }
  getFieldObject() {
    return {
      id: this.data.id,
      value: null,
      page: this.data.pageIndex,
      type: "signature"
    };
  }
}
class W9 extends Et {
  constructor(A) {
    super(A), this.data.noRotate = !0, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const {
      dict: i
    } = A;
    this.data.annotationType = Je.TEXT, this.data.hasAppearance ? this.data.name = "NoIcon" : (this.data.rect[1] = this.data.rect[3] - 22, this.data.rect[2] = this.data.rect[0] + 22, this.data.name = i.has("Name") ? i.get("Name").name : "Note"), i.has("State") ? (this.data.state = i.get("State") || null, this.data.stateModel = i.get("StateModel") || null) : (this.data.state = null, this.data.stateModel = null);
  }
}
class O9 extends Ra {
  constructor(A) {
    var a;
    super(A);
    const {
      dict: t,
      annotationGlobals: i
    } = A;
    this.data.annotationType = Je.LINK, this.data.noHTML = !1;
    const s = Fa(t, this.rectangle);
    s && (this.data.quadPoints = s), (a = this.data).borderColor || (a.borderColor = this.data.color), ta.parseDestDictionary({
      destDict: t,
      resultObj: this.data,
      docBaseUrl: i.baseUrl,
      docAttachments: i.attachments
    });
  }
}
class $l extends Ra {
  constructor(A) {
    super(A);
    const {
      dict: t
    } = A;
    this.data.annotationType = Je.POPUP, this.data.noHTML = !1, (this.data.rect[0] === this.data.rect[2] || this.data.rect[1] === this.data.rect[3]) && (this.data.rect = null);
    let i = t.get("Parent");
    if (!i) {
      k("Popup annotation has a missing or invalid parent annotation.");
      return;
    }
    this.data.parentRect = ii(i.getArray("Rect"), null);
    const s = i.get("RT");
    if (xe(s, Or.GROUP) && (i = i.get("IRT")), i.has("M") ? (this.setModificationDate(i.get("M")), this.data.modificationDate = this.modificationDate) : this.data.modificationDate = null, i.has("C") ? (this.setColor(i.getArray("C")), this.data.color = this.color) : this.data.color = null, !this.viewable) {
      const a = i.get("F");
      this._isViewable(a) && this.setFlags(a);
    }
    this.setTitle(i.get("T")), this.data.titleObj = this._title, this.setContents(i.get("Contents")), this.data.contentsObj = this._contents, i.has("RC") && (this.data.richText = Sa.getRichTextAsHtml(i.get("RC"))), this.data.open = !!t.get("Open");
  }
}
class Tr extends Et {
  constructor(A) {
    var s;
    super(A), this.data.hasOwnCanvas = this.data.noRotate, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
    const {
      evaluatorOptions: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.FREETEXT, this.setDefaultAppearance(A), this._hasAppearance = !!this.appearance, this._hasAppearance) {
      const {
        fontColor: a,
        fontSize: n
      } = v1(this.appearance, t, i);
      this.data.defaultAppearanceData.fontColor = a, this.data.defaultAppearanceData.fontSize = n || 10;
    } else {
      (s = this.data.defaultAppearanceData).fontSize || (s.fontSize = 10);
      const {
        fontColor: a,
        fontSize: n
      } = this.data.defaultAppearanceData;
      if (this._contents.str) {
        this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((I) => I.trimEnd());
        const {
          coords: r,
          bbox: g,
          matrix: o
        } = Ai.getFirstPositionInfo(this.rectangle, this.rotation, n);
        this.data.textPosition = this._transformPoint(r, g, o);
      }
      if (this._isOffscreenCanvasSupported) {
        const r = A.dict.get("CA"), g = new Ai(i, "sans-serif");
        this.appearance = g.createAppearance(this._contents.str, this.rectangle, this.rotation, n, a, r), this._streams.push(this.appearance);
      } else
        k("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
    }
  }
  get hasTextContent() {
    return this._hasAppearance;
  }
  static createNewDict(A, t, {
    apRef: i,
    ap: s
  }) {
    const {
      color: a,
      fontSize: n,
      oldAnnotation: r,
      rect: g,
      rotation: o,
      user: I,
      value: c
    } = A, l = r || new R(t);
    l.set("Type", L.get("Annot")), l.set("Subtype", L.get("FreeText")), r ? (l.set("M", `D:${xi()}`), l.delete("RC")) : l.set("CreationDate", `D:${xi()}`), l.set("Rect", g);
    const h = `/Helv ${n} Tf ${mi(a, !0)}`;
    if (l.set("DA", h), l.set("Contents", Nt(c)), l.set("F", 4), l.set("Border", [0, 0, 0]), l.set("Rotate", o), I && l.set("T", Nt(I)), i || s) {
      const C = new R(t);
      l.set("AP", C), i ? C.set("N", i) : C.set("N", s);
    }
    return l;
  }
  static async createNewAppearanceStream(A, t, i) {
    const {
      baseFontRef: s,
      evaluator: a,
      task: n
    } = i, {
      color: r,
      fontSize: g,
      rect: o,
      rotation: I,
      value: c
    } = A, l = new R(t), h = new R(t);
    if (s)
      h.set("Helv", s);
    else {
      const X = new R(t);
      X.set("BaseFont", L.get("Helvetica")), X.set("Type", L.get("Font")), X.set("Subtype", L.get("Type1")), X.set("Encoding", L.get("WinAnsiEncoding")), h.set("Helv", X);
    }
    l.set("Font", h);
    const C = await Ot._getFontData(a, n, {
      fontName: "Helv",
      fontSize: g
    }, l), [B, Q, E, f] = o;
    let d = E - B, u = f - Q;
    I % 180 !== 0 && ([d, u] = [u, d]);
    const x = c.split(`
`), m = g / 1e3;
    let p = -1 / 0;
    const D = [];
    for (let X of x) {
      const qA = C.encodeString(X);
      if (qA.length > 1)
        return null;
      X = qA.join(""), D.push(X);
      let IA = 0;
      const U = C.charsToGlyphs(X);
      for (const J of U)
        IA += J.width * m;
      p = Math.max(p, IA);
    }
    let F = 1;
    p > d && (F = d / p);
    let y = 1;
    const H = Qi * g, N = (Qi - xn) * g, T = H * x.length;
    T > u && (y = u / T);
    const _ = Math.min(F, y), oA = g * _;
    let G, S, tA;
    switch (I) {
      case 0:
        tA = [1, 0, 0, 1], S = [o[0], o[1], d, u], G = [o[0], o[3] - N];
        break;
      case 90:
        tA = [0, 1, -1, 0], S = [o[1], -o[2], d, u], G = [o[1], -o[0] - N];
        break;
      case 180:
        tA = [-1, 0, 0, -1], S = [-o[2], -o[3], d, u], G = [-o[2], -o[1] - N];
        break;
      case 270:
        tA = [0, -1, 1, 0], S = [-o[3], o[0], d, u], G = [-o[3], o[2] - N];
        break;
    }
    const $ = ["q", `${tA.join(" ")} 0 0 cm`, `${S.join(" ")} re W n`, "BT", `${mi(r, !0)}`, `0 Tc /Helv ${$A(oA)} Tf`];
    $.push(`${G.join(" ")} Td (${es(D[0])}) Tj`);
    const hA = $A(H);
    for (let X = 1, qA = D.length; X < qA; X++) {
      const IA = D[X];
      $.push(`0 -${hA} Td (${es(IA)}) Tj`);
    }
    $.push("ET", "Q");
    const yA = $.join(`
`), pA = new R(t);
    pA.set("FormType", 1), pA.set("Subtype", L.get("Form")), pA.set("Type", L.get("XObject")), pA.set("BBox", o), pA.set("Resources", l), pA.set("Matrix", [1, 0, 0, 1, -o[0], -o[1]]);
    const DA = new Ct(yA);
    return DA.dict = pA, DA;
  }
}
class V9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    this.data.annotationType = Je.LINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const s = _r(t.getArray("L"), [0, 0, 0, 0]);
    if (this.data.lineCoordinates = de.normalizeRect(s), this.setLineEndings(t.getArray("LE")), this.data.lineEndings = this.lineEndings, !this.appearance) {
      const a = this.color ? Qt(this.color) : [0, 0, 0], n = t.get("CA"), r = j0(t.getArray("IC"), null), g = r ? Qt(r) : null, o = g ? n : null, I = this.borderStyle.width || 1, c = 2 * I, l = [this.data.lineCoordinates[0] - c, this.data.lineCoordinates[1] - c, this.data.lineCoordinates[2] + c, this.data.lineCoordinates[3] + c];
      de.intersect(this.rectangle, l) || (this.rectangle = l), this._setDefaultAppearance({
        xref: i,
        extra: `${I} w`,
        strokeColor: a,
        fillColor: g,
        strokeAlpha: n,
        fillAlpha: o,
        pointsCallback: (h, C) => (h.push(`${s[0]} ${s[1]} m`, `${s[2]} ${s[3]} l`, "S"), [C[0] - I, C[2] + I, C[7] - I, C[3] + I])
      });
    }
  }
}
class Z9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.SQUARE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, !this.appearance) {
      const s = this.color ? Qt(this.color) : [0, 0, 0], a = t.get("CA"), n = j0(t.getArray("IC"), null), r = n ? Qt(n) : null, g = r ? a : null;
      if (this.borderStyle.width === 0 && !r)
        return;
      this._setDefaultAppearance({
        xref: i,
        extra: `${this.borderStyle.width} w`,
        strokeColor: s,
        fillColor: r,
        strokeAlpha: a,
        fillAlpha: g,
        pointsCallback: (o, I) => {
          const c = I[4] + this.borderStyle.width / 2, l = I[5] + this.borderStyle.width / 2, h = I[6] - I[4] - this.borderStyle.width, C = I[3] - I[7] - this.borderStyle.width;
          return o.push(`${c} ${l} ${h} ${C} re`), r ? o.push("B") : o.push("S"), [I[0], I[2], I[7], I[3]];
        }
      });
    }
  }
}
class j9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.CIRCLE, !this.appearance) {
      const s = this.color ? Qt(this.color) : [0, 0, 0], a = t.get("CA"), n = j0(t.getArray("IC"), null), r = n ? Qt(n) : null, g = r ? a : null;
      if (this.borderStyle.width === 0 && !r)
        return;
      const o = 4 / 3 * Math.tan(Math.PI / (2 * 4));
      this._setDefaultAppearance({
        xref: i,
        extra: `${this.borderStyle.width} w`,
        strokeColor: s,
        fillColor: r,
        strokeAlpha: a,
        fillAlpha: g,
        pointsCallback: (I, c) => {
          const l = c[0] + this.borderStyle.width / 2, h = c[1] - this.borderStyle.width / 2, C = c[6] - this.borderStyle.width / 2, B = c[7] + this.borderStyle.width / 2, Q = l + (C - l) / 2, E = h + (B - h) / 2, f = (C - l) / 2 * o, d = (B - h) / 2 * o;
          return I.push(`${Q} ${B} m`, `${Q + f} ${B} ${C} ${E + d} ${C} ${E} c`, `${C} ${E - d} ${Q + f} ${h} ${Q} ${h} c`, `${Q - f} ${h} ${l} ${E - d} ${l} ${E} c`, `${l} ${E + d} ${Q - f} ${B} ${Q} ${B} c`, "h"), r ? I.push("B") : I.push("S"), [c[0], c[2], c[7], c[3]];
        }
      });
    }
  }
}
class Ah extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    this.data.annotationType = Je.POLYLINE, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.vertices = null, this instanceof eh || (this.setLineEndings(t.getArray("LE")), this.data.lineEndings = this.lineEndings);
    const s = t.getArray("Vertices");
    if (!at(s, null))
      return;
    const a = this.data.vertices = Float32Array.from(s);
    if (!this.appearance) {
      const n = this.color ? Qt(this.color) : [0, 0, 0], r = t.get("CA"), g = this.borderStyle.width || 1, o = 2 * g, I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let c = 0, l = a.length; c < l; c += 2)
        I[0] = Math.min(I[0], a[c] - o), I[1] = Math.min(I[1], a[c + 1] - o), I[2] = Math.max(I[2], a[c] + o), I[3] = Math.max(I[3], a[c + 1] + o);
      de.intersect(this.rectangle, I) || (this.rectangle = I), this._setDefaultAppearance({
        xref: i,
        extra: `${g} w`,
        strokeColor: n,
        strokeAlpha: r,
        pointsCallback: (c, l) => {
          for (let h = 0, C = a.length; h < C; h += 2)
            c.push(`${a[h]} ${a[h + 1]} ${h === 0 ? "m" : "l"}`);
          return c.push("S"), [l[0], l[2], l[7], l[3]];
        }
      });
    }
  }
}
class eh extends Ah {
  constructor(A) {
    super(A), this.data.annotationType = Je.POLYGON;
  }
}
class X9 extends Et {
  constructor(A) {
    super(A), this.data.annotationType = Je.CARET;
  }
}
class Fs extends Et {
  constructor(A) {
    super(A), this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1;
    const {
      dict: t,
      xref: i
    } = A;
    this.data.annotationType = Je.INK, this.data.inkLists = [], this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = t.get("CA") || 1;
    const s = t.getArray("InkList");
    if (Array.isArray(s)) {
      for (let a = 0, n = s.length; a < n; ++a) {
        if (!Array.isArray(s[a]))
          continue;
        const r = new Float32Array(s[a].length);
        this.data.inkLists.push(r);
        for (let g = 0, o = s[a].length; g < o; g += 2) {
          const I = i.fetchIfRef(s[a][g]), c = i.fetchIfRef(s[a][g + 1]);
          typeof I == "number" && typeof c == "number" && (r[g] = I, r[g + 1] = c);
        }
      }
      if (!this.appearance) {
        const a = this.color ? Qt(this.color) : [0, 0, 0], n = t.get("CA"), r = this.borderStyle.width || 1, g = 2 * r, o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const I of this.data.inkLists)
          for (let c = 0, l = I.length; c < l; c += 2)
            o[0] = Math.min(o[0], I[c] - g), o[1] = Math.min(o[1], I[c + 1] - g), o[2] = Math.max(o[2], I[c] + g), o[3] = Math.max(o[3], I[c + 1] + g);
        de.intersect(this.rectangle, o) || (this.rectangle = o), this._setDefaultAppearance({
          xref: i,
          extra: `${r} w`,
          strokeColor: a,
          strokeAlpha: n,
          pointsCallback: (I, c) => {
            for (const l of this.data.inkLists) {
              for (let h = 0, C = l.length; h < C; h += 2)
                I.push(`${l[h]} ${l[h + 1]} ${h === 0 ? "m" : "l"}`);
              I.push("S");
            }
            return [c[0], c[2], c[7], c[3]];
          }
        });
      }
    }
  }
  static createNewDict(A, t, {
    apRef: i,
    ap: s
  }) {
    const {
      oldAnnotation: a,
      color: n,
      opacity: r,
      paths: g,
      outlines: o,
      rect: I,
      rotation: c,
      thickness: l,
      user: h
    } = A, C = a || new R(t);
    C.set("Type", L.get("Annot")), C.set("Subtype", L.get("Ink")), C.set(a ? "M" : "CreationDate", `D:${xi()}`), C.set("Rect", I), C.set("InkList", (o == null ? void 0 : o.points) || g.points), C.set("F", 4), C.set("Rotate", c), h && C.set("T", Nt(h)), o && C.set("IT", L.get("InkHighlight"));
    const B = new R(t);
    C.set("BS", B), B.set("W", l), C.set("C", Array.from(n, (E) => E / 255)), C.set("CA", r);
    const Q = new R(t);
    return C.set("AP", Q), i ? Q.set("N", i) : Q.set("N", s), C;
  }
  static async createNewAppearanceStream(A, t, i) {
    if (A.outlines)
      return this.createNewAppearanceStreamForHighlight(A, t, i);
    const {
      color: s,
      rect: a,
      paths: n,
      thickness: r,
      opacity: g
    } = A, o = [`${r} w 1 J 1 j`, `${mi(s, !1)}`];
    g !== 1 && o.push("/R0 gs");
    for (const h of n.lines) {
      o.push(`${$A(h[4])} ${$A(h[5])} m`);
      for (let C = 6, B = h.length; C < B; C += 6)
        if (isNaN(h[C]))
          o.push(`${$A(h[C + 4])} ${$A(h[C + 5])} l`);
        else {
          const [Q, E, f, d, u, x] = h.slice(C, C + 6);
          o.push([Q, E, f, d, u, x].map($A).join(" ") + " c");
        }
      h.length === 6 && o.push(`${$A(h[4])} ${$A(h[5])} l`);
    }
    o.push("S");
    const I = o.join(`
`), c = new R(t);
    if (c.set("FormType", 1), c.set("Subtype", L.get("Form")), c.set("Type", L.get("XObject")), c.set("BBox", a), c.set("Length", I.length), g !== 1) {
      const h = new R(t), C = new R(t), B = new R(t);
      B.set("CA", g), B.set("Type", L.get("ExtGState")), C.set("R0", B), h.set("ExtGState", C), c.set("Resources", h);
    }
    const l = new Ct(I);
    return l.dict = c, l;
  }
  static async createNewAppearanceStreamForHighlight(A, t, i) {
    const {
      color: s,
      rect: a,
      outlines: {
        outline: n
      },
      opacity: r
    } = A, g = [`${mi(s, !0)}`, "/R0 gs"];
    g.push(`${$A(n[4])} ${$A(n[5])} m`);
    for (let B = 6, Q = n.length; B < Q; B += 6)
      if (isNaN(n[B]))
        g.push(`${$A(n[B + 4])} ${$A(n[B + 5])} l`);
      else {
        const [E, f, d, u, x, m] = n.slice(B, B + 6);
        g.push([E, f, d, u, x, m].map($A).join(" ") + " c");
      }
    g.push("h f");
    const o = g.join(`
`), I = new R(t);
    I.set("FormType", 1), I.set("Subtype", L.get("Form")), I.set("Type", L.get("XObject")), I.set("BBox", a), I.set("Length", o.length);
    const c = new R(t), l = new R(t);
    c.set("ExtGState", l), I.set("Resources", c);
    const h = new R(t);
    l.set("R0", h), h.set("BM", L.get("Multiply")), r !== 1 && (h.set("ca", r), h.set("Type", L.get("ExtGState")));
    const C = new Ct(o);
    return C.dict = I, C;
  }
}
class qr extends Et {
  constructor(A) {
    var a;
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.HIGHLIGHT, this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1, this.data.opacity = t.get("CA") || 1, this.data.quadPoints = Fa(t, null)) {
      const n = (a = this.appearance) == null ? void 0 : a.dict.get("Resources");
      if (!this.appearance || !(n != null && n.has("ExtGState"))) {
        this.appearance && k("HighlightAnnotation - ignoring built-in appearance stream.");
        const r = this.color ? Qt(this.color) : [1, 1, 0], g = t.get("CA");
        this._setDefaultAppearance({
          xref: i,
          fillColor: r,
          blendMode: "Multiply",
          fillAlpha: g,
          pointsCallback: (o, I) => (o.push(`${I[0]} ${I[1]} m`, `${I[2]} ${I[3]} l`, `${I[6]} ${I[7]} l`, `${I[4]} ${I[5]} l`, "f"), [I[0], I[2], I[7], I[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
  static createNewDict(A, t, {
    apRef: i,
    ap: s
  }) {
    const {
      color: a,
      oldAnnotation: n,
      opacity: r,
      rect: g,
      rotation: o,
      user: I,
      quadPoints: c
    } = A, l = n || new R(t);
    if (l.set("Type", L.get("Annot")), l.set("Subtype", L.get("Highlight")), l.set(n ? "M" : "CreationDate", `D:${xi()}`), l.set("CreationDate", `D:${xi()}`), l.set("Rect", g), l.set("F", 4), l.set("Border", [0, 0, 0]), l.set("Rotate", o), l.set("QuadPoints", c), l.set("C", Array.from(a, (h) => h / 255)), l.set("CA", r), I && l.set("T", Nt(I)), i || s) {
      const h = new R(t);
      l.set("AP", h), h.set("N", i || s);
    }
    return l;
  }
  static async createNewAppearanceStream(A, t, i) {
    const {
      color: s,
      rect: a,
      outlines: n,
      opacity: r
    } = A, g = [`${mi(s, !0)}`, "/R0 gs"], o = [];
    for (const Q of n) {
      o.length = 0, o.push(`${$A(Q[0])} ${$A(Q[1])} m`);
      for (let E = 2, f = Q.length; E < f; E += 2)
        o.push(`${$A(Q[E])} ${$A(Q[E + 1])} l`);
      o.push("h"), g.push(o.join(`
`));
    }
    g.push("f*");
    const I = g.join(`
`), c = new R(t);
    c.set("FormType", 1), c.set("Subtype", L.get("Form")), c.set("Type", L.get("XObject")), c.set("BBox", a), c.set("Length", I.length);
    const l = new R(t), h = new R(t);
    l.set("ExtGState", h), c.set("Resources", l);
    const C = new R(t);
    h.set("R0", C), C.set("BM", L.get("Multiply")), r !== 1 && (C.set("ca", r), C.set("Type", L.get("ExtGState")));
    const B = new Ct(I);
    return B.dict = c, B;
  }
}
class _9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.UNDERLINE, this.data.quadPoints = Fa(t, null)) {
      if (!this.appearance) {
        const a = this.color ? Qt(this.color) : [0, 0, 0], n = t.get("CA");
        this._setDefaultAppearance({
          xref: i,
          extra: "[] 0 d 0.571 w",
          strokeColor: a,
          strokeAlpha: n,
          pointsCallback: (r, g) => (r.push(`${g[4]} ${g[5] + 1.3} m`, `${g[6]} ${g[7] + 1.3} l`, "S"), [g[0], g[2], g[7], g[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
}
class z9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.SQUIGGLY, this.data.quadPoints = Fa(t, null)) {
      if (!this.appearance) {
        const a = this.color ? Qt(this.color) : [0, 0, 0], n = t.get("CA");
        this._setDefaultAppearance({
          xref: i,
          extra: "[] 0 d 1 w",
          strokeColor: a,
          strokeAlpha: n,
          pointsCallback: (r, g) => {
            const o = (g[1] - g[5]) / 6;
            let I = o, c = g[4];
            const l = g[5], h = g[6];
            r.push(`${c} ${l + I} m`);
            do
              c += 2, I = I === 0 ? o : 0, r.push(`${c} ${l + I} l`);
            while (c < h);
            return r.push("S"), [g[4], h, l - 2 * o, l + 2 * o];
          }
        });
      }
    } else
      this.data.popupRef = null;
  }
}
class $9 extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A;
    if (this.data.annotationType = Je.STRIKEOUT, this.data.quadPoints = Fa(t, null)) {
      if (!this.appearance) {
        const a = this.color ? Qt(this.color) : [0, 0, 0], n = t.get("CA");
        this._setDefaultAppearance({
          xref: i,
          extra: "[] 0 d 1 w",
          strokeColor: a,
          strokeAlpha: n,
          pointsCallback: (r, g) => (r.push(`${(g[0] + g[4]) / 2} ${(g[1] + g[5]) / 2} m`, `${(g[2] + g[6]) / 2} ${(g[3] + g[7]) / 2} l`, "S"), [g[0], g[2], g[7], g[3]])
        });
      }
    } else
      this.data.popupRef = null;
  }
}
var $0;
class sn extends Et {
  constructor(t) {
    super(t);
    ZA(this, $0);
    this.data.annotationType = Je.STAMP, wt(this, $0, this.data.hasOwnCanvas = this.data.noRotate), this.data.isEditable = !this.data.noHTML, this.data.noHTML = !1;
  }
  mustBeViewedWhenEditing(t, i = null) {
    return t ? this.data.isEditable ? (wt(this, $0, this.data.hasOwnCanvas), this.data.hasOwnCanvas = !0, !0) : !1 : (this.data.hasOwnCanvas = PA(this, $0), !(i != null && i.has(this.data.id)));
  }
  static async createImage(t, i) {
    const {
      width: s,
      height: a
    } = t, n = new OffscreenCanvas(s, a), r = n.getContext("2d", {
      alpha: !0
    });
    r.drawImage(t, 0, 0);
    const g = r.getImageData(0, 0, s, a).data, o = new Uint32Array(g.buffer), I = o.some(ht.isLittleEndian ? (E) => E >>> 24 !== 255 : (E) => (E & 255) !== 255);
    I && (r.fillStyle = "white", r.fillRect(0, 0, s, a), r.drawImage(t, 0, 0));
    const c = n.convertToBlob({
      type: "image/jpeg",
      quality: 1
    }).then((E) => E.arrayBuffer()), l = L.get("XObject"), h = L.get("Image"), C = new R(i);
    C.set("Type", l), C.set("Subtype", h), C.set("BitsPerComponent", 8), C.set("ColorSpace", L.get("DeviceRGB")), C.set("Filter", L.get("DCTDecode")), C.set("BBox", [0, 0, s, a]), C.set("Width", s), C.set("Height", a);
    let B = null;
    if (I) {
      const E = new Uint8Array(o.length);
      if (ht.isLittleEndian)
        for (let d = 0, u = o.length; d < u; d++)
          E[d] = o[d] >>> 24;
      else
        for (let d = 0, u = o.length; d < u; d++)
          E[d] = o[d] & 255;
      const f = new R(i);
      f.set("Type", l), f.set("Subtype", h), f.set("BitsPerComponent", 8), f.set("ColorSpace", L.get("DeviceGray")), f.set("Width", s), f.set("Height", a), B = new Qe(E, 0, 0, f);
    }
    return {
      imageStream: new Qe(await c, 0, 0, C),
      smaskStream: B,
      width: s,
      height: a
    };
  }
  static createNewDict(t, i, {
    apRef: s,
    ap: a
  }) {
    const {
      oldAnnotation: n,
      rect: r,
      rotation: g,
      user: o
    } = t, I = n || new R(i);
    if (I.set("Type", L.get("Annot")), I.set("Subtype", L.get("Stamp")), I.set(n ? "M" : "CreationDate", `D:${xi()}`), I.set("Rect", r), I.set("F", 4), I.set("Border", [0, 0, 0]), I.set("Rotate", g), o && I.set("T", Nt(o)), s || a) {
      const c = new R(i);
      I.set("AP", c), s ? c.set("N", s) : c.set("N", a);
    }
    return I;
  }
  static async createNewAppearanceStream(t, i, s) {
    if (t.oldAnnotation)
      return null;
    const {
      rotation: a
    } = t, {
      imageRef: n,
      width: r,
      height: g
    } = s.image, o = new R(i), I = new R(i);
    o.set("XObject", I), I.set("Im0", n);
    const c = `q ${r} 0 0 ${g} 0 0 cm /Im0 Do Q`, l = new R(i);
    if (l.set("FormType", 1), l.set("Subtype", L.get("Form")), l.set("Type", L.get("XObject")), l.set("BBox", [0, 0, r, g]), l.set("Resources", o), a) {
      const C = wn(a, r, g);
      l.set("Matrix", C);
    }
    const h = new Ct(c);
    return h.dict = l, h;
  }
}
$0 = new WeakMap();
class Ax extends Et {
  constructor(A) {
    super(A);
    const {
      dict: t,
      xref: i
    } = A, s = new yg(t.get("FS"), i);
    this.data.annotationType = Je.FILEATTACHMENT, this.data.hasOwnCanvas = this.data.noRotate, this.data.noHTML = !1, this.data.file = s.serializable;
    const a = t.get("Name");
    this.data.name = a instanceof L ? jA(a.name) : "PushPin";
    const n = t.get("ca");
    this.data.fillAlpha = typeof n == "number" && n >= 0 && n <= 1 ? n : null;
  }
}
const ic = 512;
class ex extends $e {
  constructor(A, t, i) {
    super(t), this.str = A, this.dict = A.dict, this.decrypt = i, this.nextChunk = null, this.initialized = !1;
  }
  readBlock() {
    var r;
    let A;
    if (this.initialized ? A = this.nextChunk : (A = this.str.getBytes(ic), this.initialized = !0), !(A != null && A.length)) {
      this.eof = !0;
      return;
    }
    this.nextChunk = this.str.getBytes(ic);
    const t = ((r = this.nextChunk) == null ? void 0 : r.length) > 0, i = this.decrypt;
    A = i(A, !t);
    const s = this.bufferLength, a = s + A.length;
    this.ensureBuffer(a).set(A, s), this.bufferLength = a;
  }
}
class zi {
  constructor(A) {
    this.a = 0, this.b = 0;
    const t = new Uint8Array(256), i = A.length;
    for (let s = 0; s < 256; ++s)
      t[s] = s;
    for (let s = 0, a = 0; s < 256; ++s) {
      const n = t[s];
      a = a + n + A[s % i] & 255, t[s] = t[a], t[a] = n;
    }
    this.s = t;
  }
  encryptBlock(A) {
    let t = this.a, i = this.b;
    const s = this.s, a = A.length, n = new Uint8Array(a);
    for (let r = 0; r < a; ++r) {
      t = t + 1 & 255;
      const g = s[t];
      i = i + g & 255;
      const o = s[i];
      s[t] = o, s[i] = g, n[r] = A[r] ^ s[g + o & 255];
    }
    return this.a = t, this.b = i, n;
  }
  decryptBlock(A) {
    return this.encryptBlock(A);
  }
  encrypt(A) {
    return this.encryptBlock(A);
  }
}
const Ri = function() {
  const A = new Uint8Array([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]), t = new Int32Array([-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426, -1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162, 1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632, 643717713, -373897302, -701558691, 38016083, -660478335, -405537848, 568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784, 1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556, -1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222, -722521979, 76029189, -640364487, -421815835, 530742520, -995338651, -198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606, -1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649, -145523070, -1120210379, 718787259, -343485551]);
  function i(s, a, n) {
    let r = 1732584193, g = -271733879, o = -1732584194, I = 271733878;
    const c = n + 72 & -64, l = new Uint8Array(c);
    let h, C;
    for (h = 0; h < n; ++h)
      l[h] = s[a++];
    l[h++] = 128;
    const B = c - 8;
    for (; h < B; )
      l[h++] = 0;
    l[h++] = n << 3 & 255, l[h++] = n >> 5 & 255, l[h++] = n >> 13 & 255, l[h++] = n >> 21 & 255, l[h++] = n >>> 29 & 255, l[h++] = 0, l[h++] = 0, l[h++] = 0;
    const Q = new Int32Array(16);
    for (h = 0; h < c; ) {
      for (C = 0; C < 16; ++C, h += 4)
        Q[C] = l[h] | l[h + 1] << 8 | l[h + 2] << 16 | l[h + 3] << 24;
      let E = r, f = g, d = o, u = I, x, m;
      for (C = 0; C < 64; ++C) {
        C < 16 ? (x = f & d | ~f & u, m = C) : C < 32 ? (x = u & f | ~u & d, m = 5 * C + 1 & 15) : C < 48 ? (x = f ^ d ^ u, m = 3 * C + 5 & 15) : (x = d ^ (f | ~u), m = 7 * C & 15);
        const p = u, D = E + x + t[C] + Q[m] | 0, F = A[C];
        u = d, d = f, f = f + (D << F | D >>> 32 - F) | 0, E = p;
      }
      r = r + E | 0, g = g + f | 0, o = o + d | 0, I = I + u | 0;
    }
    return new Uint8Array([r & 255, r >> 8 & 255, r >> 16 & 255, r >>> 24 & 255, g & 255, g >> 8 & 255, g >> 16 & 255, g >>> 24 & 255, o & 255, o >> 8 & 255, o >> 16 & 255, o >>> 24 & 255, I & 255, I >> 8 & 255, I >> 16 & 255, I >>> 24 & 255]);
  }
  return i;
}();
class aA {
  constructor(A, t) {
    this.high = A | 0, this.low = t | 0;
  }
  and(A) {
    this.high &= A.high, this.low &= A.low;
  }
  xor(A) {
    this.high ^= A.high, this.low ^= A.low;
  }
  or(A) {
    this.high |= A.high, this.low |= A.low;
  }
  shiftRight(A) {
    A >= 32 ? (this.low = this.high >>> A - 32 | 0, this.high = 0) : (this.low = this.low >>> A | this.high << 32 - A, this.high = this.high >>> A | 0);
  }
  shiftLeft(A) {
    A >= 32 ? (this.high = this.low << A - 32, this.low = 0) : (this.high = this.high << A | this.low >>> 32 - A, this.low <<= A);
  }
  rotateRight(A) {
    let t, i;
    A & 32 ? (i = this.low, t = this.high) : (t = this.low, i = this.high), A &= 31, this.low = t >>> A | i << 32 - A, this.high = i >>> A | t << 32 - A;
  }
  not() {
    this.high = ~this.high, this.low = ~this.low;
  }
  add(A) {
    const t = (this.low >>> 0) + (A.low >>> 0);
    let i = (this.high >>> 0) + (A.high >>> 0);
    t > 4294967295 && (i += 1), this.low = t | 0, this.high = i | 0;
  }
  copyTo(A, t) {
    A[t] = this.high >>> 24 & 255, A[t + 1] = this.high >> 16 & 255, A[t + 2] = this.high >> 8 & 255, A[t + 3] = this.high & 255, A[t + 4] = this.low >>> 24 & 255, A[t + 5] = this.low >> 16 & 255, A[t + 6] = this.low >> 8 & 255, A[t + 7] = this.low & 255;
  }
  assign(A) {
    this.high = A.high, this.low = A.low;
  }
}
const Y0 = /* @__PURE__ */ function() {
  function A(I, c) {
    return I >>> c | I << 32 - c;
  }
  function t(I, c, l) {
    return I & c ^ ~I & l;
  }
  function i(I, c, l) {
    return I & c ^ I & l ^ c & l;
  }
  function s(I) {
    return A(I, 2) ^ A(I, 13) ^ A(I, 22);
  }
  function a(I) {
    return A(I, 6) ^ A(I, 11) ^ A(I, 25);
  }
  function n(I) {
    return A(I, 7) ^ A(I, 18) ^ I >>> 3;
  }
  function r(I) {
    return A(I, 17) ^ A(I, 19) ^ I >>> 10;
  }
  const g = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function o(I, c, l) {
    let h = 1779033703, C = 3144134277, B = 1013904242, Q = 2773480762, E = 1359893119, f = 2600822924, d = 528734635, u = 1541459225;
    const x = Math.ceil((l + 9) / 64) * 64, m = new Uint8Array(x);
    let p, D;
    for (p = 0; p < l; ++p)
      m[p] = I[c++];
    m[p++] = 128;
    const F = x - 8;
    for (; p < F; )
      m[p++] = 0;
    m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = l >>> 29 & 255, m[p++] = l >> 21 & 255, m[p++] = l >> 13 & 255, m[p++] = l >> 5 & 255, m[p++] = l << 3 & 255;
    const y = new Uint32Array(64);
    for (p = 0; p < x; ) {
      for (D = 0; D < 16; ++D)
        y[D] = m[p] << 24 | m[p + 1] << 16 | m[p + 2] << 8 | m[p + 3], p += 4;
      for (D = 16; D < 64; ++D)
        y[D] = r(y[D - 2]) + y[D - 7] + n(y[D - 15]) + y[D - 16] | 0;
      let H = h, N = C, T = B, _ = Q, oA = E, G = f, S = d, tA = u, $, hA;
      for (D = 0; D < 64; ++D)
        $ = tA + a(oA) + t(oA, G, S) + g[D] + y[D], hA = s(H) + i(H, N, T), tA = S, S = G, G = oA, oA = _ + $ | 0, _ = T, T = N, N = H, H = $ + hA | 0;
      h = h + H | 0, C = C + N | 0, B = B + T | 0, Q = Q + _ | 0, E = E + oA | 0, f = f + G | 0, d = d + S | 0, u = u + tA | 0;
    }
    return new Uint8Array([h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, h & 255, C >> 24 & 255, C >> 16 & 255, C >> 8 & 255, C & 255, B >> 24 & 255, B >> 16 & 255, B >> 8 & 255, B & 255, Q >> 24 & 255, Q >> 16 & 255, Q >> 8 & 255, Q & 255, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, E & 255, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, f & 255, d >> 24 & 255, d >> 16 & 255, d >> 8 & 255, d & 255, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, u & 255]);
  }
  return o;
}(), th = function() {
  function A(o, I, c, l, h) {
    o.assign(I), o.and(c), h.assign(I), h.not(), h.and(l), o.xor(h);
  }
  function t(o, I, c, l, h) {
    o.assign(I), o.and(c), h.assign(I), h.and(l), o.xor(h), h.assign(c), h.and(l), o.xor(h);
  }
  function i(o, I, c) {
    o.assign(I), o.rotateRight(28), c.assign(I), c.rotateRight(34), o.xor(c), c.assign(I), c.rotateRight(39), o.xor(c);
  }
  function s(o, I, c) {
    o.assign(I), o.rotateRight(14), c.assign(I), c.rotateRight(18), o.xor(c), c.assign(I), c.rotateRight(41), o.xor(c);
  }
  function a(o, I, c) {
    o.assign(I), o.rotateRight(1), c.assign(I), c.rotateRight(8), o.xor(c), c.assign(I), c.shiftRight(7), o.xor(c);
  }
  function n(o, I, c) {
    o.assign(I), o.rotateRight(19), c.assign(I), c.rotateRight(61), o.xor(c), c.assign(I), c.shiftRight(6), o.xor(c);
  }
  const r = [new aA(1116352408, 3609767458), new aA(1899447441, 602891725), new aA(3049323471, 3964484399), new aA(3921009573, 2173295548), new aA(961987163, 4081628472), new aA(1508970993, 3053834265), new aA(2453635748, 2937671579), new aA(2870763221, 3664609560), new aA(3624381080, 2734883394), new aA(310598401, 1164996542), new aA(607225278, 1323610764), new aA(1426881987, 3590304994), new aA(1925078388, 4068182383), new aA(2162078206, 991336113), new aA(2614888103, 633803317), new aA(3248222580, 3479774868), new aA(3835390401, 2666613458), new aA(4022224774, 944711139), new aA(264347078, 2341262773), new aA(604807628, 2007800933), new aA(770255983, 1495990901), new aA(1249150122, 1856431235), new aA(1555081692, 3175218132), new aA(1996064986, 2198950837), new aA(2554220882, 3999719339), new aA(2821834349, 766784016), new aA(2952996808, 2566594879), new aA(3210313671, 3203337956), new aA(3336571891, 1034457026), new aA(3584528711, 2466948901), new aA(113926993, 3758326383), new aA(338241895, 168717936), new aA(666307205, 1188179964), new aA(773529912, 1546045734), new aA(1294757372, 1522805485), new aA(1396182291, 2643833823), new aA(1695183700, 2343527390), new aA(1986661051, 1014477480), new aA(2177026350, 1206759142), new aA(2456956037, 344077627), new aA(2730485921, 1290863460), new aA(2820302411, 3158454273), new aA(3259730800, 3505952657), new aA(3345764771, 106217008), new aA(3516065817, 3606008344), new aA(3600352804, 1432725776), new aA(4094571909, 1467031594), new aA(275423344, 851169720), new aA(430227734, 3100823752), new aA(506948616, 1363258195), new aA(659060556, 3750685593), new aA(883997877, 3785050280), new aA(958139571, 3318307427), new aA(1322822218, 3812723403), new aA(1537002063, 2003034995), new aA(1747873779, 3602036899), new aA(1955562222, 1575990012), new aA(2024104815, 1125592928), new aA(2227730452, 2716904306), new aA(2361852424, 442776044), new aA(2428436474, 593698344), new aA(2756734187, 3733110249), new aA(3204031479, 2999351573), new aA(3329325298, 3815920427), new aA(3391569614, 3928383900), new aA(3515267271, 566280711), new aA(3940187606, 3454069534), new aA(4118630271, 4000239992), new aA(116418474, 1914138554), new aA(174292421, 2731055270), new aA(289380356, 3203993006), new aA(460393269, 320620315), new aA(685471733, 587496836), new aA(852142971, 1086792851), new aA(1017036298, 365543100), new aA(1126000580, 2618297676), new aA(1288033470, 3409855158), new aA(1501505948, 4234509866), new aA(1607167915, 987167468), new aA(1816402316, 1246189591)];
  function g(o, I, c, l = !1) {
    let h, C, B, Q, E, f, d, u;
    l ? (h = new aA(3418070365, 3238371032), C = new aA(1654270250, 914150663), B = new aA(2438529370, 812702999), Q = new aA(355462360, 4144912697), E = new aA(1731405415, 4290775857), f = new aA(2394180231, 1750603025), d = new aA(3675008525, 1694076839), u = new aA(1203062813, 3204075428)) : (h = new aA(1779033703, 4089235720), C = new aA(3144134277, 2227873595), B = new aA(1013904242, 4271175723), Q = new aA(2773480762, 1595750129), E = new aA(1359893119, 2917565137), f = new aA(2600822924, 725511199), d = new aA(528734635, 4215389547), u = new aA(1541459225, 327033209));
    const x = Math.ceil((c + 17) / 128) * 128, m = new Uint8Array(x);
    let p, D;
    for (p = 0; p < c; ++p)
      m[p] = o[I++];
    m[p++] = 128;
    const F = x - 16;
    for (; p < F; )
      m[p++] = 0;
    m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = 0, m[p++] = c >>> 29 & 255, m[p++] = c >> 21 & 255, m[p++] = c >> 13 & 255, m[p++] = c >> 5 & 255, m[p++] = c << 3 & 255;
    const y = new Array(80);
    for (p = 0; p < 80; p++)
      y[p] = new aA(0, 0);
    let H = new aA(0, 0), N = new aA(0, 0), T = new aA(0, 0), _ = new aA(0, 0), oA = new aA(0, 0), G = new aA(0, 0), S = new aA(0, 0), tA = new aA(0, 0);
    const $ = new aA(0, 0), hA = new aA(0, 0), yA = new aA(0, 0), pA = new aA(0, 0);
    let DA;
    for (p = 0; p < x; ) {
      for (D = 0; D < 16; ++D)
        y[D].high = m[p] << 24 | m[p + 1] << 16 | m[p + 2] << 8 | m[p + 3], y[D].low = m[p + 4] << 24 | m[p + 5] << 16 | m[p + 6] << 8 | m[p + 7], p += 8;
      for (D = 16; D < 80; ++D)
        DA = y[D], n(DA, y[D - 2], pA), DA.add(y[D - 7]), a(yA, y[D - 15], pA), DA.add(yA), DA.add(y[D - 16]);
      for (H.assign(h), N.assign(C), T.assign(B), _.assign(Q), oA.assign(E), G.assign(f), S.assign(d), tA.assign(u), D = 0; D < 80; ++D)
        $.assign(tA), s(yA, oA, pA), $.add(yA), A(yA, oA, G, S, pA), $.add(yA), $.add(r[D]), $.add(y[D]), i(hA, H, pA), t(yA, H, N, T, pA), hA.add(yA), DA = tA, tA = S, S = G, G = oA, _.add($), oA = _, _ = T, T = N, N = H, DA.assign($), DA.add(hA), H = DA;
      h.add(H), C.add(N), B.add(T), Q.add(_), E.add(oA), f.add(G), d.add(S), u.add(tA);
    }
    let X;
    return l ? (X = new Uint8Array(48), h.copyTo(X, 0), C.copyTo(X, 8), B.copyTo(X, 16), Q.copyTo(X, 24), E.copyTo(X, 32), f.copyTo(X, 40)) : (X = new Uint8Array(64), h.copyTo(X, 0), C.copyTo(X, 8), B.copyTo(X, 16), Q.copyTo(X, 24), E.copyTo(X, 32), f.copyTo(X, 40), d.copyTo(X, 48), u.copyTo(X, 56)), X;
  }
  return g;
}();
function tx(e, A, t) {
  return th(e, A, t, !0);
}
class ix {
  decryptBlock(A) {
    return A;
  }
  encrypt(A) {
    return A;
  }
}
class po {
  constructor() {
    this._s = new Uint8Array([99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]), this._inv_s = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]), this._mix = new Uint32Array([0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]), this._mixCol = new Uint8Array(256);
    for (let A = 0; A < 256; A++)
      this._mixCol[A] = A < 128 ? A << 1 : A << 1 ^ 27;
    this.buffer = new Uint8Array(16), this.bufferPosition = 0;
  }
  _expandKey(A) {
    WA("Cannot call `_expandKey` on the base class");
  }
  _decrypt(A, t) {
    let i, s, a;
    const n = new Uint8Array(16);
    n.set(A);
    for (let r = 0, g = this._keySize; r < 16; ++r, ++g)
      n[r] ^= t[g];
    for (let r = this._cyclesOfRepetition - 1; r >= 1; --r) {
      i = n[13], n[13] = n[9], n[9] = n[5], n[5] = n[1], n[1] = i, i = n[14], s = n[10], n[14] = n[6], n[10] = n[2], n[6] = i, n[2] = s, i = n[15], s = n[11], a = n[7], n[15] = n[3], n[11] = i, n[7] = s, n[3] = a;
      for (let g = 0; g < 16; ++g)
        n[g] = this._inv_s[n[g]];
      for (let g = 0, o = r * 16; g < 16; ++g, ++o)
        n[g] ^= t[o];
      for (let g = 0; g < 16; g += 4) {
        const o = this._mix[n[g]], I = this._mix[n[g + 1]], c = this._mix[n[g + 2]], l = this._mix[n[g + 3]];
        i = o ^ I >>> 8 ^ I << 24 ^ c >>> 16 ^ c << 16 ^ l >>> 24 ^ l << 8, n[g] = i >>> 24 & 255, n[g + 1] = i >> 16 & 255, n[g + 2] = i >> 8 & 255, n[g + 3] = i & 255;
      }
    }
    i = n[13], n[13] = n[9], n[9] = n[5], n[5] = n[1], n[1] = i, i = n[14], s = n[10], n[14] = n[6], n[10] = n[2], n[6] = i, n[2] = s, i = n[15], s = n[11], a = n[7], n[15] = n[3], n[11] = i, n[7] = s, n[3] = a;
    for (let r = 0; r < 16; ++r)
      n[r] = this._inv_s[n[r]], n[r] ^= t[r];
    return n;
  }
  _encrypt(A, t) {
    const i = this._s;
    let s, a, n;
    const r = new Uint8Array(16);
    r.set(A);
    for (let g = 0; g < 16; ++g)
      r[g] ^= t[g];
    for (let g = 1; g < this._cyclesOfRepetition; g++) {
      for (let o = 0; o < 16; ++o)
        r[o] = i[r[o]];
      n = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = n, n = r[2], a = r[6], r[2] = r[10], r[6] = r[14], r[10] = n, r[14] = a, n = r[3], a = r[7], s = r[11], r[3] = r[15], r[7] = n, r[11] = a, r[15] = s;
      for (let o = 0; o < 16; o += 4) {
        const I = r[o + 0], c = r[o + 1], l = r[o + 2], h = r[o + 3];
        s = I ^ c ^ l ^ h, r[o + 0] ^= s ^ this._mixCol[I ^ c], r[o + 1] ^= s ^ this._mixCol[c ^ l], r[o + 2] ^= s ^ this._mixCol[l ^ h], r[o + 3] ^= s ^ this._mixCol[h ^ I];
      }
      for (let o = 0, I = g * 16; o < 16; ++o, ++I)
        r[o] ^= t[I];
    }
    for (let g = 0; g < 16; ++g)
      r[g] = i[r[g]];
    n = r[1], r[1] = r[5], r[5] = r[9], r[9] = r[13], r[13] = n, n = r[2], a = r[6], r[2] = r[10], r[6] = r[14], r[10] = n, r[14] = a, n = r[3], a = r[7], s = r[11], r[3] = r[15], r[7] = n, r[11] = a, r[15] = s;
    for (let g = 0, o = this._keySize; g < 16; ++g, ++o)
      r[g] ^= t[o];
    return r;
  }
  _decryptBlock2(A, t) {
    const i = A.length;
    let s = this.buffer, a = this.bufferPosition;
    const n = [];
    let r = this.iv;
    for (let I = 0; I < i; ++I) {
      if (s[a] = A[I], ++a, a < 16)
        continue;
      const c = this._decrypt(s, this._key);
      for (let l = 0; l < 16; ++l)
        c[l] ^= r[l];
      r = s, n.push(c), s = new Uint8Array(16), a = 0;
    }
    if (this.buffer = s, this.bufferLength = a, this.iv = r, n.length === 0)
      return new Uint8Array(0);
    let g = 16 * n.length;
    if (t) {
      const I = n.at(-1);
      let c = I[15];
      if (c <= 16) {
        for (let l = 15, h = 16 - c; l >= h; --l)
          if (I[l] !== c) {
            c = 0;
            break;
          }
        g -= c, n[n.length - 1] = I.subarray(0, 16 - c);
      }
    }
    const o = new Uint8Array(g);
    for (let I = 0, c = 0, l = n.length; I < l; ++I, c += 16)
      o.set(n[I], c);
    return o;
  }
  decryptBlock(A, t, i = null) {
    const s = A.length, a = this.buffer;
    let n = this.bufferPosition;
    if (i)
      this.iv = i;
    else {
      for (let r = 0; n < 16 && r < s; ++r, ++n)
        a[n] = A[r];
      if (n < 16)
        return this.bufferLength = n, new Uint8Array(0);
      this.iv = a, A = A.subarray(16);
    }
    return this.buffer = new Uint8Array(16), this.bufferLength = 0, this.decryptBlock = this._decryptBlock2, this.decryptBlock(A, t);
  }
  encrypt(A, t) {
    const i = A.length;
    let s = this.buffer, a = this.bufferPosition;
    const n = [];
    t || (t = new Uint8Array(16));
    for (let o = 0; o < i; ++o) {
      if (s[a] = A[o], ++a, a < 16)
        continue;
      for (let c = 0; c < 16; ++c)
        s[c] ^= t[c];
      const I = this._encrypt(s, this._key);
      t = I, n.push(I), s = new Uint8Array(16), a = 0;
    }
    if (this.buffer = s, this.bufferLength = a, this.iv = t, n.length === 0)
      return new Uint8Array(0);
    const r = 16 * n.length, g = new Uint8Array(r);
    for (let o = 0, I = 0, c = n.length; o < c; ++o, I += 16)
      g.set(n[o], I);
    return g;
  }
}
class ih extends po {
  constructor(A) {
    super(), this._cyclesOfRepetition = 10, this._keySize = 160, this._rcon = new Uint8Array([141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145, 57, 114, 228, 211, 189, 97, 194, 159, 37, 74, 148, 51, 102, 204, 131, 29, 58, 116, 232, 203, 141]), this._key = this._expandKey(A);
  }
  _expandKey(A) {
    const i = this._s, s = this._rcon, a = new Uint8Array(176);
    a.set(A);
    for (let n = 16, r = 1; n < 176; ++r) {
      let g = a[n - 3], o = a[n - 2], I = a[n - 1], c = a[n - 4];
      g = i[g], o = i[o], I = i[I], c = i[c], g ^= s[r];
      for (let l = 0; l < 4; ++l)
        a[n] = g ^= a[n - 16], n++, a[n] = o ^= a[n - 16], n++, a[n] = I ^= a[n - 16], n++, a[n] = c ^= a[n - 16], n++;
    }
    return a;
  }
}
class ga extends po {
  constructor(A) {
    super(), this._cyclesOfRepetition = 14, this._keySize = 224, this._key = this._expandKey(A);
  }
  _expandKey(A) {
    const i = this._s, s = new Uint8Array(240);
    s.set(A);
    let a = 1, n, r, g, o;
    for (let I = 32, c = 1; I < 240; ++c) {
      I % 32 === 16 ? (n = i[n], r = i[r], g = i[g], o = i[o]) : I % 32 === 0 && (n = s[I - 3], r = s[I - 2], g = s[I - 1], o = s[I - 4], n = i[n], r = i[r], g = i[g], o = i[o], n ^= a, (a <<= 1) >= 256 && (a = (a ^ 27) & 255));
      for (let l = 0; l < 4; ++l)
        s[I] = n ^= s[I - 32], I++, s[I] = r ^= s[I - 32], I++, s[I] = g ^= s[I - 32], I++, s[I] = o ^= s[I - 32], I++;
    }
    return s;
  }
}
class sx {
  checkOwnerPassword(A, t, i, s) {
    const a = new Uint8Array(A.length + 56);
    a.set(A, 0), a.set(t, A.length), a.set(i, A.length + t.length);
    const n = Y0(a, 0, a.length);
    return B0(n, s);
  }
  checkUserPassword(A, t, i) {
    const s = new Uint8Array(A.length + 8);
    s.set(A, 0), s.set(t, A.length);
    const a = Y0(s, 0, s.length);
    return B0(a, i);
  }
  getOwnerKey(A, t, i, s) {
    const a = new Uint8Array(A.length + 56);
    a.set(A, 0), a.set(t, A.length), a.set(i, A.length + t.length);
    const n = Y0(a, 0, a.length);
    return new ga(n).decryptBlock(s, !1, new Uint8Array(16));
  }
  getUserKey(A, t, i) {
    const s = new Uint8Array(A.length + 8);
    s.set(A, 0), s.set(t, A.length);
    const a = Y0(s, 0, s.length);
    return new ga(a).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class ax {
  _hash(A, t, i) {
    let s = Y0(t, 0, t.length).subarray(0, 32), a = [0], n = 0;
    for (; n < 64 || a.at(-1) > n - 32; ) {
      const r = A.length + s.length + i.length, g = new Uint8Array(r);
      let o = 0;
      g.set(A, o), o += A.length, g.set(s, o), o += s.length, g.set(i, o);
      const I = new Uint8Array(r * 64);
      for (let h = 0, C = 0; h < 64; h++, C += r)
        I.set(g, C);
      a = new ih(s.subarray(0, 16)).encrypt(I, s.subarray(16, 32));
      const l = a.slice(0, 16).reduce((h, C) => h + C, 0) % 3;
      l === 0 ? s = Y0(a, 0, a.length) : l === 1 ? s = tx(a, 0, a.length) : l === 2 && (s = th(a, 0, a.length)), n++;
    }
    return s.subarray(0, 32);
  }
  checkOwnerPassword(A, t, i, s) {
    const a = new Uint8Array(A.length + 56);
    a.set(A, 0), a.set(t, A.length), a.set(i, A.length + t.length);
    const n = this._hash(A, a, i);
    return B0(n, s);
  }
  checkUserPassword(A, t, i) {
    const s = new Uint8Array(A.length + 8);
    s.set(A, 0), s.set(t, A.length);
    const a = this._hash(A, s, []);
    return B0(a, i);
  }
  getOwnerKey(A, t, i, s) {
    const a = new Uint8Array(A.length + 56);
    a.set(A, 0), a.set(t, A.length), a.set(i, A.length + t.length);
    const n = this._hash(A, a, i);
    return new ga(n).decryptBlock(s, !1, new Uint8Array(16));
  }
  getUserKey(A, t, i) {
    const s = new Uint8Array(A.length + 8);
    s.set(A, 0), s.set(t, A.length);
    const a = this._hash(A, s, []);
    return new ga(a).decryptBlock(i, !1, new Uint8Array(16));
  }
}
class sc {
  constructor(A, t) {
    this.StringCipherConstructor = A, this.StreamCipherConstructor = t;
  }
  createStream(A, t) {
    const i = new this.StreamCipherConstructor();
    return new ex(A, t, function(a, n) {
      return i.decryptBlock(a, n);
    });
  }
  decryptString(A) {
    const t = new this.StringCipherConstructor();
    let i = We(A);
    return i = t.decryptBlock(i, !0), ct(i);
  }
  encryptString(A) {
    const t = new this.StringCipherConstructor();
    if (t instanceof po) {
      const a = 16 - A.length % 16;
      A += String.fromCharCode(a).repeat(a);
      const n = new Uint8Array(16);
      if (typeof crypto < "u")
        crypto.getRandomValues(n);
      else
        for (let o = 0; o < 16; o++)
          n[o] = Math.floor(256 * Math.random());
      let r = We(A);
      r = t.encrypt(r, n);
      const g = new Uint8Array(16 + r.length);
      return g.set(n), g.set(r, 16), ct(g);
    }
    let i = We(A);
    return i = t.encrypt(i), ct(i);
  }
}
var g0, ze, sh, Jg, ah, un, Yg;
const n0 = class n0 {
  constructor(A, t, i) {
    ZA(this, ze);
    const s = A.get("Filter");
    if (!xe(s, "Standard"))
      throw new v("unknown encryption method");
    this.filterName = s.name, this.dict = A;
    const a = A.get("V");
    if (!Number.isInteger(a) || a !== 1 && a !== 2 && a !== 4 && a !== 5)
      throw new v("unsupported encryption algorithm");
    this.algorithm = a;
    let n = A.get("Length");
    if (!n)
      if (a <= 3)
        n = 40;
      else {
        const E = A.get("CF"), f = A.get("StmF");
        if (E instanceof R && f instanceof L) {
          E.suppressEncryption = !0;
          const d = E.get(f.name);
          n = (d == null ? void 0 : d.get("Length")) || 128, n < 40 && (n <<= 3);
        }
      }
    if (!Number.isInteger(n) || n < 40 || n % 8 !== 0)
      throw new v("invalid key length");
    const r = We(A.get("O")), g = We(A.get("U")), o = r.subarray(0, 32), I = g.subarray(0, 32), c = A.get("P"), l = A.get("R"), h = (a === 4 || a === 5) && A.get("EncryptMetadata") !== !1;
    this.encryptMetadata = h;
    const C = We(t);
    let B;
    if (i) {
      if (l === 6)
        try {
          i = Zr(i);
        } catch {
          k("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
      B = We(i);
    }
    let Q;
    if (a !== 5)
      Q = BA(this, ze, Jg).call(this, C, B, o, I, c, l, n, h);
    else {
      const E = r.subarray(32, 40), f = r.subarray(40, 48), d = g.subarray(0, 48), u = g.subarray(32, 40), x = g.subarray(40, 48), m = We(A.get("OE")), p = We(A.get("UE")), D = We(A.get("Perms"));
      Q = BA(this, ze, sh).call(this, l, B, o, E, f, d, I, u, x, m, p, D);
    }
    if (!Q && !i)
      throw new Ws("No password given", Go.NEED_PASSWORD);
    if (!Q && i) {
      const E = BA(this, ze, ah).call(this, B, o, l, n);
      Q = BA(this, ze, Jg).call(this, C, E, o, I, c, l, n, h);
    }
    if (!Q)
      throw new Ws("Incorrect Password", Go.INCORRECT_PASSWORD);
    if (this.encryptionKey = Q, a >= 4) {
      const E = A.get("CF");
      E instanceof R && (E.suppressEncryption = !0), this.cf = E, this.stmf = A.get("StmF") || L.get("Identity"), this.strf = A.get("StrF") || L.get("Identity"), this.eff = A.get("EFF") || this.stmf;
    }
  }
  createCipherTransform(A, t) {
    if (this.algorithm === 4 || this.algorithm === 5)
      return new sc(BA(this, ze, Yg).call(this, this.cf, this.strf, A, t, this.encryptionKey), BA(this, ze, Yg).call(this, this.cf, this.stmf, A, t, this.encryptionKey));
    const i = BA(this, ze, un).call(this, A, t, this.encryptionKey, !1), s = function() {
      return new zi(i);
    };
    return new sc(s, s);
  }
};
g0 = new WeakMap(), ze = new WeakSet(), sh = function(A, t, i, s, a, n, r, g, o, I, c, l) {
  if (t) {
    const C = Math.min(127, t.length);
    t = t.subarray(0, C);
  } else
    t = [];
  const h = A === 6 ? new ax() : new sx();
  return h.checkUserPassword(t, g, r) ? h.getUserKey(t, o, c) : t.length && h.checkOwnerPassword(t, s, n, i) ? h.getOwnerKey(t, a, n, I) : null;
}, Jg = function(A, t, i, s, a, n, r, g) {
  const o = 40 + i.length + A.length, I = new Uint8Array(o);
  let c = 0, l, h;
  if (t)
    for (h = Math.min(32, t.length); c < h; ++c)
      I[c] = t[c];
  for (l = 0; c < 32; )
    I[c++] = PA(n0, g0)[l++];
  for (l = 0, h = i.length; l < h; ++l)
    I[c++] = i[l];
  for (I[c++] = a & 255, I[c++] = a >> 8 & 255, I[c++] = a >> 16 & 255, I[c++] = a >>> 24 & 255, l = 0, h = A.length; l < h; ++l)
    I[c++] = A[l];
  n >= 4 && !g && (I[c++] = 255, I[c++] = 255, I[c++] = 255, I[c++] = 255);
  let C = Ri(I, 0, c);
  const B = r >> 3;
  if (n >= 3)
    for (l = 0; l < 50; ++l)
      C = Ri(C, 0, B);
  const Q = C.subarray(0, B);
  let E, f;
  if (n >= 3) {
    for (c = 0; c < 32; ++c)
      I[c] = PA(n0, g0)[c];
    for (l = 0, h = A.length; l < h; ++l)
      I[c++] = A[l];
    E = new zi(Q), f = E.encryptBlock(Ri(I, 0, c)), h = Q.length;
    const d = new Uint8Array(h);
    for (l = 1; l <= 19; ++l) {
      for (let u = 0; u < h; ++u)
        d[u] = Q[u] ^ l;
      E = new zi(d), f = E.encryptBlock(f);
    }
    for (l = 0, h = f.length; l < h; ++l)
      if (s[l] !== f[l])
        return null;
  } else
    for (E = new zi(Q), f = E.encryptBlock(PA(n0, g0)), l = 0, h = f.length; l < h; ++l)
      if (s[l] !== f[l])
        return null;
  return Q;
}, ah = function(A, t, i, s) {
  const a = new Uint8Array(32);
  let n = 0;
  const r = Math.min(32, A.length);
  for (; n < r; ++n)
    a[n] = A[n];
  let g = 0;
  for (; n < 32; )
    a[n++] = PA(n0, g0)[g++];
  let o = Ri(a, 0, n);
  const I = s >> 3;
  if (i >= 3)
    for (g = 0; g < 50; ++g)
      o = Ri(o, 0, o.length);
  let c, l;
  if (i >= 3) {
    l = t;
    const h = new Uint8Array(I);
    for (g = 19; g >= 0; g--) {
      for (let C = 0; C < I; ++C)
        h[C] = o[C] ^ g;
      c = new zi(h), l = c.encryptBlock(l);
    }
  } else
    c = new zi(o.subarray(0, I)), l = c.encryptBlock(t);
  return l;
}, un = function(A, t, i, s = !1) {
  const a = new Uint8Array(i.length + 9), n = i.length;
  let r;
  for (r = 0; r < n; ++r)
    a[r] = i[r];
  return a[r++] = A & 255, a[r++] = A >> 8 & 255, a[r++] = A >> 16 & 255, a[r++] = t & 255, a[r++] = t >> 8 & 255, s && (a[r++] = 115, a[r++] = 65, a[r++] = 108, a[r++] = 84), Ri(a, 0, r).subarray(0, Math.min(i.length + 5, 16));
}, Yg = function(A, t, i, s, a) {
  if (!(t instanceof L))
    throw new v("Invalid crypt filter name.");
  const n = this, r = A.get(t.name), g = r == null ? void 0 : r.get("CFM");
  if (!g || g.name === "None")
    return function() {
      return new ix();
    };
  if (g.name === "V2")
    return function() {
      var o;
      return new zi(BA(o = n, ze, un).call(o, i, s, a, !1));
    };
  if (g.name === "AESV2")
    return function() {
      var o;
      return new ih(BA(o = n, ze, un).call(o, i, s, a, !0));
    };
  if (g.name === "AESV3")
    return function() {
      return new ga(a);
    };
  throw new v("Unknown crypto method");
}, ZA(n0, g0, new Uint8Array([40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122]));
let Hg = n0;
function ac(e) {
  try {
    return Vs(e);
  } catch (A) {
    return k(`UTF-8 decoding failed: "${A}".`), e;
  }
}
class nx extends ar {
  constructor(A) {
    super(A), this.node = null;
  }
  onEndElement(A) {
    const t = super.onEndElement(A);
    if (t && A === "xfa:datasets")
      throw this.node = t, new Error("Aborting DatasetXMLParser.");
  }
}
class rx {
  constructor(A) {
    if (A.datasets)
      this.node = new ar({
        hasAttributes: !0
      }).parseFromString(A.datasets).documentElement;
    else {
      const t = new nx({
        hasAttributes: !0
      });
      try {
        t.parseFromString(A["xdp:xdp"]);
      } catch {
      }
      this.node = t.node;
    }
  }
  getValue(A) {
    if (!this.node || !A)
      return "";
    const t = this.node.searchNode(xc(A), 0);
    if (!t)
      return "";
    const i = t.firstChild;
    return (i == null ? void 0 : i.nodeName) === "value" ? t.children.map((s) => ac(s.textContent)) : ac(t.textContent);
  }
}
var xa;
class gx {
  constructor(A, t) {
    ZA(this, xa, null);
    this.stream = A, this.pdfManager = t, this.entries = [], this._xrefStms = /* @__PURE__ */ new Set(), this._cacheMap = /* @__PURE__ */ new Map(), this._pendingRefs = new Ne(), this._newPersistentRefNum = null, this._newTemporaryRefNum = null, this._persistentRefsCache = null;
  }
  getNewPersistentRef(A) {
    this._newPersistentRefNum === null && (this._newPersistentRefNum = this.entries.length || 1);
    const t = this._newPersistentRefNum++;
    return this._cacheMap.set(t, A), nA.get(t, 0);
  }
  getNewTemporaryRef() {
    if (this._newTemporaryRefNum === null && (this._newTemporaryRefNum = this.entries.length || 1, this._newPersistentRefNum)) {
      this._persistentRefsCache = /* @__PURE__ */ new Map();
      for (let A = this._newTemporaryRefNum; A < this._newPersistentRefNum; A++)
        this._persistentRefsCache.set(A, this._cacheMap.get(A)), this._cacheMap.delete(A);
    }
    return nA.get(this._newTemporaryRefNum++, 0);
  }
  resetNewTemporaryRef() {
    if (this._newTemporaryRefNum = null, this._persistentRefsCache)
      for (const [A, t] of this._persistentRefsCache)
        this._cacheMap.set(A, t);
    this._persistentRefsCache = null;
  }
  setStartXRef(A) {
    this.startXRefQueue = [A];
  }
  parse(A = !1) {
    let t;
    A ? (k("Indexing all PDF objects"), t = this.indexObjects()) : t = this.readXRef(), t.assignXref(this), this.trailer = t;
    let i;
    try {
      i = t.get("Encrypt");
    } catch (a) {
      if (a instanceof oe)
        throw a;
      k(`XRef.parse - Invalid "Encrypt" reference: "${a}".`);
    }
    if (i instanceof R) {
      const a = t.get("ID"), n = a != null && a.length ? a[0] : "";
      i.suppressEncryption = !0, this.encrypt = new Hg(i, n, this.pdfManager.password);
    }
    let s;
    try {
      s = t.get("Root");
    } catch (a) {
      if (a instanceof oe)
        throw a;
      k(`XRef.parse - Invalid "Root" reference: "${a}".`);
    }
    if (s instanceof R)
      try {
        if (s.get("Pages") instanceof R) {
          this.root = s;
          return;
        }
      } catch (a) {
        if (a instanceof oe)
          throw a;
        k(`XRef.parse - Invalid "Pages" reference: "${a}".`);
      }
    throw A ? new Os("Invalid Root reference.") : new P0();
  }
  processXRefTable(A) {
    "tableState" in this || (this.tableState = {
      entryNum: 0,
      streamPos: A.lexer.stream.pos,
      parserBuf1: A.buf1,
      parserBuf2: A.buf2
    });
    const t = this.readXRefTable(A);
    if (!Ge(t, "trailer"))
      throw new v("Invalid XRef table: could not find trailer dictionary");
    let i = A.getObj();
    if (!(i instanceof R) && i.dict && (i = i.dict), !(i instanceof R))
      throw new v("Invalid XRef table: could not parse trailer dictionary");
    return delete this.tableState, i;
  }
  readXRefTable(A) {
    const t = A.lexer.stream, i = this.tableState;
    t.pos = i.streamPos, A.buf1 = i.parserBuf1, A.buf2 = i.parserBuf2;
    let s;
    for (; ; ) {
      if (!("firstEntryNum" in i) || !("entryCount" in i)) {
        if (Ge(s = A.getObj(), "trailer"))
          break;
        i.firstEntryNum = s, i.entryCount = A.getObj();
      }
      let a = i.firstEntryNum;
      const n = i.entryCount;
      if (!Number.isInteger(a) || !Number.isInteger(n))
        throw new v("Invalid XRef table: wrong types in subsection header");
      for (let r = i.entryNum; r < n; r++) {
        i.streamPos = t.pos, i.entryNum = r, i.parserBuf1 = A.buf1, i.parserBuf2 = A.buf2;
        const g = {};
        g.offset = A.getObj(), g.gen = A.getObj();
        const o = A.getObj();
        if (o instanceof be)
          switch (o.cmd) {
            case "f":
              g.free = !0;
              break;
            case "n":
              g.uncompressed = !0;
              break;
          }
        if (!Number.isInteger(g.offset) || !Number.isInteger(g.gen) || !(g.free || g.uncompressed))
          throw new v(`Invalid entry in XRef subsection: ${a}, ${n}`);
        r === 0 && g.free && a === 1 && (a = 0), this.entries[r + a] || (this.entries[r + a] = g);
      }
      i.entryNum = 0, i.streamPos = t.pos, i.parserBuf1 = A.buf1, i.parserBuf2 = A.buf2, delete i.firstEntryNum, delete i.entryCount;
    }
    if (this.entries[0] && !this.entries[0].free)
      throw new v("Invalid XRef table: unexpected first object");
    return s;
  }
  processXRefStream(A) {
    if (!("streamState" in this)) {
      const {
        dict: t,
        pos: i
      } = A, s = t.get("W"), a = t.get("Index") || [0, t.get("Size")];
      this.streamState = {
        entryRanges: a,
        byteWidths: s,
        entryNum: 0,
        streamPos: i
      };
    }
    return this.readXRefStream(A), delete this.streamState, A.dict;
  }
  readXRefStream(A) {
    const t = this.streamState;
    A.pos = t.streamPos;
    const [i, s, a] = t.byteWidths, n = t.entryRanges;
    for (; n.length > 0; ) {
      const [r, g] = n;
      if (!Number.isInteger(r) || !Number.isInteger(g))
        throw new v(`Invalid XRef range fields: ${r}, ${g}`);
      if (!Number.isInteger(i) || !Number.isInteger(s) || !Number.isInteger(a))
        throw new v(`Invalid XRef entry fields length: ${r}, ${g}`);
      for (let o = t.entryNum; o < g; ++o) {
        t.entryNum = o, t.streamPos = A.pos;
        let I = 0, c = 0, l = 0;
        for (let C = 0; C < i; ++C) {
          const B = A.getByte();
          if (B === -1)
            throw new v("Invalid XRef byteWidths 'type'.");
          I = I << 8 | B;
        }
        i === 0 && (I = 1);
        for (let C = 0; C < s; ++C) {
          const B = A.getByte();
          if (B === -1)
            throw new v("Invalid XRef byteWidths 'offset'.");
          c = c << 8 | B;
        }
        for (let C = 0; C < a; ++C) {
          const B = A.getByte();
          if (B === -1)
            throw new v("Invalid XRef byteWidths 'generation'.");
          l = l << 8 | B;
        }
        const h = {};
        switch (h.offset = c, h.gen = l, I) {
          case 0:
            h.free = !0;
            break;
          case 1:
            h.uncompressed = !0;
            break;
          case 2:
            break;
          default:
            throw new v(`Invalid XRef entry type: ${I}`);
        }
        this.entries[r + o] || (this.entries[r + o] = h);
      }
      t.entryNum = 0, t.streamPos = A.pos, n.splice(0, 2);
    }
  }
  indexObjects() {
    function r(y, H) {
      let N = "", T = y[H];
      for (; T !== 10 && T !== 13 && T !== 60 && !(++H >= y.length); )
        N += String.fromCharCode(T), T = y[H];
      return N;
    }
    function g(y, H, N) {
      const T = N.length, _ = y.length;
      let oA = 0;
      for (; H < _; ) {
        let G = 0;
        for (; G < T && y[H + G] === N[G]; )
          ++G;
        if (G >= T)
          break;
        H++, oA++;
      }
      return oA;
    }
    const o = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, I = /\b(startxref|\d+\s+\d+\s+obj)\b/g, c = /^(\d+)\s+(\d+)\s+obj\b/, l = new Uint8Array([116, 114, 97, 105, 108, 101, 114]), h = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), C = new Uint8Array([47, 88, 82, 101, 102]);
    this.entries.length = 0, this._cacheMap.clear();
    const B = this.stream;
    B.pos = 0;
    const Q = B.getBytes(), E = ct(Q), f = Q.length;
    let d = B.start;
    const u = [], x = [];
    for (; d < f; ) {
      let y = Q[d];
      if (y === 9 || y === 10 || y === 13 || y === 32) {
        ++d;
        continue;
      }
      if (y === 37) {
        do {
          if (++d, d >= f)
            break;
          y = Q[d];
        } while (y !== 10 && y !== 13);
        continue;
      }
      const H = r(Q, d);
      let N;
      if (H.startsWith("xref") && (H.length === 4 || /\s/.test(H[4])))
        d += g(Q, d, l), u.push(d), d += g(Q, d, h);
      else if (N = c.exec(H)) {
        const T = N[1] | 0, _ = N[2] | 0, oA = d + H.length;
        let G, S = !1;
        if (!this.entries[T])
          S = !0;
        else if (this.entries[T].gen === _)
          try {
            new Si({
              lexer: new qt(B.makeSubStream(oA))
            }).getObj(), S = !0;
          } catch (yA) {
            yA instanceof Xr ? k(`indexObjects -- checking object (${H}): "${yA}".`) : S = !0;
          }
        S && (this.entries[T] = {
          offset: d - B.start,
          gen: _,
          uncompressed: !0
        }), o.lastIndex = oA;
        const tA = o.exec(E);
        tA ? (G = o.lastIndex + 1 - d, tA[1] !== "endobj" && (k(`indexObjects: Found "${tA[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`), G -= tA[1].length + 1)) : G = f - d;
        const $ = Q.subarray(d, d + G), hA = g($, 0, C);
        hA < G && $[hA + 5] < 64 && (x.push(d - B.start), this._xrefStms.add(d - B.start)), d += G;
      } else if (H.startsWith("trailer") && (H.length === 7 || /\s/.test(H[7]))) {
        u.push(d);
        const T = d + H.length;
        let _;
        I.lastIndex = T;
        const oA = I.exec(E);
        oA ? (_ = I.lastIndex + 1 - d, oA[1] !== "startxref" && (k(`indexObjects: Found "${oA[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`), _ -= oA[1].length + 1)) : _ = f - d, d += _;
      } else
        d += H.length + 1;
    }
    for (const y of x)
      this.startXRefQueue.push(y), this.readXRef(!0);
    const m = [];
    let p = !1;
    for (const y of u) {
      B.pos = y;
      const H = new Si({
        lexer: new qt(B),
        xref: this,
        allowStreams: !0,
        recoveryMode: !0
      }), N = H.getObj();
      if (!Ge(N, "trailer"))
        continue;
      const T = H.getObj();
      T instanceof R && (m.push(T), T.has("Encrypt") && (p = !0));
    }
    let D, F;
    for (const y of [...m, "genFallback", ...m]) {
      if (y === "genFallback") {
        if (!F)
          break;
        this._generationFallback = !0;
        continue;
      }
      let H = !1;
      try {
        const N = y.get("Root");
        if (!(N instanceof R))
          continue;
        const T = N.get("Pages");
        if (!(T instanceof R))
          continue;
        const _ = T.get("Count");
        Number.isInteger(_) && (H = !0);
      } catch (N) {
        F = N;
        continue;
      }
      if (H && (!p || y.has("Encrypt")) && y.has("ID"))
        return y;
      D = y;
    }
    if (D)
      return D;
    if (this.topDict)
      return this.topDict;
    if (!m.length)
      for (const [y, H] of this.entries.entries()) {
        if (!H)
          continue;
        const N = nA.get(y, H.gen);
        let T;
        try {
          T = this.fetch(N);
        } catch {
          continue;
        }
        if (T instanceof JA && (T = T.dict), T instanceof R && T.has("Root"))
          return T;
      }
    throw new Os("Invalid PDF structure.");
  }
  readXRef(A = !1) {
    const t = this.stream, i = /* @__PURE__ */ new Set();
    for (; this.startXRefQueue.length; ) {
      try {
        const s = this.startXRefQueue[0];
        if (i.has(s)) {
          k("readXRef - skipping XRef table since it was already parsed."), this.startXRefQueue.shift();
          continue;
        }
        i.add(s), t.pos = s + t.start;
        const a = new Si({
          lexer: new qt(t),
          xref: this,
          allowStreams: !0
        });
        let n = a.getObj(), r;
        if (Ge(n, "xref"))
          r = this.processXRefTable(a), this.topDict || (this.topDict = r), n = r.get("XRefStm"), Number.isInteger(n) && !this._xrefStms.has(n) && (this._xrefStms.add(n), this.startXRefQueue.push(n), PA(this, xa) ?? wt(this, xa, n));
        else if (Number.isInteger(n)) {
          if (!Number.isInteger(a.getObj()) || !Ge(a.getObj(), "obj") || !((n = a.getObj()) instanceof JA))
            throw new v("Invalid XRef stream");
          if (r = this.processXRefStream(n), this.topDict || (this.topDict = r), !r)
            throw new v("Failed to read XRef stream");
        } else
          throw new v("Invalid XRef stream header");
        n = r.get("Prev"), Number.isInteger(n) ? this.startXRefQueue.push(n) : n instanceof nA && this.startXRefQueue.push(n.num);
      } catch (s) {
        if (s instanceof oe)
          throw s;
        vA("(while reading XRef): " + s);
      }
      this.startXRefQueue.shift();
    }
    if (this.topDict)
      return this.topDict;
    if (!A)
      throw new P0();
  }
  get lastXRefStreamPos() {
    return PA(this, xa) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
  }
  getEntry(A) {
    const t = this.entries[A];
    return t && !t.free && t.offset ? t : null;
  }
  fetchIfRef(A, t = !1) {
    return A instanceof nA ? this.fetch(A, t) : A;
  }
  fetch(A, t = !1) {
    if (!(A instanceof nA))
      throw new Error("ref object is not a reference");
    const i = A.num, s = this._cacheMap.get(i);
    if (s !== void 0)
      return s instanceof R && !s.objId && (s.objId = A.toString()), s;
    let a = this.getEntry(i);
    if (a === null)
      return this._cacheMap.set(i, a), a;
    if (this._pendingRefs.has(A))
      return this._pendingRefs.remove(A), k(`Ignoring circular reference: ${A}.`), Vh;
    this._pendingRefs.put(A);
    try {
      a = a.uncompressed ? this.fetchUncompressed(A, a, t) : this.fetchCompressed(A, a, t), this._pendingRefs.remove(A);
    } catch (n) {
      throw this._pendingRefs.remove(A), n;
    }
    return a instanceof R ? a.objId = A.toString() : a instanceof JA && (a.dict.objId = A.toString()), a;
  }
  fetchUncompressed(A, t, i = !1) {
    const s = A.gen;
    let a = A.num;
    if (t.gen !== s) {
      const c = `Inconsistent generation in XRef: ${A}`;
      if (this._generationFallback && t.gen < s)
        return k(c), this.fetchUncompressed(nA.get(a, t.gen), t, i);
      throw new Hi(c);
    }
    const n = this.stream.makeSubStream(t.offset + this.stream.start), r = new Si({
      lexer: new qt(n),
      xref: this,
      allowStreams: !0
    }), g = r.getObj(), o = r.getObj(), I = r.getObj();
    if (g !== a || o !== s || !(I instanceof be))
      throw new Hi(`Bad (uncompressed) XRef entry: ${A}`);
    if (I.cmd !== "obj") {
      if (I.cmd.startsWith("obj") && (a = parseInt(I.cmd.substring(3), 10), !Number.isNaN(a)))
        return a;
      throw new Hi(`Bad (uncompressed) XRef entry: ${A}`);
    }
    return t = this.encrypt && !i ? r.getObj(this.encrypt.createCipherTransform(a, s)) : r.getObj(), t instanceof JA || this._cacheMap.set(a, t), t;
  }
  fetchCompressed(A, t, i = !1) {
    const s = t.offset, a = this.fetch(nA.get(s, 0));
    if (!(a instanceof JA))
      throw new v("bad ObjStm stream");
    const n = a.dict.get("First"), r = a.dict.get("N");
    if (!Number.isInteger(n) || !Number.isInteger(r))
      throw new v("invalid first and n parameters for ObjStm stream");
    let g = new Si({
      lexer: new qt(a),
      xref: this,
      allowStreams: !0
    });
    const o = new Array(r), I = new Array(r);
    for (let h = 0; h < r; ++h) {
      const C = g.getObj();
      if (!Number.isInteger(C))
        throw new v(`invalid object number in the ObjStm stream: ${C}`);
      const B = g.getObj();
      if (!Number.isInteger(B))
        throw new v(`invalid object offset in the ObjStm stream: ${B}`);
      o[h] = C, I[h] = B;
    }
    const c = (a.start || 0) + n, l = new Array(r);
    for (let h = 0; h < r; ++h) {
      const C = h < r - 1 ? I[h + 1] - I[h] : void 0;
      if (C < 0)
        throw new v("Invalid offset in the ObjStm stream.");
      g = new Si({
        lexer: new qt(a.makeSubStream(c + I[h], C, a.dict)),
        xref: this,
        allowStreams: !0
      });
      const B = g.getObj();
      if (l[h] = B, B instanceof JA)
        continue;
      const Q = o[h], E = this.entries[Q];
      E && E.offset === s && E.gen === h && this._cacheMap.set(Q, B);
    }
    if (t = l[t.gen], t === void 0)
      throw new Hi(`Bad (compressed) XRef entry: ${A}`);
    return t;
  }
  async fetchIfRefAsync(A, t) {
    return A instanceof nA ? this.fetchAsync(A, t) : A;
  }
  async fetchAsync(A, t) {
    try {
      return this.fetch(A, t);
    } catch (i) {
      if (!(i instanceof oe))
        throw i;
      return await this.pdfManager.requestRange(i.begin, i.end), this.fetchAsync(A, t);
    }
  }
  getCatalogObj() {
    return this.root;
  }
}
xa = new WeakMap();
const ox = [0, 0, 612, 792];
var ma, Kg;
class nc {
  constructor({
    pdfManager: A,
    xref: t,
    pageIndex: i,
    pageDict: s,
    ref: a,
    globalIdFactory: n,
    fontCache: r,
    builtInCMapCache: g,
    standardFontDataCache: o,
    globalImageCache: I,
    systemFontCache: c,
    nonBlendModesSet: l,
    xfaFactory: h
  }) {
    ZA(this, ma);
    this.pdfManager = A, this.pageIndex = i, this.pageDict = s, this.xref = t, this.ref = a, this.fontCache = r, this.builtInCMapCache = g, this.standardFontDataCache = o, this.globalImageCache = I, this.systemFontCache = c, this.nonBlendModesSet = l, this.evaluatorOptions = A.evaluatorOptions, this.resourcesPromise = null, this.xfaFactory = h;
    const C = {
      obj: 0
    };
    this._localIdFactory = class extends n {
      static createObjId() {
        return `p${i}_${++C.obj}`;
      }
      static getPageObjId() {
        return `p${a.toString()}`;
      }
    };
  }
  _getInheritableProperty(A, t = !1) {
    const i = Gt({
      dict: this.pageDict,
      key: A,
      getArray: t,
      stopWhenFound: !1
    });
    return Array.isArray(i) ? i.length === 1 || !(i[0] instanceof R) ? i[0] : R.merge({
      xref: this.xref,
      dictArray: i
    }) : i;
  }
  get content() {
    return this.pageDict.getArray("Contents");
  }
  get resources() {
    const A = this._getInheritableProperty("Resources");
    return iA(this, "resources", A instanceof R ? A : R.empty);
  }
  _getBoundingBox(A) {
    if (this.xfaData)
      return this.xfaData.bbox;
    const t = ii(this._getInheritableProperty(A, !0), null);
    if (t) {
      if (t[2] - t[0] > 0 && t[3] - t[1] > 0)
        return t;
      k(`Empty, or invalid, /${A} entry.`);
    }
    return null;
  }
  get mediaBox() {
    return iA(this, "mediaBox", this._getBoundingBox("MediaBox") || ox);
  }
  get cropBox() {
    return iA(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
  }
  get userUnit() {
    const A = this.pageDict.get("UserUnit");
    return iA(this, "userUnit", typeof A == "number" && A > 0 ? A : 1);
  }
  get view() {
    const {
      cropBox: A,
      mediaBox: t
    } = this;
    if (A !== t && !B0(A, t)) {
      const i = de.intersect(A, t);
      if (i && i[2] - i[0] > 0 && i[3] - i[1] > 0)
        return iA(this, "view", i);
      k("Empty /CropBox and /MediaBox intersection.");
    }
    return iA(this, "view", t);
  }
  get rotate() {
    let A = this._getInheritableProperty("Rotate") || 0;
    return A % 90 !== 0 ? A = 0 : A >= 360 ? A %= 360 : A < 0 && (A = (A % 360 + 360) % 360), iA(this, "rotate", A);
  }
  _onSubStreamError(A, t) {
    if (this.evaluatorOptions.ignoreErrors) {
      k(`getContentStream - ignoring sub-stream (${t}): "${A}".`);
      return;
    }
    throw A;
  }
  getContentStream() {
    return this.pdfManager.ensure(this, "content").then((A) => A instanceof JA ? A : Array.isArray(A) ? new xC(A, this._onSubStreamError.bind(this)) : new $r());
  }
  get xfaData() {
    return iA(this, "xfaData", this.xfaFactory ? {
      bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
    } : null);
  }
  async saveNewAnnotations(A, t, i, s, a) {
    if (this.xfaFactory)
      throw new Error("XFA: Cannot save new annotations.");
    const n = new Ci({
      xref: this.xref,
      handler: A,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    }), r = new ot(), g = new Ne();
    await BA(this, ma, Kg).call(this, i, r, g);
    const o = this.pageDict, I = this.annotations.filter((h) => !(h instanceof nA && r.has(h))), c = await Ui.saveNewAnnotations(n, t, i, s, a);
    for (const {
      ref: h
    } of c.annotations)
      h instanceof nA && !g.has(h) && I.push(h);
    const l = o.clone();
    l.set("Annots", I), a.put(this.ref, {
      data: l
    });
    for (const h of r)
      a.put(h, {
        data: null
      });
  }
  save(A, t, i, s) {
    const a = new Ci({
      xref: this.xref,
      handler: A,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    });
    return this._parsedAnnotations.then(function(n) {
      const r = [];
      for (const g of n)
        r.push(g.save(a, t, i, s).catch(function(o) {
          return k(`save - ignoring annotation data during "${t.name}" task: "${o}".`), null;
        }));
      return Promise.all(r);
    });
  }
  loadResources(A) {
    return this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources")), this.resourcesPromise.then(() => new Rn(this.resources, A, this.xref).load());
  }
  getOperatorList({
    handler: A,
    sink: t,
    task: i,
    intent: s,
    cacheKey: a,
    annotationStorage: n = null,
    modifiedIds: r = null
  }) {
    const g = this.getContentStream(), o = this.loadResources(["ColorSpace", "ExtGState", "Font", "Pattern", "Properties", "Shading", "XObject"]), I = new Ci({
      xref: this.xref,
      handler: A,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    }), c = this.xfaFactory ? null : pc(n), l = c == null ? void 0 : c.get(this.pageIndex);
    let h = Promise.resolve(null), C = null;
    if (l) {
      const Q = this.pdfManager.ensureDoc("annotationGlobals");
      let E;
      const f = /* @__PURE__ */ new Set();
      for (const {
        bitmapId: u,
        bitmap: x
      } of l)
        u && !x && !f.has(u) && f.add(u);
      const {
        isOffscreenCanvasSupported: d
      } = this.evaluatorOptions;
      if (f.size > 0) {
        const u = l.slice();
        for (const [x, m] of n)
          x.startsWith(hc) && m.bitmap && f.has(m.bitmapId) && u.push(m);
        E = Ui.generateImages(u, this.xref, d);
      } else
        E = Ui.generateImages(l, this.xref, d);
      C = new Ne(), h = Promise.all([Q, BA(this, ma, Kg).call(this, l, C, null)]).then(([u]) => u ? Ui.printNewAnnotations(u, I, i, l, E) : null);
    }
    const B = Promise.all([g, o]).then(([Q]) => {
      const E = new lt(s, t);
      return A.send("StartRenderPage", {
        transparency: I.hasBlendModes(this.resources, this.nonBlendModesSet),
        pageIndex: this.pageIndex,
        cacheKey: a
      }), I.getOperatorList({
        stream: Q,
        task: i,
        resources: this.resources,
        operatorList: E
      }).then(function() {
        return E;
      });
    });
    return Promise.all([B, this._parsedAnnotations, h]).then(function([Q, E, f]) {
      if (f) {
        E = E.filter((F) => !(F.ref && C.has(F.ref)));
        for (let F = 0, y = f.length; F < y; F++) {
          const H = f[F];
          if (H.refToReplace) {
            const N = E.findIndex((T) => T.ref && pn(T.ref, H.refToReplace));
            N >= 0 && (E.splice(N, 1, H), f.splice(F--, 1), y--);
          }
        }
        E = E.concat(f);
      }
      if (E.length === 0 || s & it.ANNOTATIONS_DISABLE)
        return Q.flush(!0), {
          length: Q.totalLength
        };
      const d = !!(s & it.ANNOTATIONS_FORMS), u = !!(s & it.IS_EDITING), x = !!(s & it.ANY), m = !!(s & it.DISPLAY), p = !!(s & it.PRINT), D = [];
      for (const F of E)
        (x || m && F.mustBeViewed(n, d) && F.mustBeViewedWhenEditing(u, r) || p && F.mustBePrinted(n)) && D.push(F.getOperatorList(I, i, s, n).catch(function(y) {
          return k(`getOperatorList - ignoring annotation data during "${i.name}" task: "${y}".`), {
            opList: null,
            separateForm: !1,
            separateCanvas: !1
          };
        }));
      return Promise.all(D).then(function(F) {
        let y = !1, H = !1;
        for (const {
          opList: N,
          separateForm: T,
          separateCanvas: _
        } of F)
          Q.addOpList(N), y || (y = T), H || (H = _);
        return Q.flush(!0, {
          form: y,
          canvas: H
        }), {
          length: Q.totalLength
        };
      });
    });
  }
  async extractTextContent({
    handler: A,
    task: t,
    includeMarkedContent: i,
    disableNormalization: s,
    sink: a
  }) {
    const n = this.getContentStream(), r = this.loadResources(["ExtGState", "Font", "Properties", "XObject"]), g = this.pdfManager.ensureCatalog("lang"), [o, , I] = await Promise.all([n, r, g]);
    return new Ci({
      xref: this.xref,
      handler: A,
      pageIndex: this.pageIndex,
      idFactory: this._localIdFactory,
      fontCache: this.fontCache,
      builtInCMapCache: this.builtInCMapCache,
      standardFontDataCache: this.standardFontDataCache,
      globalImageCache: this.globalImageCache,
      systemFontCache: this.systemFontCache,
      options: this.evaluatorOptions
    }).getTextContent({
      stream: o,
      task: t,
      resources: this.resources,
      includeMarkedContent: i,
      disableNormalization: s,
      sink: a,
      viewBox: this.view,
      lang: I
    });
  }
  async getStructTree() {
    const A = await this.pdfManager.ensureCatalog("structTreeRoot");
    if (!A)
      return null;
    await this._parsedAnnotations;
    const t = await this.pdfManager.ensure(this, "_parseStructTree", [A]);
    return this.pdfManager.ensure(t, "serializable");
  }
  _parseStructTree(A) {
    const t = new Cl(A, this.pageDict);
    return t.parse(this.ref), t;
  }
  async getAnnotationsData(A, t, i) {
    const s = await this._parsedAnnotations;
    if (s.length === 0)
      return s;
    const a = [], n = [];
    let r;
    const g = !!(i & it.ANY), o = !!(i & it.DISPLAY), I = !!(i & it.PRINT);
    for (const c of s) {
      const l = g || o && c.viewable;
      (l || I && c.printable) && a.push(c.data), c.hasTextContent && l && (r || (r = new Ci({
        xref: this.xref,
        handler: A,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      })), n.push(c.extractTextContent(r, t, [-1 / 0, -1 / 0, 1 / 0, 1 / 0]).catch(function(h) {
        k(`getAnnotationsData - ignoring textContent during "${t.name}" task: "${h}".`);
      })));
    }
    return await Promise.all(n), a;
  }
  get annotations() {
    const A = this._getInheritableProperty("Annots");
    return iA(this, "annotations", Array.isArray(A) ? A : []);
  }
  get _parsedAnnotations() {
    const A = this.pdfManager.ensure(this, "annotations").then(async (t) => {
      if (t.length === 0)
        return t;
      const [i, s] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureDoc("fieldObjects")]);
      if (!i)
        return [];
      const a = s == null ? void 0 : s.orphanFields, n = [];
      for (const I of t)
        n.push(Ui.create(this.xref, I, i, this._localIdFactory, !1, a, this.ref).catch(function(c) {
          return k(`_parsedAnnotations: "${c}".`), null;
        }));
      const r = [];
      let g, o;
      for (const I of await Promise.all(n))
        if (I) {
          if (I instanceof Ot) {
            (o || (o = [])).push(I);
            continue;
          }
          if (I instanceof $l) {
            (g || (g = [])).push(I);
            continue;
          }
          r.push(I);
        }
      return o && r.push(...o), g && r.push(...g), r;
    });
    return iA(this, "_parsedAnnotations", A);
  }
  get jsActions() {
    const A = $n(this.xref, this.pageDict, Hh);
    return iA(this, "jsActions", A);
  }
}
ma = new WeakSet(), Kg = async function(A, t, i) {
  const s = [];
  for (const a of A)
    if (a.id) {
      const n = nA.fromString(a.id);
      if (!n) {
        k(`A non-linked annotation cannot be modified: ${a.id}`);
        continue;
      }
      if (a.deleted) {
        if (t.put(n, n), a.popupRef) {
          const r = nA.fromString(a.popupRef);
          r && t.put(r, r);
        }
        continue;
      }
      i == null || i.put(n), a.ref = n, s.push(this.xref.fetchAsync(n).then((r) => {
        r instanceof R && (a.oldAnnotation = r.clone());
      }, () => {
        k(`Cannot fetch \`oldAnnotation\` for: ${n}.`);
      })), delete a.id;
    }
  await Promise.all(s);
};
const rc = new Uint8Array([37, 80, 68, 70, 45]), gc = new Uint8Array([115, 116, 97, 114, 116, 120, 114, 101, 102]), Ix = new Uint8Array([101, 110, 100, 111, 98, 106]);
function Pr(e, A, t = 1024, i = !1) {
  const s = A.length, a = e.peekBytes(t), n = a.length - s;
  if (n <= 0)
    return !1;
  if (i) {
    const r = s - 1;
    let g = a.length - 1;
    for (; g >= r; ) {
      let o = 0;
      for (; o < s && a[g - o] === A[r - o]; )
        o++;
      if (o >= s)
        return e.pos += g - r, !0;
      g--;
    }
  } else {
    let r = 0;
    for (; r <= n; ) {
      let g = 0;
      for (; g < s && a[r + g] === A[g]; )
        g++;
      if (g >= s)
        return e.pos += r, !0;
      r++;
    }
  }
  return !1;
}
var pa, vg;
class nh {
  constructor(A, t) {
    ZA(this, pa);
    if (t.length <= 0)
      throw new Os("The PDF file is empty, i.e. its size is zero bytes.");
    this.pdfManager = A, this.stream = t, this.xref = new gx(t, A), this._pagePromises = /* @__PURE__ */ new Map(), this._version = null;
    const i = {
      font: 0
    };
    this._globalIdFactory = class {
      static getDocId() {
        return `g_${A.docId}`;
      }
      static createFontId() {
        return `f${++i.font}`;
      }
      static createObjId() {
        WA("Abstract method `createObjId` called.");
      }
      static getPageObjId() {
        WA("Abstract method `getPageObjId` called.");
      }
    };
  }
  parse(A) {
    this.xref.parse(A), this.catalog = new ta(this.pdfManager, this.xref);
  }
  get linearization() {
    let A = null;
    try {
      A = cB.create(this.stream);
    } catch (t) {
      if (t instanceof oe)
        throw t;
      vA(t);
    }
    return iA(this, "linearization", A);
  }
  get startXRef() {
    const A = this.stream;
    let t = 0;
    if (this.linearization) {
      if (A.reset(), Pr(A, Ix)) {
        A.skip(6);
        let i = A.peekByte();
        for (; mt(i); )
          A.pos++, i = A.peekByte();
        t = A.pos - A.start;
      }
    } else {
      const s = gc.length;
      let a = !1, n = A.end;
      for (; !a && n > 0; )
        n -= 1024 - s, n < 0 && (n = 0), A.pos = n, a = Pr(A, gc, 1024, !0);
      if (a) {
        A.skip(9);
        let r;
        do
          r = A.getByte();
        while (mt(r));
        let g = "";
        for (; r >= 32 && r <= 57; )
          g += String.fromCharCode(r), r = A.getByte();
        t = parseInt(g, 10), isNaN(t) && (t = 0);
      }
    }
    return iA(this, "startXRef", t);
  }
  checkHeader() {
    const A = this.stream;
    if (A.reset(), !Pr(A, rc))
      return;
    A.moveStart(), A.skip(rc.length);
    let t = "", i;
    for (; (i = A.getByte()) > 32 && t.length < 7; )
      t += String.fromCharCode(i);
    uc.test(t) ? this._version = t : k(`Invalid PDF header version: ${t}`);
  }
  parseStartXRef() {
    this.xref.setStartXRef(this.startXRef);
  }
  get numPages() {
    let A = 0;
    return this.catalog.hasActualNumPages ? A = this.catalog.numPages : this.xfaFactory ? A = this.xfaFactory.getNumPages() : this.linearization ? A = this.linearization.numPages : A = this.catalog.numPages, iA(this, "numPages", A);
  }
  _hasOnlyDocumentSignatures(A, t = 0) {
    return Array.isArray(A) ? A.every((s) => {
      if (s = this.xref.fetchIfRef(s), !(s instanceof R))
        return !1;
      if (s.has("Kids"))
        return ++t > 10 ? (k("_hasOnlyDocumentSignatures: maximum recursion depth reached"), !1) : this._hasOnlyDocumentSignatures(s.get("Kids"), t);
      const a = xe(s.get("FT"), "Sig"), n = s.get("Rect"), r = Array.isArray(n) && n.every((g) => g === 0);
      return a && r;
    }) : !1;
  }
  get _xfaStreams() {
    const A = this.catalog.acroForm;
    if (!A)
      return null;
    const t = A.get("XFA"), i = {
      "xdp:xdp": "",
      template: "",
      datasets: "",
      config: "",
      connectionSet: "",
      localeSet: "",
      stylesheet: "",
      "/xdp:xdp": ""
    };
    if (t instanceof JA && !t.isEmpty)
      return i["xdp:xdp"] = t, i;
    if (!Array.isArray(t) || t.length === 0)
      return null;
    for (let s = 0, a = t.length; s < a; s += 2) {
      let n;
      if (s === 0 ? n = "xdp:xdp" : s === a - 2 ? n = "/xdp:xdp" : n = t[s], !i.hasOwnProperty(n))
        continue;
      const r = this.xref.fetchIfRef(t[s + 1]);
      !(r instanceof JA) || r.isEmpty || (i[n] = r);
    }
    return i;
  }
  get xfaDatasets() {
    const A = this._xfaStreams;
    if (!A)
      return iA(this, "xfaDatasets", null);
    for (const t of ["datasets", "xdp:xdp"]) {
      const i = A[t];
      if (i)
        try {
          const s = Vs(i.getString()), a = {
            [t]: s
          };
          return iA(this, "xfaDatasets", new rx(a));
        } catch {
          k("XFA - Invalid utf-8 string.");
          break;
        }
    }
    return iA(this, "xfaDatasets", null);
  }
  get xfaData() {
    const A = this._xfaStreams;
    if (!A)
      return null;
    const t = /* @__PURE__ */ Object.create(null);
    for (const [i, s] of Object.entries(A))
      if (s)
        try {
          t[i] = Vs(s.getString());
        } catch {
          return k("XFA - Invalid utf-8 string."), null;
        }
    return t;
  }
  get xfaFactory() {
    let A;
    return this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (A = this.xfaData), iA(this, "xfaFactory", A ? new Sa(A) : null);
  }
  get isPureXfa() {
    return this.xfaFactory ? this.xfaFactory.isValid() : !1;
  }
  get htmlForXfa() {
    return this.xfaFactory ? this.xfaFactory.getPages() : null;
  }
  async loadXfaImages() {
    const A = await this.pdfManager.ensureCatalog("xfaImages");
    if (!A)
      return;
    const t = A.getKeys();
    await new Rn(A, t, this.xref).load();
    const s = /* @__PURE__ */ new Map();
    for (const a of t) {
      const n = A.get(a);
      n instanceof JA && s.set(a, n.getBytes());
    }
    this.xfaFactory.setImages(s);
  }
  async loadXfaFonts(A, t) {
    const i = await this.pdfManager.ensureCatalog("acroForm");
    if (!i)
      return;
    const s = await i.getAsync("DR");
    if (!(s instanceof R))
      return;
    await new Rn(s, ["Font"], this.xref).load();
    const n = s.get("Font");
    if (!(n instanceof R))
      return;
    const r = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
    r.useSystemFonts = !1;
    const g = new Ci({
      xref: this.xref,
      handler: A,
      pageIndex: -1,
      idFactory: this._globalIdFactory,
      fontCache: this.catalog.fontCache,
      builtInCMapCache: this.catalog.builtInCMapCache,
      standardFontDataCache: this.catalog.standardFontDataCache,
      options: r
    }), o = new lt(), I = [], c = {
      get font() {
        return I.at(-1);
      },
      set font(B) {
        I.push(B);
      },
      clone() {
        return this;
      }
    }, l = [];
    for (const [B, Q] of n) {
      const E = Q.get("FontDescriptor");
      if (!(E instanceof R))
        continue;
      let f = E.get("FontFamily");
      f = f.replaceAll(/[ ]+(\d)/g, "$1");
      const d = E.get("FontWeight"), u = -E.get("ItalicAngle"), x = {
        fontFamily: f,
        fontWeight: d,
        italicAngle: u
      };
      eC(x) && l.push(g.handleSetFont(s, [L.get(B), 1], null, o, t, c, null, x).catch(function(m) {
        return k(`loadXfaFonts: "${m}".`), null;
      }));
    }
    await Promise.all(l);
    const h = this.xfaFactory.setFonts(I);
    if (!h)
      return;
    r.ignoreErrors = !0, l.length = 0, I.length = 0;
    const C = /* @__PURE__ */ new Set();
    for (const B of h)
      to(`${B}-Regular`) || C.add(B);
    C.size && h.push("PdfJS-Fallback");
    for (const B of h)
      if (!C.has(B))
        for (const Q of [{
          name: "Regular",
          fontWeight: 400,
          italicAngle: 0
        }, {
          name: "Bold",
          fontWeight: 700,
          italicAngle: 0
        }, {
          name: "Italic",
          fontWeight: 400,
          italicAngle: 12
        }, {
          name: "BoldItalic",
          fontWeight: 700,
          italicAngle: 12
        }]) {
          const E = `${B}-${Q.name}`, f = $c(E);
          l.push(g.handleSetFont(s, [L.get(E), 1], null, o, t, c, f, {
            fontFamily: B,
            fontWeight: Q.fontWeight,
            italicAngle: Q.italicAngle
          }).catch(function(d) {
            return k(`loadXfaFonts: "${d}".`), null;
          }));
        }
    await Promise.all(l), this.xfaFactory.appendFonts(I, C);
  }
  async serializeXfaData(A) {
    return this.xfaFactory ? this.xfaFactory.serializeData(A) : null;
  }
  get version() {
    return this.catalog.version || this._version;
  }
  get formInfo() {
    const A = {
      hasFields: !1,
      hasAcroForm: !1,
      hasXfa: !1,
      hasSignatures: !1
    }, t = this.catalog.acroForm;
    if (!t)
      return iA(this, "formInfo", A);
    try {
      const i = t.get("Fields"), s = Array.isArray(i) && i.length > 0;
      A.hasFields = s;
      const a = t.get("XFA");
      A.hasXfa = Array.isArray(a) && a.length > 0 || a instanceof JA && !a.isEmpty;
      const r = !!(t.get("SigFlags") & 1), g = r && this._hasOnlyDocumentSignatures(i);
      A.hasAcroForm = s && !g, A.hasSignatures = r;
    } catch (i) {
      if (i instanceof oe)
        throw i;
      k(`Cannot fetch form information: "${i}".`);
    }
    return iA(this, "formInfo", A);
  }
  get documentInfo() {
    const A = {
      PDFFormatVersion: this.version,
      Language: this.catalog.lang,
      EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
      IsLinearized: !!this.linearization,
      IsAcroFormPresent: this.formInfo.hasAcroForm,
      IsXFAPresent: this.formInfo.hasXfa,
      IsCollectionPresent: !!this.catalog.collection,
      IsSignaturesPresent: this.formInfo.hasSignatures
    };
    let t;
    try {
      t = this.xref.trailer.get("Info");
    } catch (i) {
      if (i instanceof oe)
        throw i;
      vA("The document information dictionary is invalid.");
    }
    if (!(t instanceof R))
      return iA(this, "documentInfo", A);
    for (const i of t.getKeys()) {
      const s = t.get(i);
      switch (i) {
        case "Title":
        case "Author":
        case "Subject":
        case "Keywords":
        case "Creator":
        case "Producer":
        case "CreationDate":
        case "ModDate":
          if (typeof s == "string") {
            A[i] = jA(s);
            continue;
          }
          break;
        case "Trapped":
          if (s instanceof L) {
            A[i] = s;
            continue;
          }
          break;
        default:
          let a;
          switch (typeof s) {
            case "string":
              a = jA(s);
              break;
            case "number":
            case "boolean":
              a = s;
              break;
            default:
              s instanceof L && (a = s);
              break;
          }
          if (a === void 0) {
            k(`Bad value, for custom key "${i}", in Info: ${s}.`);
            continue;
          }
          A.Custom || (A.Custom = /* @__PURE__ */ Object.create(null)), A.Custom[i] = a;
          continue;
      }
      k(`Bad value, for key "${i}", in Info: ${s}.`);
    }
    return iA(this, "documentInfo", A);
  }
  get fingerprints() {
    const t = "\0".repeat(16);
    function i(r) {
      return typeof r == "string" && r.length === 16 && r !== t;
    }
    const s = this.xref.trailer.get("ID");
    let a, n;
    return Array.isArray(s) && i(s[0]) ? (a = We(s[0]), s[1] !== s[0] && i(s[1]) && (n = We(s[1]))) : a = Ri(this.stream.getByteRange(0, 1024), 0, 1024), iA(this, "fingerprints", [Lo(a), n ? Lo(n) : null]);
  }
  async _getLinearizationPage(A) {
    const {
      catalog: t,
      linearization: i,
      xref: s
    } = this, a = nA.get(i.objectNumberFirst, 0);
    try {
      const n = await s.fetchAsync(a);
      if (n instanceof R) {
        let r = n.getRaw("Type");
        if (r instanceof nA && (r = await s.fetchAsync(r)), xe(r, "Page") || !n.has("Type") && !n.has("Kids") && n.has("Contents"))
          return t.pageKidsCountCache.has(a) || t.pageKidsCountCache.put(a, 1), t.pageIndexCache.has(a) || t.pageIndexCache.put(a, 0), [n, a];
      }
      throw new v("The Linearization dictionary doesn't point to a valid Page dictionary.");
    } catch (n) {
      return k(`_getLinearizationPage: "${n.message}".`), t.getPageDict(A);
    }
  }
  getPage(A) {
    const t = this._pagePromises.get(A);
    if (t)
      return t;
    const {
      catalog: i,
      linearization: s,
      xfaFactory: a
    } = this;
    let n;
    return a ? n = Promise.resolve([R.empty, null]) : (s == null ? void 0 : s.pageFirst) === A ? n = this._getLinearizationPage(A) : n = i.getPageDict(A), n = n.then(([r, g]) => new nc({
      pdfManager: this.pdfManager,
      xref: this.xref,
      pageIndex: A,
      pageDict: r,
      ref: g,
      globalIdFactory: this._globalIdFactory,
      fontCache: i.fontCache,
      builtInCMapCache: i.builtInCMapCache,
      standardFontDataCache: i.standardFontDataCache,
      globalImageCache: i.globalImageCache,
      systemFontCache: i.systemFontCache,
      nonBlendModesSet: i.nonBlendModesSet,
      xfaFactory: a
    })), this._pagePromises.set(A, n), n;
  }
  async checkFirstPage(A = !1) {
    if (!A)
      try {
        await this.getPage(0);
      } catch (t) {
        if (t instanceof Hi)
          throw this._pagePromises.delete(0), await this.cleanup(), new P0();
      }
  }
  async checkLastPage(A = !1) {
    const {
      catalog: t,
      pdfManager: i
    } = this;
    t.setActualNumPages();
    let s;
    try {
      if (await Promise.all([i.ensureDoc("xfaFactory"), i.ensureDoc("linearization"), i.ensureCatalog("numPages")]), this.xfaFactory)
        return;
      if (this.linearization ? s = this.linearization.numPages : s = t.numPages, Number.isInteger(s)) {
        if (s <= 1)
          return;
      } else throw new v("Page count is not an integer.");
      await this.getPage(s - 1);
    } catch (a) {
      if (this._pagePromises.delete(s - 1), await this.cleanup(), a instanceof Hi && !A)
        throw new P0();
      k(`checkLastPage - invalid /Pages tree /Count: ${s}.`);
      let n;
      try {
        n = await t.getAllPageDicts(A);
      } catch (r) {
        if (r instanceof Hi && !A)
          throw new P0();
        t.setActualNumPages(1);
        return;
      }
      for (const [r, [g, o]] of n) {
        let I;
        g instanceof Error ? (I = Promise.reject(g), I.catch(() => {
        })) : I = Promise.resolve(new nc({
          pdfManager: i,
          xref: this.xref,
          pageIndex: r,
          pageDict: g,
          ref: o,
          globalIdFactory: this._globalIdFactory,
          fontCache: t.fontCache,
          builtInCMapCache: t.builtInCMapCache,
          standardFontDataCache: t.standardFontDataCache,
          globalImageCache: t.globalImageCache,
          systemFontCache: t.systemFontCache,
          nonBlendModesSet: t.nonBlendModesSet,
          xfaFactory: null
        })), this._pagePromises.set(r, I);
      }
      t.setActualNumPages(n.size);
    }
  }
  fontFallback(A, t) {
    return this.catalog.fontFallback(A, t);
  }
  async cleanup(A = !1) {
    return this.catalog ? this.catalog.cleanup(A) : ao();
  }
  get fieldObjects() {
    const A = this.pdfManager.ensureDoc("formInfo").then(async (t) => {
      if (!t.hasFields)
        return null;
      const [i, s] = await Promise.all([this.pdfManager.ensureDoc("annotationGlobals"), this.pdfManager.ensureCatalog("acroForm")]);
      if (!i)
        return null;
      const a = new Ne(), n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Map(), g = new ot();
      for (const I of await s.getAsync("Fields"))
        await BA(this, pa, vg).call(this, "", null, I, r, i, a, g);
      const o = [];
      for (const [I, c] of r)
        o.push(Promise.all(c).then((l) => {
          l = l.filter((h) => !!h), l.length > 0 && (n[I] = l);
        }));
      return await Promise.all(o), {
        allFields: n,
        orphanFields: g
      };
    });
    return iA(this, "fieldObjects", A);
  }
  get hasJSActions() {
    const A = this.pdfManager.ensureDoc("_parseHasJSActions");
    return iA(this, "hasJSActions", A);
  }
  async _parseHasJSActions() {
    const [A, t] = await Promise.all([this.pdfManager.ensureCatalog("jsActions"), this.pdfManager.ensureDoc("fieldObjects")]);
    return A ? !0 : t ? Object.values(t.allFields).some((i) => i.some((s) => s.actions !== null)) : !1;
  }
  get calculationOrderIds() {
    var i;
    const A = (i = this.catalog.acroForm) == null ? void 0 : i.get("CO");
    if (!Array.isArray(A) || A.length === 0)
      return iA(this, "calculationOrderIds", null);
    const t = [];
    for (const s of A)
      s instanceof nA && t.push(s.toString());
    return iA(this, "calculationOrderIds", t.length ? t : null);
  }
  get annotationGlobals() {
    return iA(this, "annotationGlobals", Ui.createGlobals(this.pdfManager));
  }
}
pa = new WeakSet(), vg = async function(A, t, i, s, a, n, r) {
  const {
    xref: g
  } = this;
  if (!(i instanceof nA) || n.has(i))
    return;
  n.put(i);
  const o = await g.fetchAsync(i);
  if (!(o instanceof R))
    return;
  if (o.has("T")) {
    const c = jA(await o.getAsync("T"));
    A = A === "" ? c : `${A}.${c}`;
  } else {
    let c = o;
    for (; ; ) {
      if (c = c.getRaw("Parent") || t, c instanceof nA) {
        if (n.has(c))
          break;
        c = await g.fetchAsync(c);
      }
      if (!(c instanceof R))
        break;
      if (c.has("T")) {
        const l = jA(await c.getAsync("T"));
        A = A === "" ? l : `${A}.${l}`;
        break;
      }
    }
  }
  if (t && !o.has("Parent") && xe(o.get("Subtype"), "Widget") && r.put(i, t), s.has(A) || s.set(A, []), s.get(A).push(Ui.create(g, i, a, null, !0, r, null).then((c) => c == null ? void 0 : c.getFieldObject()).catch(function(c) {
    return k(`#collectFieldObjects: "${c}".`), null;
  })), !o.has("Kids"))
    return;
  const I = await o.getAsync("Kids");
  if (Array.isArray(I))
    for (const c of I)
      await BA(this, pa, vg).call(this, A, i, c, s, a, n, r);
};
function cx(e) {
  if (e) {
    const A = mn(e);
    if (A)
      return A.href;
    k(`Invalid absolute docBaseUrl: "${e}".`);
  }
  return null;
}
class rh {
  constructor(A) {
    var t, i;
    this._docBaseUrl = cx(A.docBaseUrl), this._docId = A.docId, this._password = A.password, this.enableXfa = A.enableXfa, (t = A.evaluatorOptions).isOffscreenCanvasSupported && (t.isOffscreenCanvasSupported = ht.isOffscreenCanvasSupported), (i = A.evaluatorOptions).isImageDecoderSupported && (i.isImageDecoderSupported = ht.isImageDecoderSupported), this.evaluatorOptions = Object.freeze(A.evaluatorOptions);
  }
  get docId() {
    return this._docId;
  }
  get password() {
    return this._password;
  }
  get docBaseUrl() {
    return this._docBaseUrl;
  }
  get catalog() {
    return this.pdfDocument.catalog;
  }
  ensureDoc(A, t) {
    return this.ensure(this.pdfDocument, A, t);
  }
  ensureXRef(A, t) {
    return this.ensure(this.pdfDocument.xref, A, t);
  }
  ensureCatalog(A, t) {
    return this.ensure(this.pdfDocument.catalog, A, t);
  }
  getPage(A) {
    return this.pdfDocument.getPage(A);
  }
  fontFallback(A, t) {
    return this.pdfDocument.fontFallback(A, t);
  }
  loadXfaFonts(A, t) {
    return this.pdfDocument.loadXfaFonts(A, t);
  }
  loadXfaImages() {
    return this.pdfDocument.loadXfaImages();
  }
  serializeXfaData(A) {
    return this.pdfDocument.serializeXfaData(A);
  }
  cleanup(A = !1) {
    return this.pdfDocument.cleanup(A);
  }
  async ensure(A, t, i) {
    WA("Abstract method `ensure` called");
  }
  requestRange(A, t) {
    WA("Abstract method `requestRange` called");
  }
  requestLoadedStream(A = !1) {
    WA("Abstract method `requestLoadedStream` called");
  }
  sendProgressiveData(A) {
    WA("Abstract method `sendProgressiveData` called");
  }
  updatePassword(A) {
    this._password = A;
  }
  terminate(A) {
    WA("Abstract method `terminate` called");
  }
}
class oc extends rh {
  constructor(A) {
    super(A);
    const t = new Qe(A.source);
    this.pdfDocument = new nh(this, t), this._loadedStreamPromise = Promise.resolve(t);
  }
  async ensure(A, t, i) {
    const s = A[t];
    return typeof s == "function" ? s.apply(A, i) : s;
  }
  requestRange(A, t) {
    return Promise.resolve();
  }
  requestLoadedStream(A = !1) {
    return this._loadedStreamPromise;
  }
  terminate(A) {
  }
}
class lx extends rh {
  constructor(A) {
    super(A), this.streamManager = new aC(A.source, {
      msgHandler: A.handler,
      length: A.length,
      disableAutoFetch: A.disableAutoFetch,
      rangeChunkSize: A.rangeChunkSize
    }), this.pdfDocument = new nh(this, this.streamManager.getStream());
  }
  async ensure(A, t, i) {
    try {
      const s = A[t];
      return typeof s == "function" ? s.apply(A, i) : s;
    } catch (s) {
      if (!(s instanceof oe))
        throw s;
      return await this.requestRange(s.begin, s.end), this.ensure(A, t, i);
    }
  }
  requestRange(A, t) {
    return this.streamManager.requestRange(A, t);
  }
  requestLoadedStream(A = !1) {
    return this.streamManager.requestAllChunks(A);
  }
  sendProgressiveData(A) {
    this.streamManager.onReceiveData({
      chunk: A
    });
  }
  terminate(A) {
    this.streamManager.abort(A);
  }
}
const an = {
  DATA: 1,
  ERROR: 2
}, De = {
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function Ic() {
}
function ut(e) {
  if (e instanceof Te || e instanceof Os || e instanceof No || e instanceof Ws || e instanceof Mo || e instanceof ur)
    return e;
  switch (e instanceof Error || typeof e == "object" && e !== null || WA('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), e.name) {
    case "AbortException":
      return new Te(e.message);
    case "InvalidPDFException":
      return new Os(e.message);
    case "MissingPDFException":
      return new No(e.message);
    case "PasswordException":
      return new Ws(e.message, e.code);
    case "UnexpectedResponseException":
      return new Mo(e.message, e.status);
    case "UnknownErrorException":
      return new ur(e.message, e.details);
  }
  return new ur(e.message, e.toString());
}
var As, Ut, gh, oh, Ih, dn;
class cc {
  constructor(A, t, i) {
    ZA(this, Ut);
    ZA(this, As, new AbortController());
    this.sourceName = A, this.targetName = t, this.comObj = i, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), i.addEventListener("message", BA(this, Ut, gh).bind(this), {
      signal: PA(this, As).signal
    });
  }
  on(A, t) {
    const i = this.actionHandler;
    if (i[A])
      throw new Error(`There is already an actionName called "${A}"`);
    i[A] = t;
  }
  send(A, t, i) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: A,
      data: t
    }, i);
  }
  sendWithPromise(A, t, i) {
    const s = this.callbackId++, a = Promise.withResolvers();
    this.callbackCapabilities[s] = a;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: A,
        callbackId: s,
        data: t
      }, i);
    } catch (n) {
      a.reject(n);
    }
    return a.promise;
  }
  sendWithStream(A, t, i, s) {
    const a = this.streamId++, n = this.sourceName, r = this.targetName, g = this.comObj;
    return new ReadableStream({
      start: (o) => {
        const I = Promise.withResolvers();
        return this.streamControllers[a] = {
          controller: o,
          startCall: I,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, g.postMessage({
          sourceName: n,
          targetName: r,
          action: A,
          streamId: a,
          data: t,
          desiredSize: o.desiredSize
        }, s), I.promise;
      },
      pull: (o) => {
        const I = Promise.withResolvers();
        return this.streamControllers[a].pullCall = I, g.postMessage({
          sourceName: n,
          targetName: r,
          stream: De.PULL,
          streamId: a,
          desiredSize: o.desiredSize
        }), I.promise;
      },
      cancel: (o) => {
        _e(o instanceof Error, "cancel must have a valid reason");
        const I = Promise.withResolvers();
        return this.streamControllers[a].cancelCall = I, this.streamControllers[a].isClosed = !0, g.postMessage({
          sourceName: n,
          targetName: r,
          stream: De.CANCEL,
          streamId: a,
          reason: ut(o)
        }), I.promise;
      }
    }, i);
  }
  destroy() {
    var A;
    (A = PA(this, As)) == null || A.abort(), wt(this, As, null);
  }
}
As = new WeakMap(), Ut = new WeakSet(), gh = function({
  data: A
}) {
  if (A.targetName !== this.sourceName)
    return;
  if (A.stream) {
    BA(this, Ut, Ih).call(this, A);
    return;
  }
  if (A.callback) {
    const i = A.callbackId, s = this.callbackCapabilities[i];
    if (!s)
      throw new Error(`Cannot resolve callback ${i}`);
    if (delete this.callbackCapabilities[i], A.callback === an.DATA)
      s.resolve(A.data);
    else if (A.callback === an.ERROR)
      s.reject(ut(A.reason));
    else
      throw new Error("Unexpected callback case");
    return;
  }
  const t = this.actionHandler[A.action];
  if (!t)
    throw new Error(`Unknown action from worker: ${A.action}`);
  if (A.callbackId) {
    const i = this.sourceName, s = A.sourceName, a = this.comObj;
    Promise.try(t, A.data).then(function(n) {
      a.postMessage({
        sourceName: i,
        targetName: s,
        callback: an.DATA,
        callbackId: A.callbackId,
        data: n
      });
    }, function(n) {
      a.postMessage({
        sourceName: i,
        targetName: s,
        callback: an.ERROR,
        callbackId: A.callbackId,
        reason: ut(n)
      });
    });
    return;
  }
  if (A.streamId) {
    BA(this, Ut, oh).call(this, A);
    return;
  }
  t(A.data);
}, oh = function(A) {
  const t = A.streamId, i = this.sourceName, s = A.sourceName, a = this.comObj, n = this, r = this.actionHandler[A.action], g = {
    enqueue(o, I = 1, c) {
      if (this.isCancelled)
        return;
      const l = this.desiredSize;
      this.desiredSize -= I, l > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), a.postMessage({
        sourceName: i,
        targetName: s,
        stream: De.ENQUEUE,
        streamId: t,
        chunk: o
      }, c);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, a.postMessage({
        sourceName: i,
        targetName: s,
        stream: De.CLOSE,
        streamId: t
      }), delete n.streamSinks[t]);
    },
    error(o) {
      _e(o instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, a.postMessage({
        sourceName: i,
        targetName: s,
        stream: De.ERROR,
        streamId: t,
        reason: ut(o)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: A.desiredSize,
    ready: null
  };
  g.sinkCapability.resolve(), g.ready = g.sinkCapability.promise, this.streamSinks[t] = g, Promise.try(r, A.data, g).then(function() {
    a.postMessage({
      sourceName: i,
      targetName: s,
      stream: De.START_COMPLETE,
      streamId: t,
      success: !0
    });
  }, function(o) {
    a.postMessage({
      sourceName: i,
      targetName: s,
      stream: De.START_COMPLETE,
      streamId: t,
      reason: ut(o)
    });
  });
}, Ih = function(A) {
  const t = A.streamId, i = this.sourceName, s = A.sourceName, a = this.comObj, n = this.streamControllers[t], r = this.streamSinks[t];
  switch (A.stream) {
    case De.START_COMPLETE:
      A.success ? n.startCall.resolve() : n.startCall.reject(ut(A.reason));
      break;
    case De.PULL_COMPLETE:
      A.success ? n.pullCall.resolve() : n.pullCall.reject(ut(A.reason));
      break;
    case De.PULL:
      if (!r) {
        a.postMessage({
          sourceName: i,
          targetName: s,
          stream: De.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
        break;
      }
      r.desiredSize <= 0 && A.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = A.desiredSize, Promise.try(r.onPull || Ic).then(function() {
        a.postMessage({
          sourceName: i,
          targetName: s,
          stream: De.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(o) {
        a.postMessage({
          sourceName: i,
          targetName: s,
          stream: De.PULL_COMPLETE,
          streamId: t,
          reason: ut(o)
        });
      });
      break;
    case De.ENQUEUE:
      if (_e(n, "enqueue should have stream controller"), n.isClosed)
        break;
      n.controller.enqueue(A.chunk);
      break;
    case De.CLOSE:
      if (_e(n, "close should have stream controller"), n.isClosed)
        break;
      n.isClosed = !0, n.controller.close(), BA(this, Ut, dn).call(this, n, t);
      break;
    case De.ERROR:
      _e(n, "error should have stream controller"), n.controller.error(ut(A.reason)), BA(this, Ut, dn).call(this, n, t);
      break;
    case De.CANCEL_COMPLETE:
      A.success ? n.cancelCall.resolve() : n.cancelCall.reject(ut(A.reason)), BA(this, Ut, dn).call(this, n, t);
      break;
    case De.CANCEL:
      if (!r)
        break;
      const g = ut(A.reason);
      Promise.try(r.onCancel || Ic, g).then(function() {
        a.postMessage({
          sourceName: i,
          targetName: s,
          stream: De.CANCEL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(o) {
        a.postMessage({
          sourceName: i,
          targetName: s,
          stream: De.CANCEL_COMPLETE,
          streamId: t,
          reason: ut(o)
        });
      }), r.sinkCapability.reject(g), r.isCancelled = !0, delete this.streamSinks[t];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, dn = async function(A, t) {
  var i, s, a;
  await Promise.allSettled([(i = A.startCall) == null ? void 0 : i.promise, (s = A.pullCall) == null ? void 0 : s.promise, (a = A.cancelCall) == null ? void 0 : a.promise]), delete this.streamControllers[t];
};
async function ch(e, A, t, {
  encrypt: i = null
}) {
  const s = i == null ? void 0 : i.createCipherTransform(e.num, e.gen);
  t.push(`${e.num} ${e.gen} obj
`), A instanceof R ? await Qr(A, t, s) : A instanceof JA ? await lh(A, t, s) : (Array.isArray(A) || ArrayBuffer.isView(A)) && await hh(A, t, s), t.push(`
endobj
`);
}
async function Qr(e, A, t) {
  A.push("<<");
  for (const i of e.getKeys())
    A.push(` /${Pg(i)} `), await Ch(e.getRaw(i), A, t);
  A.push(">>");
}
async function lh(e, A, t) {
  let i = e.getBytes();
  const {
    dict: s
  } = e, [a, n] = await Promise.all([s.getAsync("Filter"), s.getAsync("DecodeParms")]), r = Array.isArray(a) ? await s.xref.fetchIfRefAsync(a[0]) : a, g = xe(r, "FlateDecode");
  if (i.length >= 256 || g)
    try {
      const c = new CompressionStream("deflate"), l = c.writable.getWriter();
      await l.ready, l.write(i).then(async () => {
        await l.ready, await l.close();
      }).catch(() => {
      });
      const h = await new Response(c.readable).arrayBuffer();
      i = new Uint8Array(h);
      let C, B;
      a ? g || (C = Array.isArray(a) ? [L.get("FlateDecode"), ...a] : [L.get("FlateDecode"), a], n && (B = Array.isArray(n) ? [null, ...n] : [null, n])) : C = L.get("FlateDecode"), C && s.set("Filter", C), B && s.set("DecodeParms", B);
    } catch (c) {
      vA(`writeStream - cannot compress data: "${c}".`);
    }
  let I = ct(i);
  t && (I = t.encryptString(I)), s.set("Length", I.length), await Qr(s, A, t), A.push(` stream
`, I, `
endstream`);
}
async function hh(e, A, t) {
  A.push("[");
  let i = !0;
  for (const s of e)
    i ? i = !1 : A.push(" "), await Ch(s, A, t);
  A.push("]");
}
async function Ch(e, A, t) {
  e instanceof L ? A.push(`/${Pg(e.name)}`) : e instanceof nA ? A.push(`${e.num} ${e.gen} R`) : Array.isArray(e) || ArrayBuffer.isView(e) ? await hh(e, A, t) : typeof e == "string" ? (t && (e = t.encryptString(e)), A.push(`(${es(e)})`)) : typeof e == "number" ? A.push($A(e)) : typeof e == "boolean" ? A.push(e.toString()) : e instanceof R ? await Qr(e, A, t) : e instanceof JA ? await lh(e, A, t) : e === null ? A.push("null") : k(`Unhandled value in writer: ${typeof e}, please file a bug.`);
}
function Wr(e, A, t, i) {
  for (let s = A + t - 1; s > t - 1; s--)
    i[s] = e & 255, e >>= 8;
  return t + A;
}
function Bh(e, A, t) {
  for (let i = 0, s = e.length; i < s; i++)
    t[A + i] = e.charCodeAt(i) & 255;
}
function hx(e, A) {
  const t = Math.floor(Date.now() / 1e3), i = A.filename || "", s = [t.toString(), i, e.toString()];
  let a = s.reduce((g, o) => g + o.length, 0);
  for (const g of Object.values(A.info))
    s.push(g), a += g.length;
  const n = new Uint8Array(a);
  let r = 0;
  for (const g of s)
    Bh(g, r, n), r += g.length;
  return ct(Ri(n));
}
function Cx(e, A) {
  const t = new ar({
    hasAttributes: !0
  }).parseFromString(e);
  for (const {
    xfa: s
  } of A) {
    if (!s)
      continue;
    const {
      path: a,
      value: n
    } = s;
    if (!a)
      continue;
    const r = xc(a);
    let g = t.documentElement.searchNode(r, 0);
    !g && r.length > 1 && (g = t.documentElement.searchNode([r.at(-1)], 0)), g ? g.childNodes = Array.isArray(n) ? n.map((o) => new Js("value", o)) : [new Js("#text", n)] : k(`Node not found for path: ${a}`);
  }
  const i = [];
  return t.documentElement.dump(i), i.join("");
}
async function Bx({
  xref: e,
  acroForm: A,
  acroFormRef: t,
  hasXfa: i,
  hasXfaDatasetsEntry: s,
  xfaDatasetsRef: a,
  needAppearances: n,
  changes: r
}) {
  if (i && !s && !a && k("XFA - Cannot save it"), !n && (!i || !a || s))
    return;
  const g = A.clone();
  if (i && !s) {
    const o = A.get("XFA").slice();
    o.splice(2, 0, "datasets"), o.splice(3, 0, a), g.set("XFA", o);
  }
  n && g.set("NeedAppearances", !0), r.put(t, {
    data: g
  });
}
function Qx({
  xfaData: e,
  xfaDatasetsRef: A,
  changes: t,
  xref: i
}) {
  if (e === null) {
    const a = i.fetchIfRef(A);
    e = Cx(a.getString(), t);
  }
  const s = new Ct(e);
  s.dict = new R(i), s.dict.set("Type", L.get("EmbeddedFile")), t.put(A, {
    data: s
  });
}
async function Ex(e, A, t, i, s) {
  s.push(`xref
`);
  const a = Qh(t);
  let n = 0;
  for (const {
    ref: r,
    data: g
  } of t)
    r.num === a[n] && (s.push(`${a[n]} ${a[n + 1]}
`), n += 2), g !== null ? (s.push(`${A.toString().padStart(10, "0")} ${Math.min(r.gen, 65535).toString().padStart(5, "0")} n\r
`), A += g.length) : s.push(`0000000000 ${Math.min(r.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
  Eh(A, e, i), s.push(`trailer
`), await Qr(i, s), s.push(`
startxref
`, A.toString(), `
%%EOF
`);
}
function Qh(e) {
  const A = [];
  for (const {
    ref: t
  } of e)
    t.num === A.at(-2) + A.at(-1) ? A[A.length - 1] += 1 : A.push(t.num, 1);
  return A;
}
async function fx(e, A, t, i, s) {
  const a = [];
  let n = 0, r = 0;
  for (const {
    ref: B,
    data: Q
  } of t) {
    let E;
    n = Math.max(n, A), Q !== null ? (E = Math.min(B.gen, 65535), a.push([1, A, E]), A += Q.length) : (E = Math.min(B.gen + 1, 65535), a.push([0, 0, E])), r = Math.max(r, E);
  }
  i.set("Index", Qh(t));
  const g = Ho(n), o = Ho(r), I = [1, g, o];
  i.set("W", I), Eh(A, e, i);
  const c = I.reduce((B, Q) => B + Q, 0), l = new Uint8Array(c * a.length), h = new Qe(l);
  h.dict = i;
  let C = 0;
  for (const [B, Q, E] of a)
    C = Wr(B, I[0], C, l), C = Wr(Q, I[1], C, l), C = Wr(E, I[2], C, l);
  await ch(e.newRef, h, s, {}), s.push(`startxref
`, A.toString(), `
%%EOF
`);
}
function Eh(e, A, t) {
  if (Array.isArray(A.fileIds) && A.fileIds.length > 0) {
    const i = hx(e, A);
    t.set("ID", [A.fileIds[0], i]);
  }
}
function ux(e, A, t) {
  const i = new R(null);
  i.set("Prev", e.startXRef);
  const s = e.newRef;
  return t ? (A.put(s, {
    data: ""
  }), i.set("Size", s.num + 1), i.set("Type", L.get("XRef"))) : i.set("Size", s.num), e.rootRef !== null && i.set("Root", e.rootRef), e.infoRef !== null && i.set("Info", e.infoRef), e.encryptRef !== null && i.set("Encrypt", e.encryptRef), i;
}
async function dx(e, A, t = []) {
  const i = [];
  for (const [s, {
    data: a
  }] of e.items()) {
    if (a === null || typeof a == "string") {
      i.push({
        ref: s,
        data: a
      });
      continue;
    }
    await ch(s, a, t, A), i.push({
      ref: s,
      data: t.join("")
    }), t.length = 0;
  }
  return i.sort((s, a) => s.ref.num - a.ref.num);
}
async function xx({
  originalData: e,
  xrefInfo: A,
  changes: t,
  xref: i = null,
  hasXfa: s = !1,
  xfaDatasetsRef: a = null,
  hasXfaDatasetsEntry: n = !1,
  needAppearances: r,
  acroFormRef: g = null,
  acroForm: o = null,
  xfaData: I = null,
  useXrefStream: c = !1
}) {
  await Bx({
    xref: i,
    acroForm: o,
    acroFormRef: g,
    hasXfa: s,
    hasXfaDatasetsEntry: n,
    xfaDatasetsRef: a,
    needAppearances: r,
    changes: t
  }), s && Qx({
    xfaData: I,
    xfaDatasetsRef: a,
    changes: t,
    xref: i
  });
  const l = ux(A, t, c), h = [], C = await dx(t, i, h);
  let B = e.length;
  const Q = e.at(-1);
  Q !== 10 && Q !== 13 && (h.push(`
`), B += 1);
  for (const {
    data: u
  } of C)
    u !== null && h.push(u);
  await (c ? fx(A, B, C, l, h) : Ex(A, B, C, l, h));
  const E = h.reduce((u, x) => u + x.length, e.length), f = new Uint8Array(E);
  f.set(e);
  let d = e.length;
  for (const u of h)
    Bh(u, d, f), d += u.length;
  return f;
}
class mx {
  constructor(A) {
    this._msgHandler = A, this._contentLength = null, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  getFullReader() {
    return _e(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once."), this._fullRequestReader = new px(this._msgHandler), this._fullRequestReader;
  }
  getRangeReader(A, t) {
    const i = new yx(A, t, this._msgHandler);
    return this._rangeRequestReaders.push(i), i;
  }
  cancelAllRequests(A) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(A);
    for (const i of this._rangeRequestReaders.slice(0))
      i.cancel(A);
  }
}
class px {
  constructor(A) {
    this._msgHandler = A, this.onProgress = null, this._contentLength = null, this._isRangeSupported = !1, this._isStreamingSupported = !1;
    const t = this._msgHandler.sendWithStream("GetReader");
    this._reader = t.getReader(), this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((i) => {
      this._isStreamingSupported = i.isStreamingSupported, this._isRangeSupported = i.isRangeSupported, this._contentLength = i.contentLength;
    });
  }
  get headersReady() {
    return this._headersReady;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  async read() {
    const {
      value: A,
      done: t
    } = await this._reader.read();
    return t ? {
      value: void 0,
      done: !0
    } : {
      value: A.buffer,
      done: !1
    };
  }
  cancel(A) {
    this._reader.cancel(A);
  }
}
class yx {
  constructor(A, t, i) {
    this._msgHandler = i, this.onProgress = null;
    const s = this._msgHandler.sendWithStream("GetRangeReader", {
      begin: A,
      end: t
    });
    this._reader = s.getReader();
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    const {
      value: A,
      done: t
    } = await this._reader.read();
    return t ? {
      value: void 0,
      done: !0
    } : {
      value: A.buffer,
      done: !1
    };
  }
  cancel(A) {
    this._reader.cancel(A);
  }
}
class $i {
  constructor(A) {
    this.name = A, this.terminated = !1, this._capability = Promise.withResolvers();
  }
  get finished() {
    return this._capability.promise;
  }
  finish() {
    this._capability.resolve();
  }
  terminate() {
    this.terminated = !0;
  }
  ensureNotTerminated() {
    if (this.terminated)
      throw new Error("Worker task was terminated");
  }
}
const yo = class yo {
  static setup(A, t) {
    let i = !1;
    A.on("test", (s) => {
      i || (i = !0, A.send("test", s instanceof Uint8Array));
    }), A.on("configure", (s) => {
      Jh(s.verbosity);
    }), A.on("GetDocRequest", (s) => this.createDocumentHandler(s, t));
  }
  static createDocumentHandler(A, t) {
    let i, s = !1, a = null;
    const n = /* @__PURE__ */ new Set(), r = Yh(), {
      docId: g,
      apiVersion: o
    } = A, I = "4.10.38";
    if (o !== I)
      throw new Error(`The API version "${o}" does not match the Worker version "${I}".`);
    const c = [];
    for (const u in [])
      c.push(u);
    if (c.length)
      throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + c.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
    const l = g + "_worker";
    let h = new cc(l, g, t);
    function C() {
      if (s)
        throw new Error("Worker was terminated");
    }
    function B(u) {
      n.add(u);
    }
    function Q(u) {
      u.finish(), n.delete(u);
    }
    async function E(u) {
      await i.ensureDoc("checkHeader"), await i.ensureDoc("parseStartXRef"), await i.ensureDoc("parse", [u]), await i.ensureDoc("checkFirstPage", [u]), await i.ensureDoc("checkLastPage", [u]);
      const x = await i.ensureDoc("isPureXfa");
      if (x) {
        const F = new $i("loadXfaFonts");
        B(F), await Promise.all([i.loadXfaFonts(h, F).catch((y) => {
        }).then(() => Q(F)), i.loadXfaImages()]);
      }
      const [m, p] = await Promise.all([i.ensureDoc("numPages"), i.ensureDoc("fingerprints")]), D = x ? await i.ensureDoc("htmlForXfa") : null;
      return {
        numPages: m,
        fingerprints: p,
        htmlForXfa: D
      };
    }
    async function f({
      data: u,
      password: x,
      disableAutoFetch: m,
      rangeChunkSize: p,
      length: D,
      docBaseUrl: F,
      enableXfa: y,
      evaluatorOptions: H
    }) {
      const N = {
        source: null,
        disableAutoFetch: m,
        docBaseUrl: F,
        docId: g,
        enableXfa: y,
        evaluatorOptions: H,
        handler: h,
        length: D,
        password: x,
        rangeChunkSize: p
      };
      if (u)
        return N.source = u, new oc(N);
      const T = new mx(h), _ = T.getFullReader(), oA = Promise.withResolvers();
      let G, S = [], tA = 0;
      return _.headersReady.then(function() {
        if (_.isRangeSupported) {
          N.source = T, N.length = _.contentLength, N.disableAutoFetch || (N.disableAutoFetch = _.isStreamingSupported), G = new lx(N);
          for (const $ of S)
            G.sendProgressiveData($);
          S = [], oA.resolve(G), a = null;
        }
      }).catch(function($) {
        oA.reject($), a = null;
      }), new Promise(function($, hA) {
        const yA = function({
          value: pA,
          done: DA
        }) {
          try {
            if (C(), DA) {
              if (!G) {
                const X = dc(S);
                S = [], D && X.length !== D && k("reported HTTP length is different from actual"), N.source = X, G = new oc(N), oA.resolve(G);
              }
              a = null;
              return;
            }
            tA += pA.byteLength, _.isStreamingSupported || h.send("DocProgress", {
              loaded: tA,
              total: Math.max(tA, _.contentLength || 0)
            }), G ? G.sendProgressiveData(pA) : S.push(pA), _.read().then(yA, hA);
          } catch (X) {
            hA(X);
          }
        };
        _.read().then(yA, hA);
      }).catch(function($) {
        oA.reject($), a = null;
      }), a = ($) => {
        T.cancelAllRequests($);
      }, oA.promise;
    }
    function d(u) {
      function x(D) {
        C(), h.send("GetDoc", {
          pdfInfo: D
        });
      }
      function m(D) {
        if (C(), D instanceof Ws) {
          const F = new $i(`PasswordException: response ${D.code}`);
          B(F), h.sendWithPromise("PasswordRequest", D).then(function({
            password: y
          }) {
            Q(F), i.updatePassword(y), p();
          }).catch(function() {
            Q(F), h.send("DocException", D);
          });
        } else
          h.send("DocException", ut(D));
      }
      function p() {
        C(), E(!1).then(x, function(D) {
          if (C(), !(D instanceof P0)) {
            m(D);
            return;
          }
          i.requestLoadedStream().then(function() {
            C(), E(!0).then(x, m);
          });
        });
      }
      C(), f(u).then(function(D) {
        if (s)
          throw D.terminate(new Te("Worker was terminated.")), new Error("Worker was terminated");
        i = D, i.requestLoadedStream(!0).then((F) => {
          h.send("DataLoaded", {
            length: F.bytes.byteLength
          });
        });
      }).then(p, m);
    }
    return h.on("GetPage", function(u) {
      return i.getPage(u.pageIndex).then(function(x) {
        return Promise.all([i.ensure(x, "rotate"), i.ensure(x, "ref"), i.ensure(x, "userUnit"), i.ensure(x, "view")]).then(function([m, p, D, F]) {
          return {
            rotate: m,
            ref: p,
            refStr: (p == null ? void 0 : p.toString()) ?? null,
            userUnit: D,
            view: F
          };
        });
      });
    }), h.on("GetPageIndex", function(u) {
      const x = nA.get(u.num, u.gen);
      return i.ensureCatalog("getPageIndex", [x]);
    }), h.on("GetDestinations", function(u) {
      return i.ensureCatalog("destinations");
    }), h.on("GetDestination", function(u) {
      return i.ensureCatalog("getDestination", [u.id]);
    }), h.on("GetPageLabels", function(u) {
      return i.ensureCatalog("pageLabels");
    }), h.on("GetPageLayout", function(u) {
      return i.ensureCatalog("pageLayout");
    }), h.on("GetPageMode", function(u) {
      return i.ensureCatalog("pageMode");
    }), h.on("GetViewerPreferences", function(u) {
      return i.ensureCatalog("viewerPreferences");
    }), h.on("GetOpenAction", function(u) {
      return i.ensureCatalog("openAction");
    }), h.on("GetAttachments", function(u) {
      return i.ensureCatalog("attachments");
    }), h.on("GetDocJSActions", function(u) {
      return i.ensureCatalog("jsActions");
    }), h.on("GetPageJSActions", function({
      pageIndex: u
    }) {
      return i.getPage(u).then(function(x) {
        return i.ensure(x, "jsActions");
      });
    }), h.on("GetOutline", function(u) {
      return i.ensureCatalog("documentOutline");
    }), h.on("GetOptionalContentConfig", function(u) {
      return i.ensureCatalog("optionalContentConfig");
    }), h.on("GetPermissions", function(u) {
      return i.ensureCatalog("permissions");
    }), h.on("GetMetadata", function(u) {
      return Promise.all([i.ensureDoc("documentInfo"), i.ensureCatalog("metadata")]);
    }), h.on("GetMarkInfo", function(u) {
      return i.ensureCatalog("markInfo");
    }), h.on("GetData", function(u) {
      return i.requestLoadedStream().then(function(x) {
        return x.bytes;
      });
    }), h.on("GetAnnotations", function({
      pageIndex: u,
      intent: x
    }) {
      return i.getPage(u).then(function(m) {
        const p = new $i(`GetAnnotations: page ${u}`);
        return B(p), m.getAnnotationsData(h, p, x).then((D) => (Q(p), D), (D) => {
          throw Q(p), D;
        });
      });
    }), h.on("GetFieldObjects", function(u) {
      return i.ensureDoc("fieldObjects").then((x) => (x == null ? void 0 : x.allFields) || null);
    }), h.on("HasJSActions", function(u) {
      return i.ensureDoc("hasJSActions");
    }), h.on("GetCalculationOrderIds", function(u) {
      return i.ensureDoc("calculationOrderIds");
    }), h.on("SaveDocument", async function({
      isPureXfa: u,
      numPages: x,
      annotationStorage: m,
      filename: p
    }) {
      const D = [i.requestLoadedStream(), i.ensureCatalog("acroForm"), i.ensureCatalog("acroFormRef"), i.ensureDoc("startXRef"), i.ensureDoc("xref"), i.ensureDoc("linearization"), i.ensureCatalog("structTreeRoot")], F = new ot(), y = [], H = u ? null : pc(m), [N, T, _, oA, G, S, tA] = await Promise.all(D), $ = G.trailer.getRaw("Root") || null;
      let hA;
      if (H) {
        tA ? await tA.canUpdateStructTree({
          pdfManager: i,
          xref: G,
          newAnnotationsByPage: H
        }) && (hA = tA) : await ea.canCreateStructureTree({
          catalogRef: $,
          pdfManager: i,
          newAnnotationsByPage: H
        }) && (hA = null);
        const J = Ui.generateImages(m.values(), G, i.evaluatorOptions.isOffscreenCanvasSupported), q = hA === void 0 ? y : [];
        for (const [Z, sA] of H)
          q.push(i.getPage(Z).then((z) => {
            const W = new $i(`Save (editor): page ${Z}`);
            return B(W), z.saveNewAnnotations(h, W, sA, J, F).finally(function() {
              Q(W);
            });
          }));
        hA === null ? y.push(Promise.all(q).then(async () => {
          await ea.createStructureTree({
            newAnnotationsByPage: H,
            xref: G,
            catalogRef: $,
            pdfManager: i,
            changes: F
          });
        })) : hA && y.push(Promise.all(q).then(async () => {
          await hA.updateStructureTree({
            newAnnotationsByPage: H,
            pdfManager: i,
            changes: F
          });
        }));
      }
      if (u)
        y.push(i.serializeXfaData(m));
      else
        for (let J = 0; J < x; J++)
          y.push(i.getPage(J).then(function(q) {
            const Z = new $i(`Save: page ${J}`);
            return B(Z), q.save(h, Z, m, F).finally(function() {
              Q(Z);
            });
          }));
      const yA = await Promise.all(y);
      let pA = null;
      if (u) {
        if (pA = yA[0], !pA)
          return N.bytes;
      } else if (F.size === 0)
        return N.bytes;
      const DA = _ && T instanceof R && F.values().some((J) => J.needAppearances), X = T instanceof R && T.get("XFA") || null;
      let qA = null, IA = !1;
      if (Array.isArray(X)) {
        for (let J = 0, q = X.length; J < q; J += 2)
          X[J] === "datasets" && (qA = X[J + 1], IA = !0);
        qA === null && (qA = G.getNewTemporaryRef());
      } else X && k("Unsupported XFA type.");
      let U = /* @__PURE__ */ Object.create(null);
      if (G.trailer) {
        const J = /* @__PURE__ */ Object.create(null), q = G.trailer.get("Info") || null;
        if (q instanceof R)
          for (const [Z, sA] of q)
            typeof sA == "string" && (J[Z] = jA(sA));
        U = {
          rootRef: $,
          encryptRef: G.trailer.getRaw("Encrypt") || null,
          newRef: G.getNewTemporaryRef(),
          infoRef: G.trailer.getRaw("Info") || null,
          info: J,
          fileIds: G.trailer.get("ID") || null,
          startXRef: S ? oA : G.lastXRefStreamPos ?? oA,
          filename: p
        };
      }
      return xx({
        originalData: N.bytes,
        xrefInfo: U,
        changes: F,
        xref: G,
        hasXfa: !!X,
        xfaDatasetsRef: qA,
        hasXfaDatasetsEntry: IA,
        needAppearances: DA,
        acroFormRef: _,
        acroForm: T,
        xfaData: pA,
        useXrefStream: fc(G.topDict, "XRef")
      }).finally(() => {
        G.resetNewTemporaryRef();
      });
    }), h.on("GetOperatorList", function(u, x) {
      const m = u.pageIndex;
      i.getPage(m).then(function(p) {
        const D = new $i(`GetOperatorList: page ${m}`);
        B(D);
        const F = r >= Ps.INFOS ? Date.now() : 0;
        p.getOperatorList({
          handler: h,
          sink: x,
          task: D,
          intent: u.intent,
          cacheKey: u.cacheKey,
          annotationStorage: u.annotationStorage,
          modifiedIds: u.modifiedIds
        }).then(function(y) {
          Q(D), F && vA(`page=${m + 1} - getOperatorList: time=${Date.now() - F}ms, len=${y.length}`), x.close();
        }, function(y) {
          Q(D), !D.terminated && x.error(y);
        });
      });
    }), h.on("GetTextContent", function(u, x) {
      const {
        pageIndex: m,
        includeMarkedContent: p,
        disableNormalization: D
      } = u;
      i.getPage(m).then(function(F) {
        const y = new $i("GetTextContent: page " + m);
        B(y);
        const H = r >= Ps.INFOS ? Date.now() : 0;
        F.extractTextContent({
          handler: h,
          task: y,
          sink: x,
          includeMarkedContent: p,
          disableNormalization: D
        }).then(function() {
          Q(y), H && vA(`page=${m + 1} - getTextContent: time=${Date.now() - H}ms`), x.close();
        }, function(N) {
          Q(y), !y.terminated && x.error(N);
        });
      });
    }), h.on("GetStructTree", function(u) {
      return i.getPage(u.pageIndex).then(function(x) {
        return i.ensure(x, "getStructTree");
      });
    }), h.on("FontFallback", function(u) {
      return i.fontFallback(u.id, h);
    }), h.on("Cleanup", function(u) {
      return i.cleanup(!0);
    }), h.on("Terminate", function(u) {
      s = !0;
      const x = [];
      if (i) {
        i.terminate(new Te("Worker was terminated."));
        const m = i.cleanup();
        x.push(m), i = null;
      } else
        ao();
      a == null || a(new Te("Worker was terminated."));
      for (const m of n)
        x.push(m.finished), m.terminate();
      return Promise.all(x).then(function() {
        h.destroy(), h = null;
      });
    }), h.on("Ready", function(u) {
      d(A), A = null;
    }), l;
  }
  static initializeFromPort(A) {
    const t = new cc("worker", "main", A);
    this.setup(t, A), t.send("ready", null);
  }
};
typeof window > "u" && !Mh && typeof self < "u" && typeof self.postMessage == "function" && "onmessage" in self && yo.initializeFromPort(self);
let Tg = yo;
var bx = lc.WorkerMessageHandler;
Promise.withResolvers ?? (Promise.withResolvers = function() {
  let e, A;
  return { promise: new Promise((i, s) => {
    e = i, A = s;
  }), resolve: e, reject: A };
});
export {
  bx as WorkerMessageHandler
};
